---
title: 20221006 T4 题解
date: 2022-10-07 18:20:00
---

## Description

给定一个 $n\times m(n,m\leq 50)$ 的字符矩阵，`.` 表示平地，`X` 表示障碍，`@` 表示起点，`*` 表示绿洲。从起点出发，每天可以向四周 $8$ 个方向移动，当然需要是合法移动。然而每天还有一个风向，
若你出发时是逆风而行，则需要 $3$ 天才能到达目的地，否则只需 $1$ 天就能到达目的地。你虽然不知道未来的风向如何，但幸运的是风向是确定的，也就是说它不会根据你的决策而改变。问最坏情况下，你要多久才能到达绿洲。

## Solution

注意：风向在每次出发之前是会改变的，所以不能直接枚举风向然后最短路。

那么就要从绿洲开始往出发点跑最短路，那么每次转移有两种情况：逆风还是不逆风。如果逆风，那么上一次的就得在当前点的相邻点中的最短的那个。如果不逆风，那上一个就是当前点的相邻点中第二短的那个，描述一下就是：$dis[x][y]=\max\{dis[x_1][y_1]+3,dis[x_2][y_2]+1\}+1$，因为当前是最坏情况，所以要取 $\max$。

跑个 Bellman-Ford 就行了。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 114514
#endif

using namespace std;

const pair<int, int> kDir[] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                  {0, 1}, {1, -1}, {1, 0}, {1, 1}};

int n, m, stx, sty;
string s;
int a[55][105], dis[55][105];

string work(string s) {
  string ret = "";
  for (int i = 0; i < (int)s.size(); ++i) {
    if (s[i] == '-' || s[i] == 'X' || s[i] == '@' || s[i] == '*') {
      ret += s[i];
    }
  }
  return ret;
}

int get() {
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      if (a[i][j] == 3) {
        dis[i][j] = 0;
      } else {
        dis[i][j] = 1e9;
      }
    }
  }
  bool rel = 1;
  while (rel) {
    rel = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        int d1 = 1e9, d2 = 1e9;
        for (auto p : kDir) {
          int ti = i - p.first, tj = j - p.second;
          if (ti < 1 || ti > n || tj < 1 || tj > m || a[ti][tj] == 2) continue ;
          if (dis[ti][tj] <= d1) {
            d2 = d1, d1 = dis[ti][tj];
          } else if (dis[ti][tj] <= d2) {
            d2 = dis[ti][tj];
          }
        }
        int val = min(d1 + 3, d2 + 1);
        if (val < dis[i][j]) {
          dis[i][j] = val, rel = 1;
        }
      }
    }
  }
  return dis[stx][sty] == 1e9 ? -1 : dis[stx][sty];
}

int main() {
  freopen("desert.in", "r", stdin);
  freopen("desert.out", "w", stdout);
  cin >> n; getchar();
  for (int i = 1; i <= n; ++i) {
    getline(cin, s);
    s = work(s), m = s.size();
    s = "#" + s;
    for (int j = 1; j <= m; ++j) {
      if (s[j] == 'X') {
        a[i][j] = 2;
      } else {
        a[i][j] = 1;
        if (s[j] == '@') {
          stx = i, sty = j;
        } else if (s[j] == '*') {
          a[i][j] = 3;
        }
      }
    }
  }
  cout << get() << endl;
  return 0;
}
```

</details>

## 官方题解

> 设d[i][j]表示当前在(i,j),还需多久才能走到绿洲。
我们可以观察到，因为求的是最坏情况下的解，那么每个状态的决策只有两种
第一种是选择最优的一个相邻状态x，并用x+3更新答案，第二种是使用
次优的相邻状态x'，用x'+1更新答案。
这类似与经典的最短路问题，只是是倒着推的。
因为长,宽<=50,具体实现可以采用bellman-ford。
