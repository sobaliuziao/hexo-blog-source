---
title: QOJ #2214. Link Cut Digraph 题解
date: 2025-08-19 21:10:00
---

## Description

给定一个有 $n$ 个顶点的图，初始时没有边。共有 $m$ 个操作。每个操作首先是向图中添加一条给定的有向边，然后输出满足条件的顶点对数 $(u, v)$ （$1 \leq u < v \leq n$），使得 $u$ 从 $v$ 可达且 $v$ 从 $u$ 可达。

$n\leq 10^5,m\leq 2.5\times 10^5$。

## Solution

首先有个强连通分量是无法直接维护的，所以需要用离线算法。

考虑整体二分，二分 $t_i$ 表示最小的时刻，使得第 $i$ 条边在一个强连通分量里。

假设当前的二分区间为 $[l,r]$，答案在这个区间里的边集为 $S$。

先用并查集维护好 $[1,l-1]$ 这些边构成的强连通分量和不同强连通分量之间的边。然后把 $[l,mid]$ 加入图中跑 tarjan，但是这么做 $[1,l-1]$ 的边会算很多次，会超时。

注意到 $[1,l-1]$ 不在 $S$ 中的边要么在强连通分量内，要么最终变为强连通分量内的边的时刻大于 $r$，那这些边对 $[l,mid]$ 形成新强连通分量就没有作用，可以扔掉。

所以现在只需要保留 $S$ 中编号小于等于 $mid$ 的边跑 tarjan 即可。

时间复杂度：$O(n\log n+m\log n\log m)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 1e5 + 5, kMaxM = 2.5e5 + 5;

int n, m, dfn_cnt; int64_t ans;
int u[kMaxM], v[kMaxM], t[kMaxM], fa[kMaxN], sz[kMaxN];
int dfn[kMaxN], low[kMaxN], bel[kMaxN];
bool ins[kMaxN];
std::vector<int> stk;
std::vector<int> G[kMaxN], T[kMaxN];
std::vector<std::vector<int>> scc;
std::vector<int> add[kMaxM];

int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
void unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) {
    ans -= 1ll * sz[fx] * (sz[fx] - 1) / 2 + 1ll * sz[fy] * (sz[fy] - 1) / 2;
    fa[fx] = fy, sz[fy] += sz[fx];
    ans += 1ll * sz[fy] * (sz[fy] - 1) / 2;
  }
}

struct DSU {
  int fa[kMaxN];
  void init(int n) {
    stk.clear();
    for (int i = 1; i <= n; ++i) fa[i] = i;
  }
  int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
  void unionn(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy) fa[fx] = fy;
  }
} dsu;

void tarjan(int u) {
  dfn[u] = low[u] = ++dfn_cnt, ins[u] = 1, stk.emplace_back(u);
  for (auto v : G[u]) {
    if (!dfn[v]) {
      tarjan(v);
      low[u] = std::min(low[u], low[v]);
    } else if (ins[v]) {
      low[u] = std::min(low[u], dfn[v]);
    }
  }
  if (low[u] == dfn[u]) {
    std::vector<int> vec;
    for (; stk.size();) {
      int k = stk.back(); stk.pop_back();
      vec.emplace_back(k), bel[k] = scc.size(), ins[k] = 0;
      if (k == u) break;
    }
    scc.emplace_back(vec);
  }
}

void solve(int l, int r, std::vector<int> &vec) {
  // std::cerr << l << ' ' << r << ' ' << vec.size() << '\n';
  if (l == r) {
    for (auto i : vec) t[i] = l;
  }
  if (l > m) return;
  int mid = (l + r) >> 1;
  std::vector<int> id;
  for (auto i : vec) {
    G[dsu.find(u[i])].clear(), G[dsu.find(v[i])].clear();
    id.emplace_back(dsu.find(u[i])), id.emplace_back(dsu.find(v[i]));
  }
  for (auto i : vec) {
    if (i <= mid) G[dsu.find(u[i])].emplace_back(dsu.find(v[i]));
  }
  for (auto i : id) dfn[i] = 0;
  scc.clear();
  for (auto i : id) {
    if (!dfn[i]) tarjan(i);
  }
  if (l != r) {
    std::vector<int> vl, vr;
    for (auto i : vec) {
      if (i <= mid) {
        if (bel[dsu.find(u[i])] == bel[dsu.find(v[i])]) vl.emplace_back(i);
        else vr.emplace_back(i);
      } else {
        vr.emplace_back(i);
      }
    }
    solve(l, mid, vl), solve(mid + 1, r, vr);
  } else {
    for (auto i : vec) {
      if (i <= mid && bel[dsu.find(u[i])] == bel[dsu.find(v[i])])
        dsu.unionn(u[i], v[i]);
    }
  }
}

void dickdreamer() {
  std::cin >> n >> m;
  for (int i = 1; i <= m; ++i) std::cin >> u[i] >> v[i];
  std::vector<int> vec;
  for (int i = 1; i <= m; ++i) vec.emplace_back(i);
  dsu.init(n), solve(1, m + 1, vec);
  // for (int i = 1; i <= m; ++i) std::cerr << t[i] << " \n"[i == m];
  for (int i = 1; i <= m; ++i) add[t[i]].emplace_back(i);
  for (int i = 1; i <= n; ++i) fa[i] = i, sz[i] = 1;
  for (int i = 1; i <= m; ++i) {
    for (auto j : add[i]) unionn(u[j], v[j]);
    std::cout << ans << '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```