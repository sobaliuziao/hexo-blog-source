---
title: 2025 上海集训游记
date: 2024-12-30 19:01:00
---

# 20241230

## T1

### Description

$T$ 组询问，每组询问给定一个正整数 $n$，定义一个满足 $\sum a_i\leq n,a_i>0$ 的正整数序列 $a$ 的权值是 $\sum a_i!$，求所有序列 $a$ 的权值的 $\operatorname{mex}$ 对 $998244353$ 取模的结果，$a$ 的长度可以为 $0$，此时权值为 $0$。

**注：本题中自然数包含 $0$，$\operatorname{mex}$ 同样考虑 $0$。**

$1\leq T \leq 10^5,1\leq n\leq 10^{15}$。

### Solution

直接阶乘拆分即可。

## T2

### Description

小 $L$ 生活在一座沙尘暴肆虐的城市，这个城市里有 $n$ 个小 $L$ 关心的地点。小 $L$ 记得在沙尘暴来袭之前，从第 $i$ 个地点到第 $j$ 个地点要消耗 $w_{i,j}$ 的时间。由于常年累积的沙子，现在第 $i$ 个地点距离地表的高度是 $h_i$，因此从第 $i$ 个地点到第 $j$ 个地点消耗的时间变为了 $C|h_i-h_j|+w_{i,j}$。小 $L$ 拥有控制沙子程度的能力，所以她可以在一开始花费 $kd_i(k>0)$ 的时间让 $h_i$ 增加或减少 $k$，但是因为地表及以下的部分并不是由沙子构成的，所以她并不能把任何地点的高度降到 $0$ 以下。

现在小 $L$ 想知道，对于任意一对地点 $i,j$，她先消耗一些时间来修改 $h$，再从消耗一些时间从地点 $i$ 走到地点 $j$ 花费的最小总时间是多少。注意这里对于每一对地点是独立计算的，即修改 $h$ 是从初始的 $h$ 来修改。

$1\leq n\leq 500$，$0\leq C,h_i,d_i \leq 10^7$，$0\leq w_{i,j}\leq 10^{14}$。

### Solution

考虑固定走的路径后最优解的高度会变成什么。

有个结论是把最终的高度序列的连续段拿出来后，每个连续段一定存在一个点的初始高度等于最终高度。

证明就考虑对于不满足条件的连续段数量进行归纳。如果存在一个段不满足条件，则这个段变化的最终高度 $x$ 与贡献构成的函数一定是个凸函数，并且满足拐点一定是该区间内的初始高度或者相邻区间的最终高度，由于最优解一定在拐点上，所以要么该段满足条件，要么和相邻段合并，不满足条件的段的数量一定减少。

然后枚举每个满足初始高度等于最终高度的点 $p_1,p_2,\ldots,p_k$。那么 $s\to p_1$ 最终高度全为 $h_{p_1}$，$p_i\to p_{i+1}$ 的路径上前一半为 $h_{p_i}$，后一边为 $h_{p_{i+1}}$，$p_k\to t$ 上全为 $h_{p_k}$。

设 $f_{i,j}$ 表示从 $i$ 走到 $j$，并且让路径上的点的高度都变成 $h_i$ 的最小代价。$g_{i,j}$ 表示从 $i$ 走到 $j$，前一半变成 $h_i$，后一半变成 $h_j$ 的最小代价。

对于 $f$ 用 dijkstra 求，$g$ 用 floyd 即可。

时间复杂度：$O(n^3)$。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int int64_t

const int kMaxN = 505;

int cid, n, C;
int a[kMaxN], d[kMaxN], w[kMaxN][kMaxN], f[kMaxN][kMaxN], g[kMaxN][kMaxN], h[kMaxN][kMaxN];

void getf() {
  // f[i][j] : i -> j，将高度全变成 a[i] 的最小权值
  for (int i = 1; i <= n; ++i) {
    static bool vis[kMaxN];
    std::fill_n(f[i] + 1, n, 1e18);
    std::fill_n(vis + 1, n, 0);
    f[i][i] = 0;
    for (int c = 1; c <= n; ++c) {
      int x = 0;
      for (int j = 1; j <= n; ++j)
        if (!vis[j] && (!x || f[i][j] < f[i][x]))
          x = j;
      if (!x) break;
      vis[x] = 1;
      for (int y = 1; y <= n; ++y)
        f[i][y] = std::min(f[i][y], f[i][x] + w[x][y] + d[y] * abs(a[y] - a[i]));
    }
  }
}

void getg() {
  // g[i][j] : i -> j，前一半变成 a[i]，后一半变成 a[j] 的最小权值
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      if (i != j) g[i][j] = 1e18;
      for (int k = 1; k <= n; ++k) {
        g[i][j] = std::min(g[i][j], f[i][k] + f[j][k] + C * abs(a[i] - a[j]) - d[k] * abs(a[k] - a[j]));
      }
    }
  }
  for (int k = 1; k <= n; ++k)
    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= n; ++j)
        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);
}

void geth() {
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      h[i][j] = (i == j ? 0 : 1e18);
      for (int k = 1; k <= n; ++k)
        h[i][j] = std::min(h[i][j], f[k][i] + g[k][j]);
    }
  }
}

void dickdreamer() {
  std::cin >> cid >> n >> C;
  for (int i = 1; i <= n; ++i) std::cin >> a[i];
  for (int i = 1; i <= n; ++i) std::cin >> d[i];
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j)
      std::cin >> w[i][j];
  getf(), getg(), geth();
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      int ans = (i == j ? 0 : 1e18);
      for (int k = 1; k <= n; ++k) ans = std::min(ans, h[i][k] + f[k][j]);
      std::cout << ans << " \n"[j == n];
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```
</details>

## T3

### Description

宇宙射线大爆发，你躲到了 $0/1$ 序列里。

对于一个 $0/1$ 序列，宇宙射线照射它一次，会从每个 $0/1$ 连续段中删去一个元素，并让剩余元素补位，例如 $11011$ 被照射一次会变成 $11$。

定义一个 $0/1$ 序列 $A$ 的**强度** $f(A)$ 为，让它变为空序列所需的照射次数。

给定正整数 $n,k$，求 $\sum_{A\in\{0,1\}^n} (f(A))^k$，即所有长为 $n$ 的 $0/1$ 串的**强度**的 $k$ 次方之和，答案对 $998244353$ 取模。 

$1\leq n,k\leq 10^7$。

### Solution

考虑给定一个序列的权值怎么求。结论是权值为将 $0$ 看成 $1$，$1$ 看成 $-1$ 后前缀和的极差。

那么原题目转化为求一个长度为 $n$ 的 $1/-1$ 序列的前缀和极差为 $m$ 的方案数。

考虑枚举 $m$，用 [[AGC013D] Piling Up](https://www.luogu.com.cn/problem/AT_agc013_d) 的方法转化为起点 $(0,0),(0,1),\ldots(0,m)$，终点为 $(n,0),(n,1),\ldots(n,m)$ 且不能经过 $y=-1$ 和 $y=m+1$ 的方案数，将 $m$ 的方案数减去 $m-1$ 的方案数即为极差为 $m$ 的方案数，因为极差为 $k$ 的在 $m$ 里会算 $m-k+1$ 次，在 $m-1$ 里会算 $m-k$ 次，减去后就只有 $1$ 次了。

上面那个问题可以转化为[反射容斥](https://www.cnblogs.com/Hanghang007/p/18159154)，最终的式子是组合数前缀和的区间和的差，所以记录组合数前缀和的前缀和即可。

时间复杂度：$O(n\ln n)$。

# 20250108

## T2

### Description

有一棵点数为 $n$ 的树，根为 $1$，**每个叶子节点深度相同**。你有一个初始是 $0$ 的能量值 $S$。你现在会在树上移动。

你有 $m$ 种跳跃姿势，第 $i$ 种跳跃姿势可以用一个正整数 $b_i$ 表示。

假如你现在在节点 $u$，每一时刻你可以做以下事情**之一**：

1. 当 $u$ **不是叶子节点**，你可以睡一觉，并掉落到节点 $p_u$，能量值变为 $S+1$。保证 $p_u$ 是 $u$ 的儿子节点。

2. 当 $S>0$，你可以选择一个跳跃姿势 $k$（$1\le k \le m$） 并向上跳 $b_k$ 步，即走到 $u$ 的 $b_k$ 级祖先，能量值变为 $S-1$。你需要**保证 $\boldsymbol{b_k}$ 级祖先存在**。

定义 $dis(u,v)$ 表示从 $u$ 开始，初始 $S$ 等于 $0$，走到 $v$ 用时最短是多少。特别的，若 $u$ 无法到达 $v$ 则 $dis(u,v)=0$。

求 $\sum\limits_{u=1}^{n}\sum\limits_{v=1}^{n}dis(u,v)$。

$1 \le n \le 2\times10^5$，$1 \le m \le 100$，$2 \le b_k \le n$。

### Solution

考虑链怎么做。

首先把 $b_i=n$ 的跳跃姿势去掉。由于存在能量值的限制，所以可以猜测一定是先重复一降一升，再一直降，那么设 $f_{i}$ 表示向上跳 $i$ 步的最小步数，可以得到 dp：

$$
\begin{aligned}
\forall j\in [1,m],f_{i}&=\min{f_{i-b_j+1}}\\
f_{i}&=\min_{j\geq i}{f_j+j-i}
\end{aligned}
$$

下面证明一下上面做法的正确性：假设已经固定操作序列，那么跳的方式一定是如果当前点不是叶子且还有下降的次数，否则才往上跳。所以只有在叶子或者没有下降次数了才往上跳，显然一定不会跳出去，且这么做一定最优。

---

放到树上，固定 $lca$ 的重链顶 $t$，则一定存在一个限制 $dep_{leaf}-dep_{t}-1$，使得超过这个限制的跳跃姿势不能跳，所以只需要对 $b$ 进行排序然后做一个前缀的背包即可。

暴力做时间复杂度：$O(n^2)$。

---

考虑优化。

注意到题目里的划分链的方式为长链剖分，所以每个点到根的路径上的轻边数只有 $O(\sqrt n)$ 级别，考虑分类讨论。

设起点为 $x$，终点为 $y$。

1. $x$ 是 $lca$，$y$ 在 $x$ 所在重链上，直接算等差数列即可。
2. $x$ 是 $lca$ 的轻儿子子树里的点，$y$ 是 $lca$ 重儿子子树里的点，暴力枚举 $x$ 再算等差数列。
3. $y$ 是 $lca$，改为枚举 $x$，然后暴力跳 $x$ 到根的路径上的长链，那么某个长链对答案的贡献一定是 dp 数组上的一段区间加等差数列的形式，预处理前缀和即可。

时间复杂度：$O(nm+n\sqrt n)$。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxM = 105;

int n, m, mxd;
int p[kMaxN], son[kMaxN], b[kMaxM], f[kMaxM][kMaxN * 2], pos[kMaxM], cnt[kMaxN], iid[kMaxN];
int dep[kMaxN], dfn[kMaxN], idx[kMaxN], sz[kMaxN], top[kMaxN];
int64_t ans, sum[kMaxN], pre[kMaxM][kMaxN], pre1[kMaxM][kMaxN];
std::vector<int> G[kMaxN];

int get(int x, int y) { return dfn[x] < dfn[y] ? x : y; }
int64_t getsum(int l, int r) { return l > r ? 0 : 1ll * (l + r) * (r - l + 1) / 2; }
int getsum(int *a, int l, int r) {
  if (l > r) return 0;
  else if (l == 0) return a[r];
  else return a[r] - a[l - 1];
}
int64_t getsum(int64_t *a, int l, int r) {
  if (l > r) return 0;
  else if (l == 0) return a[r];
  else return a[r] - a[l - 1];
}

void dfs(int u, int fa, int t) {
  static int cnt = 0;
  dep[u] = dep[fa] + 1, top[u] = t, sz[u] = 1;
  idx[dfn[u] = ++cnt] = u;
  if (son[u] != -1) dfs(son[u], u, t), sz[u] += sz[son[u]];
  for (auto v : G[u]) {
    if (v == fa || v == son[u]) continue;
    dfs(v, u, v);
    sz[u] += sz[v];
  }
}

int getid(int x) { return std::upper_bound(b + 1, b + 1 + m, x) - b - 1; }

void prework() {
  dfs(1, 0, 1);
  std::sort(b + 1, b + 1 + m);
  m = std::unique(b + 1, b + 1 + m) - (b + 1);
  memset(f, 0x3f, sizeof(f));
  f[0][0] = 0;
  for (int i = 1; i <= m; ++i) {
    --b[i];
    for (int j = 0; j <= 2 * n; ++j) {
      f[i][j] = f[i - 1][j];
      if (j >= b[i]) f[i][j] = std::min(f[i][j], f[i][j - b[i]] + 2);
    }
  }
  for (int i = 1; i <= m; ++i)
    for (int j = 2 * n; ~j; --j) f[i][j] = std::min(f[i][j] + j, f[i][j + 1]);
  for (int i = 0; i <= m; ++i) {
    pre[i][0] = pre1[i][0] = 0;
    for (int j = 1; j <= n; ++j) {
      pre[i][j] = pre[i][j - 1];
      pre1[i][j] = pre1[i][j - 1];
      if (f[i][j] <= 1e8) {
        pre[i][j] += f[i][j];
        pre1[i][j] += f[i][j] - j;
      }
    }
  }
}

// namespace Sub0 {
// void solve() {
//   int64_t ans = 0;
//   for (int i = 1; i <= n; ++i) {
//     if (son[i] == -1) continue;
//     for (int j = 1; j <= n; ++j) {
//       int lca = LCA(i, j);
//       if (son[lca] == -1) continue;
//       if (top[j] != top[lca]) continue;
//       int id = getid(mxd - dep[top[lca]] - 1), mi = f[id][dep[i] - dep[lca]] + (dep[j] - dep[i]);
//       if (mi <= 1e6) ans += mi;
//     }
//   }
//   std::cout << ans << '\n';
// }
// } // namespace Sub0

void dickdreamer() {
  std::cin >> n >> m;
  for (int i = 2; i <= n; ++i) {
    std::cin >> p[i];
    G[p[i]].emplace_back(i), G[i].emplace_back(p[i]);
  }
  for (int i = 1; i <= n; ++i) std::cin >> son[i];
  for (int i = 1; i <= m; ++i) std::cin >> b[i];
  prework();
  mxd = *std::max_element(dep + 1, dep + 1 + n);
  for (int i = 1; i <= n; ++i) iid[i] = getid(mxd - dep[top[i]] - 1);
  for (int i = n; i; --i) {
    cnt[i] = 1, sum[i] = dep[i];
    if (son[i] != -1) cnt[i] += cnt[son[i]], sum[i] += sum[son[i]];
  }
  // x 是 lca
  for (int i = 1; i <= n; ++i) {
    ans += getsum(1, cnt[i] - 1);
  }
  // x 在轻子树，y 在重子树
  for (int lca = 1; lca <= n; ++lca) {
    if (son[lca] == -1) continue;
    int id = iid[lca];
    for (int i = dfn[son[lca]] + sz[son[lca]]; i <= dfn[lca] + sz[lca] - 1; ++i) {
      int x = idx[i], mi = f[id][dep[x] - dep[lca]] - dep[x];
      if (son[x] != -1 && mi <= 1e8) ans += mi * (cnt[lca] - 1) + sum[lca] - dep[lca];
    }
  }
  // y 是 lca
  // f[id][dep[x] - dep[y]] + (dep[y] - dep[x])
  for (int x = 1; x <= n; ++x) {
    if (son[x] == -1) continue;
    int lst = x;
    for (int i = top[x]; i; i = top[p[i]]) {
      // int id = getid(mxd - dep[i] - 1);
      int id = iid[i];
      ans += getsum(pre1[id], dep[x] - dep[lst], dep[x] - dep[i]);
      // for (int j = dep[x] - dep[lst]; j <= dep[x] - dep[i]; ++j)
      //   if (f[id][j] <= 1e8)
      //     ans += f[id][j] - j;
      lst = p[i];
    }
  }
  // for (int x = 1; x <= n; ++x) {
  //   if (son[x] == -1) continue;
  //   for (int y = x; y; y = p[y]) {
  //     int id = getid(mxd - dep[top[y]] - 1);
  //     int64_t mi = f[id][dep[x] - dep[y]] + (dep[y] - dep[x]);
  //     assert(mi >= 0);
  //     if (mi <= 1e8) ans += mi;
  //   }
  // }
  std::cout << ans << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```
</details>