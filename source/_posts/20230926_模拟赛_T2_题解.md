---
title: 20230926 模拟赛 T2 题解
date: 2023-09-26 20:29:00
---

## Description

给定一个由 $n$ 个点 $m$ 条边组成的边带权森林，有 $q$ 次询问，每次询问给定 $x,y$，现在随机在 $x$ 和 $y$ 所在子树之间添加一条长度为 $1$ 的边，问这个大连通块的直径的期望值是多少，对 $10^9+7$ 取模。

$1\leq n,m,q\leq 2\times 10^5,1\leq w\leq 10^9$。

## Solution

首先可以换根 dp 预处理出 $f_i$ 表示 $i$ 到 $i$ 所在的树最远距离，$l_i$ 表示第 $i$ 棵树的直径。

设 $A$ 表示 $x$ 所在子树，$B$ 表示 $y$ 所在子树，$L$ 表示 $\min\{l_A,l_B\}$。

那么答案就是：

$$
\frac{\sum_{u\in A}\sum_{v\in B}{\min\{f_u+f_v+1,L\}}}{\text{size}_x\times \text{size}_y}
$$

显然对于 $A$ 和 $B$ 中的点按照 $f$ 值从小到大排序之后使用双指针+前缀和可以做到 $O(\text{size}_x+\text{size}_y)$。

但是这样做过不了。

---

思考上面那个做法为什么慢。

原因是对于 $\text{size}$ 很大的子树每次循环是很慢的，但是 $\text{size}$ 很大的子树很少，所以考虑用根号分治优化上面那个东西。

注意到 $\text{size}>\sqrt n$ 的子树最多 $\sqrt n$ 个，于是可以对于 $\text{size}>\sqrt n$ 的子树之间的询问预处理。

那么没有预处理的询问就一定满足 $\min\{\text{size}_x,\text{size}_y\}\leq \sqrt n$，所以直接对那个 $\text{size}$ 较小的树暴力循环，然后对那个大一点的树二分即可。

时间复杂度：$O(n\sqrt n+q\sqrt n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

#define int int64_t

namespace FASTIO {
char ibuf[1 << 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
}
template <class T>
bool read(T &x) {
  x = 0;
  int f = 0;
  char ch = getc();
  while (ch < '0' || ch > '9') f |= ch == '-', ch = getc();
  while (ch >= '0' && ch <= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x);
  return 1;
}
template <typename A, typename... B>
bool read(A &x, B &...y) { return read(x) && read(y...); }

char obuf[1 << 21], *o1 = obuf, *o2 = obuf + (1 << 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) {
  *o1++ = x;
  if (o1 == o2) flush();
}
template <class T>
void write(T x) {
  if (!x) putc('0');
  if (x < 0) x = -x, putc('-');
  char c[40];
  int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) {
  while (*x) putc(*x++);
}
void write(const char *x) {
  while (*x) putc(*x++);
}
template <typename A, typename... B>
void write(A x, B... y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
}  // namespace FASTIO
using FASTIO::putc;
using FASTIO::read;
using FASTIO::write;

const int kMaxN = 2e5 + 5, kMod = 1e9 + 7;

int n, m, q, k, b;
int f[kMaxN], g[kMaxN], bel[kMaxN], mx[kMaxN], sz[kMaxN], bf[kMaxN];
std::vector<int> ff[kMaxN], gg[kMaxN], idx[kMaxN], ss[kMaxN];
std::vector<std::pair<int, int>> G[kMaxN];
std::map<std::pair<int, int>, int> mp;

int fix(int x) { return (x % kMod + kMod) % kMod; }
int add(int x, int y) { return (x + y >= kMod) ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x < y) ? (x - y + kMod) : (x - y); }
int mul(int x, int y) { return 1ll * fix(x) * fix(y) % kMod; }
void inc(int x, int y) { (x += y) >= kMod ? (x -= kMod) : x; }
void dec(int x, int y) { (x -= y) < 0 ? (x += kMod) : x; }

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = 1ll * bs * bs % kMod)
    if (idx & 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}

void dfs1(int u, int fa) {
  bel[u] = k;
  ++sz[k];
  idx[k].emplace_back(u);
  std::vector<int> pre(G[u].size()), suf(G[u].size());
  for (int i = 0; i < static_cast<int>(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (v == fa) continue;
    dfs1(v, u);
    f[u] = std::max(f[u], f[v] + w);
  }
  for (int i = 0; i < static_cast<int>(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (!i)
      pre[i] = f[v] + w;
    else
      pre[i] = std::max(pre[i - 1], f[v] + w);
  }
  for (int i = (int)G[u].size() - 1; ~i; --i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (i + 1 == G[u].size())
      suf[i] = f[v] + w;
    else
      suf[i] = std::max(suf[i + 1], f[v] + w);
  }
  for (int i = 0; i < static_cast<int>(G[u].size()); ++i) {
    if (i) ff[u][i] = std::max(ff[u][i], pre[i - 1]);
    if (i + 1 < G[u].size()) ff[u][i] = std::max(ff[u][i], suf[i + 1]);
  }
}

void dfs2(int u, int fa, int id, int ww) {
  mx[k] = std::max(mx[k], g[u]);
  if (fa) {
    for (int i = 0; i < G[u].size(); ++i)
      gg[u][i] = std::max(gg[fa][id] + ww, ff[u][i]);
  }
  for (int i = 0; i < static_cast<int>(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (v == fa) continue;
    g[v] = std::max(f[v], gg[u][i] + w);
    dfs2(v, u, i, w);
  }
}

int solve_bf(int x, int y) {
  int sum = 0, mxx = std::max(mx[x], mx[y]);
  for (int i = sz[x] - 1, j = -1; ~i; --i) {
    for (; j + 1 < sz[y] && g[idx[x][i]] + g[idx[y][j + 1]] + 1 <= mxx; ++j) {
    }
    sum += fix(mxx) * fix(j + 1) % kMod + fix(g[idx[x][i]] + 1) * fix(sz[y] - 1 - j) % kMod + sub(ss[y].back(), (~j ? ss[y][j] : 0));
    sum = fix(sum);
  }
  return fix(sum) * qpow(1ll * sz[x] * sz[y] % kMod) % kMod;
}

int solve_small(int x, int y) {
  int sum = 0, mxx = std::max(mx[x], mx[y]);
  if (sz[x] > sz[y]) std::swap(x, y);
  for (int i = 0; i < sz[x]; ++i) {
    int L = -1, R = sz[y], res = -1;
    for (; L + 1 < R;) {
      int mid = (L + R) >> 1;
      if (g[idx[x][i]] + g[idx[y][mid]] + 1 <= mxx)
        L = res = mid;
      else
        R = mid;
    }
    sum += fix(mxx) * fix(res + 1) % kMod + fix(g[idx[x][i]] + 1) * fix(sz[y] - 1 - res) % kMod + sub(ss[y].back(), (~res ? ss[y][res] : 0));
    sum = fix(sum);
  }
  return sum % kMod * qpow(1ll * sz[x] * sz[y] % kMod) % kMod;
}

void prework() {
  for (int i = 1; i <= n; ++i) {
    if (!bel[i]) {
      ++k;
      dfs1(i, 0);
      g[i] = f[i], gg[i] = ff[i];
      dfs2(i, 0, -1, 0);
      std::sort(idx[k].begin(), idx[k].end(), [&] (const int a, const int b) { return g[a] < g[b]; });
      ss[k].resize(idx[k].size());
      ss[k][0] = g[idx[k][0]] % kMod;
      for (int i = 1; i < idx[k].size(); ++i)
        ss[k][i] = (ss[k][i - 1] + g[idx[k][i]] % kMod) % kMod;
    }
  }
  for (int i = 1; i <= k; ++i) {
    if (sz[i] < b) continue;
    for (int j = i + 1; j <= k; ++j) {
      if (sz[j] < b) continue;
      mp[{i, j}] = mp[{j, i}] = solve_bf(i, j);
    }
  }
}

void dickdreamer() {
  read(n, m, q);
  b = sqrt(n) / 2;
  mp.clear();
  for (int i = 1; i <= n; ++i) {
    G[i].clear(), ff[i].clear(), gg[i].clear(), idx[i].clear(), ss[i].clear();
    f[i] = g[i] = mx[i] = bel[i] = sz[i] = 0;
  }
  for (int i = 1; i <= m; ++i) {
    int u, v, w;
    read(u, v, w);
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    ff[u].emplace_back(0), ff[v].emplace_back(0);
    gg[u].emplace_back(0), gg[v].emplace_back(0);
  }
  prework();
  for (; q; --q) {
    int x, y, sum = 0;
    read(x, y);
    x = bel[x], y = bel[y];
    if (sz[x] > sz[y]) std::swap(x, y);
    if (x == y) {
      write("-1\n");
    } else if (sz[x] > b) {
      write(mp[{x, y}], '\n');
    } else {
      write(solve_small(x, y), '\n');
    }
  }
}

int32_t main() {
  freopen("blade.in", "r", stdin);
  freopen("blade.out", "w", stdout);
  // std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int sid, T = 1;
  read(sid, T);
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```