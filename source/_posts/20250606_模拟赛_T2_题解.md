---
title: 20250606 模拟赛 T2 题解
date: 2025-06-06 16:10:00
---

## Description

称一个值域在 $1$ 到 $m$ 的序列权值是" $k$ 间距" 的，当且仅当 $\forall i, |a_i - a_{i + 1}| \le k$。

现在有一个序列 $a$ 和一个序列 $b$ ，值域均为 $1\sim m$，其中 $a$ 是 $b$ 的前缀。

并且序列 $b$ 满足，对于任意 $b$ 中的 "$k$ 间距" 子序列都满足子序列长度小于等于 $l$。

现在给出序列 $a$，其长度为 $n$，请最大化序列 $b$ 的长度，只需要输出长度即可，并不需要给出构造。

保证 $b = a$ 即为一组合法解，虽然长度不一定是最大的。

$T, \sum n \le 2 \times 10^5, 1 \le m, l \le 10^9, 0 \le k \le 10^9, 1 \le a_i \le m$。

## Solution

首先判断一个序列是否有解，可以设 $f_{i,j}$ 表示考虑到了 $1\sim i$，以 $j$ 结尾的最长合法子序列长度。

那么每次转移就是让 $\displaystyle f_{i,a_i}\leftarrow\max_{j\in[a_i-k,a_i+k]}{f_{i-1,j}+1}$，其余不变。

直接对 $f$ 数组做是不太好贪心的，不太好找到一个加数的顺序。

考虑设 $\displaystyle g_{j}=\max_{w\in[j-k,j+k]}{f_{i,w}}$，那么加入一个 $x$，就是让 $[x-k,x+k]$ 这个区间内的 $g$ 值 chkmax 上 $g_x+1$。

容易发现每次选择某个全局最小值最优，因为这么操作每次只会改变最小值的 dp 值，所以先把它们操作了一定不劣。

把所有最小值位置拿出来，现在问题转化为了有很多个位置，每次可以选择一个位置 $x$，并把所有在 $[x-k,x+k]$ 内的数删掉，问最多操作次数。

考虑把极长连续区间拿出来，为 $[L_1,R_1],[L_2,R_2],\ldots,[L_s,R_s]$，对于每个 $[L_i,R_i]$，就对应着原先的 $f$ 数组中 $[L_i-k,R_i+k]$ 为全局最小值。

由于 $[L_i,R_i]$ 和 $[L_{i+1},R_{i+1}]$ 没有连起来，所以一定存在一个数 $a_w$ 不是最小值，且 $R_i+k<w<L_{i+1}-k$。根据这个可以得到 $R_i+2k<L_{i+1}$，所以 $[L_i,R_i]$ 怎么操作都不会影响到其它区间。

那么操作次数即为 $\sum_{i=1}^{s}{\left\lfloor\frac{R_i-L_i+1}{k+1}\right\rfloor}$。

求出 $f$ 数组后从大到小加入 $f_i$，并维护连续段即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

#define int int64_t

const int kMaxN = 2e5 + 5;

int n, m, k, l, t;
int a[kMaxN], unq[kMaxN], f[kMaxN];
std::vector<int> vec[kMaxN];

inline void chkmax(int &x, int y) { x = (x > y ? x : y); }

struct SGT {
  int N, mx[kMaxN * 4];
  inline void pushup(int x) { mx[x] = std::max(mx[x << 1], mx[x << 1 | 1]); }
  void build(int n) {
    for (N = 1; N <= n + 1; N <<= 1) {}
    std::fill_n(mx, 2 * N, 0);
  }
  void update(int x, int v) {
    mx[x += N] = v;
    for (x >>= 1; x; x >>= 1) pushup(x);
  }
  int query(int l, int r) {
    if (l > r) return 0;
    int ret = 0;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
      if (~l & 1) chkmax(ret, mx[l ^ 1]);
      if (r & 1) chkmax(ret, mx[r ^ 1]);
    }
    return ret;
  }
} sgt;

int getid(int x) { return std::lower_bound(unq + 1, unq + 1 + t, x) - unq; }

void discrete() {
  std::sort(unq + 1, unq + 1 + t);
  t = std::unique(unq + 1, unq + 1 + t) - (unq + 1);
}

int calc(int l, int r) { return l <= r ? (r - l + 1 + k) / (k + 1) : 0; }

void dickdreamer() {
  std::cin >> n >> m >> k >> l;
  t = 0;
  for (int i = 1; i <= n; ++i) std::cin >> a[i], unq[++t] = a[i];
  discrete();
  std::fill_n(f + 1, t, 0);
  sgt.build(t);
  for (int i = 1; i <= n; ++i) {
    int x = getid(a[i]), l = getid(a[i] - k), r = getid(a[i] + k + 1) - 1;
    sgt.update(x, f[x] = sgt.query(l, r) + 1);
  }
  for (int i = 1; i <= n; ++i) vec[i].clear();
  for (int i = 1; i <= t; ++i) {
    if (f[i])
      vec[f[i]].emplace_back(unq[i]);
  }
  std::set<std::pair<int, int>> st;
  int ans = 0, sum = (m + k) / (k + 1);
  st.emplace(1, m);
  for (int i = std::min(n, l), lst = l; ~i; --i) {
    ans += (lst - i) * sum;
    for (auto x : vec[i]) {
      auto ss = st.lower_bound({x - k, 0});
      if (ss != st.begin() && prev(ss)->second >= x - k) --ss;
      std::vector<std::pair<int, int>> add, del;
      for (auto it = ss; it != st.end(); ++it) {
        int pl, pr;
        std::tie(pl, pr) = *it;
        if (pl > x + k) break;
        del.emplace_back(pl, pr);
        if (pl < x - k) add.emplace_back(pl, x - k - 1);
        if (pr > x + k) add.emplace_back(x + k + 1, pr);
      }
      for (auto p : del) {
        st.erase(p), sum -= calc(p.first, p.second);
      }
      for (auto p : add) {
        st.emplace(p), sum += calc(p.first, p.second);
      }
    }
    lst = i;
  }
  std::cout << ans + n << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```