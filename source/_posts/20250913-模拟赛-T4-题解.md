---
title: '20250913 模拟赛 T4 题解'
date: 2025-09-13 20:49:00
---

## Description

给定一颗初始 $n$ 个节点的树，根节点为 $1$。最开始所有点都没有被染色。再给定常数 $k$，以及 $m$ 次操作。

操作有如下三种：

1. 给定 $u, c$，对于子树内的节点 $v$，将 $v$ 染色为 $(\text{dis}(u, v) + c − 1) \bmod k + 1$，其中 $dis(u, v)$ 表示 $u, v$ 之间简单路径上的边数；
2. 给定 $u, c$，询问 $u$ 子树内某个颜色 $c$ 的出现次数；
3. 给定 $u$，表示插入一个新节点，其父亲为 $u$。新插入的节点没有被染色。

特别的，对于部分测试点，数据强制在线。

## Solution

首先这题如果不要求强制在线，则可以先求 dfs 序然后 1 操作等价于 $col_v=(dep_v-dep_u+c)\bmod k$，用线段树维护区间覆盖即可，时间复杂度是 $O(qk\log n)$。

如果强制在线的话就不能一遍 dfs 求出 dfs 序了。

考虑用平衡树维护 dfs 序，平衡树的中序排列就是 dfs 遍历到的节点编号顺序。

询问时直接分裂出 $[dfn_u,dfn_u+sz_u-1]$ 这一段即可。

对于一个点的 dfs 序就是它在这个平衡树中的排名，这个可以通过跳父亲枚举 LCA 求出来。而 size 就不好求了，因为加入一个点需要修改其所有祖先的 size，无法直接维护。

这里维护 size 有个技巧是维护括号序，即 dfs 进入 $x$ 时加入 $x_1$，遍历完儿子后再加入一次 $x_2$，那么 $x$ 的子树的大小就是 $x_1$ 的位置到 $x_2$ 的位置的长度除以 $2$。

然后我们可以发现这题加入一个点作为 $u$ 的儿子在括号序上就是在 $u_2$ 前加入新点的两个拆出来的点，dfs 也能同样可以平衡树维护。

写的时候可以直接在括号序的平衡树上维护颜色的信息。

时间复杂度：$O(n+qk\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 8e5 + 5;

int sid, n, m, k;
int p[kMaxN], dep[kMaxN], col[kMaxN], dfn[kMaxN], idx[kMaxN];
std::vector<int> G[kMaxN];
std::mt19937 rnd(114514);

struct FHQTreap {
  int rt, sz[kMaxN], ls[kMaxN], rs[kMaxN], rd[kMaxN], cnt1[kMaxN][10], cnt2[kMaxN][10], tag[kMaxN];
  int fa[kMaxN];
  void pushup(int x) {
    sz[x] = sz[ls[x]] + sz[rs[x]] + 1;
    for (int i = 0; i < k; ++i) {
      cnt1[x][i] = cnt1[ls[x]][i] + cnt1[rs[x]][i] + (dep[x] == i);
      cnt2[x][i] = cnt2[ls[x]][i] + cnt2[rs[x]][i] + (col[x] == i);
    }
    if (ls[x]) fa[ls[x]] = x;
    if (rs[x]) fa[rs[x]] = x;
  }
  void addtag(int x, int v) {
    assert(v != -1);
    if (~col[x]) --cnt2[x][col[x]];
    if (dep[x] != -1) col[x] = (dep[x] + v) % k;
    tag[x] = v;
    for (int i = 0; i < k; ++i) cnt2[x][(i + v) % k] = cnt1[x][i];
  }
  void pushdown(int x) {
    if (~tag[x]) {
      if (ls[x]) addtag(ls[x], tag[x]);
      if (rs[x]) addtag(rs[x], tag[x]);
      tag[x] = -1;
    }
  }
  int build(int l, int r) {
    if (l > r) return 0;
    if (l == r) return pushup(idx[l]), idx[l];
    int mid = (l + r) >> 1;
    ls[idx[mid]] = build(l, mid - 1), rs[idx[mid]] = build(mid + 1, r);
    return pushup(idx[mid]), idx[mid];
  }
  int merge(int x, int y) {
    if (!x || !y) return x + y;
    pushdown(x), pushdown(y);
    if (rd[x] < rd[y]) {
      rs[x] = merge(rs[x], y);
      return pushup(x), x;
    } else {
      ls[y] = merge(x, ls[y]);
      return pushup(y), y;
    }
  }
  void split(int x, int k, int &a, int &b) {
    assert(k <= sz[x]);
    if (!x) return void(a = b = 0);
    pushdown(x);
    if (sz[ls[x]] + 1 <= k) {
      a = x, split(rs[x], k - sz[ls[x]] - 1, rs[x], b);
    } else {
      b = x, split(ls[x], k, a, ls[x]);
    }
    pushup(x);
  }
  int getdfn(int x) {
    int ret = sz[ls[x]] + 1;
    for (int i = x; fa[i]; i = fa[i]) {
      if (i == rs[fa[i]]) {
        ret += sz[ls[fa[i]]] + 1;
      }
    }
    return ret;
  }
  void ins(int x, int v) {
    int a, b, c;
    split(rt, getdfn(2 * x) - 1, a, b);
    split(b, 1, b, c);
    assert(b == 2 * x);
    fa[rt = merge(merge(a, merge(2 * v - 1, 2 * v)), merge(b, c))] = 0;
  }
  void cover(int x, int v) {
    int a, b, c;
    int dfn1 = getdfn(2 * x - 1), dfn2 = getdfn(2 * x);
    // std::cerr << "!!!! " << cnt2[2][0] << ' ' << cnt2[2][1] << ' ' << cnt2[2][2] << '\n';
    split(rt, dfn1 - 1, a, b), split(b, dfn2 - dfn1 + 1, b, c);
    addtag(b, v);
    // std::cerr << "????? " << x << ' ' << dfn1 << ' ' << dfn2 << ' ' << col[b] << ' ' << cnt1[b][0] << ' ' << cnt1[b][1] << ' ' << cnt1[b][2] << '\n';
    // std::cerr << "!!!! " << a << ' ' << sz[a] << ' ' << cnt2[a][0] << ' ' << cnt2[a][1] << ' ' << cnt2[a][2] << '\n';
    // std::cerr << "!!!! " << b << ' ' << sz[b] << ' ' << cnt2[b][0] << ' ' << cnt2[b][1] << ' ' << cnt2[b][2] << ' ' << ls[b] << ' ' << rs[b] << '\n';
    // std::cerr << "!!!! " << c << ' ' << sz[c] << ' ' << cnt2[c][0] << ' ' << cnt2[c][1] << ' ' << cnt2[c][2] << '\n';
    fa[rt = merge(merge(a, b), c)] = 0;
  }
  int query(int x, int v) {
    int a, b, c;
    int dfn1 = getdfn(2 * x - 1), dfn2 = getdfn(2 * x);
    split(rt, dfn1 - 1, a, b), split(b, dfn2 - dfn1 + 1, b, c);
    // std::cerr << "????? " << x << ' ' << dfn1 << ' ' << dfn2 << ' ' << col[b] << ' ' << cnt1[b][0] << ' ' << cnt1[b][1] << ' ' << cnt1[b][2] << '\n';
    // std::cerr << "!!!! " << a << ' ' << sz[a] << ' ' << cnt2[a][0] << ' ' << cnt2[a][1] << ' ' << cnt2[a][2] << '\n';
    // std::cerr << "!!!! " << b << ' ' << sz[b] << ' ' << cnt2[b][0] << ' ' << cnt2[b][1] << ' ' << cnt2[b][2] << ' ' << ls[b] << ' ' << rs[b] << '\n';
    // std::cerr << "!!!! " << c << ' ' << sz[c] << ' ' << cnt2[c][0] << ' ' << cnt2[c][1] << ' ' << cnt2[c][2] << '\n';
    int ret = cnt2[b][v];
    fa[rt = merge(merge(a, b), c)] = 0;
    return ret;
  }
} t;

void dfs(int u) {
  static int cnt = 0;
  idx[++cnt] = 2 * u - 1;
  for (auto v : G[u]) dfs(v);
  idx[++cnt] = 2 * u;
}

void prework() {
  dfs(1);
  for (int i = 1; i <= 2 * (n + m); ++i) {
    t.rd[i] = rnd(), t.sz[i] = 1, t.tag[i] = dep[i] = col[i] = -1;
  }
  for (int i = 1; i <= n; ++i) {
    dep[2 * i] = (dep[2 * p[i]] + 1) % k;
  }
  t.rt = t.build(1, 2 * n);
  // std::cerr << t.cnt1[t.rt][1] << ' ' << t.cnt2[2][1] << '\n';
}

void dickdreamer() {
  std::cin >> sid >> n >> m >> k;
  for (int i = 1; i <= n; ++i) {
    std::cin >> p[i];
    if (p[i]) G[p[i]].emplace_back(i);
  }
  prework();
  for (int i = 1, lastans = 0; i <= m; ++i) {
    int op, u, c;
    std::cin >> op >> u;
    if (sid % 2 == 0) u ^= lastans;
    if (op == 1) {
      std::cin >> c;
      if (sid % 2 == 0) c ^= lastans;
      // std::cerr << "fuck " << op << ' ' << lastans << ' ' << u << ' ' << c << '\n';
      t.cover(u, (c - dep[2 * u] + k) % k);
      // std::cerr << "???\n";
    } else if (op == 2) {
      std::cin >> c;
      if (sid % 2 == 0) c ^= lastans;
      // std::cerr << "fuck " << op << ' ' << lastans << ' ' << u << ' ' << c << '\n';
      std::cout << (lastans = t.query(u, c % k)) << '\n';
      // std::cerr << "shabi\n";
    } else {
      dep[2 * (++n)] = (dep[2 * u] + 1) % k;
      t.pushup(2 * n - 1), t.pushup(2 * n);
      t.ins(u, n);
    }
  }
}

int32_t main() {
  freopen("grandiloquence.in", "r", stdin);
  freopen("grandiloquence.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```