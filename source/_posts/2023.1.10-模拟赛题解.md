---
title: '2023.1.10 模拟赛题解'
date: 2023-01-10 22:15:00
---

# T1

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/K)

## Solution

首先可以把这个排列看成若干个置换环，易知置换环之间是互不影响的。所以只需要考虑每个置换环的答案。

首先可以想到一个不是很优的做法：每次把置换环上相邻的两个点操作，然后每次可以让置换环大小减半，所以只能做到 $\log n$ 次，不是最优的。

这个做法不优是因为有很多操作是不能同时做的，导致浪费了很多次操作。

所以可以这么做：每次从一个置换环上相隔为 $1$ 的两点开始，每次往另一方向跳，然后把跳到的点操作。

最后会变成若干个二元环和一元环，然后就可以 $2$ 次做完了。

时间复杂度：$O(n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 5;

int n;
int a[kMaxN], b[kMaxN], tmp[kMaxN];
bool vis[kMaxN];
vector<pair<int, int>> v[3];

bool check0() {
  for (int i = 1; i <= n; ++i)
    if (a[i] != i)
      return 0;
  cout << "0\n";
  return 1;
}

bool check1() {
  int cnt = 0;
  for (int i = 1; i <= n; ++i) {
    if (a[i] == i) continue;
    if (a[a[i]] != i) return 0;
    ++cnt;
  }
  cnt /= 2;
  cout << "1\n" << cnt << ' ';
  for (int i = 1; i <= n; ++i) {
    if (a[i] == i) continue;
    if (i < a[i]) cout << i << ' ' << a[i] << ' ';
  }
  return 1;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    b[a[i]] = i;
  }
  if (check0()) return 0;
  if (check1()) return 0;
  cout << "2\n";
  for (int c = 1; c <= 2; ++c) {
    fill(vis + 1, vis + 1 + n, 0);
    for (int i = 1; i <= n; ++i)
      tmp[i] = a[i];
    for (int i = 1; i <= n; ++i) {
      if (a[i] == i || vis[i]) continue;
      bool fl = 0;
      for (int j = i; j != i || !fl; j = a[j]) {
        vis[j] = 1;
        fl = 1;
      }
      if (a[a[i]] == i) {
        v[c].emplace_back(i, a[i]);
        swap(tmp[i], tmp[a[i]]);
      } else {
        int x = a[i], y = b[i];
        for (; x != y; x = a[x], y = b[y]) {
          v[c].emplace_back(x, y);
          swap(tmp[x], tmp[y]);
          if (x == y || y == a[x]) break;
        }
      }
    }
    for (int i = 1; i <= n; ++i)  
      a[i] = tmp[i];
    cout << v[c].size() << ' ';
    for (auto [x, y] : v[c]) {
      cout << x << ' ' << y << ' ';
    }
    cout << '\n';
  }
  return 0;
}
```

</details>

# T2

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/I)

## Solution

是个模拟题，直接按题意模拟即可，时间复杂度：$O(T\times 34^3\times 25)$，这个跑不满。

## Code

<details>
<summary>Code</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kC[] = {8, 8, 8, 6};
const char kR[] = "wbsz";

struct Node {
  int cnt[4], a[4][9];
  
  void clear() { memset(cnt, 0, sizeof(cnt)), memset(a, 0, sizeof(a)); }
};

int id[300];

bool check1(Node a) {
  for (int i = 0; i <= 3; ++i)
    if (a.cnt[i] % 3)
      return 0;
  for (int i = 0; i <= 6; ++i)
    if (a.a[3][i] % 3)
      return 0;
  for (int i = 0; i <= 2; ++i) {
    for (int j = 0; j <= 8; ++j) {
      if (a.a[i][j] < 0) return 0;
      a.a[i][j] %= 3;
      if (j + 2 > kC[i] && a.a[i][j]) return 0;
      if (j + 2 <= kC[i]) a.a[i][j + 1] -= a.a[i][j], a.a[i][j + 2] -= a.a[i][j];
    }
  }
  return 1;
}

bool check(Node a) {
  for (int i = 0; i <= 3; ++i)
    for (int j = 0; j <= kC[i]; ++j) {
      if (a.a[i][j] < 2) continue;
      a.a[i][j] -= 2, a.cnt[i] -= 2;
      if (check1(a)) return 1;
      a.a[i][j] += 2, a.cnt[i] += 2;      
    }
  return 0;
}

Node trans(string s) {
  Node ret;
  ret.clear();
  for (int i = 0; i < s.size(); i += 2) {
    ++ret.cnt[id[s[i + 1]]], ++ret.a[id[s[i + 1]]][s[i] - '1'];
  }
  return ret;
}

void solve(string s) {
  Node ss = trans(s);
  if (check(ss)) {
    cout << "Tsumo!\n";
    return;
  }
  int tot = 0;
  string res[30];
  for (int i = 0; i <= 3; ++i)
    for (int j = 0; j <= kC[i]; ++j)
      if (ss.a[i][j] >= 1) {
        ss.a[i][j] -= 1, ss.cnt[i] -= 1;
        string ans = "";
        for (int ii = 0; ii <= 3; ++ii)
          for (int jj = 0; jj <= kC[ii]; ++jj)
            if (ii != i || jj != j) {
              ++ss.a[ii][jj], ++ss.cnt[ii];
              if (check(ss)) {
                ans += char(jj + '1');
                ans += kR[ii];
              }
              --ss.a[ii][jj], --ss.cnt[ii];
            }
        if (ans.size() > 0) {
          res[++tot] = char(j + '1');
          res[tot] += kR[i];
          res[tot] += " ";
          res[tot] += ans;
        } 
        ss.a[i][j] += 1, ss.cnt[i] += 1;
      }
  cout << tot << '\n';
  for (int i = 1; i <= tot; ++i)
    cout << res[i] << '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  id['w'] = 0, id['b'] = 1, id['s'] = 2, id['z'] = 3;
  int T;
  cin >> T;
  while (T--) {
    string s;
    cin >> s;
    solve(s);
  }
  return 0;
}
```
</details>

# T3

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/C)

## Solution

设 $f[l,r]$ 表示操作 $[l,r]$，最后全变成 $a[r]$ 的最小操作次数。

那么可以得到一个朴素的转移：$f[l,r]=\min\big\{f[l,r-1]+1,f[l,k]+f[k+1,r]+[a[k]\neq a[r]]\big\}$。

这里会发现当 $a[k]=a[r]$ 的时候是不用加那个 $1$ 的，所以感性理解一下会发现当 $a[k]=a[r]$ 时是最优决策点。

时间复杂度：$O(15n^2)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 5005;

int T, n;
int a[kMaxN], lst[kMaxN], idx[kMaxN], f[kMaxN][kMaxN];

int main() {
  cin >> T;
  while (T--) {
    cin >> n;
    fill(lst + 1, lst + 1 + n, 0);
    fill(idx + 1, idx + 1 + n, 0);
    for (int i = 1; i <= n; ++i) {
      cin >> a[i];
      lst[i] = idx[a[i]];
      idx[a[i]] = i;
    }
    for (int i = 1; i <= n; ++i)
      for (int j = i; j <= n; ++j)
        f[i][j] = 1e9;
    for (int i = 1; i <= n; ++i)
      f[i][i] = 0;
    for (int len = 2; len <= n; ++len) {
      for (int i = 1; i + len - 1 <= n; ++i) {
        int j = i + len - 1;
        f[i][j] = f[i][j - 1] + 1;
        for (int k = lst[j]; k >= i; k = lst[k]) {
          f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
        }
      }
    }
    cout << f[1][n] << '\n';
  }
  return 0;
}
```
</details>

# T4

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/G)

## Solution

先按生日排序，设 $f_{i,j,k}$ 表示 $1\sim i$ 这些人中，选了 $j$ 个人，总共还剩 $k$ 天剩余的最大收益。$g_{i}$ 表示送 $i$ 个人礼物的最大收益。

那么 $f_{i,j,k}=\max\big\{f_{i-1,j,k-d_i+d_{i-1}}\space,f_{i-1,j-1,k-d_i+d_{i-1}+c_i}+v_i\big\}$。$g_i$ 可以直接暴力求。

把第一维滚掉即可，时间复杂度：$O(n^2d+2^m)$，会 T。

考虑到这里的 $m$ 很小，所以不会有很多的数不选，那么可以把状态改成：$f_{i,j,k}$ 表示 $1\sim i$ 这些人中，有 $j$ 个人没选，总共还剩 $k$ 天剩余的最大收益，其中 $f_{i,m,k}$ 表示至少有 $m$ 人没选的最大收益。

那么  $f_{i,j,k}=\max\big\{f_{i-1,j-1,k-d_i+d_{i-1}}\space,f_{i-1,j,k-d_i+d_{i-1}+c_i}+v_i\big\}$。

$f_{i,m,k}=\max\big\{f_{i-1,m-1,k-d_i+d_{i-1}}\space,f_{i-1,m,k-d_i+d_{i-1}}\space,f_{i-1,m,k-d_i+d_{i-1}+c_i}+v_i\big\}$。

这样做就是 $O(nmd+2^m)$ 了。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 1005, day[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

struct Node {
  int d, c, v;
} a[kMaxN];

int n, m, w, tot;
int b[kMaxN], c[kMaxN], f[2][kMaxN][kMaxN], ff[kMaxN], g[20]; // f[i][j] : 没选 i 个人，有 j 天剩余 

bool cmp(Node a, Node b) {
  return a.d < b.d;
}

void solve() {
  memset(g, 0xcf, sizeof(g));
  memset(f, 0xcf, sizeof(f));
  memset(ff, 0xcf, sizeof(ff));
  cin >> n >> m >> w;
  for (int i = 1; i <= n; ++i) {
    char ch;
    int year, mon, diao;
    cin >> year >> ch >> mon >> ch >> diao >> a[i].c >> a[i].v;
    a[i].d = day[mon - 1] + diao;
    if (mon == 2 && diao == 29) a[i].d = 3232;
  }
  for (int i = 1; i <= m; ++i)
    cin >> b[i] >> c[i];
  sort(a + 1, a + 1 + n, cmp);
  int cur = 0;
  f[1][0][0] = 0;
  for (int i = 1; i <= n; ++i, cur ^= 1) {
    if (a[i].d == 3232) break;
    tot = i;
    for (int j = 0; j < m; ++j) {
      for (int k = 0; k <= 365; ++k) {
        f[cur][j][k] = -1e9;
        if (j >= 1 && k >= a[i].d - a[i - 1].d) f[cur][j][k] = f[cur ^ 1][j - 1][k - (a[i].d - a[i - 1].d)];
        if (k + a[i - 1].d - a[i].d + a[i].c <= 365 && k + a[i - 1].d - a[i].d + a[i].c >= 0)
          f[cur][j][k] = max(f[cur][j][k], f[cur ^ 1][j][k + a[i - 1].d - a[i].d + a[i].c] + a[i].v);
          // x + (a[i].d - a[i - 1].d) - a[i].c = k
      }
    }
    for (int k = 0; k <= 365; ++k) {
      f[cur][m][k] = -1e9;
      if (m >= 1 && k >= a[i].d - a[i - 1].d)
        f[cur][m][k] = max(f[cur ^ 1][m - 1][k - (a[i].d - a[i - 1].d)], f[cur ^ 1][m][k - (a[i].d - a[i - 1].d)]);
      if (k + a[i - 1].d - a[i].d + a[i].c <= 365 && k + a[i - 1].d - a[i].d + a[i].c >= 0)
        f[cur][m][k] = max(f[cur][m][k], f[cur ^ 1][m][k + a[i - 1].d - a[i].d + a[i].c] + a[i].v);
    }
  }
  for (int i = 0; i <= m; ++i) {
    for (int j = 0; j <= 365; ++j)
      ff[i] = max(ff[i], f[cur ^ 1][i][j]);
  }
  for (int i = 0; i < (1 << m); ++i) {
    int sumb = 0, sumc = 0, cnt = 0;
    for (int j = 1; j <= m; ++j) {
      if (i >> (j - 1) & 1) {
        sumb += b[j], sumc += c[j], ++cnt;
      }
    }
    if (sumb <= w) g[cnt] = max(g[cnt], sumc);
  }
  ff[0] = 0;
  int ans = 0;
  for (int i = 0; i <= m; ++i)
    for (int j = 0; j <= m; ++j)
      if (tot - i + j <= tot)
        ans = max(ans, ff[i] + g[j]);
  cout << ans << '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  while (T--) solve();
  return 0;
}
```

</details>