---
title: 20240628 模拟赛 T1 题解
date: 2024-06-28 20:39:00
---

## Description

小 $\omega$ 在玩一个游戏，他把它称作「换换」。

初始有一个长为 $n$ 的正整数序列 $a_1,a_2,\dots,a_n$和两个参数 $l,r$。小 $\omega$ 的操作是可以选定 $i,j\in [1,n]\cap\mathbb{N}$，并交换 $a_i,a_j$。

当序列满足 $\exists k\in[1,n]\cap\mathbb{N},\sum_{i=1}^k a_i\in[l,r]$ 时游戏结束，小 $\omega$ 获胜。

由于小 $\omega$ 不想玩游戏被发现，因此小 $\omega$ 需要你帮他求出最小操作次数。

$1\le n,l,r,a_i\le 5\times 10^3,\sum n\le 10^4,l\le r$。

## Solution

容易发现题目相当于是求一个 $k$ 中，使得选出总共 $k$ 个数，和在 $[L,R]$ 中，且 $[k+1,n]$ 的个数最少。

设 $dp1_{i,j}$ 表示从 $a_1\sim a_i$ 中选一些数和为 $j$ 的**最大个数**，$dp2_{i,j}$ 表示从 $a_1\sim a_i$ 中选一些数和为 $[L-j,R-j]$ 的**最小个数**。

做法是对于每个 $i,j$，如果 $dp1_{i,j}+dp2_{i,j}\geq i$ 就让 $dp2_{i,j}$ 更新答案。下面证明这为什么是对的。

首先如果 $dp1_{i,j}+dp2_{i,j}\geq i$，则当前缀为 $[1,dp1_{i,j}+dp2_{i,j}]$ 时答案一定 $\leq dp2_{i,j}$。

然后对于每个最优解，不妨设是从 $[1,i]$ 中选 $k$ 个，$[i+1,n]$ 选 $k-i$ 个。

如果 $dp1_{i,j}+dp2_{i,j}<i$，容易发现 $k=dp1_{i,j}$，则这时的 $dp1,dp2$ 构成的方案在 $[1,dp1+dp2]$ 时答案一定 $\leq dp2_{i,j}+i-(dp1_{i,j}+dp2_{i,j})=k-i$。于是这时求 $[1,i]$ 的答案就转化到了 $[1,dp1+dp2]$ 的答案，容易发现这个转化一定不会永远进行下去，所以每个最优解一定能被统计到。

于是对于 $dp1$ 进行 dp，$dp2$ 进行 dp+单调队列优化即可。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 5e3 + 5;

int n, L, R;
int a[kMaxN], f[kMaxN][kMaxN], g[kMaxN][kMaxN], q[kMaxN];

void dickdreamer() {
  std::cin >> n >> L >> R;
  for (int i = 1; i <= n; ++i) std::cin >> a[i];
  for (int i = 0; i <= n + 1; ++i)
    for (int j = 0; j <= R + 1; ++j)
      f[i][j] = -1e9, g[i][j] = 1e9;
  f[0][0] = 0, g[n + 1][0] = 0;
  int ans = 1e9;
  for (int i = n; i; --i) {
    for (int j = 0; j <= R; ++j) {
      g[i][j] = std::min(g[i][j], g[i + 1][j]);
      if (j <= R - a[i]) g[i][j + a[i]] = std::min(g[i][j + a[i]], g[i + 1][j] + 1);
    }
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 0; j <= R; ++j) {
      f[i][j] = std::max(f[i][j], f[i - 1][j]);
      if (j <= R - a[i]) f[i][j + a[i]] = std::max(f[i][j + a[i]], f[i - 1][j] + 1);
    }
    int h = 1, t = 0;
    for (int j = R; ~j; --j) {
      for (; h <= t && g[i + 1][R - j] <= g[i + 1][q[t]]; --t) {}
      q[++t] = R - j;
      if (j <= L - 1) {
        for (; h <= t && q[h] <= L - j - 1; ++h) {}
      }
      if (f[i][j] >= 0 && f[i][j] + g[i + 1][q[h]] >= i) ans = std::min(ans, g[i + 1][q[h]]);
    }
  }
  std::cout << (ans == 1e9 ? -1 : ans) << '\n';
}

int32_t main() {
  freopen("swap.in", "r", stdin);
  freopen("swap.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```