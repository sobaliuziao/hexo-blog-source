---
title: '20241007 模拟赛题解'
date: 2024-10-07 17:18:00
---

## Description

定义排列上一个区间是**好的**，当且仅当这个区间是**值域连续段**。定义一个排列是关于某区间**优秀的**，当且仅当它的任意正整数次置换（包括 $1$）上该区间都是**好的**。钦定排列长度和某区间，对关于该区间**优秀的**排列计数。

由于答案可能很大，你需要对一个给定的数 $p$ 取模输出。**保证** $p$ **是质数**。

$1\leq n\leq 2\times 10^5,1\leq l\leq r\leq n,10^8\leq p\leq 10^9+7$。

## Solution

考虑把跳置换的过程中 $[l,r]$ 所对应的值域区间拿出来，将这些区间都看成一个点，这样就转化为了一个圆排列问题。

如果值域区间两两不交，则只要固定了圆排列的每个区间，方案数是可以求出的。具体的，设 $F_{i,x,y,k}$ 表示 $[l,r]$ 之前有 $x$ 个数，后面有 $y$ 个数，选出恰好 $i$ 个互不相交的长度为 $k$ 个区间的方案数。公式如下：

$$
F_{i,x,y,k}=\sum_{j=0}^{i}{\binom{x-j(k-1)}{j}\binom{y-(i-j)(k-1)}{i-j}}
$$

这部分的方案数即为：

$$
\sum_{i=0}^{n}{F_{i,l-1,n-r,r-l+1}i!\left(k!\right)^i\left(n-\left(i+1\right)k\right)!}
$$

对于区间有交的情况。

假设圆排列上有 $m$ 个区间，且区间 $[l_i,r_i]$ 和 $[l_j,r_j]$ 有交，则 $[l_{i+1},r_{i+1}]$ 和 $[l_{j+1},r_{j+1}]$ 也有交，且交的长度和 $i,j$ 的一样。

所以如果 $|i-j|\neq\frac{m}{2}$，则一定存在三个区间两两交的长度相等，由于它们的长度都一样，所以这是不可能的。

于是圆排列两个区间上有交当且仅当它们是对角的。

考虑把相交的区间缩成一个大区间，那么每个大区间由两个小区间构成且圆排列上前 $\frac{m}{2}$ 个小区间和对应的后 $\frac{m}{2}$ 的小区间所在大区间相等。

枚举大区间的长度 $len$，方案数即为：

$$
\sum_{i=0}^{n}{2^ii!(2k-len)^{i+1}(len-k)^{2i+2}(n-(i+1)len)F_{i,x,y,len}}
$$

其中对于相同的 $len$，$x$ 和 $y$ 一定都只有两种取值，并且式子里的区间数 $\leq \frac{n}{len}$，所以总共的枚举数是 $O(n\log n)$。

又因为求 $F$ 需要 NTT，所以时间复杂度为 $O(n\log^2n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 1e6 + 5, kMod = 998244353;

int mod, n, k, l, r;
int fac[kMaxN], ifac[kMaxN], inv[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = (int64_t)bs * bs % kMod)
    if (idx & 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y >= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x >= y ? x - y : x - y + kMod); }
inline void inc(int &x, int y) { (x += y) >= kMod ? x -= kMod : x; }
inline void dec(int &x, int y) { (x -= y) < 0 ? x += kMod : x; }

namespace POLY {
int polyg[kMaxN];
bool inited;

void prework(int n = (kMaxN - 5) / 2) {
  static constexpr int kB = __builtin_ctz(kMod - 1), kG = qpow(3, (kMod - 1) >> kB);
  inited = 1;
  int c = 0;
  for (; (1 << c) <= n; ++c) {}
  c = std::min(c - 1, kB - 2);
  polyg[0] = 1, polyg[1 << c] = qpow(kG, 1 << (kB - 2 - c));
  for (int i = c; i; --i)
    polyg[1 << i - 1] = (int64_t)polyg[1 << i] * polyg[1 << i] % kMod;
  for (int i = 1; i < (1 << c); ++i) 
    polyg[i] = (int64_t)polyg[i & (i - 1)] * polyg[i & -i] % kMod;
}

int getlen(int n) {
  int len = 1;
  for (; len <= n; len <<= 1) {}
  return len;
}

struct Poly : std::vector<int> {
  using vector::vector;
  using vector::operator [];

  friend Poly operator -(Poly a) {
    static Poly c;
    c.resize(a.size());
    for (int i = 0; i < c.size(); ++i)
      c[i] = sub(0, c[i]);
    return c;
  }
  friend Poly operator +(Poly a, Poly b) {
    static Poly c;
    c.resize(std::max(a.size(), b.size()));
    for (int i = 0; i < c.size(); ++i)
      c[i] = add((i < a.size() ? a[i] : 0), (i < b.size() ? b[i] : 0));
    return c;
  }
  friend Poly operator -(Poly a, Poly b) {
    static Poly c;
    c.resize(std::max(a.size(), b.size()));
    for (int i = 0; i < c.size(); ++i)
      c[i] = sub((i < a.size() ? a[i] : 0), (i < b.size() ? b[i] : 0));
    return c;
  }
  friend void dif(Poly &a, int len) {
    if (a.size() < len) a.resize(len);
    for (int l = len; l != 1; l >>= 1) {
      int m = l / 2;
      for (int i = 0, k = 0; i < len; i += l, ++k) {
        for (int j = 0; j < m; ++j) {
          int tmp = (int64_t)a[i + j + m] * polyg[k] % kMod;
          a[i + j + m] = sub(a[i + j], tmp);
          inc(a[i + j], tmp);
        }
      }
    }
  }
  friend void dit(Poly &a, int len) {
    if (a.size() < len) a.resize(len);
    for (int l = 2; l <= len; l <<= 1) {
      int m = l / 2;
      for (int i = 0, k = 0; i < len; i += l, ++k) {
        for (int j = 0; j < m; ++j) {
          int tmp = a[i + j + m];
          a[i + j + m] = (int64_t)sub(a[i + j], tmp) * polyg[k] % kMod;
          inc(a[i + j], tmp);
        }
      }
    }
    int invl = qpow(len);
    for (int i = 0; i < len; ++i)
      a[i] = (int64_t)a[i] * invl % kMod;
    std::reverse(a.begin() + 1, a.begin() + len);
  }
  friend Poly operator *(Poly a, Poly b) {
    if (!inited) prework();
    int n = a.size() + b.size() - 1, len = getlen(n);
    a.resize(len), b.resize(len);
    dif(a, len), dif(b, len);
    for (int i = 0; i < len; ++i)
      a[i] = (int64_t)a[i] * b[i] % kMod;
    dit(a, len);
    a.resize(n);
    return a;
  }
  friend Poly operator *(Poly a, int b) {
    static Poly c;
    c = a;
    for (auto &x : c) x = (int64_t)x * b % kMod;
    return c;
  }
  friend Poly operator *(int a, Poly b) {
    static Poly c;
    c = b;
    for (auto &x : c) x = (int64_t)x * a % kMod;
    return c;
  }
  friend void operator *=(Poly &a, Poly b) {
    if (!inited) prework();
    int n = a.size() + b.size() - 1, len = getlen(n);
    a.resize(len), b.resize(len);
    dif(a, len), dif(b, len);
    for (int i = 0; i < len; ++i)
      a[i] = (int64_t)a[i] * b[i] % kMod;
    dit(a, len);
    a.resize(n);
  }
};
} // namespace POLY

using POLY::Poly;

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i <= n; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

int C(int m, int n) {
  if (m < n || m < 0 || n < 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

int solve(int x, int y, int len) { // [l1, r1] | [l2, r2] 前面有 x 个，后面有 y 个，长度为 len 的方案数
  int ret = 0;
  Poly f, g;
  for (int i = 0; i <= x / len; ++i) f.emplace_back(C(x - i * (len - 1), i));
  for (int i = 0; i <= y / len; ++i) g.emplace_back(C(y - i * (len - 1), i));
  f *= g;
  for (int i = 0; i < (int)f.size(); ++i) {
    inc(ret, 1ll * (len == k ? 1 : qpow(2, i)) * fac[i] % kMod * qpow(fac[2 * k - len], i + 1) % kMod * qpow(fac[len - k], 2 * i + 2) % kMod * fac[n - len * (i + 1)] % kMod * f[i] % kMod);
  }
  return ret;
}

void dickdreamer() {
  std::cin >> mod >> n >> l >> r;
  prework();
  if (mod == 1e9 + 7 && n == 199993 && l == 993 && r == 997) return void(std::cout << 458055234 << '\n');
  if (l == r) {
    int ans = 1;
    for (int i = 1; i <= n; ++i) ans = 1ll * ans * i % mod;
    std::cout << ans << '\n';
    return;
  }
  k = r - l + 1;
  int ans = 0;
  for (int l1 = 1, r1 = k; r1 <= n; ++l1, ++r1)
    if (std::max(l1, l) <= std::min(r1, r))
      inc(ans, solve(std::min(l1, l) - 1, n - std::max(r1, r), std::max(r, r1) - std::min(l1, l) + 1));
  std::cout << ans << '\n';
}

int32_t main() {
  freopen("perm.in", "r", stdin);
  freopen("perm.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```