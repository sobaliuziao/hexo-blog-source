---
title: '2023.3.10 模拟赛 T1 题解'
date: 2023-03-10 16:19:00
---

## Description

![image-20230310161208930](https://cdn.staticaly.com/gh/liuziao20081122/images@main/img/202303101612959.png)

$n,b\leq 10^7$。

## Solution

定义 $d_i$ 表示所有模 $n$ 余 $i$ 的数中非零位个数的最小值。

那么很明显把 $i$ 乘 $b$ 不会变大，所以 $d_{ib\bmod n}\leq b_i$。

然后把 $i$ 乘 $b$ 后在最后一位添上一个数，答案最多变化 $1$，所以 $d_{(ib+s)\bmod n}\leq d_i+1(0<s<b)$。

又因为已知 $d_1=d_2=\dots=d_{b-1}=1$，所以直接跑 01BFS 即可。

时间复杂度：$O(nb)$，过不了。

---

有一个显然的事情，上面的第二个式子只会更新一个区间内里还没有走到的数。所以可以用并查集维护每一个大于等于某一个数的最小的还没有走到的数。

每次操作完就把当前数 $x$ 的 $fa[x]$ 赋值成 $find(x+1)$ 即可。

时间复杂度：$O(n\log n)$ 或 $O(n\alpha(n))$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int long long

using namespace std;

const int kMaxN = 2e7 + 5;

int n, b;
int q[kMaxN], fa[kMaxN], dis[kMaxN];
bool vis[kMaxN];

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void bfs() {
  int h = n, t = n - 1;
  for (int i = 1; i <= 2e7; ++i)
    fa[i] = i;
  for (int i = 1; i < b; ++i) {
    dis[i] = 1;
    q[++t] = i;
    fa[i] = b;
  }
  while (h <= t) {
    int c = q[h++], v = dis[c];
    if (vis[c]) continue;
    vis[c] = 1;
    int cc = 1ll * c * b % n;
    if (!cc) {
      dis[0] = v;
      break;
    }
    if (cc + b - 1 >= n && !dis[0]) {
      dis[0] = v + 1;
      q[++t] = 0;
    }
    if (!dis[cc] || dis[cc] > v) {
      dis[cc] = v;
      if (fa[cc] == cc) fa[cc] = find(cc + 1);
      q[--h] = cc;
    }
    int now = find(cc + 1);
    while (now < min(cc + b, n)) {
      dis[now] = v + 1;
      fa[now] = find(now + 1);
      q[++t] = now;
      now = find(now + 1);
    }
  }
  cout << dis[0] << '\n';
}

void dickdreamer() {
  cin >> n >> b;
  bfs();
}

int32_t main() {
  freopen("puzzle.in", "r", stdin);
  freopen("puzzle.out", "w", stdout);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T = 1;
  // cin >> T;
  while (T--) dickdreamer();
  // cerr << 1.0 * clock() / CLOCKS_PER_SEC << 's';
  return 0;
}
```
