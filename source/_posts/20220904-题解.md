---
title: '20220904 题解'
date: 2022-09-06 22:42:00
---

- [problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/kz2jsqnx)

- [solution](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/o4n1itvq)

## T1

令 $f_{i,j}$ 表示 $i$ 能够进入第 $j$ 轮的概率，然后转移就行。

注：这题没卡精度，`long double` 可过。

我赛时写了个高精然后被卡常了/kk。

```cpp
#include <bits/stdc++.h>

#define db(x) cerr << #x << '=' << x << endl

using namespace std;

const int kMaxN = 1030;

int n, m;
int x;
int p[kMaxN][kMaxN];
long double f[kMaxN][15];

int rev(int x) {
  if (x & 1) return x + 1;
  else return x - 1;
}

int main() {
  freopen("elimination.in", "r", stdin);
  freopen("elimination.out", "w", stdout);
  cin >> n; m = (1 << n);
  for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= m; ++j) {
      cin >> p[i][j];
    }
  }
  for (int i = 1; i <= m; ++i) {
    f[i][0] = 1;
  }
  for (int i = 1; i <= n; ++i) {
    int k = (1 << i - 1);
    for (int j = 1; j <= m; ++j) {
      // db(j);
      int bl = (j - 1) / k + 1, bb = rev(bl);
      int l = (bb - 1) * k + 1, r = bb * k;
      for (int s = l; s <= r; ++s) {
        f[j][i] += p[j][s] * f[s][i - 1] / 100.0;
      }
      f[j][i] *= f[j][i - 1];
    }
  }
  long double mx = 0; int idx = -1;
  for (int i = 1; i <= m; ++i) {
    // print(f[i][n]), putchar('\n');
    if (f[i][n] > mx) {
      mx = f[i][n], idx = i;
    }
  }
  cout << idx << endl;
  cerr << 1.0 * clock() / CLOCKS_PER_SEC << 's' << endl;
  return 0;
}
```

## T2

令 $s_i$ 表示 $1\sim i$ 种的树的个数。

那么对于每个约束，$s_e\geq s_{b-1}+t$。

跑个最长路就行了。

```cpp
#include <bits/stdc++.h>

#define db(x) cerr << #x << '=' << x << endl

using namespace std;

const int kMaxN = 3e4 + 5, kInf = 0x3f3f3f3f;

int n, m;
vector<pair<int, int>> G[kMaxN];

void addE(int u, int v, int w) {
  G[u].push_back({v, w});
}

namespace SPFA {

int dis[kMaxN];
bool vis[kMaxN];
queue<int> q;

void SPFA() {
  while (!q.empty()) q.pop();
  fill(dis, dis + 2 + n, -kInf);
  fill(vis, vis + 2 + n, 0);
  dis[n + 1] = 0, vis[n + 1] = 1, q.push(n + 1);
  while (!q.empty()) {
    int nf = q.front(); q.pop();
    vis[nf] = 0;
    for (auto p : G[nf]) {
      int v = p.first, w = p.second;
      if (dis[v] < dis[nf] + w) {
        dis[v] = dis[nf] + w;
        if (!vis[v]) q.push(v), vis[v] = 1;
      }
    }
  }
  cout << dis[n] << endl;
}

} // namespace SPFA

int main() {
  freopen("tree.in", "r", stdin);
  freopen("tree.out", "w", stdout);
  cin >> n >> m;
  for (int i = 1, u, v, w; i <= m; ++i) {
    cin >> u >> v >> w;
    addE(u - 1, v, w);
  }
  for (int i = 0; i <= n; ++i) {
    addE(n + 1, i, 0);
  }
  for (int i = 0; i < n; ++i) {
    addE(i, i + 1, 0);
    addE(i + 1, i, -1);
  }
  SPFA::SPFA();
  return 0;
}
```

## T3

令 $y=x^x\bmod 1000$，那么答案就是 $C_{y-1}^{k-1}$，写个高精就行了。

```cpp
#include <bits/stdc++.h>

#define int long long
#define db(x) cerr << #x << '=' << x << endl;

using namespace std;

int x, k;

int qpow(int bs, int idx) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = 1ll * bs * bs % 1000) {
    if (idx & 1) ret = 1ll * ret * bs % 1000;
  }
  return ret;
}

vector<int> tovec(int x) {
  vector<int> c;
  c.clear();
  if (!x) {
    c.emplace_back(0);
    return c;
  }
  for (; x; x /= 10) {
    c.emplace_back(x % 10);
  }
  return c;
}

vector<int> add(vector<int> a, vector<int> b) {
  vector<int> c, res;
  c.clear(), res.clear();
  c.resize(max(a.size(), b.size()) + 1);
  for (int i = 0; i <= max(a.size(), b.size()) - 1; ++i) {
    if (i < a.size()) c[i] += a[i];
    if (i < b.size()) c[i] += b[i];
    c[i + 1] += c[i] / 10, c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i <= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector<int> mul(vector<int> a, vector<int> b) {
  vector<int> c, res;
  c.clear(), res.clear();
  c.resize(a.size() + b.size() + 2);
  for (int i = 0; i < a.size(); ++i) {
    for (int j = 0; j < b.size(); ++j) {
      c[i + j] += a[i] * b[j];
    }
  }
  for (int i = 0; i < c.size() - 1; ++i) {
    c[i + 1] += c[i] / 10;
    c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i <= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector<int> div(vector<int> a, int x) {
  vector<int> c, res;
  c.clear(), res.clear();
  c.resize(a.size() + 2);
  int nw = 0;
  for (int i = a.size() - 1; ~i; --i) {
    nw = 10 * nw + a[i];
    if (nw >= x) {
      c[i] = nw / x;
      nw %= x;
    } else {
      c[i] = 0;
    }
  }
  for (int i = 0; i < c.size() - 1; ++i) {
    c[i + 1] += c[i] / 10;
    c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i <= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector<int> C(int m, int n) { // m! / n! / (m - n)!
  if (m < n) return tovec(0);
  vector<int> v = tovec(1);
  for (int i = m; i >= m - n + 1; --i) {
    v = mul(v, tovec(i));
  }
  for (int i = 1; i <= n; ++i) {
    v = div(v, i);
  }
  return v;
}

void print(vector<int> v) {
  for (int i = v.size() - 1; ~i; --i) {
    putchar(v[i] + '0');
  }
  putchar('\n');
}

signed main() {
  freopen("equation.in", "r", stdin);
  freopen("equation.out", "w", stdout);
  cin >> k >> x;
  x %= 1000, x = qpow(x, x);
  if (!x) {
    putchar('0'), putchar('\n');
    return 0;
  }
  print(C(x - 1, k - 1));
  return 0;
}
// ans = C(x - 1, k - 1) = (x - 1)! / (k - 1)! / (x - k)!
```

## T4

令 $f_i$ 表示前 $i$ 天的答案，令 $s(l,r)$ 表示从 $l$ 到 $r$ 天，每天都用同一个路径的最短路。

那么 $f_i=\max\{s(1,i)\times i, f_j+s(j+1,i)\times(i-j)+k\}$。
这样做是 $O(nme)$ 的。

赛时我写了个 $O(2^m\times m\times e)$ 的大常数做法，然后最慢的点跑 $7s$，于是乎就只有 $30$ 分了。

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 114514
#endif

using namespace std;

typedef long long ll;

const int kMaxN = 25, kMaxS = (1 << 20) + 5, kMaxT = 105, kInf = 0x3f3f3f3f;

int t, n, m, k, d;
int go[kMaxN][kMaxT], nw[kMaxN];
ll f[kMaxT];
vector<pair<int, int>> G[kMaxN];

void addE(int u, int v, int w) {
  G[u].emplace_back(v, w);
}

namespace SPFA {

queue<int> q;
int dis[kMaxN];
bool vis[kMaxN];

void prework(int l, int r) {
  fill(nw + 1, nw + 1 + n, 1);
  for (int i = 1; i <= n; ++i) {
    for (int j = l; j <= r; ++j) {
      if (!go[i][j]) nw[i] = 0;
    }
  }
}

int SPFA(int l, int r) {
  prework(l, r);
  while (!q.empty()) q.pop();
  fill(dis + 1, dis + 1 + n, kInf);
  fill(vis + 1, vis + 1 + n, 0);
  q.push(1), dis[1] = 0, vis[1] = 1;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    vis[u] = 0;
    for (auto p : G[u]) {
      int v = p.first, w = p.second;
      if (!nw[v]) continue ;
      if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) q.push(v), vis[v] = 1;
      }
    }
  }
  return dis[n];
}

} // namespace SPFA

int main() {
  cin >> t >> n >> k >> m;
  for (int i = 1, u, v, w; i <= m; ++i) {
    cin >> u >> v >> w;
    addE(u, v, w), addE(v, u, w);
  }
  cin >> d;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= t; ++j) {
      go[i][j] = 1;
    }
  }
  for (int i = 1, p, a, b; i <= d; ++i) {
    cin >> p >> a >> b;
    for (int j = a; j <= b; ++j) {
      go[p][j] = 0;
    }
  }
  for (int i = 1; i <= t; ++i) {
    f[i] = 1ll * SPFA::SPFA(1, i) * i;
    for (int j = 1; j < i; ++j) {
      f[i] = min(f[i], f[j] + 1ll * SPFA::SPFA(j + 1, i) * (i - j) + k);
    }
  }
  cout << f[t] << endl;
  cerr << 1.0 * clock() / CLOCKS_PER_SEC << 's' << endl;
  return 0;
}
```

橙题模拟赛只有 $310$，垫底了。