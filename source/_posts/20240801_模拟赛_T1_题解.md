---
title: 20240801 模拟赛 T1 题解
date: 2024-08-01 19:56:00
---

## Description

Hitori的手上有一个字符串，同时有 $n$ 个长度为 $m$ 的字符串 $T_1,T_2,...,T_n$，以及一个长度为 $k$ 的正实数数列 $\{p_i\}$，保证这个数列的和为 $1$ 。每一个字符串都保证只由前 $k$ 个小写字符构成。Hitori有个爱捣蛋的朋友Kita酱，Kita酱会对字符串做如下的操作：

$\quad$1、如果存在一个 $j(1\leq j\leq n)$ 满足 $T_j$ 是 $S$ 的子串，则停止。

$\quad$2、在字符串的尾部以 $p_i(1\leq i \leq k)$ 的概率添加第 $i$ 个小写字母，然后回到步骤一检测。

这里定义一个函数 $f(S;T,p)$ 表示：字符串 $S$ 经过无限次操作停下来的期望长度。

Kita酱表示对于一个给定的 $S$，计算 $f(S;T,p)$ 太无聊了。

然而，Hitori表示对于一个给定的 $R$，计算 $R$ 的每一个前缀 $R[1...i](1\leq i \leq |R|)$ 的函数值 $f(R[1..i];T,p)$ 也很无聊，Hitori表示我甚至可以加入修改操作以及动态查询操作，具体的操作形式如下：

$\quad$· 修改操作：给定 $l$ 和 $c$，将字符串 $R$ 末尾的 $l$ 个字符换成 $c$。

$\quad$· 查询操作：给定 $l$，查询$f(R[1..i];T,p)$ 的值。

这里保证 $f(S;T,p)$ 可以被表示成一个正实数 $\frac{P}{Q}(gcd(P,Q)=1)$，同时保证对于任意的字符串 $S$ 在给定的 $T$ 和序列 $\{p_i\}$ 下，有 $Q\not\equiv 0 \enspace(mod(10^9+7))$，所以只需要计算出 $PQ^{-1}mod\enspace(10^9+7)$ 即可。

$n\leq 100,n\times m\leq 10^4,|R|\leq 10^4,Q\leq 10^5$。

[link](http://xsy.gdgzez.com.cn/JudgeOnline/problem.php?cid=2001&pid=0)

## Solution

注意到这里停止的条件为存在一个 $T_j$ 为 $S$ 的子串，这显然可以转到 AC 自动机上，等价于 $S$ 对应的节点为叶子节点。

那么就可以设计 dp 了。

设 $f_i$ 表示 AC 自动机上 $i$ 号点走到停止的期望步数，可以得到转移：

$$
f_i=\sum_{j=0}^{k-1}{p_jf_{trie_{i,j}}}+1
$$

对于解方程、修改和查询均暴力可以做到 $O((nm)^3+Q|R|)$。

---

先考虑修改和查询的优化。

不妨设 $pos_i$ 表示 $R[1\ldots i]$ 对应节点，注意到两次修改 $(l_1,c_1)$ 和 $(l_2,c_2)$，如果 $(l_2,c_2)$ 后出现并且 $l_1\leq l_2$，则 $(l_1,c_1)$ 就没用了。所以可以维护一个 $l$ 递减单调栈表示可能造成贡献的修改，每次添加一个 $(l,c)$ 就把栈里所有长度 $\leq l$ 的修改去掉，顺便维护 $g_i$ 表示栈里第 $i$ 个修改的 $pos_{l_i}$ 的值，这部分可以通过倍增维护。

对于查询节点就找到栈里覆盖当前位置的修改，通过 $g$ 值+倍增即可快速求出。

这部分时间复杂度：$O(Q|R|k\log|R|)$。

---

再考虑解方程的优化。

注意到上面那个暴力解方程有很多是浪费的，同时 $n$ 很小，考虑转化为 $n\times n$ 的方程。

可以先把 trie 树做树链剖分，然后用所有链的链顶去表示其它所有点的答案。

这里自顶向下转移，不妨设 $i$ 在同一个链里的儿子为 $trie_{i,s}$，那么可以用 $f_i$ 表示 $f_{trie_{i,s}}$：

$$
f_{trie_{i,s}}=\frac{f_i-1-\sum_{j\neq s}{p_jf_{trie_{i,j}}}}{p_s}
$$

容易发现如果 $trie_{i,j}$ 为返祖边则 $f_{trie_{i,j}}$ 一定已经计算出来了，否则 $trie_{i,j}$ 一定是一个链的链顶，也已经计算出，所以 $f_{trie_{i,s}}$ 能够成功表示。

然后通过对 $n$ 个叶子的表示就可以解出 $n$ 个链顶的答案，然后通过这 $n$ 个链顶即可求出所有节点的答案。

这部分时间复杂度：$O(n^2mk+n^3)$。

总的时间复杂度：$O(n^2mk+n^3+Q|R|k\log|R|)$。

## Code

```cpp

```#include <bits/stdc++.h>

#define int int64_t

const int kMaxN = 105, kMaxT = 1e4 + 5, kMod = 1e9 + 7;

int n, m, k, q, t, trie_tot;
int p[30], trie[kMaxT][26], fail[kMaxT], dep[kMaxT];
int a[kMaxN][kMaxN], f[kMaxT], g[kMaxN], nxt[kMaxT][26][15], pp[kMaxT], pos[kMaxT];
int top[kMaxT], bel[kMaxT], son[kMaxT], val[kMaxT][kMaxN];
bool vis[kMaxT];
std::string str, s[kMaxN];
std::vector<int> T[kMaxT];
std::vector<std::pair<int, int>> vec;

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = (int64_t)bs * bs % kMod)
    if (idx & 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y >= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x >= y ? x - y : x - y + kMod); }
inline void inc(int &x, int y) { (x += y) >= kMod ? x -= kMod : x; }
inline void dec(int &x, int y) { (x -= y) < 0 ? x += kMod : x; }

void ins(std::string s) {
  int cur = 0;
  for (auto c : s) {
    int k = c - 'a';
    if (!trie[cur][k]) dep[trie[cur][k] = ++trie_tot] = dep[cur] + 1;
    cur = trie[cur][k];
  }
  vis[cur] = 1;
}

void dfs(int u) {
  for (auto v : T[u]) {
    vis[v] |= vis[u];
    dfs(v);
  }
}

void build() {
  std::queue<int> q;
  for (int i = 0; i < k; ++i) {
    if (trie[0][i]) q.emplace(trie[0][i]);
  }
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = 0; i < k; ++i) {
      if (trie[u][i]) {
        fail[trie[u][i]] = trie[fail[u]][i];
        q.emplace(trie[u][i]);
      } else {
        trie[u][i] = trie[fail[u]][i];
      }
    }
  }
  for (int i = 1; i <= trie_tot; ++i) T[fail[i]].emplace_back(i);
  dfs(0);
}

int getnxt(int x, int c, int s) {
  for (int i = 0; i <= 14; ++i)
    if (s >> i & 1)
      x = nxt[x][c][i];
  return x;
}

void _dfs(int u) {
  static int cnt = 0;
  if (!bel[u]) bel[u] = ++cnt, top[cnt] = u;
  bool fl = 0;
  for (int i = 0; i < k; ++i) {
    int v = trie[u][i];
    if (dep[v] <= dep[u]) continue;
    if (!fl) bel[v] = bel[u], son[u] = i, fl = 1;
    _dfs(v);
  }
}

void getmat() {
  std::queue<int> q;
  q.emplace(0);
  for (int i = 1; i <= n; ++i) val[top[i]][i] = 1;
  int now = 0;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = 0; i < k; ++i) {
      int v = trie[u][i];
      if (dep[v] <= dep[u]) continue;
      assert(dep[v] == dep[u] + 1);
      q.emplace(v);
    }
    if (dep[u] == m) {
      ++now;
      for (int i = 1; i <= n; ++i) a[now][i] = val[u][i];
      a[now][n + 1] = sub(0, val[u][0]);
      continue;
    }
    int s = son[u], v = trie[u][s], iv = qpow(p[s]);
    for (int i = 0; i <= n; ++i) val[v][i] = val[u][i];
    dec(val[v][0], 1);
    for (int i = 0; i < k; ++i) {
      if (i == s) continue;
      for (int j = 0; j <= n; ++j) dec(val[v][j], 1ll * val[trie[u][i]][j] * p[i] % kMod);
    }
    for (int i = 0; i <= n; ++i) val[v][i] = 1ll * val[v][i] * iv % kMod;
  }
}

void prework() {
  for (int i = 0; i <= trie_tot; ++i) {
    for (int j = 0; j < k; ++j) nxt[i][j][0] = trie[i][j];
  }
  for (int j = 0; j < k; ++j) {
    for (int s = 1; s <= 14; ++s)
      for (int i = 0; i <= trie_tot; ++i) {
        nxt[i][j][s] = nxt[nxt[i][j][s - 1]][j][s - 1];
      }
  }
  _dfs(0), getmat();
  for (int i = 1; i <= n; ++i) {
    if (!a[i][i]) {
      for (int j = i + 1; j <= n; ++i) {
        if (a[j][i]) {
          std::swap(a[i], a[j]);
          break;
        }
      }
    }
    assert(a[i][i]);
    for (int j = i + 1; j <= n; ++j) {
      int v = 1ll * a[j][i] * qpow(a[i][i]) % kMod;
      for (int k = i; k <= n + 1; ++k)
        dec(a[j][k], 1ll * a[i][k] * v % kMod);
    }
  }
  for (int i = n; i; --i) {
    assert(a[i][i]);
    for (int j = i + 1; j <= n; ++j)
      dec(a[i][n + 1], 1ll * g[j] * a[i][j] % kMod);
    g[i] = 1ll * a[i][n + 1] * qpow(a[i][i]) % kMod;
  }
  for (int i = 0; i <= trie_tot; ++i) {
    f[i] = val[i][0];
    for (int j = 1; j <= n; ++j)
      inc(f[i], 1ll * val[i][j] * g[j] % kMod);
  }
}

void upd(int x, int c) {
  for (; !vec.empty() && vec.back().first <= x; vec.pop_back()) {}
  if (!vec.empty()) {
    pos[vec.size()] = trie[getnxt(pos[vec.size() - 1], vec.back().second, vec.back().first - x - 1)][c];
  } else {
    pos[vec.size()] = trie[pp[t - x]][c];
  }
  vec.emplace_back(x, c);
}

int getpos(int x) {
  if (vec.empty()) return pp[x];
  int L = -1, R = vec.size(), res = -1;
  while (L + 1 < R) {
    int mid = (L + R) >> 1;
    if (x >= t - vec[mid].first + 1) L = res = mid;
    else R = mid;
  }
  if (res == -1) return pp[x];
  int lst = vec[res].first, c = vec[res].second;
  return getnxt(pos[res], c, x - (t - lst + 1));
}

void dickdreamer() {
  std::cin >> n >> m >> k;
  int sump = 0;
  for (int i = 0; i < k; ++i) {
    std::cin >> p[i];
    inc(sump, p[i]);
  }
  sump = qpow(sump);
  for (int i = 0; i < k; ++i) p[i] = 1ll * p[i] * sump % kMod;
  for (int i = 1; i <= n; ++i) {
    std::cin >> s[i];
    ins(s[i]);
  }
  std::sort(s + 1, s + 1 + n);
  n = std::unique(s + 1, s + 1 + n) - (s + 1);
  build();
  std::cin >> str >> q;
  prework();
  int cur = 0;
  t = str.size(), str = " " + str;
  for (int i = 1; i <= t; ++i) {
    cur = trie[cur][str[i] - 'a'];
    std::cout << add(f[cur], i) << '\n';
    pp[i] = cur;
  }
  for (int cs = 1; cs <= q; ++cs) {
    int op, l;
    std::string c;
    std::cin >> op >> l;
    if (op == 1) {
      std::cin >> c;
      upd(l, c[0] - 'a');
    } else {
      int cur = 0;
      cur = getpos(l);
      std::cout << add(f[cur], l) << '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}