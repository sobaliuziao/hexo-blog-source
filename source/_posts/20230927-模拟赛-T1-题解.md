---
title: 20230927 模拟赛 T1 题解
date: 2023-09-27 21:59:00
---

## Description

给定一个长为 $n$ 的括号串，其中有一些是 `?`。给定常数 $a,b$。你要取出其中若干不交的子段，使得每一段都存在把 `?` 换成括号的方法使之成为合法括号串。长度为 $i$ 的段的收益 $ai+b$，一个方案的收益是所有段的收益和。求最大的收益。

$1\leq n\leq 5\times 10^5$，$|a|,|b|\leq 10^6$。

## Solution

考虑如何判断一个子串能变成合法括号串。

由于合法括号串的判定条件就是把 `(` 看成 $1$，`)` 看成 $-1$，那么所有的前缀和都 $\geq 0$ 且总和为 $0$。

但是这里有一些问号还没填。

注意到 `(` 是一定的，所以肯定要尽量让左括号放前面，右括号放后面。

那么可以得到一个判定条件就是把所有的 `?` 替换成 `(` 后所有前缀和都 $\geq 0$，至于总和可能大于 $0$，容易发现可以把后面的几个被替换成 `(` 调整成 `)` 即可。

但是这样是很难判断的。

考虑转化一下，设 $s_i$ 表示把字符串的 `?` 替换成 `(` 的前缀和，$t_i$ 表示把字符串的 `?` 替换成 ')' 后把 `(` 看成 $-1$，`)` 看成 $1$ 的后缀和。

容易发现两种替换方案的**调整**括号个数就是总问号的个数。

那么一个问号不可能被调整两次。

所以如果 $i$ 之前有替换方案 1 中调整的括号，由于 $s_i=t_{i+1}$，所以预处理出的 $t_{i+1}$ 就是替换方案 1 调整后 $i$ 的前缀和。

所以一个子串合法的条件就是所有 $s_i,t_i\geq 0$ 且长度为偶数。

线段树维护即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 5e5 + 5;

int n, A, B;
int a[kMaxN], s1[kMaxN], s2[kMaxN], l[kMaxN], r[kMaxN];
i64 f[kMaxN], g[kMaxN];
int lg[kMaxN], mi1[kMaxN][20], mi2[kMaxN][20];
std::string s;
std::vector<int> add[kMaxN], del[kMaxN];

void prework() {
  lg[0] = -1;
  for (int i = 1; i <= n; ++i) {
    lg[i] = lg[i >> 1] + 1;
    mi1[i][0] = s1[i];
    mi2[i][0] = s2[i];
  }
  for (int i = 1; i <= lg[n]; ++i) {
    for (int j = 1; j + (1 << i) - 1 <= n; ++j) {
      mi1[j][i] = std::min(mi1[j][i - 1], mi1[j + (1 << i - 1)][i - 1]);
      mi2[j][i] = std::min(mi2[j][i - 1], mi2[j + (1 << i - 1)][i - 1]);
    }
  }
}

int query1(int l, int r) {
  int k = lg[r - l + 1];
  return std::min(mi1[l][k], mi1[r - (1 << k) + 1][k]);
}

int query2(int l, int r) {
  int k = lg[r - l + 1];
  return std::min(mi2[l][k], mi2[r - (1 << k) + 1][k]);
}

struct SGT {
  i64 mx[kMaxN << 2];

  void pushup(int x) {
    mx[x] = std::max(mx[x << 1], mx[x << 1 | 1]);
  }

  void update(int x, int l, int r, int ql, i64 v) {
    if (l == r) {
      mx[x] = v;
      return;
    }
    int mid = (l + r) >> 1;
    if (ql <= mid) update(x << 1, l, mid, ql, v);
    else update(x << 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  i64 query(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql || ql > qr) {
      return -1e9;
    } else if (l >= ql && r <= qr) {
      return mx[x];
    }
    int mid = (l + r) >> 1;
    return std::max(query(x << 1, l, mid, ql, qr), query(x << 1 | 1, mid + 1, r, ql, qr));
  }
} sgt[2];

void dickdreamer() {
  std::cin >> n >> A >> B >> s;
  s = " " + s;
  for (int i = 1; i <= n; ++i)
    s1[i] = s1[i - 1] + ((s[i] == '(' || s[i] == '?') ? 1 : -1);
  for (int i = n; i; --i)
    s2[i] = s2[i + 1] + ((s[i] == ')' || s[i] == '?') ? 1 : -1);
  prework();
  for (int i = 0; i <= n; ++i) {
    int L = i, R = n + 1, res = i;
    while (L + 1 < R) {
      int mid = (L + R) >> 1;
      if (query1(i + 1, mid) >= s1[i]) L = res = mid;
      else R = mid;
    }
    r[i] = res;
    if (res != i) add[i].emplace_back(i), del[r[i]].emplace_back(i);
  }
  for (int i = 1; i <= n; ++i) {
    int L = -1, R = i, res = i;
    while (L + 1 < R) {
      int mid = (L + R) >> 1;
      if (query2(mid + 1, i) >= s2[i + 1]) R = res = mid;
      else L = mid;
    }
    l[i] = res;
  }
  memset(sgt[0].mx, 0xcf, sizeof(sgt[0].mx));
  memset(sgt[1].mx, 0xcf, sizeof(sgt[1].mx));
  for (int i = 0; i <= n; ++i) {
    if (i >= 2) f[i] = sgt[i & 1].query(1, 0, n, l[i] - 1, i - 1) + (i64)A * i + B;
    if (f[i] < 0) f[i] = 0;
    g[i] = std::max(i ? g[i - 1] : 0, f[i]);
    for (auto x : add[i]) sgt[i & 1].update(1, 0, n, x, g[x] - (i64)A * x);
    for (auto x : del[i]) sgt[i & 1].update(1, 0, n, x, -1e9);
  }
  std::cout << std::max(g[n], g[n - 1]) << '\n';
}

int32_t main() {
  freopen("bracket.in", "r", stdin);
  freopen("bracket.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```