---
title: '20241014 模拟赛 T3 题解'
date: 2024-10-14 21:03:00
---

## Description

冒险家的藏宝图可以被表示为一个 $n$ 个点的树，第 $i$ 个点可能是价值为 $a_i$ 的藏宝点，也可能什么也没有。

冒险家只知道，一定不会有两个在树上相邻的藏宝点。

记 $M=\sum a_i$。他现在希望对每个 $0\le x\le M$，求出有多少种藏宝点的分配方案，使得所有藏宝点的价值和为 $x$。由于答案可能很大，请对 $10^9+7$ 取模。

$1\le n\le 100$，$1\le a_i\le 10^5$，$M=\sum a_i\le 10^5$。

[link](http://zhengruioi.com/contest/1696/problem/2972)

## Solution

先考虑完全二叉树怎么做。注意到树的深度为 $O(\log n)$，所以可以按照 dfs 序从小到大进行 dp，同时记录当前这个点所有祖先选/没选的状态和总和，并且由于如果 $u$ 的 dfs 序刚好在 $v$ 后面一个，那么 $u$ 的父亲一定在 $v$ 的状态里被记录过。

具体的，设 $f_{i,j,k}$ 表示考虑了 dfs 序前 $i$ 的点，dfs 序为 $i$ 的点的祖先的选择状态为 $j$，总和为 $k$，每次枚举当前点选不选即可。

时间复杂度：$O(n^2m)$。

------------

对于一般树，有一种做法是用点分树将树高降为 $O(\log n)$，但是有点复杂就不管了。

考虑减少选/没选状态记录的点数。

首先求 dfs 序是先遍历一个点的轻儿子，这样就只需要记录所有祖先链上轻儿子父亲的选择状态，因为如果是重儿子的父亲，则后面这个父亲一定不会被用到过了。所以记录的点数降为到根的链上轻儿子的个数 $O(\log n)$，状态数为 $O(n)$。

时间复杂度看上去是 $O(n^2m)$，但是经过一番分析，实际上是 $O(n^{\log_23}m)$。

时间复杂度：$O(n^{\log_23}m)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 105, kMaxM = 1e5 + 5, kMod = 1e9 + 7;

int n, m;
int a[kMaxN], sz[kMaxN], p[kMaxN], wson[kMaxN], dfn[kMaxN], idx[kMaxN];
int f[2][kMaxN][kMaxM];
std::vector<int> G[kMaxN], path[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = (int64_t)bs * bs % kMod)
    if (idx & 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y >= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x >= y ? x - y : x - y + kMod); }
inline void inc(int &x, int y) { (x += y) >= kMod ? x -= kMod : x; }
inline void dec(int &x, int y) { (x -= y) < 0 ? x += kMod : x; }

void dfs1(int u, int fa) {
  sz[u] = 1, p[u] = fa;
  std::vector<int> vec;
  for (auto v : G[u]) {
    if (v == fa) continue;
      vec.emplace_back(v);
  }
  G[u] = vec;
  for (auto v : G[u]) {
    dfs1(v, u);
    sz[u] += sz[v];
  }
  std::sort(G[u].begin(), G[u].end(), [&] (int i, int j) { return sz[i] < sz[j]; });
  if (G[u].size()) wson[u] = G[u].back();
}

void dfs2(int u, int fa) {
  static int cnt = 0;
  idx[dfn[u] = ++cnt] = u;
  for (auto v : G[u]) {
    assert(v != fa);
    dfs2(v, u);
    if (v == G[u].back()) assert(v == wson[u]);
  }
}

void dickdreamer() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i) {
    std::cin >> a[i];
    m += a[i];
  }
  for (int i = 1; i < n; ++i) {
    int u, v;
    std::cin >> u >> v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  dfs1(1, 0), dfs2(1, 0);
  for (int i = 1; i <= n; ++i) {
    path[dfn[i]].emplace_back(i);
    for (int j = i; j != 1; j = p[j])
      if (j != wson[p[j]])
        path[dfn[i]].emplace_back(p[j]);
    std::reverse(path[dfn[i]].begin(), path[dfn[i]].end());
  }
  int o = 0;
  f[o][0][0] = f[o][1][a[1]] = 1;
  assert(path[1].size() == 1);
  for (int i = 2; i <= n; ++i) {
    int u = idx[i];
    o ^= 1;
    for (int s = 0; s < (1 << path[i].size()); ++s)
      std::fill_n(f[o][s], m + 1, 0);
    for (int s = 0; s < (1 << path[i - 1].size()); ++s) {
      static bool vis[kMaxN];
      memset(vis, 0, sizeof(vis));
      for (int j = 0; j < (int)path[i - 1].size(); ++j)
        vis[path[i - 1][j]] = (s >> j & 1);
      // u 不选
      int t = 0;
      for (int j = 0; j < (int)path[i].size(); ++j)
        if (vis[path[i][j]])
          t |= (1 << j);
      for (int sum = 0; sum <= m; ++sum)
        inc(f[o][t][sum], f[o ^ 1][s][sum]);
      if (!vis[p[u]]) {
        t |= (1 << (path[i].size() - 1));
        assert(u == path[i].back());
        for (int sum = 0; sum <= m - a[u]; ++sum)
          inc(f[o][t][sum + a[u]], f[o ^ 1][s][sum]);
      }
    }
  }
  for (int i = 0; i <= m; ++i) {
    int ans = 0;
    for (int s = 0; s < (1 << path[n].size()); ++s)
      inc(ans, f[o][s][i]);
    std::cout << ans << '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```