---
title: 20230927 模拟赛 T2 题解
date: 2023-09-28 22:46:00
---

## Description

给出一个 $1,\dots,n+1$ 的排列 $v_{1,\dots,n+1}$，与两组权值 $a_{1,\dots,n}$、$b_{1,\dots,n}$。满足 $v_{n+1}=n+1$。

构造一张 $n+1$ 个点的 **有向图**：

+ 对于 $i=1,\dots,n$，从 $i$ 向 $i+1$ 连一条权值为 $a_i$ 的边；
+ 对于 $i=1,\dots,n$，找到最小的 $i < j \le n+1$ 满足 $v_j>v_i$，从 $i$ 向 $j$ 连一条权值为 $b_i$ 的边。

一条路径的权值为路径上边权的 **最大值**。特别地，若一条路径不包含任何边，则其权值为 $0$。

有 $q$ 次询问，每次询问给出 $x,y$（$x \le y$），求 $x$ 到 $y$ 的权值最小的路径的权值。

## Solution

设 $p_i$ 表示 $i$ 后面第一个 $v_j>v_i$ 的 $j$。

首先如果 $i$ 要走到 $j$，且 $v_j>v_i$，那么这条路径一定会经过 $p_i$。

原因是如果没经过 $p_i$，设 $x,y$ 满足存在 $x\to y$ 的边且 $x<p_i<y$，那么一定要满足 $p_x=y$，又因为 $v_x<v_i<v_{p_i}$，所以 $y$ 一定不为 $p_x$，就矛盾了。

有了这个引理，还是求不了最终的距离，考虑求出 $d_i$ 为 $i$ 到 $p_i$ 的距离。

如果是一步到 $p_i$，代价就是 $b_i$。否则就是 $i$ 先走到 $i+1$ 再走到 $p_i$。

会发现这样还是不好搞。

但是经过观察会发现 $v_{i+1}<v_{p_i}$，所以设 $nxt_i$ 表示 $i$ 后面第一个 $p_j$ 与 $p_i$ 相同的 $j$。

会发现 $i<i+1<nxt_i$ 并且 $v_{i+1}<v_{nxt_i}$，因为如果 $v_{i+1}>v_{nxt_i}$，那么 $p_{nxt_i}<p_{i+1}<p_i$，这是不可能的。所以 $nxt_i$ 一定是 $i+1$ $p$ 数组的某个祖先。

所以 $i+1$ 走到 $p_i$ 一定会经过 $nxt_i$，这个直接倍增即可。

所以 $d_i=\min\{b_i,\max\{a_i,\text{dis}_{i+1\to nxt_i},d_{nxt_i}\}\}$。

---

然后考虑怎么求一条普通路径的答案。

先把询问离线下来，然后重新跑一边单调栈的过程，单调栈循环到询问的右端点时去处理这个询问。

假设是从 $i\to j$，且 $x$ 表示 $i\sim j$ 中 $v$ 值最大的下标。

那么由于 $x$ 为当前权值最大的点，所以 $i$ 往后跳一定会经过 $x$，因为要想逾越 $v_x$ 就要跳 $p$，但是它又是最大的，所以矛盾。

于是 $x$ 一定是当前 $x$ 的 $p$ 树祖先，那么 $i\to x$ 的权值就直接倍增处理即可。

然后考虑怎么求 $x\to j$ 的最小权值。

注意到当前单调栈只扫到了 $j$，那么设 $y_1,\dots,y_{t}$ 表示还没找到 $p$ 且 $\geq i$ 的所有点，那么 $y_1=x,y_t=j$。

所以 $x$ 下一步一定是到 $x+1$，然后发现如果 $y_2=x+1$ 是很好搞的。

否则 $x+1$ 一定找到了 $p$，所以 $x+1$ 往后走一定会经过 $p_{p\dots p_{x+1}}$ 直到没有 $p$ 了为止。

容易发现这么跳 $p$ 的终点就是 $y_2$，所以 $x\to y_2$ 的权值就是 $\min\{a_x,\text{dis}_{x+1\to y_2}\}$，这个是很好求的。

然后 $i\to j$ 的答案就是 $\min\{\text{dis}_{i\to x},\text{dis}_{y_1\to y_2},\dots,\text{dis}_{y_{t-1},j}\}$。

这个玩意可以用一个线段树维护。

时间复杂度：$O((n+m)\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, q, S, top;
int v[kMaxN], a[kMaxN], b[kMaxN], ans[kMaxN];
int lg[kMaxN], mx[kMaxN][20], idx[kMaxN][20];
int p[kMaxN][20], d[kMaxN][20], nxt[kMaxN], stk[kMaxN];
std::vector<std::pair<int, int>> qq[kMaxN];

struct SGT {
  int mx[kMaxN << 2];

  void pushup(int x) {
    mx[x] = std::max(mx[x << 1], mx[x << 1 | 1]);
  }

  void update(int x, int l, int r, int ql, int v) {
    if (l == r) {
      mx[x] = v;
      return;
    }
    int mid = (l + r) >> 1;
    if (ql <= mid) update(x << 1, l, mid, ql, v);
    else update(x << 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  int query(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql || ql > qr) {
      return 0;
    } else if (l >= ql && r <= qr) {
      return mx[x];
    }
    int mid = (l + r) >> 1;
    return std::max(query(x << 1, l, mid, ql, qr), query(x << 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

void st_prework() {
  lg[0] = -1;
  for (int i = 1; i <= n + 1; ++i) {
    lg[i] = lg[i >> 1] + 1;
    mx[i][0] = v[i];
    idx[i][0] = i;
  }
  for (int i = 1; i <= lg[n + 1]; ++i) {
    for (int j = 1; j + (1 << i) - 1 <= n + 1; ++j) {
      if (mx[j][i - 1] >= mx[j + (1 << i - 1)][i - 1]) {
        mx[j][i] = mx[j][i - 1], idx[j][i] = idx[j][i - 1];
      } else {
        mx[j][i] = mx[j + (1 << i - 1)][i - 1], idx[j][i] = idx[j + (1 << i - 1)][i - 1];
      }
    }
  }
}

int getpos(int l, int r) { // l -> r 中 v 最大的编号
  int k = lg[r - l + 1];
  if (mx[l][k] >= mx[r - (1 << k) + 1][k]) return idx[l][k];
  else return idx[r - (1 << k) + 1][k];
}

int getdis1(int x, int y) { // x -> y 且 y 是 x 的 p 祖先
  if (!y || x == y) return 0;
  int ret = 0;
  for (int i = 19; ~i; --i) {
    if (p[x][i] && p[x][i] <= y) {
      ret = std::max(ret, d[x][i]);
      x = p[x][i];
    }
  }
  return ret;
}

int getdis2(int x, int y) { // x -> y
  if (x == y) return 0;
  int mxid = getpos(x, y), dis1 = getdis1(x, mxid);
  int it = std::lower_bound(stk + 1, stk + 1 + top, mxid) - stk;
  return std::max(dis1, sgt.query(1, 1, n + 1, it + 1, top));
}

void prework() {
  st_prework();
  top = 0;
  for (int i = 1; i <= n + 1; ++i) {
    int lst = 0;
    for (; top && v[stk[top]] < v[i]; --top) {
      if (lst) nxt[stk[top]] = lst;
      lst = stk[top];
      p[stk[top]][0] = i;
    }
    stk[++top] = i;
  }
  for (int i = 1; i <= 19; ++i)
    for (int j = 1; j <= n; ++j)
      p[j][i] = p[p[j][i - 1]][i - 1];
  for (int i = n; i; --i) {
    d[i][0] = std::min(b[i], std::max({a[i], getdis1(i + 1, nxt[i]), d[nxt[i]][0]}));
    for (int j = 1; j <= 19; ++j)
      d[i][j] = std::max(d[i][j - 1], d[p[i][j - 1]][j - 1]);
  }
  top = 0;
  for (int i = 1; i <= n + 1; ++i) {
    for (; top && v[stk[top]] < v[i]; --top) {}
    stk[++top] = i;
    if (top != 1)
      sgt.update(1, 1, n + 1, top, std::max(a[stk[top - 1]], getdis1(stk[top - 1] + 1, stk[top])));
    for (auto [x, id] : qq[i])
      ans[id] = getdis2(x, i);
  }
}

void dickdreamer() {
  std::cin >> n >> q >> S;
  for (int i = 1; i <= n; ++i)
    std::cin >> v[i];
  v[n + 1] = n + 1;
  for (int i = 1; i <= n; ++i)
    std::cin >> a[i];
  for (int i = 1; i <= n; ++i)
    std::cin >> b[i];
  for (int i = 1; i <= q; ++i) {
    int x, y;
    std::cin >> x >> y;
    qq[y].emplace_back(x, i);
  }
  prework();
  for (int i = 1; i <= q; ++i)
    std::cout << ans[i] << '\n';
}

int32_t main() {
  freopen("jump.in", "r", stdin);
  freopen("jump.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```