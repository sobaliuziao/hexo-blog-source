---
title: '2023.1.16 模拟赛题解'
date: 2023-01-16 15:52:00
---

# T1

## Description

[link](https://codeforces.com/gym/103185/problem/B)

## Solution

假设当前考虑的是 $1\sim i$，那么区间长度一定是 $i$ 的因数，易知 $1\sim n$ 所有的因数个数和不超过 $n\log n$，所以可以直接暴力枚举。

所以只需要判断一个区间 $[l,r]$ 能否变成山链。

首先先把区间里面所有不是 $-1$ 的数搞出来，如果有两个山顶就肯定不行。如果只有一个山顶，那么肯定可以。如果是单调递减且 $a_l$ 是 $-1$ 或者是单调递增且 $a_r$ 是 $-1$ 也肯定行。

所以维护差分数组的最大值/最小值以及区间内数的最大值即可。

时间复杂度：$O(n\log n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 5;

int n, lst;
int a[kMaxN], d[kMaxN], pre[kMaxN], nxt[kMaxN], ans[kMaxN], sum[kMaxN];
int lg[kMaxN], st1[kMaxN][20], st2[kMaxN][20], st3[kMaxN][20], idx1[kMaxN][20];
vector<int> v[kMaxN];

void getdick() { // O(n log n)
  for (int i = 3; i <= n; ++i) {
    for (int j = i; j <= n; j += i) {
      v[j].emplace_back(i);
    }
  }
}

void getdiao() { // O(n)
  int lst = 0;
  for (int i = 1; i <= n; ++i) {
    if (a[i] != -1) lst = i;
    pre[i] = lst;
  }
  lst = 0;
  for (int i = n; i; --i) {
    if (a[i] != -1) lst = i;
    nxt[i] = lst;
  }
}

void st_prework_1() { // O(n log n)
  lg[0] = -1;
  for (int i = 1; i <= n; ++i) {
    lg[i] = lg[i >> 1] + 1;
    st1[i][0] = a[i];
    idx1[i][0] = i;
    st2[i][0] = d[i];
    if (d[i] == 2e9) st2[i][0] = -2e9;
    st3[i][0] = d[i];

  }
  for (int i = 1; i <= lg[n]; ++i) {
    for (int j = 1; j + (1 << i) - 1 <= n; ++j) {
      if (st1[j][i - 1] > st1[j + (1 << i - 1)][i - 1]) {
        st1[j][i] = st1[j][i - 1];
        idx1[j][i] = idx1[j][i - 1];
      } else {
        st1[j][i] = st1[j + (1 << i - 1)][i - 1];
        idx1[j][i] = idx1[j + (1 << i - 1)][i - 1];
      }
      st2[j][i] = max(st2[j][i - 1], st2[j + (1 << i - 1)][i - 1]);
      st3[j][i] = min(st3[j][i - 1], st3[j + (1 << i - 1)][i - 1]);

    }
  }
}

void st_prework_2() { // O(n log n)
/*
  求区间 d 的最大值 
*/
  for (int i = 1; i <= n; ++i) {
    st2[i][0] = d[i];
    if (d[i] == 2e9) st2[i][0] = -2e9;
  }
  for (int i = 1; i <= lg[n]; ++i) {
    for (int j = 1; j + (1 << i) - 1 <= n; ++j) {
      st2[j][i] = max(st2[j][i - 1], st2[j + (1 << i - 1)][i - 1]);
    }
  }
}

void st_prework_3() { // O(n log n)
/*
  求区间 d 的最小值
*/
  for (int i = 1; i <= n; ++i) {
    st3[i][0] = d[i];
  }
  for (int i = 1; i <= lg[n]; ++i) {
    for (int j = 1; j + (1 << i) - 1 <= n; ++j) {
      st3[j][i] = min(st3[j][i - 1], st3[j + (1 << i - 1)][i - 1]);
    }
  }
}

pair<int, int> query1(int l, int r) {
  int k = lg[r - l + 1];
//  cerr << "Fuck " << st1[l][k] << ' ' << st1[r - (1 << k) + 1][k] << '\n';
  if (st1[l][k] > st1[r - (1 << k) + 1][k])
    return {st1[l][k], idx1[l][k]};
  else
    return {st1[r - (1 << k) + 1][k], idx1[r - (1 << k) + 1][k]};
}

int query2(int l, int r) {
  int k = lg[r - l + 1];
  return max(st2[l][k], st2[r - (1 << k) + 1][k]);
}

int query3(int l, int r) {
  int k = lg[r - l + 1];
  return min(st3[l][k], st3[r - (1 << k) + 1][k]);
}

bool checkinc(int l, int r) { // 判断 [l,r] 是否递增 
//  int x = nxt[l], y = pre[r];
//  if (!x || x > r) return 1; // 全是 -1 
//  if (x == y) return 1; // 只有一个不是 -1 
  if (query3(l + 1, r) >= 0) return 1;
  else return 0;
}

bool checkdec(int l, int r) { // 判断 [l,r] 是否递减 
//  int x = nxt[l], y = pre[r];
//  if (!x || x > r) return 1; // 全是 -1 
//  if (x == y) return 1; // 只有一个不是 -1 
  if (query2(l + 1, r) <= 0) return 1;
  else return 0;
}

bool check(int l, int r) { // 判断 [l,r] 是否是山链 
  if (r - l + 1 <= 2) return 0;
  if (pre[r] < l) return 1;
  auto p = query1(l + 1, r - 1);
//  cerr << "***" << p.first << ' ' << p.second << '\n';
  if (p.first == -1) return 1;
  return checkinc(l, p.second) && checkdec(p.second, r) || (a[l] == -1 && checkdec(l, r) || a[r] == -1 && checkinc(l, r));
}

void solve() {
  for (int i = 3; i <= n; ++i)
    ans[i] = 1;
  for (int i = 3; i <= n; ++i) {
    if (n % i) ans[i] &= (check(n - n % i + 1, n));
  }
  for (int i = 1; i <= n; ++i) {
    for (auto x : v[i]) {
      ans[x] &= check(i - x + 1, i);
    }
  }
//  cerr << "???" << ans[3] << '\n';
  int res = 0;
  for (int i = 3; i <= n; ++i) {
    res |= ans[i];
  }
  cout << (res ? "Y\n" : "N\n");
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    sum[i] = sum[i - 1];
    if (a[i] != -1) {
      d[i] = a[i] - lst;
      lst = a[i];
    } else {
      d[i] = 2e9;
      ++sum[i];
    }
  }
  getdick(), getdiao();
  st_prework_1();
//  cerr << checkdec(1, 4) << '\n';
  solve();
  cerr << 1.0 * clock() / CLOCKS_PER_SEC << 's' << '\n';
  return 0;
}
/*
4
4 -1 3 3
*/
```
</details>

# T2

## Description

[link](https://codeforces.com/gym/103185/problem/F)

## Solution

求最大值是个简单的贪心，只需要考虑最小值。

设 $f_{i,j}$ 表示把 $1\sim i$ 划分成 $j$ 段的最小值。

那么 $f_{i,j}=\min\big\{f_{k,j-1}+\max\{a_{k+1},...,a_i\}\big\}$。

可以先钦定 $a_i$ 是最大值，那么可以用单调栈维护能满足 $a_i$ 是最大值的最优决策点。

另外一种可能就是最大值不是 $a_i$，那么维护一下最优决策点即可。

时间复杂度：$O(n^2)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 8005;

int n;
int a[kMaxN], b[kMaxN], f[kMaxN][kMaxN], g[kMaxN], mi[kMaxN];

signed main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    b[i] = a[i];
  }
  memset(f, 0x3f, sizeof(f));
  f[0][0] = 0;
  a[0] = mi[0] = LLONG_MAX / 2;
  for (int i = 1; i <= n; ++i) {
    stack<int> stk;
    stk.emplace(0);
    for (int j = i; j <= n; ++j) {
      mi[j] = f[j - 1][i - 1];
      while (!stk.empty() && a[stk.top()] < a[j]) {
        mi[j] = min(mi[j], mi[stk.top()]);
        stk.pop();
      }
      f[j][i] = mi[j] + a[j];
      if (!stk.empty()) f[j][i] = min(f[j][i], f[stk.top()][i]);
      stk.emplace(j);
    }
  }
  sort(b + 1, b + 1 + n, greater<int>());
  for (int i = 1; i <= n; ++i)
    g[i] = g[i - 1] + b[i];
  for (int i = 1; i <= n; ++i) {
    cout << f[n][i] << ' ' << g[i] << '\n';
  }
  return 0;
}
```
</details>

# T3

## Description

[link](https://codeforces.com/gym/103185/problem/J)

## Solution

直接暴力即可。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 5;

int n, k, t;
int c[kMaxN][8], tt[8], cnt[9][9][9][9][9][9][9][9];

void upd(int x, int v) {
  for (int c0 = 0; c0 <= c[x][0]; ++c0) {
    for (int c1 = 0; c1 <= c[x][1]; ++c1) {
      for (int c2 = 0; c2 <= c[x][2]; ++c2) {
        for (int c3 = 0; c3 <= c[x][3]; ++c3) {
          for (int c4 = 0; c4 <= c[x][4]; ++c4) {
            for (int c5 = 0; c5 <= c[x][5]; ++c5) {
              for (int c6 = 0; c6 <= c[x][6]; ++c6) {
                for (int c7 = 0; c7 <= c[x][7]; ++c7) {
                  cnt[c0][c1][c2][c3][c4][c5][c6][c7] += v;
                } 
              }
            } 
          }
        } 
      } 
    } 
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> k;
  while (n--) {
    string op;
    int s;
    cin >> op >> s;
    if (op[0] == 'C') {
      ++t;
      for (int i = 1; i <= s; ++i) {
        int tmp;
        cin >> tmp;
        ++c[t][tmp - 1];
      }
      upd(t, 1);
    } else if (op[0] == 'D') {
      upd(s, -1);
    } else {
      tt[0] = tt[1] = tt[2] = tt[3] = tt[4] = tt[5] = tt[6] = tt[7] = 0;
      for (int i = 1; i <= s; ++i) {
        int tmp;
        cin >> tmp;
        ++tt[tmp - 1];
      }
      cout << cnt[tt[0]][tt[1]][tt[2]][tt[3]][tt[4]][tt[5]][tt[6]][tt[7]] << '\n';
    }
  }
  return 0;
}
```
</details>

# T4

## Description

[link](https://codeforces.com/gym/103185/problem/K)

## Solution

设 $f_{i,j}$ 为当前确定了 $1\sim i$ 的字母，末尾为 $j$ 的方案数。

那么 $f_{i,j}$ 能够转移到 $f_{i+1,k}$ 就意味着 $T_{j,k}\in [s_i-L,s_i+L]$。

由于 $T$ 每一行都是单调的，所以可以直接二分能够转移的左端点和右端点，然后差分维护。

时间复杂度：$O(nk\log k)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e4 + 5, kMaxK = 755, kMod = 1e9 + 7;

int n, k, ll;
int f[kMaxN][kMaxK], t[kMaxK][kMaxK], p[kMaxN];

int main() {
  cin >> k >> ll;
  for (int i = 1; i <= k; ++i)
    for (int j = 1; j <= k; ++j)
      cin >> t[i][j];
  cin >> n;
  for (int i = 1; i < n; ++i)
    cin >> p[i];
  f[1][0] = 1;
  for (int i = 1; i < n; ++i) {
    for (int j = 1; j <= k; ++j)
      f[i][j] = (f[i][j] + f[i][j - 1]) % kMod;
    for (int j = 1; j <= k; ++j) {
      // t[j][s] in [p[i]-L,p[i]+L]
      int l = p[i] - ll, r = p[i] + ll;
      int L = 0, R = k + 1, resl = -1, resr = -1;
      while (L + 1 < R) {
        int mid = L + (R - L) / 2;
        if (t[j][mid] >= l) R = resl = mid;
        else L = mid;
      }
      if (resl == -1) continue;
      L = 0, R = k + 1;
      while (L + 1 < R) {
        int mid = L + (R - L) / 2;
        if (t[j][mid] <= r) L = resr = mid;
        else R = mid;
      }
      if (resr == -1) continue;
      f[i + 1][resl] = (f[i + 1][resl] + f[i][j]) % kMod;
      f[i + 1][resr + 1] = (f[i + 1][resr + 1] + kMod - f[i][j]) % kMod;
    }
  }
  int ans = 0;
  for (int i = 1; i <= k; ++i) {
    f[n][i] = (f[n][i] + f[n][i - 1]) % kMod;
    ans = (ans + f[n][i]) % kMod;
  }
  cout << ans << '\n';
  return 0;
}
```
</details>
