---
title: 2023.1.14 模拟赛题解
date: 2023-01-14 14:46:00
---

# T1

## Description

[link](https://codeforces.com/gym/102471/problem/A)

## Solution

枚举中点，然后两个端点的 $x$ 之和以及 $y$ 之和都是确定的，乘法原理即可。

时间复杂度：$O(nm)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

int n, m;
int ans, ans1;

signed main() {
  cin >> n >> m;
  ++n, ++m; 
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      ans += min(i - 1, n - i) * min(j - 1, m - j);
      ans1 += min(i - 1, n - i) + min(j - 1, m - j); 
    }
  }
//  cerr << ans << ' ' << ans1 << '\n';
  cout << ans * 2ll + ans1 << '\n';
  return 0;
}
```
</details>

# T2

## Description

[link](https://codeforces.com/gym/102471/problem/E)

## Solution

容易知道最大流量是 $\dfrac{sum}{len}$。然后把每条路径上的边按边权排序。

那么就可以将 $k$ 条路径当成一条来看。把每条路径的容量，从小到大排序，然后把 $k$ 条路径合在一起。此时，平均流量和总容量的差值，就是需要操作的次数。

这里我们无需关心这个操作是怎么实现的，只需要关注当前状态和最终状态之间的差值即可。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5;

int n, m, cnt, sum;
int a[kMaxN], s[kMaxN];
pair<int, int> nxt[kMaxN];
vector<pair<int, int>> st, G[kMaxN];

signed main() {
  cin >> n >> m;
  for (int i = 1; i <= m; ++i) {
    int u, v, w;
    cin >> u >> v >> w;
    if (u != 1 && v != 1) nxt[u] = {v, w};
    else st.emplace_back(v, w), ++cnt;
    sum += w;
  }
  int tot = m / cnt, flow = sum / tot;
//  cerr << flow << '\n';
  for (auto [u, w1] : st) {
//    cerr << "***" << u << ' ' << w1 << '\n';
    vector<int> tmp;
    int v = u, w = w1;
    for (;; w = nxt[v].second, v = nxt[v].first) {
      tmp.emplace_back(w);
      if (v == n) break;
    }
    sort(tmp.begin(), tmp.end());
    s[0] += tmp[0];
    for (int i = 1; i < tmp.size(); ++i) {
      s[i] += tmp[i] - tmp[i - 1];
    }
  }
//  cerr << s[0] << ' ' << s[1] << ' ' << s[2] << '\n';
  int now = s[0], ans = 0, idx = 0;
  while (now + s[idx + 1] < flow) {
    ++idx;
    now += s[idx];
    ans += idx * s[idx];
  }
//  cerr << now << '\n';
  ans += (idx + 1) * (flow - now);
  cout << ans << '\n';
  return 0;
}
```
</details>

# T3

## Description

[link](https://codeforces.com/gym/102471/problem/H)

## Solution

容易发现当长度不小于 $\dfrac{n}{2}$ 时，必定会有两个相邻或者相隔 $1$ 数，所以可以直接随机化这两个数，然后公比 $q=\dfrac{a[y]}{a[x]}$。

然后分别从 $x-1$ 往前扫以及从 $y+1$ 往后扫即可。错误率为 $\dfrac{1}{2^k}$，其中 $k$ 为随机化次数。

时间复杂度：$O(kn)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 2e5 + 5;

int T, n, p;
int a[kMaxN];
mt19937 rnd(1234);

int qpow(int bs, int idx, int p) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = 1ll * bs * bs % p)
    if (idx & 1)
      ret = 1ll * ret * bs % p;
  return ret;
}

int inv(int x, int p) {
  return qpow(x, p - 2, p);
}

int calc(int x, int y) {
  int ret = 2, q = 1ll * a[y] * inv(a[x], p) % p, iq = inv(q, p);
  int ned = 1ll * a[x] * iq % p;
//  if (x == 1) cerr << q << ' ' << a[x] << ' ' << inv(a[x], p) << ' ' << a[x + 1] << '\n';
  for (int i = x - 1; i; --i) {
    if (a[i] == ned) {
      ++ret;
      ned = 1ll * a[i] * iq % p;
    }
  }
  ned = 1ll * a[y] * q % p;
  for (int i = y + 1; i <= n; ++i) {
    if (a[i] == ned) {
      ++ret;
      ned = 1ll * a[i] * q % p;
    }
  }
  return ret;
}

void solve() {
  cin >> n >> p;
  for (int i = 1; i <= n; ++i)
    cin >> a[i];
  if (n == 2) {
    cout << "2\n";
    return;
  }
  int ans = 0;
  for (int i = 1; i <= 200; ++i) {
    int k = rnd() % 2 + 1, x = rnd() % (n - k) + 1, y = x + k;
    ans = max(ans, calc(x, y));
  }
  cout << (ans >= n / 2.0 ? ans : -1) << '\n';
}

signed main() {
  cin >> T;
//  cerr << "???" << qpow(2, 4, 1e9 + 7) << '\n';
  while (T--) solve();
  return 0;
}
```
</details>

# T4

## Description

[link](https://codeforces.com/gym/102471/problem/M)

## Solution

如果两个数能够表示成同一个数的次方，那么他们就是互相影响的。思考一下会发现这个影响的关系会形成很多个完全图，其中每个完全图上的都是 $p^1,p^2,...,p^k$。

然后对于每一个完全图分别考虑即可。

时间复杂度：$O(n\sqrt n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long 

using namespace std;

const int kMaxN = 1e5 + 5;

int n, ans;
int a[kMaxN], b[kMaxN], x[kMaxN], y[kMaxN];
bool vis[kMaxN];

bool check(int x, int y) {
  int r = x;
  for (; r <= y; r *= x) {
    
    if (r == y) return 1;
  }
  return 0;
}

signed main() {
  cin >> n;
  for (int i = 1; i <= n; ++i)
    cin >> a[i];
  for (int i = 1; i <= n; ++i)  
    cin >> b[i];
  ans = a[1];
  for (int i = 2; i <= n; ++i) {
    int t = 0, tmp = 0;
    if (vis[i]) continue;
    for (int j = i; j <= n; j *= i) {
      vis[j] = 1;
      x[++t] = j;
    }
    for (int s = 0; s < (1 << t); ++s) {
      int tt = 0, tmpp = 0;
      for (int j = 1; j <= t; ++j)
        if (s >> (j - 1) & 1) {
          y[++tt] = j;
          tmpp += a[x[j]];
        }
      for (int j = 1; j <= tt; ++j) {
        for (int k = 1; k < j; ++k)
          if (y[j] % y[k] == 0)
            tmpp -= b[x[y[j]]];
      }
      tmp = max(tmp, tmpp);
    }
    ans += tmp;
  }
  cout << ans << '\n';
  return 0;
}
```
</details>
