---
title: 2023.1.12 模拟赛题解
date: 2023-01-12 15:01:00
---

# T1

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/K)

## Solution

由于图中没有奇环等价于图是二分图。

所以直接枚举每个点在左边还是右边，然后判断每条边是否在同一阵营。如果不是，就可以涂它。

时间复杂度：$O(2^n m)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;
int a[20];
vector<int> G[20];

void solve(int cs) {
  for (int i = 1; i <= n; ++i)
    G[i].clear();
  cin >> n >> m;
  for (int i = 1; i <= m; ++i) {
    int u, v;
    cin >> u >> v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  int ans = 0;
  for (int s = 0; s < (1 << n); ++s) {
    for (int i = 1; i <= n; ++i)
      a[i] = (s >> (i - 1) & 1);
    int tmp = 0;
    for (int i = 1; i <= n; ++i)
      for (auto j : G[i])
        if (a[i] != a[j])
          ++tmp;
    ans = max(ans, tmp / 2);
  }
  cout << "Case #" << cs << ": " << ans << '\n';
}

int main() {
  int T;
  cin >> T;
  for (int i = 1; i <= T; ++i) solve(i);
  return 0;
}
```
</details>

# T2

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/D)

## Solution

考虑递推构造。容易知道最多只能做 $\lfloor\frac{n}{2}\rfloor$ 次。

那么 $2k$ 就最多做 $k$ 次。如果已经求出了 $2k$ 的操作方案，那么就在第 $i$ 次的方案里连上 $(2i-1,2k+1)$ 和 $(2i,2k+2)$ 两条边，这样操作后还是一棵树。

然后再加上剩余的边作为最后一次操作，这样就由 $2k$ 推出了 $2k+2$ 的方案。

由 $2k$ 推到 $2k+1$ 就直接在第 $i(1\leq i\leq k)$ 次的方案里连上 $(i,2k+1)$ 即可。

时间复杂度：$O(n^2)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;
using Tree = vector<pair<int, int>>;

int n;

void solve(int cs) {
  vector<Tree> ff;
  cin >> n;
  Tree tmp;
  tmp.emplace_back(1, 2);
  ff.emplace_back(tmp);
  for (int i = 4; i <= n; i += 2) {
    for (int j = 0; j < i / 2 - 1; ++j) {
      auto &vec = ff[j];
      vec.emplace_back(2 * j + 1, i - 1);
      vec.emplace_back(2 * j + 2, i);
    }
    tmp.clear();
    tmp.emplace_back(i - 1, i);
    for (int j = 1; j <= i - 2; ++j) {
      if (j & 1) tmp.emplace_back(j, i);
      else tmp.emplace_back(j, i - 1);
    }
    ff.emplace_back(tmp);
  }
  if (n & 1) {
    for (int j = 0; j < ff.size(); ++j) {
      ff[j].emplace_back(n, j + 1);
    }
  }
  cout << "Case #" << cs << ": " << ff.size() << '\n';
  for (auto &vec : ff) {
    for (auto [x, y] : vec) {
      cout << x << ' ' << y << '\n';
    }
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  for (int i = 1; i <= T; ++i) solve(i);
  return 0;
}
```
</details>

# T3

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/E)

## Solution

设 $f[i,j]$ 表示 $(i,j)$ 这个点第一次是从哪里走过来的。

容易发现 $f$ 数组构成一棵树，如果把起点换一下，就相当于换一个根，树的形态不会变。所以把相邻的点连一条边，然后跑最大生成树即可。由于边权很小，所以排序用桶排会快一些。

时间复杂度：$O(nm\log nm)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 1005, kMaxS = 1e6 + 5, kD[][2] = {{0, 1}, {1, 0}};

struct Edge {
  int u, v, w;
} e[kMaxS << 2];

int n, m, ed;
int x[kMaxS], fa[kMaxS];

bool cmp(Edge e1, Edge e2) {
  return e1.w > e2.w;
}

void init() {
  ed = 0;
  for (int i = 1; i <= n * m; ++i) {
    fa[i] = i;
  }
}

void addE(int u, int v, int w) {
  e[++ed] = {u, v, w};
}

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

int kruskal() {
  vector<Edge> vec[10005];
  int ret = 0, cnt = 0;
  for (int i = 1; i <= ed; ++i) {
    vec[e[i].w].emplace_back(e[i]);
  }
  ed = 0;
  for (int i = 10000; ~i; --i) {
    for (auto p : vec[i])
      e[++ed] = p;
  }
  for (int i = 1; i <= ed; ++i) {
    int fu = find(e[i].u), fv = find(e[i].v);
    if (fu != fv) {
      fa[fu] = fv;
      ret += e[i].w;
      if (++cnt == n * m - 1) break;
    }
  }
  return ret;
}

void solve(int cs) {
  int sr, sc, tr, tc, A, B, C, P;
  cin >> n >> m >> sr >> sc >> tr >> tc;
  cin >> x[1] >> x[2] >> A >> B >> C >> P;
  init();
  for (int i = 3; i <= n * m; ++i) {
    x[i] = (A * x[i - 1] % P + B * x[i - 2] % P + C) % P;
  }
  auto getid = [&] (int x, int y) { return (x - 1) * m + y; };
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      for (auto [dx, dy] : kD) {
        int ti = i + dx, tj = j + dy;
        if (ti < 1 || ti > n || tj < 1 || tj > m) continue;
        addE(getid(i, j), getid(ti, tj), x[getid(i, j)] * x[getid(ti, tj)]);
      }
    }
  }
  cout << "Case #" << cs << ": " << kruskal() << '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  for (int i = 1; i <= T; ++i) solve(i);
  return 0;
}
```
</details>


# T4

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/H)

## Solution

首先肯定是二分最大值 $x$。

设 $f[i]$ 表示 $i$ 的子树里，$i$ 所在连通块的最小合法权值。容易发现 $f[i]$ 只跟 $i$ 的儿子有关，所以直接按 $f$ 从小到大排序，能拼就拼，不能拼就割掉。

时间复杂度：$O(n\log n\log\sum{w_i})$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5;

int n, k, x, cnt;
int w[kMaxN], f[kMaxN];
vector<int> G[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

void dfs(int u, int fa) {
  vector<int> vec;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u);
    vec.emplace_back(f[v]);
  }
  sort(vec.begin(), vec.end());
  f[u] = w[u];
  for (int i = 0; i < vec.size(); ++i) {
    if (f[u] + vec[i] > x) {
      cnt += vec.size() - i;
      return;
    } else {
      f[u] += vec[i];
    }
  }
}

bool check(int s) {
  cnt = 0;
  fill(f + 1, f + 1 + n, 0);
  x = s;
  dfs(1, 0);
  return cnt <= k - 1;
}

void solve(int cs) {
  int sum = 0, maxi = 0;
  for (int i = 1; i <= n; ++i)
    G[i].clear();
  cin >> n >> k;
  for (int i = 1; i < n; ++i) {
    int u, v;
    cin >> u >> v;
    addE(u, v), addE(v, u);
  }
  for (int i = 1; i <= n; ++i) {
    cin >> w[i];
    sum += w[i];
    maxi = max(maxi, w[i]);
  }
  int L = maxi - 1, R = sum + 1, res;
  while (L + 1 < R) {
    int mid = (L + R) >> 1;
    if (check(mid)) R = res = mid;
    else L = mid;
  }
  cout << "Case #" << cs << ": " << res << '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  for (int i = 1; i <= T; ++i) solve(i);
  return 0;
}
```
</details>
