---
title: 2023.8.30 模拟赛 T3 题解
date: 2023-08-30 07:41:00
---

## Description

给定一个有 $n$ 个数的整数数组 $a$，$a_i$ 的值域为 $[1,200]$。现在有 $q$ 次互相独立的操作，每次操作形如 $b,c,d$，表示把 $a$ 的第 $b$ 位删掉，并且把 $a_{b+1\sim n}$ 放到 $a_{1\sim b-1}$ 前面，然后把 $c$ 放到开头，问有多少个以 $d$ 结尾的本质不同子序列。

$n,q\leq 2\times 10^5,m\leq 200$。

## Solution

先考虑朴素 dp。

设新数组为 $b$，$f_{i,j}$ 表示在操作完的数组中，考虑前 $i$ 个数，末尾为 $j$ 的本质不同子序列数，$\text{pre}_i$ 表示上一个和 $i$ 相等的下标。表示么转移方程就是

$$\begin{cases}f_{i,j}=f_{i-1,j}&\left(a_i\neq j\right)\\\displaystyle f_{i,j}=f_{i-1,j}+\sum_{k=0}^{m}{f_{i-1,k}-f_{{\text{pre}}_i,j}}&\left(a_i=j\right)\end{cases}$$

这样就可以做到 $O(nmq)$。

---

注意到上面那个式子其实有很多是重复算了的，因为操作并没有改变很多，只有两段的顺序，考虑预处理来优化复杂度。

设 $g_{i,j}$ 表示原数组里面考虑了 $a_{i\sim n}$，末尾为 $j$ 的本质不同方案数。

那么 $g_{i,j}=2\times g_{i+1,j}-g_{\text{nxt}_i,j}$。

特别的，如果 $\text{nxt}_i=0$，说明 $i$ 后面没有和他相等的数，所以 $g_{i,a_i}=1$。

求完这个就只要对于每个 $j$，求出 $g_{b+1,j}$ 对最终结果贡献的系数。

于是设 $f_{i,j,k}$ 表示 $g_{b+1,k}$ 对 $f_{i,j}$ 这个状态的贡献系数，$\text{sum}_{i,k}=\displaystyle\sum_{j=0}^{m}{f_{i,j,k}}$。那么

$$
\begin{cases}
f_{i,j,k}=f_{i-1,j,k}&\left(a_i\neq j\right)\\
f_{i,j,k}=\text{sum}_{i-1,k}+f_{i-1,j,k}-f_{i,j,k}&\left(a_{i}=j\right)
\end{cases}
$$

由于这里只要求 $f_{i,a_i,k}$ 所以可以设 $h_{i,k}=f_{i,a_i,k}$，那么 $h_{i,k}=\text{sum}_{i-1,k}+f_{i-1,a_i,k}-f_{\text{pre}_i,a_i,k}$，也就是 $\text{sum}_{i-1,k}+f_{\text{pre}_i,a_i,k}-f_{\text{pre}_i,a_i,k}=\text{sum}_{i-1,k}+h_{\text{pre}_i,k}-h_{\text{pre}_i,k}$。

同样的，$\text{sum}_{i,k}=2\times \text{sum}_{i-1,k}-h_{\text{pre}_i,k}$。注意，$k=a_i$ 时 $h_{i,k}$ 时才为 $1$。

时间复杂度：$O\left((n+q)\times m\right)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxM = 205, kMod = 998244353;

int n, m, q;
int a[kMaxN], sum[kMaxM], k[kMaxN][kMaxM], f[kMaxN][kMaxM], g[kMaxN][kMaxM], ff[kMaxM], noww[kMaxN][kMaxM], gg[kMaxN][kMaxM], pre[kMaxN], nxt[kMaxN], now[kMaxM];

inline int add(int x, int y) { return (x + y >= kMod) ? (x + y - kMod) : (x + y); }
inline int sub(int x, int y) { return (x >= y) ? (x - y) : (x + kMod - y); }
inline void inc(int &x, int y) { (x += y) >= kMod ? x -= kMod : x; }
inline void dec(int &x, int y) { (x -= y) < 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin >> n >> m >> q;
  for (int i = 1; i <= n; ++i)
    std::cin >> a[i];
  for (int i = 0; i <= m; ++i)
    sum[i] = 1;
  for (int i = 1; i <= n; ++i) {
    pre[i] = gg[i - 1][a[i]];
    for (int j = 0; j <= m; ++j)
      gg[i][j] = gg[i - 1][j];
    gg[i][a[i]] = i;
    for (int j = 0; j <= m; ++j) {
      k[i][j] = sum[j];
      int sb;
      if (pre[i]) sb = k[pre[i]][j];
      else sb = (j == a[i]);
      sum[j] = sub (2ll * sum[j] % kMod, sb);
    }
  }
  for (int i = n; i; --i) {
    nxt[i] = noww[i + 1][a[i]];
    now[a[i]] = i;
    for (int j = 0; j <= m; ++j)
      g[i][j] = sub(2ll * g[i + 1][j] % kMod, bool(nxt[i]) * g[nxt[i] + 1][j]);
    if (!nxt[i]) g[i][a[i]] = 1;
    for (int j = 0; j <= m; ++j)
      noww[i][j] = noww[i + 1][j];
    noww[i][a[i]] = i;
  }
  for (; q; --q) {
    int b, c, d;
    std::cin >> b >> c >> d;
    for (int i = 0; i <= m; ++i)
      ff[i] = sub(add(g[b + 1][i], g[b + 1][i]), bool(noww[b + 1][c]) * g[noww[b + 1][c] + 1][i]);
    if (!noww[b + 1][c]) ff[c] = 1;
    int ans = 0, t = gg[b - 1][d];
    if (!t) {
      std::cout << ff[d] << '\n';
      continue;
    }
    ff[0] = 1;
    for (int i = 0; i <= m; ++i)
      inc(ans, (long long)k[gg[b - 1][d]][i] * ff[i] % kMod);
    std::cout << ans << '\n';
  }
}

int32_t main() {
  freopen("third.in", "r", stdin);
  freopen("third.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```