---
title: 20240213 模拟赛 T3 题解
date: 2024-02-14 09:58:00
---

## Description

在坐标平面上有 $n$ 个矩形，边平行于坐标轴。第 $i$ 个矩形覆盖了所有满足 $l_i\le x\le r_i$ 和 $d_i\le y\le u_i$ 的点 $(x,y)$。

为简单起见，对于每个 $i\neq j$，我们有 $l_i\neq l_j,r_i\neq r_j, l_i\neq r_j , d_i\neq d_j , u_i\neq u_j, d_i\neq u_j$。

计算满足 $1\le i< j < k \le n$ 且第 $i,j$ 和 $k$ 个矩形两两不相交（它们之间没有共同点）的三元组 $(i,j,k)$ 的数量。

$1\leq n\leq 2\times 10^5$。

## Solution

考虑容斥。

答案可以写成钦定 $0$ 个交 - 钦定 $1$ 个交 + 钦定 $2$ 个交 - 钦定 $3$ 个交。

容易发现如果把相交的两个矩形连一条边，那么 $1$ 和 $2$ 就只跟每个点的度数有关，而 $3$ 就是求三元环数。

先考虑如何求度数。

显然可以扫描线，对于一个点 $i$ 的度数，可以用 $l_j<l_i$ 的相交数 + $l_j\leq r_i$ 的相交数 - $l_j\leq l_i$ 的相交数表示。

所以只要维护 $l$ 和 $r$ 的树状数组，用 $l_j\leq l_i$ 的个数 - $r_j\leq l_i$ 的个数就是答案。

---

然后是如何求三元环。

由于这里只需要求三元环的个数，所以可以在三元环中 $l$ 最大的点算贡献。

也考虑扫描线，设 $cnt_i$ 表示 $i$ 被 $[l_j,r_j]$ 覆盖的个数。

有一个假做法是对于每个 $i$，把 $\sum_{j=l_i}^{r_i}{\binom{cnt_j}{2}}$ 算成贡献，但是这样显然会算重，这个求的是 $y$ 轴点交的大小和。

观察到对于一个交，它的点数 - 边数一定是 $1$，所以答案等于点交大小和 - 边交大小和，这个同样维护即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int l[kMaxN], r[kMaxN], u[kMaxN], d[kMaxN], deg[kMaxN], op[kMaxN * 2], id[kMaxN * 2];

int64_t C(int m, int n) {
  if (n == 0) return 1;
  else if (n == 1) return m;
  else if (n == 2) return 1ll * m * (m - 1) / 2;
  else return 1ll * m * (m - 1) * (m - 2) / 6;
}

struct BIT {
  int c[kMaxN * 2];

  void upd(int x, int v) {
    for (; x <= 2 * n; x += x & -x) c[x] += v;
  }

  int qry(int x) {
    int ret = 0;
    for (; x; x -= x & -x) ret += c[x];
    return ret;
  }
} bit1, bit2;

struct SGT {
  int64_t sum[kMaxN * 8][3], tag[kMaxN * 8];

  void pushup(int x) {
    for (int i = 0; i <= 2; ++i)
      sum[x][i] = sum[x << 1][i] + sum[x << 1 | 1][i];
  }

  void addtag(int x, int64_t v) {
    tag[x] += v;
    for (int i = 2; ~i; --i) {
      for (int j = i - 1; ~j; --j)
        sum[x][i] += sum[x][j] * C(v, i - j);
    }
  }

  void pushdown(int x) {
    if (!tag[x]) return;
    addtag(x << 1, tag[x]), addtag(x << 1 | 1, tag[x]);
    tag[x] = 0;
  }

  void build(int x, int l, int r) {
    sum[x][0] = 1;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l > qr || r < ql) {
      return;
    } else if (l >= ql && r <= qr) {
      return addtag(x, v);
    }
    pushdown(x);
    int mid = (l + r) >> 1;
    update(x << 1, l, mid, ql, qr, v), update(x << 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int64_t query(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql) {
      return 0;
    } else if (l >= ql && r <= qr) {
      return sum[x][2];
    }
    pushdown(x);
    int mid = (l + r) >> 1;
    return query(x << 1, l, mid, ql, qr) + query(x << 1 | 1, mid + 1, r, ql, qr);
  }
} sgt1, sgt2;

void discrete(int *a, int *b) {
  static int unq[kMaxN * 2];
  int m = 0;
  for (int i = 1; i <= n; ++i) {
    unq[++m] = a[i];
    unq[++m] = b[i];
  }
  std::sort(unq + 1, unq + 1 + m);
  m = std::unique(unq + 1, unq + 1 + m) - (unq + 1);
  for (int i = 1; i <= n; ++i) {
    a[i] = std::lower_bound(unq + 1, unq + 1 + m, a[i]) - unq;
    b[i] = std::lower_bound(unq + 1, unq + 1 + m, b[i]) - unq;
  }
}

void dickdreamer() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i)
    std::cin >> l[i] >> r[i] >> d[i] >> u[i];
  if (n <= 2) return void(std::cout << "0\n");
  discrete(l, r), discrete(d, u);
  for (int i = 1; i <= n; ++i) {
    op[l[i]] = 1, op[r[i]] = -1;
    id[l[i]] = id[r[i]] = i;
  }
  for (int i = 1; i <= 2 * n; ++i) {
    if (op[i] == 1) deg[id[i]] += bit1.qry(u[id[i]]) - bit2.qry(d[id[i]] - 1);
    bit1.upd(d[id[i]], op[i]), bit2.upd(u[id[i]], op[i]);
  }
  for (int i = 1; i <= 2 * n; ++i) {
    if (op[i] == 1) bit1.upd(d[id[i]], op[i]), bit2.upd(u[id[i]], op[i]);
    deg[id[i]] += (-op[i]) * (bit1.qry(u[id[i]]) - bit2.qry(d[id[i]] - 1));
  }
  int64_t ans = 0;
  for (int i = 1; i <= n; ++i) {
    ans -= 1ll * deg[i] * (n - 2);
  }
  ans = ans / 2 + C(n, 3);
  for (int i = 1; i <= n; ++i) {
    ans += C(deg[i], 2);
  }
  sgt1.build(1, 1, 2 * n), sgt2.build(1, 1, 2 * n);
  for (int i = 1; i <= 2 * n; ++i) {
    if (op[i] == 1) {
      ans -= sgt1.query(1, 1, 2 * n, d[id[i]], u[id[i]]) - sgt2.query(1, 1, 2 * n, d[id[i]], u[id[i]] - 1);
    }
    sgt1.update(1, 1, 2 * n, d[id[i]], u[id[i]], op[i]), sgt2.update(1, 1, 2 * n, d[id[i]], u[id[i]] - 1, op[i]);
  }
  std::cout << ans << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("rectangle.in", "r", stdin);
  freopen("rectangle.out", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```