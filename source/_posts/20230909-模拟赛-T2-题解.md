---
title: 20230909 模拟赛 T2 题解
date: 2023-09-13 20:28:00
---

## Description

![image](https://img2023.cnblogs.com/blog/2268753/202309/2268753-20230913201030446-1357891809.png)

$1\leq t,n\leq 10^6,1\leq a_i\leq b_i\leq t,1\leq c_i,v_i,h_i\leq 10^9$。

## Solution

考虑先把药水按照 $c$ 排个序，然后双指针，即对于 $l$，求出一个最小的 $r$ 使得 $[l,r]$ 这些药水能够满足条件，于是题目就转化成这这个：

> 给定长度为 $n$ 的序列 $\{h_i\}$ 的初值，有 $\Theta(q)$ 次操作：
> 
> 1. 插入一个操作：给定 $l, r, v$，将 $[l, r]$ 中 $h_i \leqslant v$ 的 $h_i$ 修改为 $0$。
> 2. 查询在当前操作集合下 $\max h_i$ 是否为 $0$。
> 3. 删除最早的一个操作。

注意到对于前面两个操作只要在线段树上维护一个 maxh 和 maxv，然后如果当前的 $maxh\leq maxv$ 就把这个区间的 maxh 置为 $0$，但是有删除就要维护覆盖了这个区间的所有的 $v$，每次要把线段树里面所有含有删掉这个元素的东西给处理掉，然后还要重构整棵线段树，时间复杂度 $O(n^2\log n)$。

---

这个做法退化得与暴力差不多，因为它每次下传标记会把 $v$ 放到很多个线段树节点上，因此我们思考，不下传标记能不能做呢？

考虑标记永久化，每次添加后不下传标记，然后对于每个节点维护一个单调队列，显然总的 $v$ 个数为 $O(n\log t)$ 级别。

添加到一个线段树节点后就重构单调队列，然后把 maxh 和 maxv 更新。删除就考虑删除队头然后更新 maxh 和 maxv。

那么这样做为什么是对的呢？考虑对于每一个 $h_i$，从 $[i,i]$ 到线段树根节点的这条路径上一定涵盖了所有覆盖了它的 $v$ 值，如果路径上某一个节点的 $maxv>h_i$ 则这个 $h_i$ 一定就变成 $0$ 了，所以对于某个节点 $[l,r]$，如果 $\max\{h_l,\dots,h_r\}\leq maxv$ 说明这个区间全为 $0$，否则说明以 $[l,r]$ 为根的子树里的 $v$ 不足以干掉 $h_{l\sim r}$，就往上继续。

然后由于这是标记永久化，所以如果一个 $v$ 添加或删除到了 $[l,r]$，那么 $[l,r]$ 所有子孙节点的 maxh 一定不变，所以重构后再跑一定是对的。

时间复杂度：$O\left((n+t)\log t\right)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 1e6 + 5;

struct Node {
  int l, r, c, v;
} a[kMaxN];

int t, n;
int h[kMaxN], maxh[kMaxN << 2], maxv[kMaxN << 2];
std::list<int> q[kMaxN << 2];

void pushup(int x) {
  maxh[x] = std::max(maxh[x << 1], maxh[x << 1 | 1]);
}

void build(int x, int l, int r) {
  if (l == r) {
    maxh[x] = h[l];
    return;
  }
  int mid = (l + r) >> 1;
  build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);
  pushup(x);
}

void addv(int x, int l, int r, int ql, int qr, int k) {
  if (l > qr || r < ql) {
    return;
  } else if (l >= ql && r <= qr) {
    for (; !q[x].empty() && a[q[x].back()].v <= a[k].v; q[x].pop_back()) {}
    q[x].emplace_back(k);
    maxv[x] = a[q[x].front()].v;
    if (maxh[x] <= maxv[x]) maxh[x] = 0;
    return;
  }
  int mid = (l + r) >> 1;
  addv(x << 1, l, mid, ql, qr, k), addv(x << 1 | 1, mid + 1, r, ql, qr, k);
  pushup(x);
  if (maxh[x] <= maxv[x]) maxh[x] = 0;
} 

void delv(int x, int l, int r, int ql, int qr, int k) {
  if (l > qr || r < ql) {
    return;
  } else if (l >= ql && r <= qr) {
    for (; !q[x].empty() && q[x].front() <= k; q[x].pop_front()) {}
    if (q[x].empty()) maxv[x] = 0;
    else maxv[x] = a[q[x].front()].v;
    if (l == r) maxh[x] = h[l];
    else pushup(x);
    if (maxh[x] <= maxv[x]) maxh[x] = 0;
    return;
  }
  int mid = (l + r) >> 1;
  delv(x << 1, l, mid, ql, qr, k), delv(x << 1 | 1, mid + 1, r, ql, qr, k);
  pushup(x);
  if (maxh[x] <= maxv[x]) maxh[x] = 0;
}

void dickdreamer() {
  std::cin >> t >> n;
  for (int i = 1; i <= n; ++i)
    std::cin >> a[i].l >> a[i].r >> a[i].c >> a[i].v; 
  for (int i = 1; i <= t; ++i)
    std::cin >> h[i];
  std::sort(a + 1, a + 1 + n, [&] (const Node &n1, const Node &n2) { return n1.c < n2.c; });
  build(1, 1, t);
  int ans = 1e9;
  for (int l = 1, r = 0; l <= n; delv(1, 1, t, a[l].l, a[l].r, l), ++l) {
    for (; r < n && maxh[1]; ++r, addv(1, 1, t, a[r].l, a[r].r, r)) {}
    if (!maxh[1]) ans = std::min(ans, a[r].c - a[l].c);
  }
  std::cout << (ans == 1e9 ? -1 : ans) << '\n';
}

int32_t main() {
  freopen("game.in", "r", stdin);
  freopen("game.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```