---
title: 2022.1.17 模拟赛题解
date: 2023-01-17 15:04:00
---

# T1

## Description

[link](https://codeforces.com/gym/103186/problem/D)

## Solution

由于左边的数不大于右边的数，第二排的数不大于第一排的数。所以从小到大加数时只能靠左放，并且放完后上面的数量不超过下面的数量。

然后就可以 dp 了，设 $f_{i,j}(i\leq j)$ 表示上面放了 $i$ 个数，下面放了 $j$ 个数的方案。

那么 $f_{i,j}$ 就可以转移到所有 $f_{i+s,j+c_k-s}(i+s\leq j+c_k-s)$，暴力转移复杂度是对的。

时间复杂度：$O(n^2)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 5005, kMod = 998244353;

int n;
int a[kMaxN], fac[kMaxN], cnt[kMaxN], sum[kMaxN], f[kMaxN][kMaxN], d[kMaxN][kMaxN];

int main() {
  cin >> n;
  fac[0] = 1;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    ++cnt[a[i]];
    fac[i] = 1ll * i * fac[i - 1] % kMod;
  }
  for (int i = 1; i <= n; ++i)
    sum[i] = sum[i - 1] + cnt[i];
  f[0][0] = 1;
  for (int i = 1; i <= n; ++i) {
    if (!cnt[i]) continue;
    for (int j = 0, k = sum[i] - cnt[i]; j <= k; ++j, --k) {
      for (int s = 0; s <= cnt[i]; ++s) {
        if (j + s <= k + cnt[i] - s)
          f[j + s][k + cnt[i] - s] = (f[j + s][k + cnt[i] - s] + 1ll * f[j][k] * fac[cnt[i]] % kMod) % kMod;
      }
    }
  }
  cout << f[n / 2][n / 2] << '\n';
  return 0;
}
```
</details>

# T2

## Description

[link](https://codeforces.com/gym/103186/problem/H)

## Solution

考虑二分答案，设当前时间是 $t$。

那么 $i$ 和 $j$ 相遇就等价于 $p_i<p_j$ 并且 $p_i+v_it>p_j+v_jt$，这个东西就可以维护一个以 $p$ 为下标的求区间最大值和最小值的线段树。

又因为类型不能相同，所以需要先按类型排序，然后一个类型一个类型地加到线段树里去判断。

时间复杂度：$O(n\log P\log n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5, kInf = LLONG_MAX - 1;

struct Node {
  int p, v, t, vv;
} a[kMaxN];

int n, k, m;
int lsh[kMaxN];
vector<Node> v[kMaxN];

struct SGT {
  int mi[kMaxN << 2], mx[kMaxN << 2];
  
  void clear() {
    fill(mi + 1, mi + 1 + m * 4, kInf);
    fill(mx + 1, mx + 1 + m * 4, -kInf);
  }
  void pushup(int x) {
    mi[x] = min(mi[x << 1], mi[x << 1 | 1]);
    mx[x] = max(mx[x << 1], mx[x << 1 | 1]);
  }
  void update(int x, int l, int r, int ql, int val) {
    if (l > ql || r < ql) {
      return;
    } else if (l == r) {
      mi[x] = min(mi[x], val);
      mx[x] = max(mx[x], val);
      return;
    }
    int mid = (l + r) >> 1;
    update(x << 1, l, mid, ql, val);
    update(x << 1 | 1, mid + 1, r, ql, val);
    pushup(x);
  }
  int querymin(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql) {
      return kInf;
    } else if (l >= ql && r <= qr) {
      return mi[x];
    }
    int mid = (l + r) >> 1;
    return min(querymin(x << 1, l, mid, ql, qr), querymin(x << 1 | 1, mid + 1, r, ql, qr));
  }
  int querymax(int x, int l, int r, int ql, int qr) {
    if (l > qr || r < ql) {
      return -kInf;
    } else if (l >= ql && r <= qr) {
      return mx[x];
    }
    int mid = (l + r) >> 1;
    return max(querymax(x << 1, l, mid, ql, qr), querymax(x << 1 | 1, mid + 1, r, ql, qr));
  }
} s;

void discrete() {
  for (int i = 1; i <= n; ++i) {
    lsh[++m] = a[i].p;
  }
  sort(lsh + 1, lsh + 1 + m);
  m = unique(lsh + 1, lsh + 1 + m) - (lsh + 1);
  for (int i = 1; i <= n; ++i) {
    a[i].vv = lower_bound(lsh + 1, lsh + 1 + m, a[i].p) - lsh;
  }
}

bool check(int x) {
  s.clear();
  for (int i = 1; i <= k; ++i) {
    for (auto p : v[i]) {
      if (p.vv < m && s.querymin(1, 1, m, p.vv + 1, m) <= p.p + p.v * x) return 0;
      if (p.vv > 1 && s.querymax(1, 1, m, 1, p.vv - 1) >= p.p + p.v * x) return 0;
    }
    for (auto p : v[i]) {
      s.update(1, 1, m, p.vv, p.p + p.v * x);
    }
  }
  return 1;
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> k;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i].p >> a[i].v >> a[i].t;
  }
  discrete();
  for (int i = 1; i <= n; ++i) {
    v[a[i].t].emplace_back(a[i]);
  }
  int L = 0, R = 2e9 + 1, res = 0;
  if (check(2e9)) {
    cout << "-1\n";
    return 0;
  }
  while (L + 1 < R) {
    int mid = L + (R - L) / 2;
    if (check(mid)) L = res = mid;
    else R = mid;
  }
  cout << res << '\n';
  return 0;
}
```
</details>

# T3

## Description

[link](https://codeforces.com/gym/103186/problem/J)

## Solution

答案就是

$$
|A|-|S-A|=
\begin{cases}
S\space\space\space\space\space\space\space\space\space\space\space\space(A\geq S)\\
2A-S\space\space(0\leq A<S)\\
-S\space\space\space\space\space\space\space\space\space(A<0)
\end{cases}
$$

容易发现这个东西是单调不减的，所以 Alice 每次选最大的即可。

时间复杂度：$O(n\log n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 5005;

int n;
long long sum;
int a[kMaxN];

int main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    sum += a[i];
  }
  sort(a + 1, a + 1 + n);
  if (n & 1) {
    long long ans = 0;
    for (int i = 1; i <= n; ++i) {
      if (i & 1) ans += a[i];
    }
    cout << -abs(sum - ans) + abs(ans) << '\n';
  } else {
    long long m1 = 0, m2 = 0;
    for (int i = 1; i <= n; ++i) {
      if (i & 1) m1 += a[i];
      else m2 += a[i];
    }
    cout << max(abs(m1) - abs(sum - m1), abs(m2) - abs(sum - m2)) << '\n';
  }
  return 0;
}
```
</details>

# T4

## Description

[link](https://codeforces.com/gym/103186/problem/K)

## Solution

暴力求出 sg 函数即可。

时间复杂度：$O(能过)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

bool operator < (const vector<int> &v1, const vector<int> &v2) {
  if (v1.size() != v2.size()) return v1.size() < v2.size();
  for (int i = 0; i < v1.size(); ++i) {
    if (v1[i] != v2[i]) return v1[i] < v2[i];
  }
  return 1;
}

int n;
string s[15];
map<vector<int>, int> mp;

vector<int> getdiao(string s) {
  vector<int> vec;
  sort(s.begin(), s.end());
  int lst = -1;
  for (int i = 0; i < s.size(); ++i) {
    if (i == (int)s.size() - 1 || s[i] != s[i + 1]) {
      vec.emplace_back(i - lst);
      lst = i;
    }
  }
  sort(vec.begin(), vec.end());
  return vec;
}

vector<int> work(vector<int> vec) {
  vector<int> ret;
  for (auto x : vec)
    if (x > 0)
      ret.emplace_back(x);
  sort(ret.begin(), ret.end());
  return ret;
}

int mex(vector<int> vec) {
  int ret = 0;
  sort(vec.begin(), vec.end());
  for (auto x : vec) {
    if (x > ret) break;
    if (x == ret) ++ret;
  }
  return ret;
}

int dfs(vector<int> vec) {
  if (!vec.size()) return 0;
  if (mp.count(vec)) return mp[vec];
  auto kk = vec;
  vector<int> sg;
  for (int i = 0; i < kk.size(); ++i) {
    --vec[i];
    sg.emplace_back(dfs(work(vec)));
    for (int j = i + 1; j < kk.size(); ++j) {
      --vec[j];
      sg.emplace_back(dfs(work(vec)));
      ++vec[j];
    }
    ++vec[i];
  }
  return mp[kk] = mex(sg);
}

void solve() {
  int ans = 0;
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> s[i];
    ans ^= dfs(work(getdiao(s[i])));
  }
  cout << (ans ? "Alice\n" : "Bob\n");
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  while (T--) solve();
  return 0;
}
```
</details>