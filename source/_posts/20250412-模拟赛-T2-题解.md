---
title: '20250412 模拟赛 T2 题解'
date: 2025-04-12 16:11:00
---

## Description

在一个二维平面上，给定 $n$ 个坐标 $(a_i,b_i)$ 和 $n$ 个正整数 $e_i$，有三种移动方式：

- 花费 $1$ 的代价，从 $(x,y)$ 移动到 $(x+1,y+1)$。
- 花费 $0$ 的代价，从 $(a_i,b_i)$ 移动到 $(a_i+e_i,b_i+e_i)$。
- 花费 $0$ 的代价，从 $(x,y)$ 移动到任意满足 $x'\le x,y'\le y$ 的 $(x',y')$。

有 $q$ 次询问，每次询问给定 $c_i,d_i$，你需要求出从 $(0,0)$ 经过任意次移动到 $(c_i,d_i)$ 的最小代价总和。

$n,q\leq 5\times 10^5$。

## Solution

首先可以把询问看成二维平面上的点，但是 $e_i=0$。

考虑进行 dp，设 $f_i$ 表示从 $(0,0)$ 走到 $(a_i,b_i)$ 的最小代价。

可以得到转移方程：$f_j\leftarrow f_i+\max\{0,a_j-a_i-e_i,b_j-b_i-e_i\}$。

考虑对 $a_j-a_i-e_i$ 和 $b_j-b_i-e_i$ 的大小分讨，可以得到：

$$
f_j\leftarrow f_i+\begin{cases}\max\{0,a_j-a_i-e_i\}\quad &(a_j-b_j\geq a_i-b_i)\\\max\{0,b_j-b_i-e_i\}\quad &(a_j-b_j<a_i-b_i)\end{cases}
$$

所以可以对 $a_i-b_i$ 进行排序，先不管和 $0$ 取 $\max$ 的情况，可以用线段树维护区间 $a_i$ 和 $b_i$ 分别的最小值以及待转移 dp 值的最小值。

每次选择待转移 dp 值最小的出来，然后分别对一段前缀和一段后缀做和 $x_i-val$ 和 $y_i+val$ 取 $\min$ 的操作，维护 tag 即可。

加上和 $0$ 取 $\max$ 的话，如果当前大于等于之前选的肯定合法；如果小于之前选的最大值，由于每次是贪心选最小的 dp 值，所以当前的答案不能比之前的答案优，和前面的 dp 最大值取 $\max$ 即可。

时间复杂度：$O((n+q)\log(n+q))$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

using pii = std::pair<int, int>;

const int kMaxN = 1e6 + 5;

int n, q;
int a[kMaxN], b[kMaxN], e[kMaxN], f[kMaxN], id[kMaxN];

template<class T> inline void chkmin(T &a, T b) { a = (a < b ? a : b); }
template<class T> inline void chkmax(T &a, T b) { a = (a > b ? a : b); }

struct SGT {
  pii mi[kMaxN * 4], mia[kMaxN * 4], mib[kMaxN * 4];
  int taga[kMaxN * 4], tagb[kMaxN * 4];
  void pushup(int x) {
    mi[x] = std::min(mi[x << 1], mi[x << 1 | 1]);
    mia[x] = std::min(mia[x << 1], mia[x << 1 | 1]);
    mib[x] = std::min(mib[x << 1], mib[x << 1 | 1]);
  }
  void addtaga(int x, int v) {
    chkmin(taga[x], v);
    chkmin(mi[x], pii{mia[x].first + v, mia[x].second});
    // std::cerr << v << ' ' << mia[x].first << ' ' << mia[x].second << ' ' << mi[x].first << ' ' << mi[x].second << '\n';
  }
  void addtagb(int x, int v) {
    chkmin(tagb[x], v);
    chkmin(mi[x], pii{mib[x].first + v, mib[x].second});
  }
  void pushdown(int x) {
    if (taga[x] != 1e9) {
      addtaga(x << 1, taga[x]), addtaga(x << 1 | 1, taga[x]);
      taga[x] = 1e9;
    }
    if (tagb[x] != 1e9) {
      addtagb(x << 1, tagb[x]), addtagb(x << 1 | 1, tagb[x]);
      tagb[x] = 1e9;
    }
  }
  void build(int x, int l, int r) {
    taga[x] = tagb[x] = 1e9;
    if (l == r) {
      mi[x] = {std::max(a[id[l]], b[id[l]]), l};
      mia[x] = {a[id[l]], l};
      mib[x] = {b[id[l]], l};
      return;
    }
    int mid = (l + r) >> 1;
    build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);
    pushup(x);
  }
  void updatea(int x, int l, int r, int ql, int qr, int v) {
    if (l > qr || r < ql) return;
    else if (l >= ql && r <= qr) return addtaga(x, v);
    pushdown(x);
    int mid = (l + r) >> 1;
    updatea(x << 1, l, mid, ql, qr, v), updatea(x << 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }
  void updateb(int x, int l, int r, int ql, int qr, int v) {
    if (l > qr || r < ql) return;
    else if (l >= ql && r <= qr) return addtagb(x, v);
    pushdown(x);
    int mid = (l + r) >> 1;
    updateb(x << 1, l, mid, ql, qr, v), updateb(x << 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }
  void erase(int x, int l, int r, int ql) {
    if (l == r) return void(mi[x] = mia[x] = mib[x] = {1e9, 0});
    pushdown(x);
    int mid = (l + r) >> 1;
    if (ql <= mid) erase(x << 1, l, mid, ql);
    else erase(x << 1 | 1, mid + 1, r, ql);
    pushup(x);
  }
} sgt;

void dickdreamer() {
  std::cin >> n >> q;
  for (int i = 1; i <= n; ++i) std::cin >> a[i] >> b[i] >> e[i];
  for (int i = n + 1; i <= n + q; ++i) std::cin >> a[i] >> b[i];
  std::iota(id + 1, id + 1 + n + q, 1);
  std::sort(id + 1, id + 1 + n + q, [&] (int x, int y) { return a[x] - b[x] < a[y] - b[y]; });
  sgt.build(1, 1, n + q);
  int lst = 0;
  for (int i = 1; i <= n + q; ++i) {
  // for (int i = 1; i <= 3; ++i) {
    auto p = sgt.mi[1];
    int x = p.second;
    f[id[x]] = std::max(lst, p.first);
    lst = std::max(lst, f[id[x]]);
    sgt.erase(1, 1, n + q, x);
    // std::cerr << x << ' ' << id[x] << ' ' << f[id[x]] << '\n';
    // if (i == 2) std::cerr << "------------------\n";
    sgt.updatea(1, 1, n + q, x, n + q, f[id[x]] - a[id[x]] - e[id[x]]);
    sgt.updateb(1, 1, n + q, 1, x - 1, f[id[x]] - b[id[x]] - e[id[x]]);
    // if (i == 2) std::cerr << "------------------\n";
  }
  // std::cerr << f[1] << ' ' << f[2] << '\n';
  for (int i = n + 1; i <= n + q; ++i) std::cout << f[i] << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```