---
title: '20230913 模拟赛 T4 题解'
date: 2023-09-13 20:38:00
---

## Description

![image](https://img2023.cnblogs.com/blog/2268753/202309/2268753-20230913203718264-15641136.png)

$1\leq n,x_i,y_i\leq 5\times 10^5$。

## Solution

注意到每个棋子只会被吃一次，那么只要考虑把白棋放到某个黑棋上，然后在这个基础上继续吃黑棋。

那么如果黑棋 $i$ 能够吃掉黑棋 $j$ 就意味着 $|y_i-y_j|=1$ 且 $x_j>x_i$，然后连一条从 $i$ 到 $j$ 的有向边，容易发现会形成一个 DAG，而答案就是这个 DAG 的最小不相交链覆盖，建出二分图跑最大匹配可以做到 $O(n^2\sqrt{n})$。

---

注意到这个最大匹配很难发现性质，考虑把答案转化为最大独立集，答案=$n-最大匹配=n-(2n-最大独立集)=最大独立集-n$，这样做后会发现如果右边的第 $i$ 个点在最大独立集里，说明左边没有能够吃掉 $i$ 的点，那么原图里面 $y_j=y_i$ 且 $x_j>x_i$ 的 $j$ 在右边对应的点也在最大独立集里。

所以如果把右边 $y$ 值相同的放在一起，那么对于每一个 $y$ 放到最大独立集里的一定是一个后缀。同理，左边的一定是个前缀。

然后考虑从前往后对于每一个列进行 dp。设 $f_{i,j,0/1}$ 表示考虑了 $1\sim i$ 列，第 $i$ 列选了前缀/后缀 $j$ 个，当前考虑的是第 $i$ 的左边/右边。

那么 $f_{i,j,0}=\min\left\{f_{i-1,k,1}+j\right(a_{i-1,k}\geq a_{i,j})\},f_{i,j,1}=\min\left\{f_{i-1,k,0}+j\right(a_{i-1,k}\leq a_{i,j})\}$。

设 $m$ 为 $y_i$ 的值域，然后对于 $f_{1,j,0},f_{2,j,1},f_{3,j,0},\dots,f_{m,j,1-(m\bmod 2)}$ 和 $f_{1,j,1},f_{2,j,0},f_{3,j,1},\dots,f_{m,j,m\bmod 2}$ 分别 dp 即可。

时间复杂度：$O(n+V)$，实测桶排没有 sort 快。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m;
int x[kMaxN], y[kMaxN], sz[kMaxN], f[2][kMaxN];
std::vector<int> v[kMaxN], buc[kMaxN];

int solve(int o) { // 0 : 从下到上，1 : 从上到下
  memset(f, 0xcf, sizeof(f));
  if (!o) {
    for (int i = 0; i <= sz[1]; ++i)
      f[o][i] = i;
  } else {
    for (int i = 1; i <= sz[1] + 1; ++i)
      f[o][i] = sz[1] - i + 1;
  }
  for (int i = 2; i <= m; ++i) {
    o ^= 1;
    for (int j = 0; j <= sz[i] + 1; ++j)
      f[o][j] = -1e9;
    if (!o) { // v[i - 1][k] >= v[i][j]
      for (int j = sz[i], k = sz[i - 1] + 1; ~j; --j) {
        for (; k > 1 && v[i - 1][k - 1] >= v[i][j]; --k) {}
        f[o][j] = f[o ^ 1][k] + j;
      }
      for (int j = 1; j <= sz[i]; ++j)
        f[o][j] = std::max(f[o][j], f[o][j - 1]);
    } else { // v[i - 1][k] <= v[i][j]
      for (int j = 1, k = 0; j <= sz[i] + 1; ++j) {
        for (; k < sz[i - 1] && v[i - 1][k + 1] <= v[i][j]; ++k) {}
        f[o][j] = f[o ^ 1][k] + sz[i] - j + 1;
      }
      for (int j = sz[i]; j >= 1; --j)
        f[o][j] = std::max(f[o][j], f[o][j + 1]);
    }
  }
  return (o ? f[o][1] : f[o][sz[m]]);
}

void dickdreamer() {
  std::cin >> n;
  int mx = 0;
  for (int i = 1; i <= n; ++i) {
    std::cin >> x[i] >> y[i];
    buc[x[i]].emplace_back(y[i]);
    m = std::max(m, y[i]);
    mx = std::max(mx, x[i]);
    ++sz[y[i]];
  }
  for (int i = 1; i <= m; ++i)
    v[i].emplace_back(-1e9);
  for (int i = 1; i <= mx; ++i)
    for (auto y : buc[i])
      v[y].emplace_back(i);
  for (int i = 1; i <= m; ++i)
    v[i].emplace_back(1e9);
  std::cout << solve(0) + solve(1) - n << '\n';
}

int32_t main() {
  freopen("orz.in", "r", stdin);
  freopen("orz.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```