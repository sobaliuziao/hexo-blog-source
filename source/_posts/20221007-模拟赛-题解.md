---
title: '20221007 模拟赛 题解'
date: 2022-10-07 16:11:00
---

[problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/5t8063ap)
[官方题解](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/5t8063ap)

## T1

### Solution

容易发现行和列互相是不影响的，所以只需要单独考虑即可。

不妨设当前序列为 $a$，$A$ 为序列的平均数，$x_i$ 为 $i$ 跟 $i$ 左边那个人的交换次数，那么我们要求 $\sum\limits_{i=1}^{n}{x_i}$。

可以列出下面的式子：

$$
\begin{cases}
a_1+x_2-x_1=A\\
a_2+x_3-x_2=A\\
...\\
a_n+x_1-x_n=A
\end{cases}
$$

把这个式子转化一下：

$$
\begin{cases}
x_2=A+x_1-a_1\\
x_3=A+x_2-a_2=x_1-(a_1-A)-(a_2-A)\\
...\\
x_1=x_1-\sum_\limits{i=1}^{n}{(a_i-A)} 
\end{cases}
$$

那么可以设 $b_i=a_i-A$，$c_i=\sum_\limits{j=1}^{i}{b_j}$。

那么要求的式子就变为：$\sum\limits_{i=1}^{n}{|x_1-c_i|}$。由于 $c$ 是确定的，所以当 $x_1$ 取 $c$ 的中位数时最小。

因为有个 `sort` 所以是 $O(n\log n)$ 的。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 1
#endif

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch < '0' || ch > '9') f |= ch == '-', ch = getchar();
  while (ch >= '0' && ch <= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

typedef long long ll;

const int kMaxN = 1e5 + 5;

int n, m, t;
int a[kMaxN], b[kMaxN];
ll s[kMaxN], c[kMaxN];

ll solve(int *a, int n) {
  int A = 0;
  ll x, ret = 0;
  for (int i = 1; i <= n; ++i) {
    A += a[i];
  }
  A /= n;
  for (int i = 1; i <= n; ++i) {
    s[i] = a[i] - A;
    c[i] = s[i] + c[i - 1];
  }
  sort(c + 1, c + 1 + n);
  x = c[(n + 1) / 2];
  for (int i = 1; i <= n; ++i) {
    ret += abs(c[i] - x);
  }
  return ret;
}

int main() {
  file("tanabata");
  n = read(), m = read(), t = read();
  for (int i = 1, x, y; i <= t; ++i) {
    x = read(), y = read();
    ++a[x], ++b[y];
  }
  if (t % n == 0 && t % m == 0) printf("both %lld\n", solve(a, n) + solve(b, m));
  else if (t % n == 0) printf("row %lld\n", solve(a, n));
  else if (t % m == 0) printf("column %lld\n", solve(b, m));
  else printf("impossible\n"); 
  return 0;
}
```

</details>

## T2

### Solution

爆搜即可。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...)
#endif

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch < '0' || ch > '9') f |= ch == '-', ch = getchar();
  while (ch >= '0' && ch <= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

const int kMaxN = (1 << 21) + 5;

int n, k;
int a[kMaxN], vis[kMaxN], cp[kMaxN];

int get(int l, int r) {
  int nw = 0;
  if (l <= r) {
    for (int i = l; i <= r; ++i) {
      nw = (nw << 1) + a[i];
    }    
  } else {
    for (int i = l; i <= n; ++i) {
      nw = (nw << 1) + a[i];
    }
    for (int i = 1; i <= r; ++i) {
      nw = (nw << 1) + a[i];
    }
  }
  return nw;
}

void check() {
  for (int s = n - k + 2; s <= n; ++s) {
    if (vis[get(s, s + k - n - 1)]) goto GG;
    vis[get(s, s + k - n - 1)] = 1;
  }
  cout << n << ' ';
  for (int i = 1; i <= n; ++i) {
    cout << a[i];
  }
  exit(0);
  GG:;
  memset(vis, 0, sizeof(vis));
  for (int i = 1; i <= n - k + 1; ++i) {
    vis[get(i, i + k - 1)] = 1;
  }
}

void dfs(int x) {
  if (x == n + 1) return check();
  for (int i = 0; i <= 1; ++i) {
    a[x] = i;
    if (x < k) goto FK;
    if (vis[get(x - k + 1, x)]) continue ;
    vis[get(x - k + 1, x)] = 1;
    FK:;
    dfs(x + 1);
    vis[get(x - k + 1, x)] = 0;
  }
}

int main() {
  file("taiko");
  cin >> k;
  n = (1 << k);
  dfs(1);
  return 0;
}
```

</details>

## T3

### Solution

考虑一个最简分数 $\dfrac{p}{q}(p\neq 0)$ 在 $k$ 进制下，如果 $(q,k)=1$ 则无论 $p$ 取任何数，这个分数都是纯循环小数。

那么对于第一问直接模拟相除的过程，每一位除完之后约分即可。如果当前 $q$ 与 $k$ 不互质，则每次都能除掉一个大于 $1$ 的数，所以最多 $\log q$ 次。

---

第一问做完之后 $q$ 与 $k$ 互质，那么循环节就是最小的 $x$，使得 $k^x\equiv 1(\text{mod}\space q)$，直接 BSGS 会被卡常，实测最慢的点跑 $1.8\text{s}$，所以要想一个更快的算法。

考虑到 $k^{\varphi(q)}\equiv 1(\text{mod}\space q)$，根据阶的性质可知最小的 $x$ 整除 $\varphi(q)$，所以可以直接枚举 $\varphi(q)$ 的因数然后取最小值就行了。

虽然这样做还是 $O(\sqrt{n}\log n)$ 的（$\log$ 是快速幂的），但是常数小了很多，可以飞快地通过。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 1
#endif

#define int long long
#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch < '0' || ch > '9') f |= ch == '-', ch = getchar();
  while (ch >= '0' && ch <= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

typedef __int128 i128;

int T, a, b, k;
vector<int> p;

int gcd(int m, int n) {
  if (!n) return m;
  int m1 = (m & 1), n1 = (n & 1);
  if (!m1 && !n1) return gcd(m >> 1, n >> 1) << 1;
  if (!m1) return gcd(m >> 1, n);
  if (!n1) return gcd(m, n >> 1);
  return gcd(n, m % n);
}

int qpow(int bs, int idx, int mod) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = (i128)bs * bs % mod) {
    if (idx & 1) ret = (i128)ret * bs % mod;
  }
  return ret % mod;
}

int phi(int x) {
  p.clear();
  int cx = x;
  for (int i = 2; i * i <= cx; ++i) {
    if (cx % i == 0) {
      p.emplace_back(i);
      while (cx % i == 0) cx /= i;
    }
  }
  if (cx > 1) p.emplace_back(cx);
  for (auto k : p) {
    x = x / k * (k - 1);
  }
  return x;
}

int getm(int &b) {
  int nw = 1;
  if (gcd(b, k) == 1) return 0;
  for (int i = 1; ; ++i) {
    nw = (i128)nw * k % b;
    int d = gcd(b, nw);
    if (nw) b /= d, nw /= d;
    else return i;
    if (gcd(b, k) == 1) return i;
  }
}

bool check(int x) {
  return qpow(k, x, b) == 1;
}

int getr(int b) {
  if (b == 1) return 0;
  int p = phi(b), ans = p;
  for (int i = 1; i * i <= p; ++i) {
    if (p % i == 0) {
      if (check(i)) ans = min(ans, i);
      if (check(p / i)) ans = min(ans, p / i);
    }
  }
  return ans;
}

signed main() {
  file("kubi");
  cin >> T;
  while (T--) {
    cin >> a >> b >> k;
    int d = gcd(a, b);
    a /= d, b /= d;
    cout << getm(b) << ' ' << getr(b) << endl;
  }
  return 0;
}
```

</details>