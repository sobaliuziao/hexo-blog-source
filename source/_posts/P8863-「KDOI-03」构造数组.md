---
title: P8863 「KDOI-03」构造数组
date: 2024-02-07 21:09:00
---

## Descriptoin

你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。

* 选出两个**不同的**下标 $1\leq i<j\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。

两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。

**答案对 $\bm{998244353}$ 取模。**

$1\le n\le 5000$，$1\leq b_i\le30000$，$\sum b_i\le30000$。

## Solution

这题可以转化为给定 $t$ 个空位置，每个位置最多放 $2$ 个数，每次可以选择 $a_i$ 个没满位置放 $i$ 进去，问最后把这 $t$ 个位置都放满有多少种方案。

设 $f_{i,j}$ 表示前 $i$ 个数，放满了 $j$ 个位置，容易发现只放了一个的位置个数为 $cnt_1=\sum_{k=1}^{i}{a_k}-2j$，还没放的位置个数为 $t-cnt_1-j$。

那么只要枚举当前的 $i$ 放在 $k$ 个 $1$ 位置，$a_i-k$ 个 $0$ 位置，然后乘上组合数即可做到 $O\left(\left(\sum b_i\right)^2\right)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 5e3 + 5, kMaxS = 3e4 + 5, kMod = 998244353;

int n;
int a[kMaxN], sum[kMaxN], f[2][kMaxS], fac[kMaxS], ifac[kMaxS], inv[kMaxS];

inline void inc(int &x, int y) { (x += y) >= kMod ? (x -= kMod) : x; }

inline int C(int m, int n) {
  if (m < n || m < 0 || n < 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i <= sum[n]; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void dickdreamer() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i) {
    std::cin >> a[i];
    sum[i] = sum[i - 1] + a[i];
  }
  if (sum[n] & 1) return void(std::cout << "0\n");
  prework();
  int o = 0, t = sum[n] / 2;
  f[o][0] = 1;
  for (int i = 0; i < n; ++i) {
    o ^= 1;
    for (int j = 0; j <= t; ++j)
      f[o][j] = 0;
    for (int j = 0; j <= t; ++j) {
      int cnt1 = sum[i] - 2 * j, cnt0 = t - cnt1 - j;
      if (cnt1 < 0 || cnt0 < 0) continue;
      for (int k = std::max(0, a[i + 1] - cnt0); k <= std::min(cnt1, a[i + 1]); ++k) { // 放在 1 位置的个数
        inc(f[o][j + k], 1ll * f[o ^ 1][j] * C(cnt1, k) % kMod * C(cnt0, a[i + 1] - k) % kMod);
      }
    }
  }
  std::cout << f[o][t] << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```