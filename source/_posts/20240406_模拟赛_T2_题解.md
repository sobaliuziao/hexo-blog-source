---
title: 20240406 模拟赛 T2 题解
date: 2025-04-06 16:54:00
---

## Description

给定一个左右各有 $n$ 个点的二分图，左边第 $i$ 个点和右边第 $j$ 个点有边的概率是 $p_{i,j}$，问这张图存在完美匹配的概率。

答案对 $10^9+7$ 取模。

$n\leq 9$。

## Solution

考虑用 Hall 定理判断是否存在完美匹配。

不存在完美匹配的充要条件是存在一个左部点集合 $S$ 使得 $|S|-|N(S)|>0$。

但是一个不满足条件的图可能有很多这样的集合 $S$，考虑找一个代表元来计数。

具体的，找到满足 $|S|-|N(S)|$ 最大，在满足这个最大的条件下找 $|S|$ 最小的 $S$。

证明就考虑如果存在 $|S|-|N(S)|=|T|-|N(T)|$ 且 $|S|=|T|$，则由于 $|S\cap T|<|S|$，所以 $|S\cap T|-|N(S\cap T)|<|S|-|N(S)|$。然后：

$$
\begin{aligned}
&|S\cup T|-|N(S\cup T)|\\
\geq&|S|+|T|-|S\cap T|-(|N(S)|+|N(T)|-|N(S\cap T)|)\\
=&(|S|-|N(S)|)+(|T|-|N(T)|)-(|S\cap T|-|N(S\cap T)|)\\
>&|T|-|N(T)|
\end{aligned}
$$

矛盾，所以这个 $S$ 是唯一的。

后面就设 $f_{S,T}$ 表示只考虑左边 $S$ 右边 $T$ 的导出子图，且这个子图不存在子集 $s$，使得 $|s|-|N(s)|>0$ 的概率。$g_{S,T}$ 为只考虑左边 $S$ 右边 $T$ 的导出子图，$T=N(S)$ 且 $S$ 是这个导出子图的代表元的概率。

对 $g$ 转移时用总概率减去 $S$ 不是 代表元的概率。

设实际代表元为 $(S_1,T_1)$，则需要满足 $(S-S_1,T-T_1)$ 必须合法，否则找到这个图的子图加进去一定更优。同时 $S_1$ 和 $T-T_1$ 之间不能有边。

具体转移方程见代码。

时间复杂度：$O(3^{2n})$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 10, kMaxS = (1 << 9) + 5, kMod = 1e9 + 7;

int n;
int w[kMaxN][kMaxN], pc[kMaxS], p[kMaxS][kMaxS], f[kMaxS][kMaxS], g[kMaxS][kMaxS];

/*
  f[s][t] : 左边 s，右边 t 存在完美匹配的概率
  g[s][t] : 左边 s，右边 t，N(s) = t 且要求只考虑 s -> t 的边时 |s| - |t| 是最大的概率
*/

int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx >>= 1, bs = (int64_t)bs * bs % kMod)
    if (idx & 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y >= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x >= y ? x - y : x - y + kMod); }
inline void inc(int &x, int y) { (x += y) >= kMod ? x -= kMod : x; }
inline void dec(int &x, int y) { (x -= y) < 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j)
      std::cin >> w[i][j];
  for (int s = 0; s < (1 << n); ++s) {
    pc[s] = pc[s >> 1] + (s & 1);
    for (int t = 0; t < (1 << n); ++t) {
      p[s][t] = 1;
      for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
          if ((s >> (i - 1) & 1) && (t >> (j - 1) & 1))
            p[s][t] = 1ll * p[s][t] * sub(1, w[i][j]) % kMod;
    }
  }
  f[0][0] = g[0][0] = 1;
  for (int s = 0; s < (1 << n); ++s) {
    for (int t = 0; t < (1 << n); ++t) {
      if (!s && !t) continue;
      int cs = pc[s], ct = pc[t];
      f[s][t] = g[s][t] = 1;
      for (int s1 = s; ~s1; s1 = (!s1 ? -1 : ((s1 - 1) & s))) {
        for (int t1 = t; ~t1; t1 = (!t1 ? -1 : (t1 - 1) & t)) {
          if (s1 != s || t1 != t) {
            int cs1 = pc[s1], ct1 = pc[t1], val = 1ll * g[s1][t1] * f[s - s1][t - t1] % kMod * p[s1][t - t1] % kMod;
            if (cs1 - ct1 >= cs - ct) dec(g[s][t], val);
            if (cs1 - ct1 > 0) dec(f[s][t], val);
          }
          // if (s == 1 && t == 1) std::cerr << "!!! " << s1 << ' ' << t1 << ' ' << f[s][t] << ' ' << g[s][t] << '\n';
        }
      }
      if (cs > ct) f[s][t] = 0;
      // std::cerr << f[s][t] << ' ' << g[s][t] << '\n';
    }
  }
  std::cout << f[(1 << n) - 1][(1 << n) - 1] << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```