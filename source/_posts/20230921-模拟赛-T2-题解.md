---
title: 20230921 模拟赛 T2 题解
date: 2023-09-21 20:58:00
---

## Description

给你一颗有 $n$ 个点的树，其中 $1$ 号点为根节点，每个点都有一个权值 $val[i]$。

你可以从树中选择一些点， 注意如果 $i$ 与 $j$ 都被选中且 $j$ 在 $i$ 的子树内，那么必须满足 $val[i] > val[j]$。

请你求出最多能同时选出多少个点

$n\leq 10^5$。

## Solution

考虑 Dilworth 定理。

如果 $j$ 在 $i$ 的子树里，且 $val[i]\leq val[j]$ 那么连一条从 $i$ 到 $j$ 的边。

那么原题就相当于找最多的点，使得对于任意两点 $i,j(dep[i]<dep[j])$，要么 $i,j$ 都不在对方子树里，要么 $val[i]>val[j]$，也就是两两不可到达，根据 Dilworth 定理，就是原来那个 DAG 的最小链覆盖。

于是答案就是在原树里面用最少的从叶子到根的不上升子序列来覆盖所有点的序列数。

考虑对于每个点维护一个 multiset，这个点对应子树的最小链覆盖的末尾值。

那么对于一个点 $u$，先把 $u$ 所有儿子的 multiset 合并，然后 $u$ 优先要找子树里面的链末尾最小的去接上，也就是找 $\geq val[u]$ 的最小的那个末尾去接，如果找不到，就只能新建一条链。

至于为什么要找到 $\geq val[u]$ 的最小的末尾接，是因为如果能接，那么肯定是把某个大于等于 $val[u]$ 的替换成 $val[u]$，由于大的到后面能接的肯定比小的要多，所以肯定是找到最小的且能接的去接。

至于合并 multiset，直接 dsu on tree 即可。

时间复杂度：$O(n\log^2 n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n;
int val[kMaxN], sz[kMaxN], wson[kMaxN];
std::vector<int> G[kMaxN];
std::multiset<int> st[kMaxN];

void dfs1(int u) {
  sz[u] = 1;
  for (auto v : G[u]) {
    dfs1(v);
    if (sz[v] > sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, std::multiset<int> &s) {
  if (wson[u]) dfs2(wson[u], s);
  for (auto v : G[u]) {
    if (v == wson[u]) continue;
    dfs2(v, st[v]);
    for (auto x : st[v]) s.emplace(x);
  }
  auto it = s.lower_bound(val[u]);
  if (it != s.end()) s.erase(it);
  s.emplace(val[u]);
}

void dickdreamer() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i) {
    int p;
    std::cin >> val[i] >> p;
    if (p) G[p].emplace_back(i);
  }
  dfs1(1), dfs2(1, st[1]);
  std::cout << st[1].size() << '\n';
}

int32_t main() {
  freopen("tree.in", "r", stdin);
  freopen("tree.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```