---
title: 20220827 题解
date: 2023-10-07 20:41:00
---

## T1 [JOI 2020 Final] 長いだけのネクタイ

### Description

[link](https://www.luogu.com.cn/problem/P6877?contestId=82279)

### Solution

结论题。

设去掉一条领带后的序列为 $c_1,c_2,...,c_n$，那么当答案最小时，$c_1\leq c_2\leq...\leq c_n$，不会证，但是这是对的。

时间复杂度：$O(n\log n)$，瓶颈在 `sort` 上。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef pair<int, int> pii;

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN], b[kMaxN], mx[kMaxN][2], ans[kMaxN];
pii p[kMaxN];

/* ---------- Line ---------- */

bool m_ed;

int main() {
//  freopen("a.txt", "r", stdin);
//  freopen("b.txt", "w", stdout);
  scanf("%d", &n);
  for (int i = 1; i <= n + 1; ++i) {
    scanf("%d", &a[i]);
    p[i] = {a[i], i};
  }
  for (int i = 1; i <= n; ++i) {
    scanf("%d", &b[i]);
  }
  sort(b + 1, b + 1 + n), sort(p + 1, p + 2 + n);
//  mx[0][0] = mx[n + 1][1] = -2e9;
  for (int i = 1; i <= n + 1; ++i) {
    mx[i][0] = max(mx[i - 1][0], p[i].first - b[i]);
  }
  for (int i = n + 1; i; --i) {
    mx[i][1] = max(mx[i + 1][1], p[i].first - b[i - 1]);
  }
  for (int i = 1; i <= n + 1; ++i) {
    ans[p[i].second] = max(mx[i - 1][0], mx[i + 1][1]);
  }
  for (int i = 1; i <= n + 1; ++i) {
    printf("%d ", ans[i]);
  }
  putchar('\n');
  return summary, 0;
}
```

</details>

## T2 [JOI 2021 Final] 雪玉

### Description

[link](https://www.luogu.com.cn/problem/P7405)

### Solution

容易发现能对雪球产生贡献的雪地一定是连续的，那么我们就可以对于雪球 $i$，二分能对于它产生贡献的雪地的左端点，右端点就是雪球 $i$ 能到的最大的长度和 $i+1$ 的左端点的较小值。

考虑如何二分。假设当前二分雪球 $x$ 的左端点，二分的范围就是 $a[x-1]\sim a[x]$，如果当前的答案是 $k$，那么我们就再用一个二分找到雪球 $i$ 第一次经过 $k$ 的时间，那么只要看 $i-1$ 在这个时间之前（包括这个时间）有没有到过 $k$，如果到过 $k$ 那么就不行，而没到过就表示 $k$ 可行。

时间复杂度：$O(n\log q\log 10^{12})$，这东西显然跑不满，所以能 比 较 快 地通过。

貌似正解是线性的，wtcl/kk

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long
#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 2e5 + 5, kInf = 1e18;

int n, q;
int a[kMaxN], w[kMaxN], mx[kMaxN], mi[kMaxN], ml[kMaxN], mr[kMaxN];

bool checkl(int x, int kk) {
  int L = -1, R = q + 1, res = kInf;
  while (L + 1 < R) {
    int mid = (L + R) >> 1;
    if (mi[mid] <= kk - a[x]) R = res = mid;
    else L = mid;
  }
  if (res == kInf) return 0;
  if (a[x - 1] + mx[res] > kk) return 0;
  else return 1;
}

int getl(int x) {
  int L = a[x - 1] - 1, R = a[x] + 1, res = a[x];
  while (L + 1 < R) {
    int mid = (L + R) >> 1;
    if (checkl(x, mid)) R = res = mid;
    else L = mid;
  }
  return res;
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  cin >> n >> q;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
  }
  a[0] = -kInf, a[n + 1] = kInf;
  int cur = 0;
  for (int i = 1; i <= q; ++i) {
    cin >> w[i]; cur += w[i];
    mx[i] = max(mx[i - 1], cur), mi[i] = min(mi[i - 1], cur);
  }
  for (int i = 1; i <= n; ++i) {
    ml[i] = getl(i);
  }
  ml[n + 1] = kInf;
  for (int i = 1; i <= n; ++i) {
    mr[i] = min(ml[i + 1], a[i] + mx[q]);
    cout << mr[i] - ml[i] << endl;
  }
  return summary, 0;
}
```

</details>

## T3 [JOISC2020] 首都

### Description

[link](https://www.luogu.com.cn/problem/P7215)

### Solution

前置知识：[线段树优化建图](https://www.cnblogs.com/maoyiting/p/13764109.html#/cnblog/works/article/13764109)，树链剖分，强连通分量，缩点。

首先如果城市 $i$ 里的城镇之间需要经过城市 $j$ 里的城镇，那么就连一条 $i\to j$ 的有向边，表示如果选城市 $i$ 作为首都，那么需要把 $j$ 合并在一起。把这个有向图缩点后，答案就是出度为 $0$ 的点 $sz-1$ 的最小值。
因为如果出度不是 $0$，那么这个点与它连出的所有点都要合并，而那些连出的点又要和它连出的点合并，直到到达出度为 $0$ 的点，所以直接选择出度为 $0$ 的点最为划算。

然后直接建图是 $O(n^2)$ 的，时间和空间都过不了，直接线段树优化建图即可，那么就是 $O(n\log n)$ 的了。

时间复杂度：$O(n\log n)$，瓶颈在建图上。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 1e6 + 5;

struct Node {
  int l, r, ls, rs;
} tr[kMaxN];

int n, k, base, rt, cnt, tot, scccnt, ans;
int col[kMaxN];
int a[kMaxN]; // 线段树
int sz[kMaxN], wson[kMaxN], top[kMaxN], fa[kMaxN], dep[kMaxN], idx[kMaxN], rev[kMaxN]; // 树链剖分
int scc[kMaxN], ins[kMaxN], dfn[kMaxN], low[kMaxN], siz[kMaxN], deg[kMaxN];
stack<int> stk; // Tarjan
vector<int> g[kMaxN], G[kMaxN], v[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

/* ----- 树链剖分 ----- */

void dfs1(int u, int fat) {
  sz[u] = 1, fa[u] = fat, dep[u] = dep[fat] + 1;
  for (auto v : g[u]) {
    if (v == fat) continue ;
    dfs1(v, u), sz[u] += sz[v];
    if (sz[v] > sz[wson[u]]) {
      wson[u] = v;
    }
  }
}

void dfs2(int u, int fat, int t) {
  top[u] = t, idx[u] = ++cnt, rev[cnt] = u;
  if (!wson[u]) return ;
  dfs2(wson[u], u, t);
  for (auto v : g[u]) {
    if (v == fat || v == wson[u]) continue ;
    dfs2(v, u, v);
  }
}

int LCA(int u, int v) {
  while (top[u] != top[v]) {
    if (dep[top[u]] < dep[top[v]]) swap(u, v);
    u = fa[top[u]];
  }
  if (dep[u] < dep[v]) swap(u, v);
  return v;
}

/* ----- 树链剖分 ----- */

/* ----- 线段树 -----*/

int build(int x, int l, int r) {
  int nw = ++base;
  tr[nw].l = l, tr[nw].r = r;
  if (l == r) {
    return addE(nw, col[rev[l]]), nw;
  }
  int mid = (l + r) >> 1;
  tr[nw].ls = build(x << 1, l, mid), tr[nw].rs = build(x << 1 | 1, mid + 1, r);
  addE(nw, tr[nw].ls), addE(nw, tr[nw].rs);
  return nw;
}

void update(int x, int ql, int qr, int u) {
  int l = tr[x].l, r = tr[x].r;
  if (l > qr || r < ql) {
    return ;
  } else if (l >= ql && r <= qr) {
    return addE(u, x);
  }
  update(tr[x].ls, ql, qr, u), update(tr[x].rs, ql, qr, u);
}

void link(int u, int v) {
  int cl = col[u];
  while (top[u] != top[v]) {
    if (dep[top[u]] < dep[top[v]]) swap(u, v);
    update(rt, idx[top[u]], idx[u], cl);
    u = fa[top[u]];
  }
  if (dep[u] > dep[v]) swap(u, v);
  update(rt, idx[u], idx[v], cl);
}

/* ----- 线段树 -----*/

/* ----- Tarjan -----*/

void tarjan(int u) {
  dfn[u] = low[u] = ++tot, ins[u] = 1, stk.emplace(u);
  for (auto v : G[u]) {
    if (!dfn[v]) {
      tarjan(v), low[u] = min(low[u], low[v]);
    } else if (ins[v]) {
      low[u] = min(low[u], dfn[v]);
    }
  }
  if (low[u] == dfn[u]) {
    ++scccnt;
    while (!stk.empty()) {
      int tp = stk.top(); stk.pop();
      ins[tp] = 0, scc[tp] = scccnt;
      if (tp == u) break ;
    }
  }
}

/* ----- Tarjan -----*/

/* ---------- Line ---------- */

bool m_ed;

int main() {
  cin >> n >> k; base = k;
  for (int i = 1, u, v; i < n; ++i) {
    cin >> u >> v;
    g[u].emplace_back(v), g[v].emplace_back(u);
  }
  for (int i = 1, c; i <= n; ++i) {
    cin >> c;
    col[i] = c;
    v[c].emplace_back(i);
  }
  dfs1(1, 0), dfs2(1, 0, 1);
  rt = build(1, 1, n);
  for (int i = 1; i <= k; ++i) {
    if (v[i].size() <= 1) continue ;
    int s = v[i][0], tp = -1, nw = 1e9;
    for (int j = 1; j < (int)v[i].size(); ++j) {
      int t = v[i][j], lca = LCA(s, t);
      if (lca != t) link(t, lca);
      if (dep[lca] < nw) nw = dep[lca], tp = lca;
    }
    if (~tp && tp != s) link(s, tp);
  }
  for (int i = 1; i <= base; ++i) {
    if (!dfn[i]) {
      tarjan(i);
    }
  }
  for (int i = 1; i <= k; ++i) {
    ++siz[scc[i]];
  }
  for (int i = 1; i <= base; ++i) {
    for (auto v : G[i]) {
      if (scc[i] != scc[v]) ++deg[scc[i]];
    }
  }
  ans = 2e9;
  for (int i = 1; i <= k; ++i) {
    if (!deg[scc[i]]) {
      ans = min(ans, siz[scc[i]] - 1);
    }
  }
  cout << ans << endl;
  return summary, 0;
}
```

</details>

## T4 [JOI2018] Snake Escaping

不会。