---
title: 20240906 模拟赛 T3 题解
date: 2024-09-06 20:54:00
---

## Description

你有 $2n$ 个点和 $m$ 条边，每个点 $i$ 对应着一组 $m+1$ 个整数 $p_{i,0},p_{i,1},\ldots,p_{i,m}$，表示当点 $i$ 的度数为 $j$ 时会带来 $p_{i,j}$ 的代价。

你需要求出一张左边为点 $1\sim n$，右边为点 $n+1\sim 2n$，边数恰为 $m$ 的二分图，满足所有点的代价之和最小，且这张二分图的最大匹配数在 $[l,r]$ 之间。

**数据保证有解**。

你只需要输出最小代价和。

$1\leq n,m\leq 40,0\leq l\leq r\leq n,|p_{i,j}|\leq 10^9$。

## Solution

假设没有最大匹配的限制就只要让左右的点的度数之和均为 $m$ 即可，考虑怎么更好地表示最大匹配。

容易发现可以将最大匹配转化为最小点覆盖。

设 $L$ 表示左部点度数不为 $0$ 的点集，$R$ 表示右部点度数不为 $0$ 的点集，最大匹配为 $x$。

结论是最大匹配为 $x$ 等价于存在左部点集合 $P$，右部点集合 $Q$，满足 $|P|+|Q|=x$，$L-P$ 与 $R-Q$ 无连边，且 $P$ 与 $R-Q$ 存在大小为 $|P|$ 的匹配，$Q$ 与 $L-P$ 存在大小为 $|Q|$ 的匹配。

证明就考虑如果满足这个条件，最大匹配一定不小于 $|P|+|Q|=x$。并且由于 $L-P$ 和 $R-Q$ 没有连边，所以最大匹配不超过 $x$，于是最大匹配就是 $x$。

如果最大匹配为 $x$，则令最大独立集的左部点为 $L-P$，右部点为 $R-Q$，容易发现此时的 $P$ 和 $Q$ 一定满足条件。

基于这个结论就可以设计 dp 了。设 $f_{i,j,k,w}$ 表示 $P$ 的点数为 $i$，$L-P$ 的点数为 $j$，$P$ 的度数和为 $k$，$L-P$ 的度数和为 $w$ 的最小权值和，$g_{i,j,k,w}$ 表示右边的，这两个容易 dp 求出。

那么 $f_{i_1,j_1,k_1,m-k_1}+g_{i_2,j_2,k_2,m-k_2}$ 能对答案造成贡献，等价于 $l\leq i_1+i_2\leq r,i_1\geq j_2,i_2\geq j_1,k_1\geq m-k_2,k_2\geq m-k_1$，判断一下即可。

时间复杂度：$O(n^3m^3+n^4m^2)$。

## Code

```cpp
#include <bits/stdc++.h>

#define int int64_t

const int kMaxN = 45;

int n, m, l, r;
int a[kMaxN][kMaxN], b[kMaxN][kMaxN], f[kMaxN][kMaxN][kMaxN][kMaxN], g[kMaxN][kMaxN][kMaxN][kMaxN];

void dickdreamer() {
  std::cin >> n >> m >> l >> r;
  for (int i = 1; i <= n; ++i)
    for (int j = 0; j <= m; ++j)
      std::cin >> a[i][j];
  for (int i = 1; i <= n; ++i)
    for (int j = 0; j <= m; ++j)
      std::cin >> b[i][j];
  memset(f, 0x3f, sizeof(f)), memset(g, 0x3f, sizeof(g));
  f[0][0][0][0] = g[0][0][0][0] = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = i - 1; ~j; --j) {
      for (int k = i - 1 - j; ~k; --k) {
        for (int dj = m; ~dj; --dj) {
          for (int dk = m - dj; ~dk; --dk) {
            for (int d = 1; d <= m - dj - dk; ++d) {
              f[j + 1][k][dj + d][dk] = std::min(f[j + 1][k][dj + d][dk], f[j][k][dj][dk] + a[i][d]);
              f[j][k + 1][dj][dk + d] = std::min(f[j][k + 1][dj][dk + d], f[j][k][dj][dk] + a[i][d]);
              g[j + 1][k][dj + d][dk] = std::min(g[j + 1][k][dj + d][dk], g[j][k][dj][dk] + b[i][d]);
              g[j][k + 1][dj][dk + d] = std::min(g[j][k + 1][dj][dk + d], g[j][k][dj][dk] + b[i][d]);
            }
            f[j][k][dj][dk] += a[i][0];
            g[j][k][dj][dk] += b[i][0];
          }
        }
      }
    }
  }
  int ans = 1e18;
  for (int i = 0; i <= n; ++i) {
    for (int j = 0; j <= n; ++j) {
      if (i + j < l || i + j > r) continue;
      for (int k = j; k <= n - i; ++k)
        for (int w = i; w <= n - j; ++w)
          for (int di = 0; di <= m; ++di)
            for (int dj = m - di; dj <= m; ++dj)
              ans = std::min(ans, f[i][k][di][m - di] + g[j][w][dj][m - dj]);
    }
  }
  std::cout << ans << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```