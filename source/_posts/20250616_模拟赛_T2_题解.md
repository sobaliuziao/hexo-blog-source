---
title: 20250616 模拟赛 T2 题解
date: 2025-06-16 18:05:00
---

## Description

有 $m$ 个元素（$m$ 是奇数）排成一排，每个元素有一个非负整数编号。

每个时刻，某三个相邻的元素会发生**反应**，每次**反应**会把这三个元素合并，合并之后的元素的编号是原来三个元素编号的中位数。例如，编号为 $1,1,4$ 的元素合并会生成一个编号为 $1$ 的元素，而编号为 $5,1,4$ 的元素合并会生成一个编号为 $4$ 的元素。

法师 $\text{bot}$ 认为，编号越大的元素价值越大，所以他想知道这排元素反应完全结束（只剩余一个元素）后，剩下的这一个元素预期的编号。

$\text{bot}$ 并不懂数学期望，因此他只想知道这个编号的最大值。

$\text{bot}$ 对这个问题产生了更大的兴趣。具体地，他有 $n$ 个元素排成一排，他有很多个问题，每个问题是：区间 $[l,r]$ 内的元素（保证区间的长度是奇数）不断反应，可能生成的元素编号的最大值是多少？

$1\le n\le 2^{20}$，$1\le q\le 2^{22}$，$0\le a_i\le n$，$1\le l\le r\le n$。

保证 $r-l \equiv 0 \pmod 2$。

## Solution

首先有个很显然的想法是转为 $01$ 问题。

注意到如果存在长度不小于 $3$ 的 $1$ 连续段就一定可以合出来 $1$。

同时经过手玩，如果存在两个长度为 $2$ 的连续段，且它们之间的距离是奇数也合法。

给出结论：在整个序列开头和末尾各添加一个 $1$ 后，如果存在 $i,j$ 满足 $a_i=a_{i+1}=a_j=a_{j+1}=1$ 且 $j-i\equiv 1\pmod 2$ 就一定合法，否则不合法。

证明就考虑如果满足这个条件，将其余位置都看成 $0$ 后只有如下几种情况：$101,10110,11011,01101$。这些显然都合法。

对于必要性，就考虑进行归纳证明。假设长度为 $n-2$ 的序列都满足了条件，那么将 $0$ 替换成 $000,001,010,100$ 显然不会影响其余位置的奇偶性。将 $1$ 替换成 $111,110,101,011$ 后，原先合法的一定满足这个条件。

这个东西容易把 $01$ 去掉，用 ST 表维护即可。

时间复杂度：$O(n\log n+q)$。

## Code

```cpp
// g++ -std=c++14 -O2 -fsanitize=address,undefined -o element element.cpp && ./element
#include <bits/stdc++.h>

// #define int int64_t

using u32 = unsigned;

const int kMaxN = (1 << 20) + 5, kMaxQ = (1 << 22) + 5;

int n, m, q; u32 seed;
int a[kMaxN], res[kMaxQ], f[kMaxN][20][2][2];

void chkmin(int &x, int y) { x = (x < y ? x : y); }
void chkmax(int &x, int y) { x = (x > y ? x : y); }

u32 _rnd(u32 &_SEED){
  _SEED ^= _SEED << 7;
  _SEED ^= _SEED >> 15;
  _SEED ^= _SEED << 9;
  return _SEED;
}
void gen(const int &_N, u32 &_SEED, int &l, int &r){
  int len = _rnd(_SEED) % ((_N + 1) / 2) * 2;
  l = _rnd(_SEED) % (_N - len) + 1;
  r = l + len;
}

void prework() {
  for (int i = 1; i <= n; ++i) {
    f[i][0][i & 1][i & 1] = std::min(a[i], a[i + 1]);
  }
  for (int i = 1; i <= std::__lg(n); ++i) {
    for (int j = 1; j <= n - (1 << i) + 1; ++j) {
      for (int o = 0; o < 2; ++o) {
        f[j][i][o][o] = std::max(f[j][i - 1][o][o], f[j + (1 << (i - 1))][i - 1][o][o]);
        f[j][i][o][o ^ 1] = std::max({f[j][i - 1][o][o ^ 1], f[j + (1 << (i - 1))][i - 1][o][o ^ 1], std::min(f[j][i - 1][o][o], f[j + (1 << (i - 1))][i - 1][o ^ 1][o ^ 1])});
      }
    }
  }
}

int query1(int l, int r, int o) {
  if (l > r) return 0;
  int k = std::__lg(r - l + 1);
  return std::max(f[l][k][o][o], f[r - (1 << k) + 1][k][o][o]);
}

int query2(int l, int r, int o) {
  if (l > r) return 0;
  int k = std::__lg(r - l + 1);
  return std::max({f[l][k][o][o ^ 1], f[r - (1 << k) + 1][k][o][o ^ 1], std::min(query1(l, r - (1 << k), o), query1(l + (1 << k), r, o ^ 1))});
}

int query(int l, int r) {
  int o = (~l & 1);
  return std::max({query2(l, r - 1, o), std::min(a[l], query1(l, r - 1, o ^ 1)), std::min(query1(l, r - 1, o), a[r]), std::min(a[l], a[r])});
}

void dickdreamer() {
  std::cin >> n >> q;
  for (int i = 1; i <= n; ++i) std::cin >> a[i];
  prework();
  std::cin >> seed;
  u32 ans = 0;
  for (int i = 1; i <= q; ++i) {
    int l, r;
    gen(n, seed, l, r);
    ans += (u32)i * query(l, r);
    // std::cerr << query(l, r) << '\n';
  }
  std::cout << ans << '\n';
}

int32_t main() {
  freopen("element.in", "r", stdin);
  freopen("element.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```