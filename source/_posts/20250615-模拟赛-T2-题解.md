---
title: '20250615 模拟赛 T2 题解'
date: 2025-06-15 20:51:00
---

## Description

小 T 创建存档时，得知了这个存档的地图：地图上有 $n$ 个格子，被 $n-1$ 条边连通，构成一棵树。地图上共有 $n$ 只怪物，第 $i$ 只怪物在编号为 $i$ 的格子上。在开始游戏前，小 T 可以选中一个连通块，然后清除这个连通块上的怪物，并获得相应的增益。

具体地，小 T 有两种属性，攻击力与怒气值，初始均为 $0$。第 $i$ 个怪如果在连通块内，就会给小 T 增加 $a_i$ 点攻击力以及 $b_i$ 点怒气值。此外，第 $i$ 只怪物有 $c_i$ 点血量。小 T 在清除怪物后，还会获得一定量的金币。设 $A$ 为小 T 最终的攻击力，$B$ 为小 T 最终的怒气值，$C$ 为清除的怪物血量之和，那么小 T 会获得 $AB-C$ 个金币。

由于金币在这个游戏中很重要，所以小 T 想知道如何能获得最多的金币。小 T 也可以选择直接跳过这个游戏前的阶段，那么他会获得 $0$ 个金币。

（注：最终的攻击力 $A$ 即为所有选中怪物的 $a_i$ 之和，$B,C$ 同理）

小 T 会重开很多个档，所以本题有多组询问。

$T\leq 5,n\leq 2000$。

## Solution

先考虑没有连通块限制怎么做。

设 $x_i$ 表示 $i$ 选或者不选，选则为 $1$，否则为 $0$，题目相当于是要最大化 $\displaystyle\sum_i\sum_j a_ib_jx_ix_j-\sum_i c_ix_i$。

注意到这个东西没有什么性质，但是长得很像最小割的代数形式，所以考虑用最小割做。

先取反，变为最小化 $\displaystyle-\sum_i\sum_j a_ib_jx_ix_j+\sum_i c_ix_i$。

由于 $-a_ib_jx_ix_j$ 这个东西不能直接割，先写成 $a_ib_jx_i\overline{x_j}-a_ib_jx_i$，变为：

$$
\begin{aligned}
&\sum_i\sum_j a_ib_j(x_i\overline{x_j}-x_i)+\sum_i c_ix_i\\
=&\sum_i\sum_j a_ib_jx_i\overline{x_j}-\sum_i a_ix_i\sum_j b_j+\sum_i c_ix_i
\end{aligned}
$$

这是一个标准的最小割的形式，直接建图跑网络流即可。

加上连通块限制后，就先点分治，钦定根必须选，现在相当于是不能出现 $x_i=1,x_{p_i}=0$ 的情况，式子里加入 $+\infty\cdot x_i\overline{x_{p_i}}$ 即可。

可能会卡常，解决办法是在跑网络流时用邻接矩阵存图，这样访问就连续了。

时间复杂度：$O(n^2\sqrt n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

#define int int64_t

const int kMaxN = 2e3 + 5;

int n, rt, ans;
int a[kMaxN], b[kMaxN], c[kMaxN];
int sz[kMaxN], mx[kMaxN], p[kMaxN];
bool del[kMaxN], res[kMaxN];
std::vector<int> G[kMaxN], vec;

namespace Dinic {
const int kMaxN = 4e3 + 5;

int n, s, t, tot, dep[kMaxN], e[kMaxN][kMaxN], cur[kMaxN];

void adde(int u, int v, int w) { e[u][v] += w; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

void init(int _n, int _s, int _t) {
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j)
      e[i][j] = 0;
  tot = 1, n = _n, s = _s, t = _t;
}

bool bfs() {
  for (int i = 1; i <= n; ++i)
    dep[i] = 1e9, cur[i] = 1;
  std::queue<int> q;
  q.emplace(s), dep[s] = 0;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    if (u == t) return 1;
    for (int v = 1; v <= n; ++v) {
      int w = e[u][v];
      if (w && dep[v] == 1e9) {
        dep[v] = dep[u] + 1, q.emplace(v);
      }
    }
  }
  return 0;
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &i = cur[u]; i <= n; ++i) {
    int v = i, w = e[u][v];
    if (w && dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = 1e9;
      e[u][v] -= fl, e[v][u] += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

int maxflow() {
  int ans = 0;
  for (; bfs(); ans += dfs(s, 1e18)) {}
  return ans;
}
} // namespace Dinic

void getsz(int u, int fa) {
  sz[u] = 1, mx[u] = 0;
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    getsz(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
  }
}

void getrt(int u, int fa, int tot) {
  mx[u] = std::max(mx[u], tot - sz[u]);
  if (mx[u] < mx[rt]) rt = u;
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    getrt(v, u, tot);
  }
}

void dfs2(int u, int fa) {
  p[u] = fa, vec.emplace_back(u);
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    dfs2(v, u);
  }
}

void solve(std::vector<int> &id) {
  int m = id.size();
  id.emplace_back(0), std::reverse(id.begin(), id.end());
  int s = m + 1, t = s + 1, A = 0, B = 0;
  Dinic::init(t, s, t);
  for (auto x : id) A += a[x], B += b[x];
  for (int i = 1; i <= m; ++i) {
    int x = id[i];
    Dinic::add(s, i, a[x] * B);
    Dinic::add(i, t, c[x]);
    for (int j = 1; j <= m; ++j) {
      int y = id[j];
      if (i != j) Dinic::add(i, j, a[x] * b[y]);
      if (y == p[x]) Dinic::add(i, j, 1e15);
    }
  }
  // std::cerr << id.size() << ' ' << A << ' ' << B << '\n';
  int val = A * B - Dinic::maxflow();
  // std::cerr << val << '\n';
  if (val > ans) {
    ans = val;
    for (int i = 1; i <= n; ++i) res[i] = 0;
    for (int i = 1; i <= m; ++i) {
      if (Dinic::dep[i] != 1e9) res[id[i]] = 1;
    }
  }
}

void dfs1(int u) {
  // std::cerr << sz[u] << ' ' << mx[u] << '\n';
  vec.clear(), dfs2(u, 0);
  solve(vec);
  del[u] = 1;
  for (auto v : G[u]) {
    if (del[v]) continue;
    rt = 0, getsz(v, 0), getrt(v, 0, sz[v]), dfs1(rt);
  }
}

void dickdreamer() {
  std::cin >> n;
  ans = 0;
  for (int i = 1; i <= n; ++i) G[i].clear(), res[i] = del[i] = 0;
  for (int i = 1; i <= n; ++i) std::cin >> a[i] >> b[i] >> c[i];
  for (int i = 1; i < n; ++i) {
    int u, v;
    std::cin >> u >> v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  mx[rt = 0] = 1e9, getsz(1, 0), getrt(1, 0, n), dfs1(rt);
  std::cout << ans << '\n';
  for (int i = 1; i <= n; ++i) std::cout << res[i];
  std::cout << '\n';
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```