---
title: 20240627 模拟赛 T2 题解
date: 2024-06-27 20:04:00
---

## Description

给定一个包含 $n$ 个排列的序列 $x_1,x_2,\cdots,x_n$，排列 $x_i$ 是由 $1\sim m $ 的整数组成的。

你需要找到一个 $1\sim n$ 的排列 $p_1,p_2,\cdots,p_n$。令 $y_i=x_{p_i}$，则 $y_1,y_2,\cdots,y_n$ 满足如下性质：

对于任意 $1\le i<j<k\le n$ 和 $1\le a,b\le m$，如果 $a$ 在排列 $y_i$ 和 $y_k$ 的位置都在 $b$ 之前，那么 $a$ 在 $y_j$ 也在 $b$ 之前出现。（直观上，任意 $a,b$ 在排列中的相对顺序至多改变一次。）

$1 \leq T \leq 5,1 \leq n\times m \leq 10^6$。

## Solution

不妨设 $c(i,j)$ 表示 $x_i$ 与 $x_j$ 有多少对数顺序变化。

那么对于一个合法的排列，对于 $\forall 1\leq i\leq n$，必然满足 $c(p_1,p_i)\geq c(p_2,p_i)\geq\dots \geq c(p_i,p_i)\leq c(p_{i+1},p_i)\leq\dots\leq c(p_n,p_i)$。

所以任意选一个排列然后找到与其 $c$ 值最大的排列 $x_k$，则 $x_k$ 一定是可能的答案的开头。

找到开头后，容易发现只要对所有的 $c(x,i)$ 进行排序即可得到一组可能的答案，但是没法确定是否合法，需要进一步验证。

注意到对于 $1\leq a,b\leq m$ 和 $1\leq i<j<k\leq n$，如果排列合法，则 $\text{diff}_{a,b}(p_i,p_j)+\text{diff}_{a,b}(p_j,p_k)=\text{diff}_{a,b}(p_i,p_k)$，即 $c(p_i,p_j)+c(p_j,p_k)=c(p_i,p_k)$，所有的不合法排列一定存在 $i,j,k$ 不满足这个条件。

容易发现只要对于所有的 $i$，判断是否满足 $c(p_1,p_{i-1})+c(p_{i-1},p_i)=c(p_1,p_i)$ 即可。

时间复杂度：$O(nm\log n)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 1e6 + 5;

namespace FASTIO {
char ibuf[1 << 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
}
template<class T> bool read(T &x) {
  x = 0; int f = 0; char ch = getc();
  while (ch < '0' || ch > '9') f |= ch == '-', ch = getc();
  while (ch >= '0' && ch <= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template<typename A, typename ...B> bool read(A &x, B &...y) { return read(x) && read(y...); }
 
char obuf[1 << 21], *o1 = obuf, *o2 = obuf + (1 << 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template<class T> void write(T x) {
  if (!x) putc('0');
  if (x < 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) { while (*x) putc(*x++); }
void write(const char *x) { while (*x) putc(*x++); }
template<typename A, typename ...B> void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

int n, m;
int id[kMaxN];
int64_t val[kMaxN];
std::vector<std::vector<int>> a;

struct BIT {
  int c[kMaxN];

  void upd(int x, int v) {
    for (; x; x -= x & -x) c[x] += v;
  }
  int qry(int x) {
    int ret = 0;
    for (; x <= m; x += x & -x) ret += c[x];
    return ret;
  }
} bit;

int64_t calc(std::vector<int> &a, std::vector<int> &b) {
  static int c[kMaxN];
  for (int i = 1; i <= m; ++i) c[a[i]] = i;
  int64_t cnt = 0;
  for (int i = 1; i <= m; ++i) {
    cnt += bit.qry(c[b[i]]);
    bit.upd(c[b[i]], 1);
  }
  for (int i = 1; i <= m; ++i) bit.upd(c[b[i]], -1);
  return cnt;
}

void dickdreamer() {
  read(n, m);
  a.resize(n + 1);
  for (int i = 1; i <= n; ++i) {
    a[i].resize(m + 1);
    for (int j = 1; j <= m; ++j) read(a[i][j]);
  }
  int64_t mx = 0; int p = 1;
  for (int i = 2; i <= n; ++i) {
    int64_t val = calc(a[1], a[i]);
    if (val > mx) mx = val, p = i;
  }
  for (int i = 1; i <= n; ++i)
    id[i] = i, val[i] = calc(a[p], a[i]);
  std::sort(id + 1, id + 1 + n, [&] (int i, int j) { return val[i] < val[j]; });
  for (int i = 2; i <= n; ++i) {
    if (val[id[i - 1]] + calc(a[id[i - 1]], a[id[i]]) != val[id[i]])
      return write("-1\n");
  }
  for (int i = 1; i <= n; ++i) write(id[i], ' ');
  write('\n');
}

int32_t main() {
  freopen("perm.in", "r", stdin);
  freopen("perm.out", "w", stdout);
  int T = 1;
  read(T);
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```