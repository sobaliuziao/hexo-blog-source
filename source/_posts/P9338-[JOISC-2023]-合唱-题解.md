---
title: P9338 [JOISC 2023] 合唱 题解
date: 2025-02-16 16:24:00
---

---
title: P9338 [JOISC 2023] 合唱 题解
date: 2025-02-16 12:35:29
tags:
- 题解
- 洛谷
- JOISC
- DP
- 四边形不等式
categories:
- 题解
- 洛谷
---
## Description

在舞台上，有 $2N$ 只海狸排成一列。它们是合唱团的成员。每只海狸唱着高音部或低音部。这些信息由一个字符串 $S$ 给出。具体地，如果 $S$ 的第 $i$ 个字符是 $A$，编号为 $i$ 的海狸（从右边看台来看）唱高音。如果 $S$ 的第 $i$ 个字符是 $B$，编号为 $i$ 的海狸唱低音。有 $N$ 只海狸唱高音，有 $N$ 只海狸唱低音。

从现在起，这些海狸将要演唱 $K$ 首歌。然而，因为所有歌曲非常复杂，每只海狸只唱一首歌曲，不会唱其他歌曲。此外，为了使歌声更加美妙，每首歌曲必须满足以下条件：

+ 至少有一只海狸唱这首歌。

+ 唱这首歌的唱高音和唱低音的海狸数量应当相等。

+ 如果只考虑唱这首歌的海狸，所有唱高音的海狸都在唱低音的海狸的右边。

指挥家 Bitaro 想找到一种方案，给出哪些海狸唱哪首歌，满足以上所有条件。由于 Bitaro 特别聪明，他注意到这可能无法实现。为了应对这个问题，Bitaro 将交换相邻两只海狸的位置多次，以便有一种方式可以调配海狸，从而满足上述条件。

由于 Bitaro 认为效率很重要，所以他想最小化要执行的操作数。然而，这是一个非常困难的问题。由于您是一位出色的程序员，Bitaro 请求您解决此问题。

编写一份程序，在给出合唱与演唱歌曲数量 $K$ 的信息时，计算 Bitaro 需要执行的最小操作数。请注意，在本任务的限制下，可以执行操作多次，以便有一种方式可以在海狸之间分配歌曲，满足上述条件。

## Solution

首先由于每个方案都可以分裂，所以如果可以得到 $k$ 的方案，则 $>k$ 的方案也可以得到。那么题目可以转化为求让最小歌曲数 $\leq k$ 的最小操作次数。

考虑对于给定字符串，怎么求最小歌曲数。

容易发现一定是让第 $i$ 个 A 匹配第 $i$ 个 $B$。所以可以转化为存在 $n$ 个左右端点分别递增的区间，问将其划分成最少的互不相交的集合数，使得每个集合内的区间两两有交。

如果把一个区间完全在另一个区间的右边看成一个偏序关系，上面的东西就等价于最小反链覆盖，等于最长链。这样就得到一个比较优美的贪心。

然后就可以 dp 了。

设 $f_{i,l}$ 表示考虑了前 $i$ 个 A，目前的最长链为 $l$，且下一条链必须从 $i+1$ 开始的最小操作数，$c_i$ 表示原串第 $i$ 个 A 前的 B 的个数。

不妨设第 $i+1$ 个 B 位于第 $j$ 个 A 之后，则 $[i+1,j]$ 这些 A 的 $c$ 值都应该小于等于 $i$，而每次操作至多会让一个 $c_k\leftarrow c_k-1$，所以代价为：$\sum_{k=i+1}^{j}{\max\{c_k-i,0\}}$。可以得到转移方程：

$$
f_{i,l}=\min_{j<i}{\left\{f_{j,l-1}+\sum_{k=j+1}^{i}{\max\{c_k-j,0\}}\right\}}
$$

注意到 $cost(j,i)=\sum_{k=j+1}^{i}{\max\{c_k-j,0\}}$ 满足四边形不等式，所以 $f_{n,l}$ 是凸的，考虑 wqs 二分。

设 $nxt_i$ 表示最小的 $j$ 满足 $c_j\geq i$，那么如果 $nxt_j>i$，让 $j\to i$ 一定不优，因为 $j$ 往后多匹配几个一定不劣。

所以只需要考虑 $nxt_j\leq i$ 的情况，式子里的 $\max$ 就没了，凸包优化即可。

时间复杂度：$O(n\log n\log V)$。

## Code

```cpp
#include <bits/stdc++.h>

#define int int64_t

using i128 = __int128_t;
using pii = std::pair<int, int>;

const int kMaxN = 1e6 + 5;

int n, k;
int c[kMaxN], sumc[kMaxN], nxt[kMaxN];
int f[kMaxN], g[kMaxN], a[kMaxN], b[kMaxN];
std::string s;

pii sub(pii a, pii b) { return {a.first - b.first, a.second - b.second}; }
i128 mul(pii a, pii b) { return (i128)a.first * b.second - (i128)a.second * b.first; }

void prework() {
  int cnta = 0, cntb = 0;
  for (int i = 1; i <= 2 * n; ++i) {
    if (s[i] == 'A') c[++cnta] = cntb;
    else ++cntb;
  }
  for (int i = 1; i <= n; ++i) sumc[i] = sumc[i - 1] + c[i];
  for (int i = 1, j = 0; i <= n; ++i) {
    for (; j < n && c[j + 1] < i; ++j) {}
    nxt[i] = std::max(i, j);
  }
}

void add(pii *stk, int &top, pii p) {
  for (; top >= 2 && mul(sub(p, stk[top]), sub(stk[top], stk[top - 1])) >= 0; --top) {}
  stk[++top] = p;
}

int calc(pii p, int x) { return x * p.first + p.second; }

std::pair<int, int> check(int x) {
  static int id[kMaxN];
  static pii stk[kMaxN];
  int top = 0;
  for (int i = 1, lst = -1; i <= n; ++i) {
    int now = std::min(i - 1, c[i]);
    for (; lst < now; ++lst, add(stk, top, {a[lst], b[lst]}), id[top] = lst) {}
    f[i] = 1e18, g[i] = 1e18;
    int L = 1, R = top + 1, res = 1;
    while (L + 1 < R) {
      int mid = (L + R) >> 1;
      if (calc(stk[mid], -i) < calc(stk[mid - 1], -i)) L = res = mid;
      else R = mid;
    }
    int j = id[res];
    f[i] = -i * a[j] + b[j] + sumc[i] - x, g[i] = g[j] + 1;
    a[i] = i, b[i] = f[i] - sumc[nxt[i]] + i * nxt[i];
  }
  return {f[n], g[n]};
}

void dickdreamer() {
  std::cin >> n >> k >> s;
  s = " " + s;
  prework();
  int L = -1e12, R = 1, res = 1;
  while (L + 1 < R) {
    int mid = (L + R) >> 1;
    if (check(mid).second <= k) L = res = mid;
    else R = mid;
  }
  auto p = check(res);
  std::cout << p.first + res * k << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```