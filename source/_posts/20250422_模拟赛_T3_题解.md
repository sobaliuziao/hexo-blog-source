---
title: 20250422 模拟赛 T3 题解
date: 2025-04-22 21:32:00
---

## Description

小 L 邀请了 $m$ 个朋友来家里游玩。为方便描述，我们把小 L 的 $m$ 个朋友编号 $1$ 到 $m$。小 L 准备了 $n$ 块饼干招待朋友们，编号 $1$ 到 $n$。饼干 $i$ 的甜度为 $a_i$。

小 L 的朋友们知道小 L 喜欢饼干，所以朋友 $j$ 会带来一块甜味为 $b_j$ 的饼干。每个朋友有一个偏好的口味，可以用一个长为 $m$ 的字符串 $s$ 表示。若 $s_j=S$ 表示朋友 $j$ 喜爱甜的饼干；若 $s_j=B$ 表示朋友 $j$ 喜爱苦的饼干。

一开始，小 L 会选择一个整数 $k$，将饼干 $1,2,...,k$ 放在桌上用来招待朋友。然后朋友 $1,2,...,m$ 依次到达家里。当朋友 $j$ 到达时，会将带来的饼干送给小 L ，而小 L 会慷慨地将这块饼干也放到桌上。接着朋友 $j$ 会在桌上的饼干中（包括朋友 $j$ 带来的）找到最甜或最苦的吃掉（取决于其口味），甜度越高
的饼干越甜，反之则越苦。最后小 L 会将桌上剩下的饼干吃掉。

小 L 忙着给朋友们制订游玩计划，所以想请你帮她求出对于每个 $k=1,2,...,n$，她最后吃掉的饼干的甜味度之和 $f_k$。

$n,m\leq 2\times 10^5$，强制在线。

## Solution

首先有个很厉害的转化是设 $B_i$ 表示第 $i$ 个客人吃到的饼干甜度，每次初始新加入一个甜度为 $v$ 的饼干，则只需要做下面的操作：从小到大枚举 $i$，如果 $s_i=\texttt{S}$ 且 $B_i<v$ 或者 $s_i=\texttt{B}$ 且 $B_i>v$，则交换 $v$ 和 $B_i$。最后的 $v$ 就是主人新吃的饼干。

可以感性理解主人吃掉的饼干每次只会新增，而不会改变原来吃掉的。

然后就可以得到一个跟 $s$ 极长连续段数有关的做法：对于一个 $\texttt{S}$ 连续段，维护小根堆表示这个连续段的 $B_i$ 构成的集合，$\texttt{B}$ 连续段维护大根堆，由于每个段只会修改至多 $1$ 个元素，判断栈顶能否替换即可。

正解是对于相邻的两个连续段，前一个维护的小根堆 $q_1$，后一个是大根堆 $q_2$，如果 $q_1.\text{top}>q_2.\text{top}$，则由于一个 $v$ 在这两段内只会至多修改一次，可以将两段交换，这样连续段数会减少。可以证明暴力做是 $O((n+m)\log^2m)$。

证明见[官方题解](https://codeforces.com/gym/102586/attachments/download/24124/gp_of_tokyo_editorial.pdf)。

时间复杂度：$O((n+m)\log^2m)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 2e5 + 5;

struct Node {
  int op;
  std::priority_queue<int> q;
} t[kMaxN];

int n, m, tp, now;
int a[kMaxN], b[kMaxN], pre[kMaxN], nxt[kMaxN];
i64 f[kMaxN];
std::string str;

void fix() {
  for (int i = nxt[0]; i != m + 1; i = nxt[i]) {
    if (nxt[i] == m + 1) break;
    if (t[i].op == 1 && -t[i].q.top() >= t[nxt[i]].q.top()) {
      int j = nxt[i], x = pre[i], y = nxt[nxt[i]];
      nxt[x] = j, pre[j] = x;
      nxt[j] = i, pre[i] = j;
      nxt[i] = y, pre[y] = i;
      i = nxt[i];
    }
  }
  for (int i = nxt[0]; i != m + 1; i = nxt[i]) {
    if (nxt[i] == m + 1) break;
    if (t[i].op == t[nxt[i]].op) {
      if (t[i].q.size() < t[nxt[i]].q.size()) t[i].q.swap(t[nxt[i]].q);
      for (; !t[nxt[i]].q.empty(); t[nxt[i]].q.pop()) t[i].q.emplace(t[nxt[i]].q.top());
      --now;
      int j = nxt[nxt[i]];
      nxt[i] = j, pre[j] = i;
    }
  }
}

int solve(int v) {
  for (int i = nxt[0]; i != m + 1; i = nxt[i]) {
    if (t[i].op == 1) {
      int val = -t[i].q.top();
      if (val < v) t[i].q.pop(), t[i].q.emplace(-v), v = val;
    } else {
      int val = t[i].q.top();
      if (val > v) t[i].q.pop(), t[i].q.emplace(v), v = val;
    }
  }
  fix();
  return v;
}

void dickdreamer() {
  std::cin >> n >> tp;
  for (int i = 1; i <= n; ++i) std::cin >> a[i];
  std::cin >> m; now = m;
  for (int i = 1; i <= m; ++i) std::cin >> b[i];
  std::cin >> str; str = " " + str;
  nxt[0] = 1, pre[m + 1] = m, nxt[m + 1] = m + 1;
  for (int i = 1; i <= m; ++i) {
    pre[i] = i - 1, nxt[i] = i + 1;
    if (str[i] == 'S') { // 小根堆
      t[i].op = 1, t[i].q.emplace(-b[i]);
    } else {
      t[i].op = 2, t[i].q.emplace(b[i]);
    }
  }
  fix();
  for (int i = 1; i <= n; ++i) {
    a[i] = (a[i] + tp * f[i - 1]) % 1000000000;
    f[i] = f[i - 1] + solve(a[i]);
    std::cout << f[i] << ' ';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```