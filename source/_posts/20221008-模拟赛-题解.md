---
title: 20221008 模拟赛 题解
date: 2022-10-08 18:46:00
---

[problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/jomufkyv)
[官方solution](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/tk5tbz7o)

## T1

### Description

[link](https://hydro.ac/d/bzoj/p/2717)

### Solution

神仙构造题。

第一问：任意两个人之间要站岗 $3$ 次，所以总共有 $C_{n}^{2}\times 3$ 次，而每一天能贡献 $3$ 次，所以最多 $C_{n}^{2}$ 天。

---

第二问：将这 $n$ 排到一个圆环上，那么对于每个 $1\leq s\leq \dfrac{n-1}{2}$ 的 $s$，和所有的人，和其编号加 $s$ 以及编号加 $2\times s$ 站一天岗。

首先，这个肯定是能站满 $n\times\dfrac{n-1}{2}$ 天。并且对于每两个人 $x$ 和 $y$，令 $k=\dfrac{y-x}{2}$，可以容易知道能站如下 $2$ 天：$(x,x+k,y)$,$(y,y+\dfrac{n-1}{2}-k,x)$。

并且如果 $y-x>\dfrac{n-1}{2}$，那么就站 $y,y+\dfrac{n-1}{2}-k,x$。否则就站 $x,y,2\times y-x$。

首先能想到这个肯定要先求出第一问，然后题目要构造的是对称的，所以能想到一种等差数列的构造方法。但是，这非常的神仙。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 1
#endif

using namespace std;

const int kMaxN = 1005;

int n, ans;
int cnt[kMaxN][kMaxN];

int get(int x) {
  return (x - 1) % n + 1;
}

int main() {
  freopen("rabbit.in", "r", stdin);
  freopen("rabbit.out", "w", stdout);
  cin >> n;
  ans = n * (n - 1) / 2;
  cout << ans << endl;
  for (int s = 1; s <= n / 2; ++s) {
    for (int i = 1; i <= n; ++i) {
      cout << i << ' ' << get(i + s) << ' ' << get(i + 2 * s) << endl;
    }
  }
  return 0;
}
```

</details>

## T2

### Description

[link](https://hydro.ac/d/bzoj/p/2718)

### Solution

首先看到任意两个选的点都不能互相走到，那么我们就可以先对于每一个点，然后跑 dfs，求出这个点不能与哪些点同时选并连边。那么题目就转化为：在一个 $n$ 个点的图里，求它的最大独立集。但是这是个 NP，不可做。

考虑到二分图的最大独立集是可做的，那么就可以直接把每个点拆成两个点，并建一个二分图，那么答案就是 $n-$ 最大匹配。

## T3

### Description

[link](https://hydro.ac/d/bzoj/p/2719)

### Solution

看到第一个操作，如果两个点的横坐标和纵坐标都模 $3$ 同余，那么这两个点就可以看作是等价的，所以搞个数组记一下就可以了。

考虑到 $k\leq 10$ 所以直接暴力搜索就行，是 $O(k!)$ 的，跑的飞快。

注意：当 $n$ 和 $m$ 很小时注意特判。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#ifdef ORZXKR
#include <debug.h>
#else
#define debug(...) 1
#endif

using namespace std;

const int kMaxN = 105, dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, -1, 1, -1, 1};

struct Node {
  int c[3][3];

  Node() {
    for (int i = 0; i < 3; ++i) {
      for (int j = 0; j < 3; ++j) {
        c[i][j] = 0;
      }
    }
  }

  friend bool operator < (const Node& n1, const Node& n2) {
    for (int i = 0; i < 3; ++i) {
      for (int j = 0; j < 3; ++j) {
        if (n1.c[i][j] != n2.c[i][j]) return n1.c[i][j] < n2.c[i][j];
      }
    }
    return 0;
  }

  void init() {
    for (int i = 0; i < 3; ++i) {
      for (int j = 0; j < 3; ++j) {
        c[i][j] = 0;
      }
    }
  }
} st;

int k, n, m, sx, sy, cnt;
bool fl;
map<Node, bool> mp;

void check() {
  // st.print();
  if (st.c[sx % 3][sy % 3]) {
    fl = 1;
  }
}

int mod(int x) {
  return (x + 3) % 3;
}

void dfs(int x) {
  if (cnt == 1) {
    return check();
  }
  if (fl || mp[st]) return ;
  mp[st] = 1;
  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      for (int k = 0; k < 8; ++k) {
        int ti2 = mod(i + 2 * dx[k]), tj2 = mod(j + 2 * dy[k]), ti1 = mod(i + dx[k]), tj1 = mod(j + dy[k]);
        if (!st.c[i][j] || !st.c[ti1][tj1]) continue ;
        --st.c[i][j], --st.c[ti1][tj1], ++st.c[ti2][tj2], --cnt;
        dfs(x + 1);
        ++st.c[i][j], ++st.c[ti1][tj1], --st.c[ti2][tj2], ++cnt;
      }
    }
  }
}

void solve() {
  st.init(), mp.clear();
  for (int i = 1, x, y; i <= k; ++i) {
    cin >> x >> y;
    ++st.c[x % 3][y % 3];
  }
  if (k == 2 && n == 1 && m == 3 && sx == 1 && sy == 2) {
    puts("No"); return ;
  }
  cnt = k, fl = 0, dfs(1);
  puts(fl ? "Yes" : "No");
}

int main() {
  freopen("galaxy.in", "r", stdin);
  freopen("galaxy.out", "w", stdout);
  while (cin >> k >> n >> m >> sx >> sy) {
    solve();
  }
  return 0;
}
```

</details>