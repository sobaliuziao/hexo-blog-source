---
title: 20220825 模拟赛题解
date: 2022-08-25 22:20:00
---

## T1 芝麻开门

### Description

给你 $a,k$，求 $a^k$ 的因数和。

### Solution

直接因数和定理然后跑个高精就行了。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long
#define mkp make_pair
#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef __int128 i128;

int n, k;
vector<int> sm[105];
vector<int> vec[105];
vector<pair<int, int>> v;

vector<int> tovec(i128 x) {
  static vector<int> tmp;
  tmp.clear();
  while (x) {
    tmp.emplace_back(x % 10);
    x /= 10;
  }
  return tmp;
}

vector<int> add(vector<int> a, vector<int> b) {
  static vector<int> tmp;
  tmp.clear();
  tmp.resize(max(a.size(), b.size()) + 1);
  for (int i = 0; i < tmp.size(); ++i) {
    int s1 = 0, s2 = 0;
    if (i < a.size()) s1 = a[i];
    if (i < b.size()) s2 = b[i];
    tmp[i] = s1 + s2;
  }
//  dbg;
  for (int i = 0; i < tmp.size() - 1; ++i) {
    tmp[i + 1] += tmp[i] / 10;
    tmp[i] %= 10;
  }
  int idx = 0;
  for (int i = tmp.size() - 1; ~i; --i) {
    if (tmp[i]) {
      idx = i; break ;
    }
  }
  static vector<int> vec;
  vec.resize(idx + 1);
  for (int i = 0; i <= idx; ++i) {
    vec[i] = tmp[i];
  }
//  dbg;
  return vec;
}

vector<int> mul(vector<int> a, vector<int> b) {
  static vector<int> tmp;
  tmp.clear();
  tmp.resize(a.size() * 2 + b.size() * 2);
  for (int i = 0; i < (int)a.size(); ++i) {
    for (int j = 0; j < (int)b.size(); ++j) {
      tmp[i + j] += a[i] * b[j];
    }
  }
  for (int i = 0; i < tmp.size() - 1; ++i) {
    tmp[i + 1] += tmp[i] / 10;
    tmp[i] %= 10;
  }
  int idx = 0;
  for (int i = tmp.size() - 1; ~i; --i) {
    if (tmp[i]) {
      idx = i; break ;
    }
  }
  static vector<int> vec;
  vec.resize(idx + 1);
  for (int i = 0; i <= idx; ++i) {
    vec[i] = tmp[i];
  }
  return vec;
}

void print(vector<int> v) {
  for (int i = v.size() - 1; ~i; --i) {
    cout << v[i];
  }
  putchar('\n');
}

bool isprime(int n) {
  if (n < 2) return 0;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return 0;
  }
  return 1;
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  cin >> n >> k;
  for (int i = 1; i * i <= n; ++i) {
    if (n % i != 0) continue ;
//    db(i);
    if (isprime(i)) {
//      db(i);
      int cn = n, cnt = 0;
      while (cn % i == 0) {
        ++cnt, cn /= i;
      }
      v.emplace_back(mkp(i, cnt * k));
    }
    if (i * i != n && isprime(n / i)) {
      int cn = n, cnt = 0;
//      db(n / i);
      while (cn % (n / i) == 0) {
        ++cnt, cn /= (n / i);
      }
      v.emplace_back(mkp(n / i, cnt * k));
    }
  }
  if (n == 1) {
    cout << 1 << endl;
    return 0;
  }
  int cnt = 0;
  for (auto p : v) {
    int x = p.first, y = p.second;
    vector<int> nw = tovec((i128)1), xx = tovec((i128)x);
//    print(xx);
//    sm[++cnt] = nw;
//    dbg;
    sm[++cnt] = nw;
//    db(nw.size());
    for (int i = 1; i <= y; ++i) {
      nw = mul(nw, xx);
      sm[cnt] = add(sm[cnt], nw);
//      print(nw);
//      db(sm[cnt].size());
    }
//    db(cnt);
//    print(sm[cnt]);
    vec[cnt] = sm[cnt];
  }
  for (int i = 2; i <= cnt; ++i) {
    vec[i] = mul(vec[i], vec[i - 1]);
  }
  int idx = 0;
  for (int i = vec[cnt].size() - 1; ~i; --i) {
    if (vec[cnt][i]) {
      idx = i;break ;
    } 
  }
  for (int i = idx; ~i; --i) {
    cout << vec[cnt][i];
  }
  putchar('\n');
//  for (auto p : v) {
//    cout << p.first << ' ' << p.second<< endl;
//  }
  return summary, 0;
}
```
</details>

## T2 [SNOI2022] 垃圾回收

### Description

给定一个 $n$ 个点，$m$ 个边的图，有 $q$ 次操作，每次操作形如：

- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。
- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）

求每个点的权值乘上它存活时间的和。

### Solution

显然是离线，倒序循环。

那么这时 DELETE 操作就转化为了加边操作，可以直接并查集。
而 GC 就先存到数组里面。

而如果一个点 $x$ 的集合在第 $i$ 次操作与 $1$ 号点合并了，那么意味着正序循环时就在第 $i$ 次操作后与 $1$ 号点的集合分离，所以找到第一个编号大于 $i$ 的 GC 操作即可。

然后这题有可能图不连通，所以最后还要再特判一下。

时间复杂度是 $O(n\log q)$（我写了个 `lower_bound`，所以带 $\log$）。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int unsigned long long
#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef __int128 i128;

const int kMaxN = 4e5 + 5;

i128 ans;

struct Edge {
  int u, v;
} e[kMaxN];

int n, m, q;
int op[kMaxN], idx[kMaxN], a[kMaxN];
i128 res[kMaxN];
bool del[kMaxN];
vector<int> v;
map<pair<int, int>, int> mp;

class UFS {
  public:
    int find(int x) {
      return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void unionn(int x, int y) {
      int fx = find(x), fy = find(y);
      int n1 = find(1);
      if (fx == fy) return ;
      if (fx == n1) fa[fy] = fx, sum[fx] += sum[fy];
      else if (fy == n1) fa[fx] = fy, sum[fy] += sum[fx];
      else fa[fx] = fy, sum[fy] += sum[fx];
//      if (fx != fy) fa[fx] = fy, sum[fy] += sum[fx];
    }
    void unionn(int x, int y, int idx) {
      int fx = find(x), fy = find(y);
      int n1 = find(1);
      if (fx == fy) return ;
      if (fx == n1) {
//        ans += idx * sum[fy];
        sum[fx] += sum[fy];
        sz[fx] += sz[fy];
        fa[fy] = fx;
        res[idx] += sum[fy];
//        sum[fy] = 0;
      } else if (fy == n1) {
//        ans += idx * sum[fx];
        sz[fy] += sz[fx];
        sum[fy] += sum[fx];
        fa[fx] = fy;
        res[idx] += sum[fx];
//        sum[fx] = 0;
      } else {
        sz[fy] += sz[fx];
        sum[fy] += sum[fx];
        fa[fx] = fy;
//        sum[fx] = 0;
      }
    }
    void init(){
      for (int i = 1; i <= n; ++i) {
        fa[i] = i;
        sum[i] = a[i], sz[i] = 1;
      }
    }
  private:
    int fa[kMaxN]; i128 sum[kMaxN], sz[kMaxN];
} ufs;

void print(i128 x) {
  if (x < 10) {
    putchar(x + '0');
    return ;
  }
  print(x / 10), putchar(x % 10 + '0');
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
//   freopen("a.txt", "r", stdin);
  cin >> n >> m >> q;
  for (int i = 1; i <= m; ++i) {
    cin >> e[i].u >> e[i].v;
    if (e[i].u > e[i].v) swap(e[i].u, e[i].v);
  }
//  dbg;
  for (int i = 1; i <= q; ++i) {
    string s;
    cin >> s;
    if (s[0] == 'D') {
      op[i] = 1;
      cin >> idx[i];
      del[idx[i]] = 1;
    } else {
      op[i] = 2;
    }
  }
//  dbg;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
  }
//  dbg;
//  summary;
//  s = UFS(n);
  ufs.init();
  for (int i = 1; i <= m; ++i) {
    if (!del[i]) {
      ufs.unionn(e[i].u, e[i].v, q + 1);
    }
  }
  int n1 = ufs.find(1);
  for (int i = 1; i <= n; ++i) {
    if (ufs.find(i) == n1) ans += (q + 1) * a[i];
  }
//  dbg;
  v.clear();
  v.emplace_back(q + 1);
  for (int i = q; i; --i) {
    if (op[i] == 1) {
      ufs.unionn(e[idx[i]].u, e[idx[i]].v, i);
      del[idx[i]] = 0;
    } else {
      v.emplace_back(i);
    }
  }
//  for (int i = 1; i <= m; ++i) {
//    if (del[i]) dbg;
//  }
//  dbg;
  sort(v.begin(), v.end());
  for(int i = 1; i <= q; ++i) {
      ans += (i128)(*lower_bound(v.begin(), v.end(), i))* res[i];
  }
  for (int i = 1; i <= n; ++i) {
    if (ufs.find(i) != ufs.find(1)) ans += v[0] * a[i];
  }
  print(ans); putchar('\n');
  return summary, 0;
}
```

</details>

## T3 [CEOI2015 Day1] 卡尔文球锦标赛

### Description

给定数列 $a_1,a_2,...,a_n$，求字典序小于等于数列 $a$ 且将 $a$ 离散化后数列是从 $1$ 开始连续的。（感觉概括的好艹啊）

### Solution

不妨设当前的数列为 $b_1,b_2,...,b_n$。

显然是 dp。

设 $f[i][j][0/1]$ 表示从 $1$ 考虑到 $i$，最大值为 $j$，是否到达上界的方案数。不妨设 $l_i=\max\{b_1,b_2,...,b_i\}$。

先考虑 $f[i][j][0]$ 的转移。

1. $b_i > l_{i-1}$
	那么 $b_i$ 只能取 $j$，且 $l_{i-1}$ 只能取 $j-1$，那么就是由 $f[i-1][j-1][0]$ 转移过来的。
   
2. $b_i \leq l_{i-1}$
	那么 $b_i$ 小于等于 $j$，如果上一位没有到达上界，则是由 $f[i-1][j][0]\times j$ 转移过来。否则就是由这一位一定要小于 $a_i$，那么就是由 $f[i-1][\min\{a_i-1,j\}][1]$ 转移过来。
	
所以 $f[i][j][0]=f[i-1][j-1][0]+f[i-1][j][0]\times j+f[i-1][\min\{a_i-1,j\}][1]$。

---

然后考虑 $f[i][j][1]$ 的转移。

如果 $a_i=j$，那么 $f[i][j][1]$ 就得从 $f[i-1][j-1][1]$ 转移过来。
如果 $a_i\neq j+1$，那么 $f[i][j][1]$ 就得从 $f[i][j][1]$ 转移过来。

所以 $f[i][j][1]=[a_i=j]\times f[i-1][j-1][1]+[a_i\neq j+1]\times f[i][j][1]$。

然后这道题就可以 $O(n^2)$ 解决了。

### Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

#define int long long
#define db(x) cerr << #x << '=' << x << endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&m_ed - &m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 1e4 + 5, kMod = 1e6 + 7;

int n, cur;
int p[kMaxN], f[2][kMaxN][2]; 
bool ok;

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  // freopen("a.txt", "r", stdin);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> p[i];
    // l[i] = max(l[i - 1], p[i]);
  }
  cur = 0;
  f[1][1][1] = 1;
  for (int i = 2; i <= n; ++i, cur ^= 1) {
    for (int j = 1; j <= i + 1; ++j) {
      f[cur][j][0] = f[cur][j][1] = 0;
    }
    // db(cur);
    for (int j = n; j; --j) {
      // f[cur][j][0] = f[cur][j][1] = 0;
      f[cur][j][0] += f[cur ^ 1][j][0] * j % kMod + f[cur ^ 1][j][1] * min(j, p[i] - 1) % kMod + f[cur ^ 1][j - 1][0];
      f[cur][j][0] %= kMod;
      if (p[i] != j + 1) {
        f[cur][j][1] += f[cur ^ 1][j][1];
      }
      if (p[i] == j) {
        f[cur][j][1] += f[cur ^ 1][j - 1][1];
      }
      f[cur][j][1] %= kMod;
    }
    // if (i == 2) db(f[cur][])
  }
  int ans = 0;
  for (int i = 1; i <= n + 2; ++i) {
    ans += (f[cur ^ 1][i][0] + f[cur ^ 1][i][1]) % kMod;
    ans %= kMod;
  }
  cout << ans % kMod << endl;
  return summary, 0;
}
```

</details>

## T4 [ZJOI2011]营救皮卡丘

不会。