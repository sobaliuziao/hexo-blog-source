---
title: 省队集训2024 Day6 T1 题解
date: 2024-05-08 20:10:00
---

## Description

给定 $m$ 个 $\{1,2,\dots,n\}$ 的子集，要求选出两个不交的编号集合，使得两组编号所对应的集合并相等。

$n+1\leq m\leq 500$。

## Solution

考虑强化原题。

不妨把每个集合看成一个 $n$ 为向量 $X_i$，设大小为 $i$ 的序列 $s$ 和 $t$，如果 $i$ 被第一个集合选了则 $s_i$ 为正数，被第二个选了则 $t_i$ 为正数。

题目等价于找到 $s,t$，使得 $\sum_{i=1}^{m}{X_i s_i}=\sum_{i=1}^{m}{X_i t_i}$，等价于 $\sum_{i=1}^{m}{X_i (s_i-t_i)}=0$。

这里用高斯消元解出 $s$ 和 $t$ 即可，注意如果一个 $a_i$ 的解为无数个则把他设为 $1$ 来保证方案不全为 $0$。

时间复杂度：$O(m^3)$。

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

using f64 = long double;

const int kMaxN = 505;
const f64 kEps = 1e-6;

int n, m;
int sz[kMaxN];
f64 a[kMaxN][kMaxN], res[kMaxN];

void solve() {
  static int vis[kMaxN] = {0};
  int now = 0;
  std::fill_n(vis + 1, m, 0);
  std::cerr << std::fixed << std::setprecision(5);
  for (int i = 1; i <= m; ++i) {
    ++now;
    if (abs(a[now][i]) < kEps) {
      for (int j = now + 1; j <= n; ++j) {
        if (abs(a[j][i]) >= kEps) {
          std::swap(a[now], a[j]); break;
        }
      }
      if (abs(a[now][i]) < kEps) {
        --now; continue;
      }
    }
    vis[i] = now;
    for (int j = 1; j <= n; ++j) {
      if (j == now || abs(a[j][i]) < kEps) continue;
      f64 d = a[j][i] / a[now][i];
      for (int k = i; k <= m + 1; ++k)
        a[j][k] -= a[now][k] * d;
    }
    if (now == n) break;
  }
  for (int i = m; i; --i) {
    if (!vis[i]) {
      res[i] = 1; break;
    }
  }
  for (int i = m; i; --i) {
    if (vis[i]) {
      int p = vis[i];
      res[i] = a[p][m + 1];
      for (int j = 1; j <= m; ++j)
        if (i != j) res[i] -= res[j] * a[p][j];
      res[i] /= a[p][i];
    }
  }
}

void dickdreamer() {
  std::cin >> n >> m;
  for (int i = 1; i <= m; ++i) std::cin >> sz[i];
  for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= sz[i]; ++j) {
      int x;
      std::cin >> x;
      a[x][i] = 1;
    }
  }
  solve();
  std::vector<int> vec1, vec2;
  for (int i = 1; i <= m; ++i) {
    if (res[i] > kEps) vec1.emplace_back(i);
    if (res[i] < -kEps) vec2.emplace_back(i);
  }
  std::cout << vec1.size() << ' ' << vec2.size() << '\n';
  for (auto x : vec1) std::cout << x << ' ';
  std::cout << '\n';
  for (auto x : vec2) std::cout << x << ' ';
  std::cout << '\n';
}

int32_t main() {
  freopen("moon.in", "r", stdin);
  freopen("moon.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```