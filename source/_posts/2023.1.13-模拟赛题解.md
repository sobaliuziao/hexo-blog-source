---
title: '2023.1.13 模拟赛题解'
date: 2023-01-13 16:18:00
---

# T1

## Description

[link](https://codeforces.com/gym/102835/problem/C)

## Solution

容易发现每个点最后的状态只跟它的经过次数有关，所以可以设 $f[i,j]$ 表示经过 $(i,j)$ 的次数。

那么 $f[0][0]=k,f[i,j]=\big\lceil\frac{f[i-1,j]}{2}\big\rceil+\big\lfloor\frac{f[i,j-1]}{2}\big\rfloor$。

时间复杂度：$O(n^2)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e4 + 5;

int n, k;
int f[kMaxN][kMaxN];

void solve() {
  cin >> n >> k;
  for (int i = 1; i <= n + 1; ++i) {
    for (int j = 1; j + i <= n + 1; ++j)
      f[i][j] = 0;
  }  
  f[1][1] = k;
  int ans = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j + i <= n + 1; ++j) {
      f[i + 1][j] += (f[i][j] + 1) / 2;
      f[i][j + 1] += f[i][j] / 2;
    }
  }
  int x = 1, y = 1;
  for (; x + y <= n;) {
    if (f[x][y] & 1) ++x;
    else ++y;
  }  
  cout << y - 1 << '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin >> T;
  while (T--) solve();
  
  cerr << 1.0 * clock() / CLOCKS_PER_SEC << 's' << '\n';
  return 0;
}
```
</details>

# T2

## Description

[link](https://codeforces.com/gym/102835/problem/E)

## Solution

设 $f[l,r,c]$ 表示把 $a[l,...,r]$ 操作后只剩颜色为 $c$，$c$ 的数量的最大值。

那么 $f[l,r,c]=\max_{k=l}^{r-1}{(f[l][k][c]+f[k+1][r][c])}$。

注意，如果求出 $f[l,r,c]$ 不小于 $m$，那么这个区间其它的颜色数量不会小于 $0$，所以要和 $0$ 取 $\text{max}$。

时间复杂度：$O(n^3)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 505;

int n, m;
int a[kMaxN], b[300], f[kMaxN][kMaxN][8];
string s;

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  b['R'] = 1, b['G'] = 2, b['B'] = 3, b['C'] = 4, b['M'] = 5, b['Y'] = 6, b['K'] = 7;
  cin >> s >> m;
  n = s.size();
  for (int i = 0; i < n; ++i) {
    a[i + 1] = b[s[i]];
  }
  memset(f, 0xcf, sizeof(f));
  for (int i = 1; i <= n; ++i) {
    f[i][i][a[i]] = 1;
    if (m == 1) {
      for (int c = 1; c <= 7; ++c)
        f[i][i][c] = max(f[i][i][c], 0);
    }
  }
  for (int len = 2; len <= n; ++len) {
    for (int i = 1; i + len - 1 <= n; ++i) {
      int j = i + len - 1;
      bool fl = 0;
      for (int c = 1; c <= 7; ++c) {
        for (int k = i; k < j; ++k)
          f[i][j][c] = max(f[i][j][c], f[i][k][c] + f[k + 1][j][c]);
        if (f[i][j][c] >= m) fl = 1;
      }
      if (fl) {
        for (int c = 1; c <= 7; ++c)
          f[i][j][c] = max(f[i][j][c], 0);
      }
    }
  }
  int maxi = 0;
  for (int c = 1; c <= 7; ++c)
    maxi = max(maxi, f[1][n][c]);
  cout << (maxi >= m ? "Yes\n" : "No\n");
  return 0;
}
```
</details>

# T3

## Description

[link](https://codeforces.com/gym/102835/problem/F)

## Solution

如果没有环，就直接设 $f[i,0/1]$ 表示把 $i$ 的子树全控制，$i$ 不选/选的最小答案。

那么 $f[i,0]=\sum{f[j,1]},f[i,1]=\sum{\min\{f[j,0],f[j,1]\}}+1$。

然后找到环上任意一对相邻的点 $x,y$，把这条边断掉，分别以 $x$ 和 $y$ 为根跑一遍上面那个 dp，输出最小值即可。

时间复杂度：$O(n)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 2e5 + 5;

int n, m, x, y;
int f[kMaxN][2];
vector<int> G[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

int dfs(int u, int fa) {
  f[u][0] = 0, f[u][1] = 1;
  for (auto v : G[u]) {
    if (v == fa || u == x && v == y || u == y && v == x) continue;
    dfs(v, u);
    f[u][0] += f[v][1];
    f[u][1] += min(f[v][0], f[v][1]);
  }
  return f[u][1];
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= n + m; ++i) {
    int u, v;
    cin >> u >> v;
    ++u, ++v;
    addE(u, v), addE(v, u);
    if (u <= n && v <= n) x = u, y = v;
  }
  cout << min(dfs(x, 0), dfs(y, 0)) << '\n';
  return 0;
}
```
</details>

# T4

## Description

[link](https://codeforces.com/gym/102835/problem/H)

## Solution

首先跑一遍最大生成树，把最大瓶颈求出来。然后把所有小于瓶颈的边删掉，跑一遍最小生成树，最小生成树上就是所求的生成树。

然后把边按边权从大到小排序，然后每次算贡献即可。

时间复杂度：$O(m\log m)$。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e4 + 5, kMaxM = 5e5 + 5;

struct Edge {
  int u, v, w;
} e1[kMaxM], e2[kMaxM], e3[kMaxM];

int n, m, m1, m2, m3, k;
int fa[kMaxN], sz[kMaxN];

void addE(int u, int v, int w) {
  e1[++m1] = {u, v, w};
}

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void getmax1() {
  for (int i = 1; i <= n; ++i)
    fa[i] = i;
  sort(e1 + 1, e1 + 1 + m1, [&] (Edge e1, Edge e2) { return e1.w > e2.w; });
  int cnt = 0;
  for (int i = 1; i <= m1; ++i) {
    int fu = find(e1[i].u), fv = find(e1[i].v);
    e2[++m2] = e1[i];
    if (fu != fv) {
      fa[fu] = fv;
      if (++cnt == n - 1) break;
    }
  }
}

void getmin2() {
  for (int i = 1; i <= n; ++i)
    fa[i] = i;
  sort(e2 + 1, e2 + 1 + m2, [&] (Edge e1, Edge e2) { return e1.w < e2.w; });
  int cnt = 0;
  for (int i = 1; i <= m1; ++i) {
    int fu = find(e2[i].u), fv = find(e2[i].v);
    if (fu != fv) {
      fa[fu] = fv;
      e3[++m3] = e2[i];
      if (++cnt == n - 1) break;
    }
  }
}

void getmax2() {
  for (int i = 1; i <= n; ++i) {
    fa[i] = i;
    sz[i] = 1;
  }
  sort(e3 + 1, e3 + 1 + m3, [&] (Edge e1, Edge e2) { return e1.w > e2.w; });
  int cnt = 0;
  long long ans = 0;
  for (int i = 1; i <= m3; ++i) {
    int fu = find(e3[i].u), fv = find(e3[i].v);
    ans += 1ll * sz[fu] * sz[fv] * e3[i].w; 
    if (fu != fv) {
      fa[fu] = fv;
      sz[fv] += sz[fu];
      if (++cnt == n - 1) break;
    }
  }
  cout << ans << '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= m; ++i) {
    int u, v, w;
    cin >> u >> v >> w;
    addE(u, v, w);
  }
  getmax1(), getmin2(), getmax2();
  return 0;
}
```
</details>

# T5

## Description

[link](https://codeforces.com/gym/102835/problem/K)

## Solution

考虑数位 dp。

设 $f[x][s][0/1][0/1]$ 表示从最高位考虑到第 $x$ 位，当前用了的数的二进制状态为 $s$，没到/到了限制，没有/有前导零的数量。

然后枚举当前这一位是哪个数，然后直接 dp 即可。

注意：十六进制输入输出要用 `hex`，用完要重新用 `dec` 转回十进制。

## Code

<details>
<summary>代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;
using u64 = unsigned long long;

const u64 kInf = 18446744073709551615ull;

int n, t;
int a[30];
u64 f[2][30][1 << 17];

u64 dfs(int x, int s, bool lim, bool flag, int base) {
/*
  lim=1：到了限制
  lim=0：没到限制
  flag=1：有前导零
  flag=0：没有前导零 
*/
  if (x == 0) return 1;
  int bs = (base == 16);
  if (!lim && !flag && f[bs][x][s] != kInf) return f[bs][x][s];
  int up = (lim ? a[x] : (base - 1));
  u64 ret = 0;
  for (int i = 0; i <= up; ++i) {
    if (!i) {
      if (flag) {
        ret += dfs(x - 1, s, (lim && i == a[x]), (flag && !i), base);
      } else {
        if (s >> i & 1) continue;
        ret += dfs(x - 1, (s | (1 << i)), (lim && i == a[x]), (flag && !i), base);
      }
    } else {
      if (s >> i & 1) continue;
      ret += dfs(x - 1, (s | (1 << i)), (lim && i == a[x]), (flag && !i), base);
    }
  }
  if (!lim && !flag) f[bs][x][s] = ret;
  return ret;
}

u64 calc(u64 x, int base) {
  t = 0;
  while (x) {
    a[++t] = x % base;
    x /= base;
  }
  return dfs(t, 0, 1, 1, base);
}

u64 calc(u64 l, u64 r, int base) {
  if (!l) return calc(r, base);
  else return calc(r, base) - calc(l - 1, base);
}

void solve10() {
  int op;
  u64 l, r;
  cin >> op;
  if (op == 0) {
    cin >> dec >> l >> r;
    cout << dec << calc(l, r, 10) << '\n';
  } else {
    cin >> dec >> l;
    if (l == 1) {
      cout << "0\n";
      return;
    }
    u64 L = 0, R = 1000000001, res; 
    bool fl = 0;
    while (L + 1 < R) {
      u64 mid = L + (R - L) / 2;
      if (calc(mid, 10) >= l) R = res = mid, fl = 1;
      else L = mid;
    }
    if (fl) cout << dec << res << '\n';
    else cout << "-\n";
  }
}

void solve16() {
  int op;
  u64 l, r;
  cin >> op;
  if (op == 0) {
    cin >> hex >> l >> r;
    cout << hex << calc(l, r, 16) << '\n';
  } else {
    cin >> hex >> l;
    if (l == 1) {
      cout << "0\n";
      return;
    }
    u64 L = 0, R = kInf - 1, res;
    bool fl = 0;
    while (L + 1 < R) {
      u64 mid = L + (R - L) / 2;
      if (calc(mid, 16) >= l) R = res = mid, fl = 1;
      else L = mid;
    }
    if (fl) cout << hex << res << '\n';
    else cout << "-\n";
  }
}

void solve() {
  string s;
  cin >> s;
  if (s[0] == 'd') solve10();
  else solve16();
}

int main() {
//  freopen("K.in", "r", stdin);
//  freopen("K.out", "w", stdout);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  memset(f, 0xff, sizeof(f));
  int T;
  cin >> T;
  while (T--) solve();
  return 0;
}
```
</details>