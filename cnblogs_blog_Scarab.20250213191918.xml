<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园 - 下蛋爷</title>
  <subtitle type="text">博客备份 - cnblogs_blog_Scarab.20250213191918</subtitle>
  <id>uuid:cda98c3d-732c-4a15-b024-9b36c46a9ba7;id=21</id>
  <updated>2025-02-13T11:21:13Z</updated>
  <author>
    <name>下蛋爷</name>
    <uri>https://www.cnblogs.com/Scarab</uri>
  </author>
  <link rel="alternate" href="https://www.cnblogs.com/Scarab" />
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14558127.html</id>
    <title type="text">哈希学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2020-11-17T12:50:00Z</published>
    <updated>2020-11-17T12:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14558127.html" />
    <content type="text"># 哈希(HASH)

哈希(HASH)本质上是一种映射。

## 引入1

给定 $n$ 个正整数，这些正整数的值域均为 $[1,10^6)$，让你把这些数去重后按从小到大排序后输出。

### 方法

用一个桶来统计每一个数的次数，最后循环值域，如果次数不为 $0$，就输出即可。

时间复杂度：$O(n)$，空间复杂度：$O(10^6)$。

## 引入2

给定 $n$ 个正整数，这些正整数的值域均为 $[1,10^9)$，让你把这些数去重后按从小到大排序后输出。

---
这题发现值域到了 $10^9$，很明显无法用桶排来做。

## 方法1

用STL-unique来写，时间复杂度大概为 $O(n)$，可以过。

---

不过大部分题目都无法用unique，就有了新的算法-哈希。

## 方法2-哈希算法

我们用一个函数 $H$，将一个很大的数 $x$ 变为一个可以用数组存下的数。

一般都将哈希函数 $H(x)$ 定义为 $x\bmod P$（$P$为一个质数）。

最后将哈希之后的数做桶排即可。

## 哈希冲突

我们发现如果两个数 $x,y$ 使 $H(x)=H(y)$，此时发现哈希之后冲突了，答案就错误。此时就叫**哈希冲突**、

## 解决哈希冲突

我们用一个链表处理 $0\sim P-1$ 的模数情况。即，将 $x$ 插入到 $H(x)$ 的链表下。

每次插入时遍历 $H(x)$ 的链表，如果没有重复就插入，否则就不插入链表。

## 时间复杂度

$
O(n\cdot len) \approx O(n\cdot \dfrac{n}{P})
$

$\text{当}P\approx n\text{时，}O(n\cdot \dfrac{n}{P})\approx O(n)$。

此时的时间复杂度就十分优秀了。

## 模板代码

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MOD = 999983;

int n, x, ans;

vector &lt;int&gt; G[MOD + 5];

int Hash (int x) {
  return x % MOD;
}

int insert (int x) {
  int val = Hash(x);
  for (int i = 0; i &lt; G[val].size(); ++i) {
    if (G[val][i] == x) return 0;
  }
  G[val].push_back(x);
  return 1; 
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; x;
    ans += insert(x);
  } 
  cout &lt;&lt; ans &lt;&lt; endl; 
  return 0;
} 
```

## 例题

- [P4305 [JLOI2011]不重复数字](https://www.luogu.com.cn/problem/P4305)

这题定义哈希函数 $H(x)=x\bmod P$，如果过不了，别忘了考虑负数的情况。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 5e4 + 5;
const int MOD = 999983;

int T, n, ans;
int a[N];

vector &lt;int&gt; G[MOD + 5];

int Hash (int x) {
  return (x % MOD + MOD) % MOD;
}

int insert (int x) {
  int val = Hash(x);
  for (int i = 0; i &lt; G[val].size(); ++i) {
    if (G[val][i] == x) return 0;
  }
  G[val].push_back(x);
  return 1;
}

int main() {
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; n;
    ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
      scanf("%d", &amp;a[i]);
    }
    for (int i = 0; i &lt; MOD; ++i) {
      G[i].clear();
    }
    for (int i = 1; i &lt;= n; ++i) {
      if (insert(a[i]) == 1) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
      }
    }
    cout &lt;&lt; endl;
  }
  return 0;
}
```

- [P1955 [NOI2015]程序自动分析](https://www.luogu.com.cn/problem/P1955)

首先先看题目，看到有 $x_i=x_j$ 时，就想到了用图论的并查集来做。即，先将所有 $e=1$ 的情况中的 $(i,j)$ 合并，最后合并完再枚举 $e=0$ 的情况看是否在同一个连通块就行了。

可发现数据范围中的

&gt; $1\leq i,j\leq 10^9$

就知道用纯的并查集过不去。于是想到了用哈希将数的范围缩小，随后并查集维护即可。哈希函数一样是 $H(x) = x\bmod P$。时间复杂度：$O(n\cdot\alpha(n))\approx O(n) $

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 5;
const int MOD = 990887;

int T, n;
int x[N], y[N], opt[N];
int fa[MOD + 5];

int Hash (int x) {
  return x % MOD;
}

int find (int x) {
  if (x == fa[x]) return x;
  else return fa[x] = find(fa[x]);
}

void unionn (int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) fa[fx] = fy;
  return ;
}

int main() {
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; n;
    for (int i = 0; i &lt; MOD; ++i) {
      fa[i] = i;
    }
    for (int i = 1; i &lt;= n; ++i) {
      cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; opt[i];
      if (opt[i] == 1) unionn(Hash(x[i]), Hash(y[i]));
    }
    bool flag = false;
    for (int i = 1; i &lt;= n; ++i) {
      if (opt[i] == 0) {
        if (find(Hash(x[i])) == find(Hash(y[i]))){
          puts("NO");
          flag = true;
          break;
        }
      }
    }
    if (flag == false) puts("YES"); 
  }
  return 0;
}
```

- [SP4354 TWINSNOW - Snowflakes](https://www.luogu.com.cn/problem/SP4354)

样例输入(POJ)：

```
2
1 2 3 4 5 6
4 3 2 1 6 5
```

样例输出(POJ)：

```
Twin snowflakes found.
```

---

首先看到这题，发现每个雪花是一个含有六个数的序列，我们就定义这个序列的哈希值为这些数的和 $\bmod P$ 的值，即：

$$
H(a)=\sum_{i=1}^{6}{a_i}
$$

（当然也可以是别的，比如这个序列的和加这个序列的乘积 $\bmod P$ 的值，只要与这个序列的顺序无关即可）

需要注意的是，判断两个雪花是否相同时，从某个节点，顺时针和逆时针都要比较才行。

代码：

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#define int long long
using namespace std;

const int N = 1e5 + 5;
const int MOD = 99991;

int n;
int a[N][20];

vector &lt;int&gt; G[MOD + 5];

int Hash (int ind) {
  int sum = 0;
  for (int i = 1; i &lt;= 6; ++i) {
    sum = (sum + a[ind][i]) % MOD;
  }
  return sum % MOD;
}

bool issame (int ind1, int ind2) {
  for (int i = 1; i &lt;= 6; ++i) {
    for (int j = 1; j &lt;= 6; ++j) {
      bool flag = true;
      for (int k = 0; k &lt; 6; ++k) {
        if (a[ind1][(i + k) % 6 + 1] != a[ind2][(j + k) % 6 + 1]) flag = false;
      }
      if (flag == true) return true;
      flag = true;
      for (int k = 0; k &lt; 6; ++k) {
        if (a[ind1][(i + k) % 6 + 1] != a[ind2][(j - k + 6) % 6 + 1]) flag = false;
      }
      if (flag == true) return true;
    }
  }
  return false;
}

int insert (int ind) {
  int val = Hash(ind);
  for (int i = 0; i &lt; G[val].size(); ++i) {
    if (issame(G[val][i], ind)) return 1;
  }
  G[val].push_back(ind);
  return 0;
}

int ans = 0;

signed main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= 6; ++j) {
      scanf("%lld", &amp;a[i][j]);
    } 
    if (insert(i) == 1) {
      puts("Twin snowflakes found.");
      return 0;
    }
  }
  puts("No two snowflakes are alike.");
  return 0;
}
```

## 字符串哈希</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745367.html</id>
    <title type="text">Trie学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2020-12-20T13:57:00Z</published>
    <updated>2020-12-20T13:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745367.html" />
    <content type="text"># Trie树

Trie树（字典树），是一种查询快速，省空间（相对而言）的一种数据结构。

## 引入

上[百度](https://www.baidu.com/)搜东西，我们发现搜索“洛谷”会出现二十多页的结果。我们知道，百度是一个十分强大的搜索引擎，而且信息量巨大，但我们搜索东西总会非常快得搜索出结果，而且还十分准确。而他们就是运用了Trie实现的。

---

## Trie思想

我们发现，“洛”、“洛谷”、“洛谷强”都有共同的前缀，这时候我们就将前缀“洛”存储成一个节点，然后就变成“谷”，“谷强”，然后再将“谷”存一个，如此往复。如图：

![graph.png](https://cdn.luogu.com.cn/upload/image_hosting/geem6lk6.png)

但是如果是：“洛”，“洛谷”，“洛神赋”的情况，很明显就不能用链来存储，于是就想到了用一个树来存，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/w32yxq6y.png)

于是，每个重复的字母都不会被重复存储。

## 模板代码

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 5;

int n, m, tot;
string s;

int node[N * 5][26];
bool exist[N * 5 * 26];

void insert (string s) {
  int len = s.size();
  int now = 1;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';// 当前字母
    if (node[now][k] == 0) node[now][k] = ++tot;//如果此时没有节点，就新建节点
    now = node[now][k];
  }
  exist[now] = true;//标记，表示此时的now对应有结果
  return ;
}

bool search (string s) {
  int len = s.size();
  int now = 1;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';
    if (node[now][k] == 0) return false;//如果此时没有结果，则直接返回false
    now = node[now][k];
  }
  return exist[now];//这里的exist意义和上面的一样，表示此时的now有没有结果
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; s;
    insert(s);
  }
  cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    cin &gt;&gt; s;
    puts(search(s) == true ? "Yes" : "No");
  }
  return 0;
} 
```

代码注意点：

1. Trie数组空间要开到 $\text{字符串个数}\times \text{不同的字符个数}$。

2. 代码中的 ```tot``` 和 ```now``` 的初始值必须相同，例如：我们定义 ```tot``` 初始为```0```，那么 ```now``` 初始也得为0。

## 例题

- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)

Trie板子题，插入删除没啥变化，只用把 ```exist``` 数组定为 ```int``` 类型，插入时将 ```exist[now]++```，为了节省空间，我们询问时如果出现 ```OK``` 才插入。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 5;

int n, m, tot;
string s;

int node[N * 5][26];
int exist[N * 5 * 26];

void insert (string s) {
  int len = s.size();
  int now = 1;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';
    if (node[now][k] == 0) node[now][k] = ++tot;
    now = node[now][k];
  }
  exist[now]++;
  return ;
}

string search (string s) {
  int len = s.size();
  int now = 1;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';
    if (node[now][k] == 0) return "WRONG";
    now = node[now][k];
  }
  if (exist[now] == 0) return "WRONG";
  else if (exist[now] == 1) return "OK";
  else return "REPEAT";
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; s;
    insert(s);
  }
  cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    cin &gt;&gt; s;
    string res = search(s);
    cout &lt;&lt; res &lt;&lt; endl;
    if (res == "OK") insert(s);
  }
  return 0;
} 
```

- [P3879 [TJOI2010]阅读理解](https://www.luogu.com.cn/problem/P3879)

Trie的模板改了一下，```exist```数组从二维增到了三维，增加的那一维度就是文章号，其余的均一样。但这题 ```#11``` 数据点MLE，这也是没办法。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 5e3 + 5;

int n, m, L, tot;
string s;
int res[N], node[1005][N][26];
bool exist[1005][N * 26];

void insert (int Case, string s) {
  int len = s.size();
  int now = 0;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';
    if (node[Case][now][k] == 0) node[Case][now][k] = ++tot;
    now = node[Case][now][k];
  }
  exist[Case][now] = true;
}

bool search (int Case, string s) {
  int len = s.size();
  int now = 0;
  for (int i = 0; i &lt; len; ++i) {
    int k = s[i] - 'a';
    if (node[Case][now][k] == 0) return false;
    now = node[Case][now][k];
  }
  return exist[Case][now];
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; L;
    for (int j = 1; j &lt;= L; ++j) {
      cin &gt;&gt; s;
      insert(i, s);
    }
  }
  cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    cin &gt;&gt; s;
    int cnt = 0;
    for (int j = 1; j &lt;= n; ++j) {
      if (search(j, s) == true) res[++cnt] = j;
    }
    for (int j = 1; j &lt;= cnt; ++j) {
      if (j != 1) printf(" ");
      printf("%d", res[j]);
    }
    cout &lt;&lt; endl;
  }
  return 0;
}
```

---

# 01 Trie

## 引入

我们如果要给定两个数组 ```a``` 和 ```b```，均有 $n$ 个数，我们固定 ```a``` 不动，让 ```b``` 自由排列，使排列后的 ```b[i] xor a[i]``` 的值最大，求字典序最小的答案。

### 方法一

暴力枚举 ```b``` 的排列，取最大值即可，时间复杂度 $O(n!\times n)$，随便就卡死了。

### 方法二 - 01 Trie

本质上是一种贪心。我们发现：

&gt; 二进制高位尽量不同，异或出的值就会越大。

有了这个性质，就发现我们处理二进制位就行了。发现，此时只要求二进制高位开始的第 $i$ 位有相同的或者是没相同的即可。于是，便发现可以用Trie来维护。

时间复杂度： $O(n\log \max(a_i,b_i))$，在 ```int``` 范围内，即可理解为 $O(n\log n)$，时间复杂度极其优秀，空间也就 $O(2\times n\log n)$。

## 例题

- [CF923C Perfect Security](https://www.luogu.com.cn/problem/CF923C)

01 Trie板子，直接上代码：

```cpp
#include &lt;bits/stdc++.h&gt;

const int N = 3e5 + 5;

struct Trie {
  int count, son[2];
} Tree[N * 35 * 2] ;

int n, tot = 1;
int a[N], b[N];

void insert (int x) {
  int now = 1;
  Tree[now].count++;
  for (int i = 30; i &gt;= 0; --i) {
    int key = x &gt;&gt; i &amp; 1;//取x从右往左数第i位
    if (Tree[now].son[key] == 0) Tree[now].son[key] = ++tot;
    now = Tree[now].son[key];
    Tree[now].count++;
  }
  return ;
}

int search (int x) {
  int result = 0, now = 1;
  for (int i = 30; i &gt;= 0; --i) {
    int key = x &gt;&gt; i &amp; 1;
    if (Tree[Tree[now].son[key]].count == 0) key ^= 1;
    result = (result &lt;&lt; 1) + key;
    now = Tree[now].son[key];
    Tree[now].count--;
  }
  return x ^ result;
}

int main() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; b[i];
    insert(b[i]);
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::cout &lt;&lt; search(a[i]) &lt;&lt; " ";
  }
  return 0;
}
```

- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

我们任取两点 $u,v(u\neq v)$，令 $(u,v)$ 的公共祖先为 $k$，$1\to k$ 上经过的边权分别为 $w_1,w_2,...,w_t$，$k\to u$ 的简单路径上的边权分别为 $p_1,p_2,...,p_f$，$k\to v$ 的简单路径上的边权分别为 $q_1,q_2,...,q_g$。

那么
$dis(u)=w_1\oplus w_2\oplus,....,\oplus w_t\oplus p_1\oplus p_2\oplus,...,\oplus p_f$，
$dis(v)=w_1\oplus w_2\oplus,....,\oplus w_t\oplus q_1\oplus q_2\oplus,...,\oplus q_g$，此时 $dis(u)\oplus dis(v)=p_1\oplus p_2\oplus,...,\oplus p_f\oplus q_1\oplus q_2\oplus,...,\oplus q_g$，此时发现就等于我们要求的简单路径的异或值。此时我们只要让 $dis(u)\oplus dis(v)$ 的值最小即可，用01Trie维护就行了。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 5; 

struct edge {
  int to, w;
} ;
vector &lt;edge&gt; G[N];

int n, ans, tot = 1;
int u, v, w;
int dis[N], vis[N];

int Tree[N * 31][2];

void addEdge (int u, int v, int w) {
  G[u].push_back((edge){v, w}); 
}

void Prework (int k) {//取出dis(k)的值
  for (vector &lt;edge&gt; :: iterator it = G[k].begin(); it != G[k].end(); ++it) {
    int to = it -&gt; to, v = it -&gt; w;
    if (vis[to] == 1) continue ;
    dis[to] = dis[k] ^ v;
    vis[to] = 1;
    Prework(to);
  }
  return ;
}

void insert (int k) {//01Trie板子
  int now = 1, key;
  for (int i = 31; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    if (Tree[now][key] == 0) Tree[now][key] = ++tot;
    now = Tree[now][key];
  }
  return ;
}

int search (int k) {//01Trie板子
  int now = 1, res = 0, key;
  for (int i = 31; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    key ^= 1;
    if (Tree[now][key] == 0) key ^= 1;
    res = (res &lt;&lt; 1) + key;
    now = Tree[now][key];
  }
  return res;
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n - 1; ++i) {
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    addEdge(u, v, w), addEdge(v, u, w);
  }
  vis[1] = 1;
  Prework(1);
  for (int i = 1; i &lt;= n; ++i) {
    insert(dis[i]);
    if (i != 1) ans = max(ans, dis[i] ^ search(dis[i]));
  }
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
```

- [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

~~惊不惊喜，意不意外，让你用01Trie维护平衡树~~

1. 插入

01Trie板子即可，但要记录  $\text{size}$ 表示插入时这一位被经过的次数。代码：

```cpp
void Insert (int k) {
  int now = 1, key;
  for (int i = MAXBIT; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    if (Tree[now][key] == 0) Tree[now][key] = ++tot;
    now = Tree[now][key];
    Size[now]++;
  }
  Exist[now]++;
  return ;
}
```

2 删除

跟插入实现差不多，代码：

```cpp
void Delete (int k) {
  int now = 1, key;
  for (int i = MAXBIT; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    now = Tree[now][key];
    Size[now]--;
  }
  Exist[now]--;
  return ;
}
```

3. 查询 $k$ 的排名

对于 $k$ 的第 $i$ 位，如果为 $1$ ，计数器就加 ```Size[lson(now)]```，否则就不加，最后输出计数器+1即可。代码：

```cpp
int Rank (int k) {
  int now = 1, res = 0, key;
  for (int i = MAXBIT; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    if (key == 1) res += Size[Tree[now][0]];
    now = Tree[now][key];
  }
  return res + 1;
}
```

4. 查询排名为 $k$ 的数

首先实现 ```Count(k)``` 函数，表示数 $k$ 的出现次数。

实现 ```GetKth(k)``` 时。

- 如果 $k$ 的第 $i$ 位为 $0$

	继续向下转移即可
- 如果 $k$ 的第 $i$ 位为 $1$

先用 $k$ 减去 ```Size[lson(now)]```，计数器```|=```$2^i$，再转移即可。

代码：

```cpp
int GetKth (int k) {
  int now = 1, key, res = 0;
  for (int i = MAXBIT; ~i; --i) {
    key = k &gt;&gt; i &amp; 1;
    if (k &lt;= Size[Tree[now][0]]) now = Tree[now][0];
    else {
      k -= Size[Tree[now][0]];
      res |= (1 &lt;&lt; i);
      now = Tree[now][1];
    }
  }
  return res;
}
```

- 查询前驱 &amp; 后继

分别取 ```GetKth(Rank(k)-1)``` 和 ```GetKth(Rank(k)+Count(k))```，代码：

```cpp
int GetPre (int k) {
  int res;
  Insert(k);
  res = GetKth(Rank(k) - 1);
  Delete(k);
  return res;
}
int GetNext (int k) {
  int res;
  Insert(k);
  res = GetKth(Rank(k) + Count(k));
  Delete(k);
  return res;
}
````

完整代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, opt, x;

namespace Trie {
  const int N = 1e5 + 5;
  const int MAXBIT = 23;
  int tot = 1, Tree[N * MAXBIT][2], Exist[N * MAXBIT * 2], Size[N * MAXBIT * 2];
  
  void Insert (int k) {
    int now = 1, key;
    for (int i = MAXBIT; ~i; --i) {
      key = k &gt;&gt; i &amp; 1;
      if (Tree[now][key] == 0) Tree[now][key] = ++tot;
      now = Tree[now][key];
      Size[now]++;
    }
    Exist[now]++;
    return ;
  }
  void Delete (int k) {
    int now = 1, key;
    for (int i = MAXBIT; ~i; --i) {
      key = k &gt;&gt; i &amp; 1;
      now = Tree[now][key];
      Size[now]--;
    }
    Exist[now]--;
    return ;
  }
  int Count (int k) {
    int now = 1, key;
    for (int i = MAXBIT; ~i; --i) {
      key = k &gt;&gt; i &amp; 1;
      now = Tree[now][key];
      if (now == 0) return 0;
    }
    return Exist[now];
  }
  int Rank (int k) {
    int now = 1, res = 0, key;
    for (int i = MAXBIT; ~i; --i) {
      key = k &gt;&gt; i &amp; 1;
      if (key == 1) res += Size[Tree[now][0]];
      now = Tree[now][key];
    }
    return res + 1;
  }
  int GetKth (int k) {
    int now = 1, key, res = 0;
    for (int i = MAXBIT; ~i; --i) {
      key = k &gt;&gt; i &amp; 1;
      if (k &lt;= Size[Tree[now][0]]) now = Tree[now][0];
      else {
        k -= Size[Tree[now][0]];
        res |= (1 &lt;&lt; i);
        now = Tree[now][1];
      }
    }
    return res;
  }
  int GetPre (int k) {
    int res;
    Insert(k);
    res = GetKth(Rank(k) - 1);
    Delete(k);
    return res;
  }
  int GetNext (int k) {
    int res;
    Insert(k);
    res = GetKth(Rank(k) + Count(k));
    Delete(k);
    return res;
  }
}

namespace Solution {
  static int BASE = 1e7;
  void Solve (int opt, int x) {
    switch (opt) {
      case 1: Trie::Insert(x + BASE); break;
      case 2: if (Trie::Count(x + BASE) != 0) Trie::Delete(x + BASE); break;
      case 3: printf("%d\n", Trie::Rank(x + BASE)); break;
      case 4: printf("%d\n", Trie::GetKth(x) - BASE); break;
      case 5: printf("%d\n", Trie::GetPre(x + BASE) - BASE); break;
      default: printf("%d\n", Trie::GetNext(x + BASE) - BASE); break;
    }
  }
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; opt &gt;&gt; x;
    Solution::Solve(opt, x);
  }
  return 0;
}
```

# The end</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745395.html</id>
    <title type="text">P2016 战略游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-04-02T06:25:00Z</published>
    <updated>2021-04-02T06:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745395.html" />
    <content type="text">这题一眼看上去是一道树形DP的题目，然后后面一想好像可以用二分图来做（虽然是教练提醒的），故产生了此份题解。

## 题目大意

给定一个无根树，每个节点可以“管制”一堆给定点，求选择最少的点数来覆盖这棵树。

## Solution

这题的“覆盖”看起来有那么亿点点像最小点覆盖，所以可以想想如何用二分图来解。

### 如何建立二分图？

注意到这是一棵树，则每层之间肯定不会有连接，而且没有跨越两层的边，所以我们可以把原图划分为奇数层和偶数层。

然后跑匈牙利貌似就可以了。

Tips：最小点覆盖数就是最大匹配数。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1505;

vector &lt;int&gt; G[N];

int n, ind, k, r;
int ans, tot, dep[N], points[N];//tot表示奇数层点个数，dep[]表示每个点的层数，points[]表示所有奇数层点

bool vis[N];

void Pre (int k) {//处理出层数
  for (int i = 0; i &lt; (int)G[k].size(); ++i) {
    int to = G[k][i];
    if (vis[to]) continue ;
    vis[to] = true, dep[to] = dep[k] + 1;
    Pre(to);
  }
}

int match[N];

bool DFS (int k) {//匈牙利板子
  for (int i = 0; i &lt; (int)G[k].size(); ++i) {
    int to = G[k][i];
    if (!vis[to]) {
      vis[to] = true;
      if (!match[to] || DFS(match[to])) {
        match[to] = k; return true;
      }
    }
  }
  return false;
}

int main() {
  scanf("%d", &amp;n);
  for (int Case = 0; Case ^ n; ++Case) {
    scanf("%d%d", &amp;ind, &amp;k); ++ind;
    for (int i = 0; i ^ k; ++i) {
      scanf("%d", &amp;r); ++r;
      G[ind].push_back(r), G[r].push_back(ind);
    }
  }
  vis[1] = true, dep[1] = 1, Pre(1);
  for (int i = 1; i &lt;= n; ++i)//取出奇数层点
    if (dep[i] % 2 == 1) points[++tot] = i;
  for (int i = 1; i &lt;= tot; ++i) {//最大匹配
    memset(vis, false, sizeof(vis));
    if (DFS(points[i])) ++ans;
  }
  printf("%d\n", ans);
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745419.html</id>
    <title type="text">CF1504B Flip the Bits 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-04-04T12:20:00Z</published>
    <updated>2021-04-04T12:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745419.html" />
    <content type="text">赛时调了半天没调出来，赛后又调了半天还发帖询问后才过的。。。

## 题意

给定两个 $01$ 串 $a,b$，定义操作规则：

对于一个 $01$ 串，每次只能选择串中从 $1\sim i$ 的数字进行翻转（$0$变$1$，$1$变$0$），而且这 $i$ 个数字 $0$ 的个数与 $1$ 的个数是相同的。

问你能否对 $a$ 操作后变成 $b$。

## 思路

这题我是从后往前考虑的。

结论：从后往前扫，如果碰到 $a_i=b_i$ 且 $a_{i-1} \neq b_{i-1}$ 则就必须将 $1\sim i-1$ 翻转。易知此时 $1\sim i-1$ 中 $0$ 的个数不等于 $1$ 的个数则输出$\texttt{NO}$。如果坚持到底的话，就输出$\texttt{YES}$。

感性理解：找到从右到左满足 $a_i=b_i$ 并且 $a_{i-1} \neq b_{i-1}$ 的第一个 $i$，任意取一数 $j(i&lt;j\leq n)$。那么我们将 $1\sim j-1$ 翻转后，此时 $i\sim j-1$ 就不满足了，所以还要再翻转一次，就跟只翻转 $1\sim i - 1$ 一样了。

## 实现

很明显我们每一次对 $1\sim i-1$ 进行翻转操作时，不能直接模拟，否则时间卡爆你。那么怎么优化呢？

考虑到这是一个 $01$ 串，所以翻转结果只跟翻转次数有关，而且这里的操作是对一个连续的区间考虑的，所以完全可以用树状数组来写（类似于[树状数组 2](https://www.luogu.com.cn/problem/P3368)），然后正常写就可以了。

Tip：多组数据时，树状数组清空不能用 ```memset```，否则会 T。

## 代码

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 3e5 + 5;

int T, n;
int s[N];

string a1, b1;
int a[N], b[N];

int sum[N &lt;&lt; 2];
int lowbit (int x) {
  return x &amp; (-x);
}

void update (int x, int y) {//树状数组
  while (x &lt;= n) {
    sum[x] += y;
    x += lowbit(x);
  }
  return ;
}

int query (int x) {
  int res = 0;
  while (x != 0) {
    res += sum[x];
    x -= lowbit(x);
  }
  return res;
}

int main() {
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; n &gt;&gt; a1 &gt;&gt; b1;
    s[0] = 0;
    for (int i = 1; i &lt;= n; ++i) a[i] = a1[i - 1] - '0', b[i] = b1[i - 1] - '0', s[i] = s[i - 1] + a[i];//求前缀1的个数
    for (int i = 1; i &lt;= n; ++i) sum[i] = 0;
    bool flag = true;
    for (int i = n; i &gt;= 1; --i) {
      int k = query(i);
      if (k % 2 == 1) {
        a[i] ^= 1;
      }
      if (a[i] == b[i]) continue ;
      if (s[i] != i - s[i]) { flag = false; break ; }//如果不能进行翻转，就退出
      update(1, 1), update(i, -1);//对1~i-1 全部加上1
      s[i - 1] = i - 1 - s[i - 1];//前缀1变化
    }
    puts(flag == true ? "YES" : "NO");
  }
  return 0;
}
```

时间复杂度：$O(n\log n)$

能过。

$\text{Upd on 2021.4.10}$

这种思路可以 $O(n)$ 写，而且 $n\log n$ 的写法貌似复杂了（

定义一个计数器 $k$ 当这个时候需要翻转时就将 $k+1$，那么每次遍历到时，$k$ 就是次数。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 3e5 + 5;

int T, n;
int s[N];

string a1, b1;
int a[N], b[N];

int main() {
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; n &gt;&gt; a1 &gt;&gt; b1;
    s[0] = 0;
    for (int i = 1; i &lt;= n; ++i) a[i] = a1[i - 1] - '0', b[i] = b1[i - 1] - '0', s[i] = s[i - 1] + a[i];
    bool flag = true; int k = 0;
    for (int i = n; i &gt;= 1; --i) {
      if (k % 2 == 1) {
        a[i] ^= 1;
      }
      if (a[i] == b[i]) continue ;
      if (s[i] != i - s[i]) { flag = false; break ; }
      ++k;
      s[i - 1] = i - 1 - s[i - 1];
    }
    puts(flag == true ? "YES" : "NO");
  }
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745435.html</id>
    <title type="text">P2065 [TJOI2011]卡片 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-04-17T14:14:00Z</published>
    <updated>2021-04-17T14:14:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745435.html" />
    <content type="text">刚学网络流，记一篇题解。

## 题意

给你两堆卡片，分蓝的和红的，分别有 $n$ 个和 $m$ 个，然后每个卡片上都有一个数。一个人要拿很多张卡片，每次只能从两堆中各取一个，而且这两个卡片上的 $\gcd&gt;1$，问：最多能拿多少个。

## 思路1

&gt; 这不就是个二分图板子吗，暴力建图然后跑EK不就可以过了吗？

然后：

![](https://cdn.luogu.com.cn/upload/image_hosting/etrcic7o.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

稍微想一下发现建图就 $O(nm)$ 了，再带一堆常数就 T 飞了。

## 思路2

知道是建图慢了，就要去优化建图。

很明显这里不能两边同时建，所以要两边分开建图。

问题来了：怎么建？

这里发现是用 $\gcd$ 连接两边的，那么只要找到中间的一堆“中间商”即可。然后就很容易想到用**质因数**。

先预处理一遍 $1\sim 10^7$ 的质因数，然后对于每个卡片，再向卡片上数字的所有质因数连一条边，然后跑一遍网络流，问题就迎刃而解了。

## 代码(EK)

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e4 + 5;
const int M = 1e5 + 5;
const int PRIME = 1e7 + 5;
const int CNT = 6e5 + 5;

int T;
int n, m, s, t, ans;
int b[N], r[N];
int tot, pre[M &lt;&lt; 1], to[M &lt;&lt; 1], val[M &lt;&lt; 1], tail[N];

void addEdge (int u, int v, int w) {
  to[++tot] = v, val[tot] = w, pre[tot] = tail[u], tail[u] = tot;
  to[++tot] = u, val[tot] = 0, pre[tot] = tail[v], tail[v] = tot;
}

int gcd (int m, int n) {
  if (m &lt; n) swap(m, n);
  if (n == 0) return m;
  return gcd(n, m % n);
}

int cnt;
int primes[CNT];
void Prework () { //预处理质数（埃氏筛）
  bool vis[PRIME] = {0};
  for (int i = 2; i * i &lt;= 1e7; ++i)
    if (!vis[i])
      for (int j = i * i; j &lt;= 1e7; j += i)
        vis[j] = true;
  for (int i = 2; i &lt;= 1e7; ++i)
    if (!vis[i]) primes[++cnt] = i;
}

namespace MaxFlow { //网络流
#define INF 0x3f3f3f3f
  int p[N] = {0}, inc[N];
  bool vis[N];
  int q[N];
  void Init () { memset(p, 0, sizeof(p)), memset(inc, 0, sizeof(inc)); }
  bool BFS () {
    memset(vis, false, sizeof(vis));
    int head = 0, back = 1;
    vis[s] = true, inc[s] = INF; q[1] = s;
    while (head &lt; back) {
      int nowfront = q[++head];
      for (int ind = tail[nowfront]; ind; ind = pre[ind]) {
        if (!val[ind]) continue ;
        if (vis[to[ind]]) continue ;
        inc[to[ind]] = min(inc[nowfront], val[ind]);
        vis[to[ind]] = true, q[++back] = to[ind], p[to[ind]] = ind;
        if (to[ind] == t) return true;
      }
    }
    return false;
  }
  void Work () {
    int cur = t;
    while (cur ^ s) {
      int las = p[cur];
      val[las] -= inc[t], val[las ^ 1] += inc[t];
      cur = to[las ^ 1];
    }
    ans += inc[t];
    return ;
  }
}

int main() {
  scanf("%d", &amp;T);
  Prework();
  while (T--) {
    scanf("%d%d", &amp;n, &amp;m); s = n + m + 1, t = n + m + 2;
    memset(pre, 0, sizeof(pre)), memset(tail, 0, sizeof(tail));
    tot = 1; ans = 0;
    for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;b[i]), addEdge(s, i, 1); //左边的超级源点向i连边
    for (int i = 1; i &lt;= m; ++i) scanf("%d", &amp;r[i]), addEdge(i + n, t, 1); //右边的超级源点向i+n连边（至于为什么是i+n就不用解释了吧）
    for (int i = 1; i &lt;= n; ++i) {
      for (int j = 1; j &lt;= cnt; ++j) {
        if (primes[j] &gt; b[i]) break ;
        if (b[i] % primes[j] == 0) addEdge(i, j + n + m + 2, 1); //找到质因数然后建边
      }
    }
    for (int i = 1; i &lt;= m; ++i) {
      for (int j = 1; j &lt;= cnt; ++j) {
        if (primes[j] &gt; r[i]) break ;
        if (r[i] % primes[j] == 0) addEdge(j + n + m + 2, i + n, 1);
      }
    }
    while (MaxFlow::BFS()) MaxFlow::Work();
    printf("%d\n", ans);
  }
  return 0;
} 

```

至于时间复杂度：不会算。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745457.html</id>
    <title type="text">CF1514C Product 1 Modulo N 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-05-08T08:24:00Z</published>
    <updated>2021-05-08T08:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745457.html" />
    <content type="text">~~赛时想了一下就过了~~

一个显然的结论：给定一个正整数 $n$，很多个与 $n$ 互质的正整数的积与 $n$ 互质。

由于这题要求的数的乘积被 $n$ 除余 $1$，所以这些数都是与 $n$ 互质的。

所以长度 $\leq$ $n$ 的既约剩余系长度（指的就是 $1\sim n$ 与 $n$ 互质的数的个数）。

由于这些数的乘积 $\bmod n$ 不一定为 $1$，所以要考虑去掉一些最少的数使得剩下的数的积满足条件。然后很明显去掉这个乘积 $\bmod n$ 即为最多的情况。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 1e5 + 5;

int n, tot, a[N];

int gcd (int m, int n) {
  if (m &lt; n) swap(m, n);
  if (n == 0) return m;
  return gcd(n, m % n);
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    if (gcd(i, n) == 1) a[++tot] = i;
  }
  int times = 1;
  for (int i = 1; i &lt;= tot; ++i) {
    times = 1ll * times * a[i] % n;
  }
  if (times == 1) {
    cout &lt;&lt; tot &lt;&lt; endl;
    for (int i = 1; i &lt;= tot; ++i) cout &lt;&lt; a[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
  }
  if (times &gt; 1) {
    cout &lt;&lt; tot - 1 &lt;&lt; endl;
    for (int i = 1; i &lt;= tot; ++i)
      if (a[i] != times) cout &lt;&lt; a[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
  }
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/14745469.html</id>
    <title type="text">P2472 [SCOI2007]蜥蜴 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-05-02T14:21:00Z</published>
    <updated>2021-05-02T14:21:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/14745469.html" />
    <content type="text">很明显这题要拆点，因为蜥蜴跳上去的个数是有限的。

超级源点直接向左边那一堆点连流量为 $1$ 的边即可（只可能遍历一次）。

处理蜥蜴跳来跳去的情况只需要用拆出来的点向最开始没拆的点连流量为 $\infty$ 的边就行（顺序要搞对）。

然后右边那一堆点如果能跳到图外，就向超级汇点连流量为 $\infty$ 的边（注意：这里是可以经过多次的，因为上面蜥蜴可以从一个点跳到另一个点）。

[代码](https://www.luogu.com.cn/paste/wl4y3d39)。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15191397.html</id>
    <title type="text">2021-08-26 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-08-26T12:25:00Z</published>
    <updated>2021-08-26T12:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15191397.html" />
    <content type="text">[题目](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/izbhwwkq)

[出题人题解](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/9b1scj2o)

- T1

区间DP。

显然，合并后的集合一定是连续的一段。
定义 $f[l][r]$ 表示从第 $l$ 个集合开始，合并到第 $r$ 个集合的最大收益。
这里令集合 $T$ 表示从 $l$ 合并到 $r$ 之后的集合。
显然，$|T|=S_l,S_{l+1},..., S_r$ 中不同元素的个数。

然后就能够随便转移了，时间复杂度：$O(n^3)$。

- T2

贪心。

跟蜗牛爬井问题差不多，先按一天内向上爬的高度从大到低排序，如果有多个高度相同则按上午向上爬的高度**从低到高**排序。

然后定义 $f_i$ 表示在 $i\sim n$ 这些天里上午向上爬的高度的最大值，然后就如果前面 $i - 1$ 天总共爬的再加上 $f_i$ 后大于等于 $L$ 的话就相当于在第 $i$ 天爬出去了，如果这些天能爬的最高高度小于雨水的高度的话就直接输出 $-1$ 即可。

时间复杂度：$O(n\log n)$。

upd：这个做法假了，需要套个二分，复杂度：$O(n\log^2 n)$

- T3

博弈论，二分图染色，不会。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15205411.html</id>
    <title type="text">[NOIP2017 提高组] 逛公园 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-08-30T04:50:00Z</published>
    <updated>2021-08-30T04:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15205411.html" />
    <content type="text">[题目](https://www.luogu.com.cn/problem/P3953)

- $\text{30pts}$

显然就是[这道题](https://www.luogu.com.cn/problem/P1144)。

- $\text{100pts}$

肯定要跑最短路的。令 $d_i$ 表示 $i$ 到 $n$ 的最短路长度。
$f_{u,i}$ 表示从 $u$ 到 $n$ 长度为 $d_u+i$ 的路径个数。

$dis$ 数组显然可以建反图然后跑源点为 $n$ 的最短路。

考虑 $f$ 数组的转移。

$$f_{u,i}=\sum{f_{v,i-(d_v+w-d_u)}}$$

其中，存在 $u$ 到 $v$ 的边且边权为 $w$。
可以这样做的原因就是 $d_v+w-d_u$ 就是给 $v$ 给 $u$ 的路径距离最短路“偏差”的贡献，这样的话 $v$ 中的偏差就必须为 $i-(d_v+w-d_u)$。

这样可以直接记忆化搜索也可以就跑一遍拓扑排序，我是用记搜写的。
有无数种的路线的情况就是有边权均为 $0$ 的环，在记搜里面记录个 $e_{u,i}$ 数组即可，如果此时数组值为真的话就相当于找到了边权为 $0$ 的环。

显然时间复杂度 $O(m\log m+nk)$。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;
	
```cpp
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

using LL = long long;

const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;

struct Edge {
  int to, w;
  
  Edge () {}
  Edge (int _to, int _w) { to = _to, w = _w; }
  ~Edge () {}
};

struct Node {
  int id, dis;
  
  Node () {}
  Node (int _id, int _dis) { id = _id, dis = _dis; }
  ~Node () {}
  
  friend bool operator &lt; (const Node&amp; n1, const Node&amp; n2) {
    return n1.dis &gt; n2.dis;
  }
};

vector &lt;Edge&gt; G[N], rG[N];
priority_queue &lt;Node&gt; q;

int T, n, m, k, p;
int u, v, w;
LL f[N][55], dis[N];
bool flag, vis[N], exi[N][55];

int add (int x, int y) {
  return (x + y &gt;= p) ? (x + y - p) : (x + y);
}

void init () {
  flag = false;
  for (int i = 1; i &lt;= n; ++i) {
    G[i].clear(), rG[i].clear();
    for (int j = 0; j &lt;= k; ++j)
      f[i][j] = -1;
  }
  while (!q.empty())
    q.pop();
}

void AddEdge (int u, int v, int w) {
  G[u].push_back(Edge(v, w));
  rG[v].push_back(Edge(u, w));
}

void Dijkstra (int s) {
  fill(dis + 1, dis + 1 + n, INF), 
  fill(vis + 1, vis + 1 + n, false);
  q.push(Node(s, 0)), dis[s] = 0;
  while (!q.empty()) {
    Node nowtop = q.top(); q.pop();
    int nowid = nowtop.id;
    if (vis[nowid]) continue ;
    vis[nowid] = true;
    for (auto Ed : rG[nowid]) {
      int to = Ed.to, w = Ed.w;
      if (dis[to] &gt; dis[nowid] + w) {
        dis[to] = dis[nowid] + w;
        q.push(Node(to, dis[to]));
      }
    }
  }
}

LL Solve (int x, int y) {
  if (exi[x][y]) {
    flag = true;
    return 0;
  }
  if (f[x][y] &gt; 0)
    return f[x][y];
//  f[x][y] = 0;
  exi[x][y] = true;
  LL ret = 0;
  for (auto Ed : G[x]) {
    int to = Ed.to, w = Ed.w;
    int temp = y - (dis[to] + w - dis[x]);
    if (temp &lt; 0 || temp &gt; k) continue ;
    ret = add(ret, Solve(to, temp));
    if (flag) return 0;
  }
  if (x == n &amp;&amp; !y)
    ret = 1;
  exi[x][y] = false;
  return f[x][y] = ret;
}

int main() {
  scanf("%d", &amp;T);
  while (T--) {
    init();
    scanf("%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;p);
    for (int i = 1; i &lt;= m; ++i) {
      scanf("%d%d%d", &amp;u, &amp;v, &amp;w);
      AddEdge(u, v, w);
    }
    Dijkstra(n);
    LL res = 0;
    for (int i = 0; i &lt;= k; ++i) {
      for (int j = 1; j &lt;= n; ++j)
        for (int s = 0; s &lt;= k; ++s)
          exi[j][s] = false;
      res = add(res, Solve(1, i));
    }
    printf("%lld\n", flag ? -1 : res);
  }
  return 0;
}
```

&lt;/details&gt;

貌似不开 O2 过不了（</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15302171.html</id>
    <title type="text">[数学]卡特兰数-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-09-16T12:21:00Z</published>
    <updated>2021-09-16T12:21:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15302171.html" />
    <content type="text">## 前言

卡特兰数是初赛中比较重要的数学知识，所以写篇博客总结一下。

## 定义

![](https://i.loli.net/2019/08/04/MKCVdjvW8GoaSF5.png)

用 $C_n$ 表示从 $(0,0)$ 出发，每次只能向右或向上走 1 步，且 $x$ 轴的值始终不小于 $y$ 轴的值，到 $(n,n)$的方案种数。

## 通项+证明

$$C_n=\dfrac{1}{n+1}\left(\begin{matrix}2n \\ n\end{matrix}\right)$$

证明：

![](https://img2018.cnblogs.com/blog/1440636/201908/1440636-20190804140509202-1893391382.png)

不考虑越过线的情况的话显然有 $\left(\begin{matrix}2n \\ n\end{matrix}\right)$ 种情况。

考虑非法的情况，令直线 $l:y=x+1$，那么每一个非法的方案都与 $l$ 有至少 1 个交点。

对于每一个方案，我们取 $x$ 值最小且在 $l$ 上的点记为 $p(x_1,y_1)$，将 $x&gt;x_1,y\leq x$ 的点沿 $l$ 对称，那么就变为从 $(0,0)$ 到 $(n-1,n+1)$ 的路径了，显然是一个映射，所以有 $\left(\begin{matrix}2n \\ {n-1}\end{matrix}\right)$ 种非法方案。

所以 $C_n=\left(\begin{matrix}2n \\ n\end{matrix}\right) -  \left(\begin{matrix}2n \\ {n-1}\end{matrix}\right)$。

## 化简

$$
\begin{aligned}
C_n=&amp;\left(\begin{matrix}2n \\ n\end{matrix}\right) -  \left(\begin{matrix}2n \\ {n-1}\end{matrix}\right) \\
=&amp;\dfrac{(2n)!}{n!\cdot n!}-\dfrac{(2n)!}{(n-1)!\cdot (n+1)!}\\
=&amp;(2n)!\cdot\bigg[\dfrac{(n+1)-n}{n!\cdot (n+1)!}\bigg]\\
=&amp;\dfrac{1}{n+1}\left(\begin{matrix}2n \\ n\end{matrix}\right)
\end{aligned}
$$

## 应用

1. $n$ 对括号的合法配对方案书
2. $n$ 个节点的二叉树的形态数
3. $n+1$ 个叶子（$n$ 个非叶节点）的满二叉树的形态数, 走到左儿子 $+1$,走到 右儿子 $-1$,类似于括号匹配(大致同2)
4. $n$ 个数入栈后出栈的排列总数
5. 对凸 $n+2$ 边形进行不同的三角形分割的方案数(分割线断点仅为顶点，且分割线仅在顶点上相交)
6. $n$ 层的阶梯切割为 $n$ 个矩形的切法数

转自 &lt;https://www.cnblogs.com/linzhengmin/p/11298140.html&gt;。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15317595.html</id>
    <title type="text">P4591 [TJOI2018]碱基序列 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-09-21T11:27:00Z</published>
    <updated>2021-09-21T11:27:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15317595.html" />
    <content type="text">一道字符串&amp;DP好题。

## 题意

给你一个字符串 $s$，还有 $k$ 组字符串，问你从每组字符串中只选一个字符串，且按顺序排列后连接起来的串为 $s$ 的子串的选择种数有多少个，对 $1\text{e}9+7$ 取模。

## 题解

显然是道 DP。

定义 $f_{i,j}$ 表示按顺序选到第 $i$ 组串且连接起来的字符串匹配到 $s$ 的第 $j$ 个位置的种数。

显然不是每个状态都能转移到 $f_{i,j}$。当且仅当第 $i$ 组中的某个字符串被 $s$ 从 $j$ 结尾的最后几个字符匹配才能转移，这样就好办了。

用哈希判断就可以了，也可以用 KMP，但我觉得哈希对于这题来说更简单。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

using namespace std;

typedef unsigned long long ULL;

const int N = 1e4 + 5;
const int K = 1e2 + 5;
const int MOD = 1e9 + 7;
const int BASE = 13331;

string s, a[K][15];
int k, n, c[K], f[K][N];
ULL hs[N], hsh[K][15], pw[N];

void Prework () {
  pw[0] = 1;
  for (int i = 1; i &lt;= n; ++i)
    pw[i] = pw[i - 1] * BASE;
  hs[0] = s[0];
  for (int i = 1; i &lt; n; ++i)
    hs[i] = hs[i - 1] * BASE + s[i];
//  for (int i = 0; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; hs[i] &lt;&lt; endl;
}

ULL Gethsh (int l, int r) {
  if (!l) return hs[r];
  return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int main() {
  cin &gt;&gt; k &gt;&gt; s;
  n = s.size();
  for (int i = 1; i &lt;= k; ++i) {
    cin &gt;&gt; c[i];
    for (int j = 1; j &lt;= c[i]; ++j) {
      cin &gt;&gt; a[i][j];
      int len = a[i][j].size();
      for (int s = 0; s &lt; len; ++s)
        hsh[i][j] = hsh[i][j] * BASE + a[i][j][s];
//      if (i == 1) {
//        for (int s = 0; s + len - 1 &lt; n; ++s)
//          f[i][s + len - 1] += 1 * (Gethsh(s, s + len - 1) == hsh[i][j]);
//      }
    }
  }
  Prework();
  for (int i = 0; i &lt; n; ++i)
    f[0][i] = 1;
  for (int i = 1; i &lt;= k; ++i)
    for (int j = 1; j &lt;= c[i]; ++j) {
      int len = a[i][j].size();
//      cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
      for (int s = len - 1; s &lt; n; ++s) {
        f[i][s + 1] = (f[i][s + 1] + (hsh[i][j] == Gethsh(s - len + 1, s)) * f[i - 1][s - len + 1]) % MOD;
//        cout &lt;&lt; "***" &lt;&lt; hsh[i][j] &lt;&lt; " " &lt;&lt; Gethsh(s - len + 1, s) &lt;&lt; endl;
//        if (hsh[i][j] == Gethsh(s - len + 1, s)) puts("!!!");
      }
    }
  
  int ans = 0;
  for (int i = 0; i &lt; n; ++i)
    ans = (ans + f[k][i + 1]) % MOD;
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15393497.html</id>
    <title type="text">P7629 [COCI2011-2012#1] SORT 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-10-11T07:14:00Z</published>
    <updated>2021-10-11T07:14:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15393497.html" />
    <content type="text">## sort

这题题意就是给定有 $n$ 个数的数组 $a$，每次将 $a$ 划分为多个连续的下降区间，将每个有至少两个数的区间翻转。问让 $a$ 排好序需要至少多少次翻转。

$O(n^2)$ 的做法很显然，就按题意模拟即可，考虑优化。

假设第一次数组 $a$ 划分成了 $[1,2,\dots,p_1],[p_1+1,p_1+2,\dots,p2],\dots,[p_{s-1}+1,p_{s-2}+1,...,p_s](p_s=n)$，那么做完第一次轮反转操作后，每一个区间都是按从小到大排好序的。那么做第二轮操作时，下降区间就只能跨越第一轮的相邻区间。比如说：```4 2 3 1```，第一轮为 ```4 2 | 3 1```，翻转之后变成了 ```2 4 | 1 3```，第二次下降区间只有 ```4 1```。然后有个显而易见的结论就是第二次以后的下降区间长度只能为 $2$。

那么问题就转换为了每次交换相邻的数，问排好序之后的最小交换次数。然后逆序对做就行了。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

const int N = 1e5 + 5;

int n;
LL ans;
int a[N], cut[N];

class BIT {
  public:
    void upd (int x, int v) {
      for (; x &lt;= n; x += x &amp; -x)
        c[x] += v;
    }
    LL qry (int x) {
      LL ret = 0;
      for (; x; x -= x &amp; -x)
        ret += c[x];
      return ret; 
    }
  private:
    LL c[N];
} t ;

bool check () {
  for (int i = 1; i &lt;= n; ++i)
    if (a[i] != i) return false;
  return true;
}

void solve () {
  int cnt = 0;
  for (int i = 1; i &lt;= n; ++i)
    if (a[i] &lt; a[i + 1])
      cut[++cnt] = i;
  for (int i = 1; i &lt;= cnt; ++i)
    if (cut[i] - cut[i - 1] != 1) {
      reverse(a + cut[i - 1] + 1, a + cut[i] + 1);
      ++ans;
    }
  for (int i = 1; i &lt;= n; ++i) {
    ans += i - 1 - t.qry(a[i]);
    t.upd(a[i], 1);
  }
  cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
  // freopen("sort.in", "r", stdin);
  // freopen("sort.out", "w", stdout);
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    cin &gt;&gt; a[i];
  a[n + 1] = n + 1;
  solve();
  cerr &lt;&lt; clock() * 1.0 / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl;
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15496722.html</id>
    <title type="text">缺省源-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-11-01T15:24:00Z</published>
    <updated>2021-11-01T15:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15496722.html" />
    <content type="text">```cpp
/*
I hope JLQ can bless me to AC the problem.
*/
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {

  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/articles/15506051.html</id>
    <title type="text">BGP-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-11-03T14:25:00Z</published>
    <updated>2021-11-03T14:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/articles/15506051.html" />
    <content type="text"># BGP
愿来日再用键盘打代码的你，是进队了的
----- 2021.11.3</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15708356.html</id>
    <title type="text">P4302 [SCOI2003]字符串折叠 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-12-19T11:47:00Z</published>
    <updated>2021-12-19T11:47:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15708356.html" />
    <content type="text">## [SCOI2003]字符串折叠

一道比较普通的 **区间DP** 题。

题意：定义了折叠操作，如 $\texttt{ABCABC}$ 可折叠为 $\texttt{2(ABC)}$，也可以嵌套折叠。注意：字符串中两位数是算两个数位。问折叠操作后最小的字符串长度。

首先，题目意思很清楚，~~而且如果不算折叠就是输出字符串原长~~，折叠这个操作是一个区间一个区间来的，所以可以用区间DP来做。

定义状态：$f_{i,j}$ 表示字符串 $s[i,i+1,...,j]$ 折叠后的最小长度。

关于状态转移，分两种情况考虑：
1. 这个区间不是折叠构成的，那么就按照套路枚举中间点正常转移即可。
2. 这个区间是由折叠构成的，那么枚举这个折叠字符串的区间长度，判大字符串是否有这个折叠字符串构成即可。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
/*
I hope JLQ can bless me to AC the problem.
*/
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 105;

int n, f[N][N];
string s;

int JLQ (int x) {
  int cnt = 0;
  while (x) ++cnt, x /= 10;
  return cnt;
}

bool check (int l, int r, int k) {
  if ((r - l + 1) % k != 0) return false;
  int c = (r - l + 1) / k;
  for (int i = 0; i &lt; k; ++i) {
    int t = l + i;
    for (int j = 0; j &lt; c; ++j)
      if (s[t + k * j] != s[t]) return false;
  }
  return true;
}

int main() {
  cin &gt;&gt; s;
  n = s.size(); s = " " + s;
  memset(f, 0x3f, sizeof(f));
  for (int i = 1; i &lt;= n; ++i)
    f[i][i] = 1;
  for (int len = 2; len &lt;= n; ++len) {
    for (int i = 1; i + len - 1 &lt;= n; ++i) {
      int j = i + len - 1;
      f[i][j] = len;
      for (int k = i; k &lt; j; ++k)
        f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
      for (int k = 1; i + k - 1 &lt;= j; ++k)
        if (check(i, j, k))
          f[i][j] = min(f[i][j], JLQ((j - i + 1) / k) + 2 + f[i][i + k - 1]);
    }
  }
//  cerr &lt;&lt; "***" &lt;&lt; f[6][11] &lt;&lt; endl;
  printf("%d\n", f[1][n]);
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15730079.html</id>
    <title type="text">ABC232 部分题目题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2021-12-25T03:28:00Z</published>
    <updated>2021-12-25T03:28:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15730079.html" />
    <content type="text">- ## A

不讲，[代码](https://atcoder.jp/contests/abc232/submissions/28097669)。

- ## B

挨个判断每一位需要做多少次即可，$O(|S|)$。

[代码](https://atcoder.jp/contests/abc232/submissions/28097743)。

- ## C

题目已经给你判断相同图的方法了，注意到 $n\leq 8$ 所以直接阶乘枚举编号即可，$O(n^2\cdot n!)$。

[代码](https://atcoder.jp/contests/abc232/submissions/28097880)。

- ## D

典型的标数法。

设 $f[i][j]$ 表示从 $(1,1)$ 走到 $(i,j)$ 中经过的最多的空方块个数。若无法走到则 $f[i][j]$ 设为 $-1$。

初始化：处理出第一行和第一列，如果当前格为障碍，则其再往右或往下均为 $-1$。

状态转移：
如果 $f[i-1][j]$ 和 $f[i][j-1]$ 均为 $-1$ 或者 $(i,j)$ 本身就是障碍，则 $f[i][j]$ 也应设为 $-1$。

否则，取 $f[i-1][j]$ 和 $f[i][j-1]$ 中的那个不是 $-1$ 的转移，不妨设 $f[i-1][j] \neq -1$，则 $f[i][j] = f[i-1][j] +1$。

时间复杂度：$O(nm)$。

[代码](https://atcoder.jp/contests/abc232/submissions/28098021)。

- ## E

假设一矩阵 $M_k$ 表示車从 $(x1,y1)$ 出发后移动 $k$ 步后到每一个格子的方法种数。

易知：

$$
M_0=
\begin{bmatrix}
0 &amp; \cdots &amp; 0\\
\vdots&amp; \vdots &amp; \vdots\\
0&amp;\cdots 1\cdots &amp;0\\
\vdots&amp; \vdots &amp; \vdots\\
0&amp;\cdots &amp; 0\\
\end{bmatrix}
$$

且 $M_k$ 中的 $(i,j)$ 上的数即为 $M_{k-1}$ 中第 $i$ 行 与第 $j$ 列上所有数的和（不算 $(i,j)$）。

可以发现一个事实：对于任意 $M_k$，第 $x1$ 行上的数（不算 $(i,j)$） 全部相同，第 $y1$ 列上的数（不算 $(i,j)$） 全部相同，其余所有的数也全部相同。

那么可以设：

$$
M_k=
\begin{bmatrix}
d &amp; d&amp; \cdots b&amp; \cdots d&amp;\\
d &amp; d&amp; \cdots b&amp; \cdots d&amp;\\
\vdots&amp; \vdots&amp; \cdots \vdots&amp;\cdots\vdots&amp; \\
c &amp; c&amp; \cdots a&amp; \cdots c&amp;\\
d &amp; d&amp; \cdots b&amp; \cdots d&amp;\\
\vdots&amp; \vdots&amp; \cdots \vdots&amp; \cdots\vdots&amp; \\
d &amp; d&amp; \cdots b&amp; \cdots d&amp;\\
\end{bmatrix}
$$

则可得出递推式子：

$$
\begin{cases}
a=(n-1)b_0+(m-1)c_0\\
b=a_0+(n-2)b_0+(m-1)d_0\\
c=a_0+(m-2)c_0+(n-1)d_0\\
d=b_0+c_0+(n+m-4)d_0
\end{cases}
$$

复杂度 $O(k)$，可以过，[代码](https://atcoder.jp/contests/abc232/submissions/28098528)。

### 优化

这个式子显然可以矩阵递推。

设 $A_k=\begin{bmatrix}a,b,c,d\end{bmatrix}$。

$$
A_k=A_{k-1}*
\begin{bmatrix}
0&amp;n-1&amp;m-1&amp;0\\
1&amp;n-2&amp;0&amp;m-1\\
1&amp;0&amp;m-2&amp;n-1\\
0&amp;1&amp;1&amp;n+m-4
\end{bmatrix}
$$

那么就可以 $O(\log k)$ 了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15839298.html</id>
    <title type="text">P5123 [USACO18DEC]Cowpatibility G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-01-24T06:32:00Z</published>
    <updated>2022-01-24T06:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15839298.html" />
    <content type="text">## P5123 [USACO18DEC]Cowpatibility G

这题正着直接做显然不行，所以要反着容斥做。

记录 $f_i$ 表示从第 $1\sim i-1$ 头奶牛中可以和第 $i$ 头奶牛和谐共处的头数。

$f_i=\text{有1个数与 i 中的匹配的个数}-\text{有2个数与 i 中的匹配的个数}+\text{有3个数与 i 中的匹配的个数}-\text{有4个数与 i 中的匹配的个数}+\text{有5个数与 i 中的匹配的个数}$ 。

这个匹配的个数显然可以用 $5$ 个 $\text{map+tuple}$ 记，每次算完 $f_i$ 就将 $i$ 这头牛的信息加入 $\text{map}$ 即可。

时间复杂度：$O(64\cdot n\log n)$，不开 $O2$ 过不了。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;
	
```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

using ll = long long;

const int kMaxN = 5e4 + 5;

map &lt;tuple &lt;int&gt;, int&gt; mp1;
map &lt;tuple &lt;int, int&gt;, int&gt; mp2;
map &lt;tuple &lt;int, int, int&gt;, int&gt; mp3;
map &lt;tuple &lt;int, int, int, int&gt;, int&gt; mp4;
map &lt;tuple &lt;int, int, int, int, int&gt;, int&gt; mp5;
int n;
int s[6], a, b, c, d, e;
ll ans;

int main() {
  scanf("%d", &amp;n);
  for (int i = 1; i &lt;= n; ++i) {
    scanf("%d%d%d%d%d", &amp;s[1], &amp;s[2], &amp;s[3], &amp;s[4], &amp;s[5]);
    sort(s + 1, s + 6);
    a = s[1], b = s[2], c = s[3], d = s[4], e = s[5];
    ans += i - 1;
    ans -= mp1[make_tuple(a)] + mp1[make_tuple(b)] + mp1[make_tuple(c)] + mp1[make_tuple(d)]
         + mp1[make_tuple(e)];
    ans += mp2[make_tuple(a, b)] + mp2[make_tuple(a, c)] + mp2[make_tuple(a, d)] + mp2[make_tuple(a, e)]
         + mp2[make_tuple(b, c)] + mp2[make_tuple(b, d)] + mp2[make_tuple(b, e)] + mp2[make_tuple(c, d)]
         + mp2[make_tuple(c, e)] + mp2[make_tuple(d, e)];
    ans -= mp3[make_tuple(a, b, c)] + mp3[make_tuple(a, b, d)] + mp3[make_tuple(a, b, e)]
         + mp3[make_tuple(a, c, d)] + mp3[make_tuple(a, c, e)] + mp3[make_tuple(a, d, e)]
         + mp3[make_tuple(b, c, d)] + mp3[make_tuple(b, c, e)] + mp3[make_tuple(b, d, e)]
         + mp3[make_tuple(c, d, e)];
    ans += mp4[make_tuple(a, b, c, d)] + mp4[make_tuple(a, b, c, e)] + mp4[make_tuple(a, b, d, e)]
         + mp4[make_tuple(a, c, d, e)] + mp4[make_tuple(b, c, d, e)];
    ans -= mp5[make_tuple(a, b, c, d, e)];
    ++mp1[make_tuple(a)], ++mp1[make_tuple(b)], ++mp1[make_tuple(c)], ++mp1[make_tuple(d)], 
    ++mp1[make_tuple(e)];
    ++mp2[make_tuple(a, b)], ++mp2[make_tuple(a, c)], ++mp2[make_tuple(a, d)], ++mp2[make_tuple(a, e)], 
    ++mp2[make_tuple(b, c)], ++mp2[make_tuple(b, d)], ++mp2[make_tuple(b, e)], ++mp2[make_tuple(c, d)], 
    ++mp2[make_tuple(c, e)], ++mp2[make_tuple(d, e)];
    ++mp3[make_tuple(a, b, c)], ++mp3[make_tuple(a, b, d)], ++mp3[make_tuple(a, b, e)], 
    ++mp3[make_tuple(a, c, d)], ++mp3[make_tuple(a, c, e)], ++mp3[make_tuple(a, d, e)], 
    ++mp3[make_tuple(b, c, d)], ++mp3[make_tuple(b, c, e)], ++mp3[make_tuple(b, d, e)], 
    ++mp3[make_tuple(c, d, e)];
    ++mp4[make_tuple(a, b, c, d)], ++mp4[make_tuple(a, b, c, e)], ++mp4[make_tuple(a, b, d, e)], 
    ++mp4[make_tuple(a, c, d, e)], ++mp4[make_tuple(b, c, d, e)];
    ++mp5[make_tuple(a, b, c, d, e)];
  }
  printf("%lld\n", ans);
  cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl;
  return 0;
}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/15853617.html</id>
    <title type="text">数论学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-01-28T11:28:00Z</published>
    <updated>2022-01-28T11:28:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/15853617.html" />
    <content type="text">概念不说了。

## 同余方程

同余方程基本形式：$ax\equiv c(\text{mod}\space b)$。

$ax\equiv c(\text{mod}\space b)\Longleftrightarrow \exists y\in \mathbb{Z},s.t. ax+by=c$

$ax+by=c$ 就可以用扩展欧几里得来求。

代码：

```cpp
int exgcd (int a, int b, int&amp; x, int&amp; y) {
  if (!b) {
    x = 1, y = 0;
    return a;
  }
  int d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
```

## 乘法逆元

若 $ax\equiv 1(\text{mod}\space p)$，并且 $(a,p)=1$，则称 $a$ 与 $x$ 在 $\text{mod}\space p$ 下互为逆元，$x=\text{inv}(a)$。

### 求解乘法逆元的方法：

1. 扩欧，相当于 解 $ax\equiv 1(\mod\space p)$。适合求某一个数的逆元。
2. 费马小定理，若 $p$ 是质数，且 $(a,p)=1$，则 $a^{p-1}\equiv 1(\text{mod} p)$，那么 $\text{inv}(a)=a^{p-2}$。适用于 $p$ 为质数的情况。
3. 线性递推求逆元，适合求 $1\sim n$ 的逆元。

$$
设\space p=aq+r,q=\bigg\lfloor\dfrac{p}{a}\bigg\rfloor，r=p\bmod a\\

\begin{aligned}
aq+r&amp;\equiv 0(\text{mod}\space p)\\
aq&amp;\equiv -r(\text{mod}\space p)\\
a&amp;\equiv -r\cdot \text{inv}(q)(\text{mod}\space p)\\
\text{inv}(a)&amp;\equiv -q\cdot \text{inv}(r)(\text{mod}\space p)\\
\end{aligned}\\

那么\space \text{inv}[a]=-\bigg\lfloor\dfrac{p}{a}\bigg\rfloor\cdot \text{inv}[p\bmod a]
$$

总之，我觉得要求单个的逆元就用扩欧，多个的逆元就用线性递推，费马小定理随便。

## 中国剩余定理

这里直接讲扩展中国剩余定理。

定义：线性同余方程组，不要求模数两两互质。

$$
\begin{cases}
p_1\equiv a_1(\text{mod}\space m_1)\\
p_2\equiv a_2(\text{mod}\space m_2)\\
\space\space\space\space\space
\space\vdots\\
p_n\equiv a_n(\text{mod}\space m_n)\\
\end{cases}
$$

就是求这个方程的一个解。

### 解法

采用数学归纳法。

1. 假设前 $k-1$ 个方程的特解为 $x$，那么通解为 $x+t\cdot M$，其中 $M=\text{lcm}(m_1,m_2,\dots,m_{k-1})$。
2. 求解 $t$，使得 $x+t\cdot M\equiv a_k(\text{mod}\space m_k)$。
3. exgcd 判断是否有解，若有解，则 $x\gets x+t\cdot M$。

代码：

```cpp
#include &lt;bits/stdc++.h&gt;
#define int long long

using namespace std;

const int kMaxN = 1e5 + 5;

int n, a[kMaxN], b[kMaxN];
int M = 1;
__int128 res, x, y;

__int128 mod (__int128 x, __int128 m) {
  return (x % m + m) % m;
}

__int128 add (__int128 x, __int128 y, __int128 m) {
  return (x + y &gt;= m) ? (x + y - m) : (x + y);
}

__int128 times (__int128 x, __int128 y, __int128 m) {
  return 1ll * x * y % m;
}

__int128 gcd (__int128 m, __int128 n) {
  return (!n) ? m : gcd(n, m % n);
}

__int128 lcm (__int128 m, __int128 n) {
  return m / gcd(m, n) * n;
}

__int128 exgcd (__int128 a, __int128 b, __int128&amp; x, __int128&amp; y) {
  if (!b) {
    x = 1, y = 0;
    return a;
  }
  __int128 d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}

__int128 inv (__int128 a, __int128 m) {
  __int128 x, y;
  exgcd(a, m, x, y);
  return mod(x, m);
} 

signed main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i] &gt;&gt; b[i];
  }
  res = b[1], M = a[1];
  for (int i = 2; i &lt;= n; ++i) {
    __int128 s = mod(b[i] - mod(res, a[i]), a[i]);
    __int128 d = exgcd(M, a[i], x, y);
    __int128 m = M;
    M = lcm(M, a[i]);
    x = mod(times(x, s / d, a[i]), a[i]);
//    cout &lt;&lt; "***" &lt;&lt; i &lt;&lt; ' ' &lt;&lt; res &lt;&lt; endl;
    res += times(x, m, M);
    res = mod(res, M);
  }
//  cout &lt;&lt; exgcd(4, 48, x, y) &lt;&lt; endl;
  cout &lt;&lt; (long long)res &lt;&lt; endl;
  return 0;
}
```

## 欧拉函数

对于 $n\in \mathbb{Z}^{+}$，$\varphi(n)$ 表示 $1\sim n$ 中与 $n$ 互质的正整数个数。

- 性质一：若 $p$ 是质数，$\varphi(p^{n})=p^{n-1}\cdot(p-1)$。
- 性质二：若 $a|x$，$\varphi(ax)=a\cdot\varphi(x)$。
- 性质三：若 $(a,b)=1$，$\varphi(ab)=\varphi(a)\cdot \varphi(b)$。

公式：

$$
\text{If}\space n=\prod_{i=1}^{k}{p_i^{\alpha_i}},
\text{then}\space \varphi(n)=n\cdot\prod_{i=1}^{k}\dfrac{p_{i}-1}{p_{i}}
$$

## 欧拉定理

若 $(a,m)=1$，$a^{\varphi(m)}\equiv 1(\text{mod}\space m)$。

推论：$a^b\equiv a^{b\bmod \varphi(m)}(\text{mod}\space m)$。

若 $b\geq \varphi(m)$，则 $a^b\equiv a^{b\bmod\varphi(m)+\varphi(m)}(\text{mod}\space m)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16063871.html</id>
    <title type="text">莫比乌斯反演学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-03-27T10:44:00Z</published>
    <updated>2022-03-27T10:44:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16063871.html" />
    <content type="text">## 数论函数

定义：定义域是正整数，值域是复数的函数。

## 狄利克雷卷积

1. 定义：

$$
\begin{aligned}
(f\ast g)(n)=&amp;\sum_{d|n,d\in{\mathbb{N}}}{f(d)\cdot g\bigg(\dfrac{n}{d}\bigg)}\\
=&amp;\sum_{d|n,d\in{\mathbb{N}}}{f\bigg(\dfrac{n}{d}\bigg)\cdot g(d)}
\end{aligned}
$$

## 常用的数论函数

1. 单位函数：

$$
\varepsilon(n)=
\begin{cases}
1&amp; n=1\\
0&amp; \text{其它}
\end{cases}
$$

2. 幂函数：

$$
Id_{k}(n)=n^k
$$

- 当 $k=1$ 时，$Id_{k}(n)$ 可以表示为 $Id(n)$。
- 当 $k=0$ 时，$Id_{k}(n)$ 可以表示为 $I(n)$。

3. 除数函数：

$$
\sigma_{k}(n)=\sum_{d|n}{d^k}
$$

4. 欧拉函数

$$
\varphi(n)=n\cdot\prod_{i=1}^{k}{\dfrac{p_i-1}{p_i}}
$$

## 积性函数

1. 定义：积性函数是指对于所有互质的正整数 $a,b$，都有 $f(ab)=f(a)\cdot f(b)$ 的数论函数。
另：完全积性函数指任意两个正整数 $a,b$，都有 $f(ab)=f(a)\cdot f(b)$ 的数论函数。

2. 性质：若 $f$ 是一个积性函数，那么 $f(1)=1$。

## 狄利克雷卷积的常用定理

1. 若 $f,g$ 都是积性函数，那么 $f\ast g$ 也是积性函数。
2. 交换律：$f\ast g=g\ast f$
3. 结合律：$(f\ast g)\ast h=f\ast(g\ast h)$
4. 分配律：$f\ast(g+h)=f\ast g+f\ast h$

## 常用的特殊狄利克雷卷积

1. $Id_k\ast I=\sigma_{k}$
2. $\varphi\ast I=Id$
3. $I\ast I=\sigma$

## 狄利克雷逆

1. 单位元：乘上单位元后不改变结果的数值。
2. 狄利克雷卷积中的单位元：$\varepsilon$。
3. 狄利克雷逆：
- 定义：若函数 $f\ast g=\varepsilon$，就称 $f$  和 $g$ 互为狄利克雷逆。
- 函数 $f$ 的狄利克雷逆表示为 $f^{-1}$。
- 一个数论函数 $f$ 存在狄利克雷逆的充分必要条件是：$f(1)\neq 0$，且函数 $f$ 若存在狄利克雷逆，则 $f^{-1}$ 是唯一的。
- 积性函数一定存在狄利克雷逆。

## 莫比乌斯反演公式

1. 莫比乌斯函数
- 定义：莫比乌斯函数 $\mu$ 为常数函数 $I$ 的狄利克雷逆。
$$
\mu(n)=
\begin{cases}
1&amp; n=1\\
(-1)^{k}&amp; n=\prod\limits_{i=1}^{k}{p_i}\space\space\space p_i\in \mathbb{prime}\\
0&amp; \text{其它}
\end{cases}
$$

2. 莫比乌斯反演公式
- $g=f\ast I\Longleftrightarrow f=g\ast \mu$
- $g(n)=\sum\limits_{d|n}{f(d)}\Longleftrightarrow f(n)=\sum\limits_{d|n}{\mu(d)\cdot g\big(\frac{n}{d}\big)}$
- $g(n)=\sum\limits_{n|N}{f(N)}\Longleftrightarrow f(n)=\sum\limits_{n|N}{g(N)\cdot\mu\big(\frac{N}{n}\big)}$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16485509.html</id>
    <title type="text">P1006 [NOIP2008 提高组] 传纸条 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-07-16T14:48:00Z</published>
    <updated>2022-07-16T14:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16485509.html" />
    <content type="text">## 传纸条

这题一眼看就是 DP。考虑如何建状态。

首先，我们可以把问题转化为从 $(1,1)$ 出发，选择到 $(n,n)$ 的两个路径，使这两个路径中途没有交点。

有一个显然的性质：从 $(1,1)$ 出发，走到 $(x,y)$ 需要 $(x-1)+(y-1)$ 步。在这道题里，只要同一时刻，两个点的纵坐标不相等，则这两个路径没有交点。那么我们可以定义 $f_{s,i,j}$ 表示：纵、横坐标和为 $s$，左边那个点的纵坐标为 $i$，右边那个点的纵坐标为 $j$ 的最大和。

$$
f_{s,i,j}=max\bigg\{f_{s-1,i,j},f_{s-1,i-1,j},f_{s-1,i,j-1},f_{s-1,i-1,j-1}\bigg\}+a_{s-i,i}+a_{s-j,j}
$$

代码：

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m;
int a[55][55], f[105][55][55];

int main() {
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      cin &gt;&gt; a[i][j];
    }
  }
  memset(f, -1, sizeof(f));
  f[2][1][1] = 0;
  for (int s = 3; s &lt; n + m; ++s) {
    for (int i = 1; i &lt; m; ++i) {
      for (int j = i + 1; j &lt;= m; ++j) {
        if (s - i &gt; n || s - j &gt; n) continue ;
        int tmp = -1;
        tmp = max(tmp, f[s - 1][i][j]);
        tmp = max(tmp, f[s - 1][i - 1][j]);
        tmp = max(tmp, f[s - 1][i][j - 1]);
        tmp = max(tmp, f[s - 1][i - 1][j - 1]);
        if (tmp == -1) continue ;
        f[s][i][j] = tmp + a[s - i][i] + a[s - j][j];
      }
    }
  }
  cout &lt;&lt; f[n + m - 1][m - 1][m] &lt;&lt; endl;
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16625958.html</id>
    <title type="text">20220825 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-08-25T14:20:00Z</published>
    <updated>2022-08-25T14:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16625958.html" />
    <content type="text">## T1 芝麻开门

### Description

给你 $a,k$，求 $a^k$ 的因数和。

### Solution

直接因数和定理然后跑个高精就行了。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long
#define mkp make_pair
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef __int128 i128;

int n, k;
vector&lt;int&gt; sm[105];
vector&lt;int&gt; vec[105];
vector&lt;pair&lt;int, int&gt;&gt; v;

vector&lt;int&gt; tovec(i128 x) {
  static vector&lt;int&gt; tmp;
  tmp.clear();
  while (x) {
    tmp.emplace_back(x % 10);
    x /= 10;
  }
  return tmp;
}

vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) {
  static vector&lt;int&gt; tmp;
  tmp.clear();
  tmp.resize(max(a.size(), b.size()) + 1);
  for (int i = 0; i &lt; tmp.size(); ++i) {
    int s1 = 0, s2 = 0;
    if (i &lt; a.size()) s1 = a[i];
    if (i &lt; b.size()) s2 = b[i];
    tmp[i] = s1 + s2;
  }
//  dbg;
  for (int i = 0; i &lt; tmp.size() - 1; ++i) {
    tmp[i + 1] += tmp[i] / 10;
    tmp[i] %= 10;
  }
  int idx = 0;
  for (int i = tmp.size() - 1; ~i; --i) {
    if (tmp[i]) {
      idx = i; break ;
    }
  }
  static vector&lt;int&gt; vec;
  vec.resize(idx + 1);
  for (int i = 0; i &lt;= idx; ++i) {
    vec[i] = tmp[i];
  }
//  dbg;
  return vec;
}

vector&lt;int&gt; mul(vector&lt;int&gt; a, vector&lt;int&gt; b) {
  static vector&lt;int&gt; tmp;
  tmp.clear();
  tmp.resize(a.size() * 2 + b.size() * 2);
  for (int i = 0; i &lt; (int)a.size(); ++i) {
    for (int j = 0; j &lt; (int)b.size(); ++j) {
      tmp[i + j] += a[i] * b[j];
    }
  }
  for (int i = 0; i &lt; tmp.size() - 1; ++i) {
    tmp[i + 1] += tmp[i] / 10;
    tmp[i] %= 10;
  }
  int idx = 0;
  for (int i = tmp.size() - 1; ~i; --i) {
    if (tmp[i]) {
      idx = i; break ;
    }
  }
  static vector&lt;int&gt; vec;
  vec.resize(idx + 1);
  for (int i = 0; i &lt;= idx; ++i) {
    vec[i] = tmp[i];
  }
  return vec;
}

void print(vector&lt;int&gt; v) {
  for (int i = v.size() - 1; ~i; --i) {
    cout &lt;&lt; v[i];
  }
  putchar('\n');
}

bool isprime(int n) {
  if (n &lt; 2) return 0;
  for (int i = 2; i * i &lt;= n; ++i) {
    if (n % i == 0) return 0;
  }
  return 1;
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i * i &lt;= n; ++i) {
    if (n % i != 0) continue ;
//    db(i);
    if (isprime(i)) {
//      db(i);
      int cn = n, cnt = 0;
      while (cn % i == 0) {
        ++cnt, cn /= i;
      }
      v.emplace_back(mkp(i, cnt * k));
    }
    if (i * i != n &amp;&amp; isprime(n / i)) {
      int cn = n, cnt = 0;
//      db(n / i);
      while (cn % (n / i) == 0) {
        ++cnt, cn /= (n / i);
      }
      v.emplace_back(mkp(n / i, cnt * k));
    }
  }
  if (n == 1) {
    cout &lt;&lt; 1 &lt;&lt; endl;
    return 0;
  }
  int cnt = 0;
  for (auto p : v) {
    int x = p.first, y = p.second;
    vector&lt;int&gt; nw = tovec((i128)1), xx = tovec((i128)x);
//    print(xx);
//    sm[++cnt] = nw;
//    dbg;
    sm[++cnt] = nw;
//    db(nw.size());
    for (int i = 1; i &lt;= y; ++i) {
      nw = mul(nw, xx);
      sm[cnt] = add(sm[cnt], nw);
//      print(nw);
//      db(sm[cnt].size());
    }
//    db(cnt);
//    print(sm[cnt]);
    vec[cnt] = sm[cnt];
  }
  for (int i = 2; i &lt;= cnt; ++i) {
    vec[i] = mul(vec[i], vec[i - 1]);
  }
  int idx = 0;
  for (int i = vec[cnt].size() - 1; ~i; --i) {
    if (vec[cnt][i]) {
      idx = i;break ;
    } 
  }
  for (int i = idx; ~i; --i) {
    cout &lt;&lt; vec[cnt][i];
  }
  putchar('\n');
//  for (auto p : v) {
//    cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second&lt;&lt; endl;
//  }
  return summary, 0;
}
```
&lt;/details&gt;

## T2 [SNOI2022] 垃圾回收

### Description

给定一个 $n$ 个点，$m$ 个边的图，有 $q$ 次操作，每次操作形如：

- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。
- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）

求每个点的权值乘上它存活时间的和。

### Solution

显然是离线，倒序循环。

那么这时 DELETE 操作就转化为了加边操作，可以直接并查集。
而 GC 就先存到数组里面。

而如果一个点 $x$ 的集合在第 $i$ 次操作与 $1$ 号点合并了，那么意味着正序循环时就在第 $i$ 次操作后与 $1$ 号点的集合分离，所以找到第一个编号大于 $i$ 的 GC 操作即可。

然后这题有可能图不连通，所以最后还要再特判一下。

时间复杂度是 $O(n\log q)$（我写了个 `lower_bound`，所以带 $\log$）。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int unsigned long long
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef __int128 i128;

const int kMaxN = 4e5 + 5;

i128 ans;

struct Edge {
  int u, v;
} e[kMaxN];

int n, m, q;
int op[kMaxN], idx[kMaxN], a[kMaxN];
i128 res[kMaxN];
bool del[kMaxN];
vector&lt;int&gt; v;
map&lt;pair&lt;int, int&gt;, int&gt; mp;

class UFS {
  public:
    int find(int x) {
      return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void unionn(int x, int y) {
      int fx = find(x), fy = find(y);
      int n1 = find(1);
      if (fx == fy) return ;
      if (fx == n1) fa[fy] = fx, sum[fx] += sum[fy];
      else if (fy == n1) fa[fx] = fy, sum[fy] += sum[fx];
      else fa[fx] = fy, sum[fy] += sum[fx];
//      if (fx != fy) fa[fx] = fy, sum[fy] += sum[fx];
    }
    void unionn(int x, int y, int idx) {
      int fx = find(x), fy = find(y);
      int n1 = find(1);
      if (fx == fy) return ;
      if (fx == n1) {
//        ans += idx * sum[fy];
        sum[fx] += sum[fy];
        sz[fx] += sz[fy];
        fa[fy] = fx;
        res[idx] += sum[fy];
//        sum[fy] = 0;
      } else if (fy == n1) {
//        ans += idx * sum[fx];
        sz[fy] += sz[fx];
        sum[fy] += sum[fx];
        fa[fx] = fy;
        res[idx] += sum[fx];
//        sum[fx] = 0;
      } else {
        sz[fy] += sz[fx];
        sum[fy] += sum[fx];
        fa[fx] = fy;
//        sum[fx] = 0;
      }
    }
    void init(){
      for (int i = 1; i &lt;= n; ++i) {
        fa[i] = i;
        sum[i] = a[i], sz[i] = 1;
      }
    }
  private:
    int fa[kMaxN]; i128 sum[kMaxN], sz[kMaxN];
} ufs;

void print(i128 x) {
  if (x &lt; 10) {
    putchar(x + '0');
    return ;
  }
  print(x / 10), putchar(x % 10 + '0');
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
//   freopen("a.txt", "r", stdin);
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= m; ++i) {
    cin &gt;&gt; e[i].u &gt;&gt; e[i].v;
    if (e[i].u &gt; e[i].v) swap(e[i].u, e[i].v);
  }
//  dbg;
  for (int i = 1; i &lt;= q; ++i) {
    string s;
    cin &gt;&gt; s;
    if (s[0] == 'D') {
      op[i] = 1;
      cin &gt;&gt; idx[i];
      del[idx[i]] = 1;
    } else {
      op[i] = 2;
    }
  }
//  dbg;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
  }
//  dbg;
//  summary;
//  s = UFS(n);
  ufs.init();
  for (int i = 1; i &lt;= m; ++i) {
    if (!del[i]) {
      ufs.unionn(e[i].u, e[i].v, q + 1);
    }
  }
  int n1 = ufs.find(1);
  for (int i = 1; i &lt;= n; ++i) {
    if (ufs.find(i) == n1) ans += (q + 1) * a[i];
  }
//  dbg;
  v.clear();
  v.emplace_back(q + 1);
  for (int i = q; i; --i) {
    if (op[i] == 1) {
      ufs.unionn(e[idx[i]].u, e[idx[i]].v, i);
      del[idx[i]] = 0;
    } else {
      v.emplace_back(i);
    }
  }
//  for (int i = 1; i &lt;= m; ++i) {
//    if (del[i]) dbg;
//  }
//  dbg;
  sort(v.begin(), v.end());
  for(int i = 1; i &lt;= q; ++i) {
      ans += (i128)(*lower_bound(v.begin(), v.end(), i))* res[i];
  }
  for (int i = 1; i &lt;= n; ++i) {
    if (ufs.find(i) != ufs.find(1)) ans += v[0] * a[i];
  }
  print(ans); putchar('\n');
  return summary, 0;
}
```

&lt;/details&gt;

## T3 [CEOI2015 Day1] 卡尔文球锦标赛

### Description

给定数列 $a_1,a_2,...,a_n$，求字典序小于等于数列 $a$ 且将 $a$ 离散化后数列是从 $1$ 开始连续的。（感觉概括的好艹啊）

### Solution

不妨设当前的数列为 $b_1,b_2,...,b_n$。

显然是 dp。

设 $f[i][j][0/1]$ 表示从 $1$ 考虑到 $i$，最大值为 $j$，是否到达上界的方案数。不妨设 $l_i=\max\{b_1,b_2,...,b_i\}$。

先考虑 $f[i][j][0]$ 的转移。

1. $b_i &gt; l_{i-1}$
	那么 $b_i$ 只能取 $j$，且 $l_{i-1}$ 只能取 $j-1$，那么就是由 $f[i-1][j-1][0]$ 转移过来的。
   
2. $b_i \leq l_{i-1}$
	那么 $b_i$ 小于等于 $j$，如果上一位没有到达上界，则是由 $f[i-1][j][0]\times j$ 转移过来。否则就是由这一位一定要小于 $a_i$，那么就是由 $f[i-1][\min\{a_i-1,j\}][1]$ 转移过来。
	
所以 $f[i][j][0]=f[i-1][j-1][0]+f[i-1][j][0]\times j+f[i-1][\min\{a_i-1,j\}][1]$。

---

然后考虑 $f[i][j][1]$ 的转移。

如果 $a_i=j$，那么 $f[i][j][1]$ 就得从 $f[i-1][j-1][1]$ 转移过来。
如果 $a_i\neq j+1$，那么 $f[i][j][1]$ 就得从 $f[i][j][1]$ 转移过来。

所以 $f[i][j][1]=[a_i=j]\times f[i-1][j-1][1]+[a_i\neq j+1]\times f[i][j][1]$。

然后这道题就可以 $O(n^2)$ 解决了。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 1e4 + 5, kMod = 1e6 + 7;

int n, cur;
int p[kMaxN], f[2][kMaxN][2]; 
bool ok;

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  // freopen("a.txt", "r", stdin);
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; p[i];
    // l[i] = max(l[i - 1], p[i]);
  }
  cur = 0;
  f[1][1][1] = 1;
  for (int i = 2; i &lt;= n; ++i, cur ^= 1) {
    for (int j = 1; j &lt;= i + 1; ++j) {
      f[cur][j][0] = f[cur][j][1] = 0;
    }
    // db(cur);
    for (int j = n; j; --j) {
      // f[cur][j][0] = f[cur][j][1] = 0;
      f[cur][j][0] += f[cur ^ 1][j][0] * j % kMod + f[cur ^ 1][j][1] * min(j, p[i] - 1) % kMod + f[cur ^ 1][j - 1][0];
      f[cur][j][0] %= kMod;
      if (p[i] != j + 1) {
        f[cur][j][1] += f[cur ^ 1][j][1];
      }
      if (p[i] == j) {
        f[cur][j][1] += f[cur ^ 1][j - 1][1];
      }
      f[cur][j][1] %= kMod;
    }
    // if (i == 2) db(f[cur][])
  }
  int ans = 0;
  for (int i = 1; i &lt;= n + 2; ++i) {
    ans += (f[cur ^ 1][i][0] + f[cur ^ 1][i][1]) % kMod;
    ans %= kMod;
  }
  cout &lt;&lt; ans % kMod &lt;&lt; endl;
  return summary, 0;
}
```

&lt;/details&gt;

## T4 [ZJOI2011]营救皮卡丘

不会。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16629013.html</id>
    <title type="text">20220823 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-08-26T12:48:00Z</published>
    <updated>2022-08-26T12:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16629013.html" />
    <content type="text">## T1 文件压缩

### Decription

[link](https://www.luogu.com.cn/problem/P1124)

### Solution

可以根据 $S'$ 和 $p$ 求出第一个字符，然后把 $S'$ `sort` 一遍后得到字符串 $T$，那么我们就可以求出每一个字符的前驱和后继，所以从第一个字符开始跑，就可以根据这些关系求出原字符串，这样肯定是正确的。

时间复杂度：$O(n^2)$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)

using namespace std;

const int kMaxN = 1e4 + 5;

int n, p, idx;
char fir, c1[kMaxN], c2[kMaxN], ans[kMaxN];
string s;
bool vis[kMaxN];

int main() {
  cin &gt;&gt; n &gt;&gt; s &gt;&gt; p;
  s = " " + s;
  for (int i = 1; i &lt;= n; ++i) {
    c1[i] = c2[i] = s[i];
  }
  fir = c1[p];
  sort(c2 + 1, c2 + 1 + n);
  for (int i = 1; i &lt;= n; ++i) {
    if (c2[i] == fir) {
      idx = i; break ;
    }
  }
  ans[1] = c1[idx]; vis[idx] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    for (int j = n; j; --j) {
      if (!vis[j] &amp;&amp; c2[j] == c1[idx]) {
        ans[i] = c1[j];
        idx = j;
        vis[idx] = 1;
        break ;
      }
    }
  }
  for (int i = n; i; --i) {
    cout &lt;&lt; ans[i];
  }
  return 0;
}
```

&lt;/details&gt;

## T2  [AGC018D] Tree and Hamilton Path

### Decription

[link](https://www.luogu.com.cn/problem/AT2673)

### Solution

先求出哈密尔顿**回路**，再减去回路中最短一条路径就是最长的哈密尔顿路径了。

哈密尔顿回路直接求肯定不好求，所以可以求出每条边对于整个回路的贡献。
假设当前边为 $\{u,v\}$（$u$ 是 $v$ 的父亲），权值为 $w$，可以发现这条边最多经过 $2\times\min\{sz[v],n-sz[v]\}$ 次，至于构造，就是它从下边过去又从上边回来，那么至多也只能经过这么多次。然后可以发现这样是可行的。

然后考虑删哪条边。
这里可以《容 易》地发现，如果当前点不是重心，那么必有一个子树的 $sz&gt;\frac{n}{2}$  那么这时就会有一个完整的路径在那个最大的子树内，则这条路径不会经过 $u$。所以要删的边必须至少有一边是重心，那么取重心连出来的最短的边就行了。

如果有两个重心，则只能删这两个重心之间的边。

时间复杂度：$O(n)$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

using ll = long long;

const int kMaxN = 1e5 + 5;

struct Edge {
  int v, w;

  Edge() {}
  Edge(int _v, int _w) : v(_v), w(_w) {}
  ~Edge() {}
};

int n, mi;
ll ans;
int sz[kMaxN];
vector&lt;int&gt; ctr;
vector&lt;Edge&gt; G[kMaxN];

void dfs(int u, int fa) {
  sz[u] = 1;
  int mx = 0;
  for (auto [v, w] : G[u]) {
    if (v == fa) continue ;
    dfs(v, u);
    sz[u] += sz[v], mx = max(mx, sz[v]), ans += 2ll * w * min(sz[v], n - sz[v]);
  }
  mx = max(mx, n - sz[u]);
  if (mx &lt;= n / 2) ctr.emplace_back(u);
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1, u, v, w; i &lt; n; ++i) {
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(Edge(v, w));
    G[v].emplace_back(Edge(u, w));
  }
  dfs(1, 0);
  if (ctr.size() &gt;= 2) {
    for (auto [v, w] : G[ctr[0]]) {
      if (v == ctr[1]) {
        ans -= w; break ;
      }
    }
  } else {
    mi = 1e9;
    for (auto [v, w] : G[ctr[0]]) {
      mi = min(mi, w);
    }
    ans -= mi;
  }
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;

## T3 [USACO20JAN]Springboards G

### Description

[link](https://www.luogu.com.cn/problem/P6007)

### Solution

可以写出 $30$ 分暴力。

优化：把每个跳板拆成两个点，分别是它的起点和终点，把这些点按 $x$ 排序，然后就可以树状数组优化了。那么在起点的地方转移，在终点的地方加入树状数组即可。

时间复杂度：$O(n\log n)$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)

using namespace std;

const int kMaxP = 2e5 + 5;

class BIT {
  public:
    void upd(int x, int v) {
      for (; x &lt;= n; x += x &amp; -x) {
        c[x] = max(c[x], v);
      }
    }
    int qry(int x) {
      int ret = 0;
      for (; x; x -= x &amp; -x) {
        ret = max(ret, c[x]);
      }
      return ret;
    }

    BIT() {}
    BIT(int _n) : n(_n) {}
    ~BIT() {}
  private:
    int n, c[kMaxP &lt;&lt; 2];
} bit;

struct Node {
  int x, y, id, op;

  Node() {}
  Node(int _x, int _y, int _id, int _op) : x(_x), y(_y), id(_id), op(_op) {}
  ~Node() {}

  friend bool operator &lt; (const Node&amp; n1, const Node&amp; n2) {
    if (n1.x != n2.x) return n1.x &lt; n2.x;
    return n1.y &lt; n2.y;
  }
} a[kMaxP &lt;&lt; 1];

int n, p, tot, ans, tt;
int b[kMaxP &lt;&lt; 2], xx[kMaxP], xy[kMaxP], yx[kMaxP], yy[kMaxP], f[kMaxP], dis[kMaxP];

signed main() {
  cin &gt;&gt; n &gt;&gt; p;
  for (int i = 1; i &lt;= p; ++i) {
    cin &gt;&gt; xx[i] &gt;&gt; xy[i] &gt;&gt; yx[i] &gt;&gt; yy[i];
    a[++tot] = Node(xx[i], xy[i], i, 0);
    a[++tot] = Node(yx[i], yy[i], i, 1);
    b[++tt] = xy[i];
    b[++tt] = yy[i];
    dis[i] = abs(xx[i] - yx[i]) + abs(xy[i] - yy[i]);
  }
  sort(a + 1, a + 1 + tot), sort(b + 1, b + 1 + tt);
  tt = unique(b + 1, b + 1 + tt) - (b + 1);
  for (int i = 1; i &lt;= tot; ++i) {
    a[i].y = lower_bound(b + 1, b + 1 + tt, a[i].y) - b;
  }
  bit = BIT(tt);
  for (int i = 1; i &lt;= tot; ++i) {
    if (!a[i].op) {
      f[a[i].id] = max(f[a[i].id], bit.qry(a[i].y) + dis[a[i].id]);
      ans = max(ans, f[a[i].id]);
    } else {
      bit.upd(a[i].y, f[a[i].id]);
    }
  }
  // db(ans);
  cout &lt;&lt; 2 * n - ans &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;

## T4 [AHOI2018初中组]球球的排列

### Description

[link](https://www.luogu.com.cn/problem/P4448)

### Solution

容易发现一个性质：如果 $x\times y$ 和 $y\times z$ 都是完全平方数，那么 $x\times z$ 也是完全平方数。

那么我们就可以将这 $n$ 个数看成 $n$ 个不同颜色的球，相同颜色的球两两乘积就是完全平方数，那么用个并查集就可以暴力 $O(n^2)$ 预处理出来了。

然后这个东西就转换成了：有 $n$ 个球，一共有 $m$ 个颜色，求相同球颜色都不相同的排列数。

这个东西直接不好做，所以考虑容斥。

不妨设 $a_i$ 表示颜色为 $i$ 的球的个数。
设 $f(s)$ 表示有至少 $s$ 对相邻的球颜色相同的方案数，那么答案就是：

$$
\sum_{i=0}^{n}{f(i)\cdot (-1)^i}
$$

我们可以将当前序列分为连续的颜色相同的若干块，设 $b_i$ 表示颜色为 $i$ 的块的个数。所以当前情况的答案就是：

$$
\dfrac{(\sum{b_i})!}{\prod{(b_i!)}}\cdot \prod_{i=1}^{m}{(a_i!\cdot C_{a_i-1}^{b_i-1})}
$$

这里的 $\dfrac{(\sum{b_i})!}{\prod{(b_i!)}}$ 就表示整块整块地进行排序的方案数，$a_i!$ 就是每种颜色的排序，$C_{a_i-1}^{b_i-1}$ 就是插板法求出每种颜色的块的分配方案。

考虑一件事：如果恰有 $s$ 对相邻的球颜色相同，那么 $\sum{b_i}=n-s$。

所以上面那个式子就可以转化为：

$$
(n-s)!\cdot \prod_{i=1}^{m}{(\dfrac{a_i!\cdot C_{a_i-1}^{b_i-1}}{b_i!})}
$$

所以我们发现只要求出 $b_i$，整个方案数就能确定，所以对于 $\prod\limits_{i=1}^{m}{(\dfrac{a_i!\cdot C_{a_i-1}^{b_i-1}}{b_i!})}$
 进行 dp 即可。

设 $f[i][j]$ 表示前 $i$ 种颜色，至多 $j$ 对相邻且颜色相等的块的个数，这里只要枚举 $b_i$ 就可以进行转移：

$$
f[i][j]=\sum_{k=1}^{min\{a_i,j\}}{f[i-1][j-k]\cdot \dfrac{a_i!\cdot C_{a_i-1}^{k-1}}{k!}}
$$

最后答案就是 $\sum\limits_{i=0}^{n}{f[n][i]\cdot (-1)^i}$。

时间复杂度：$O(n^2)$。
 
### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef long long ll;

const int kMaxN = 305, kMod = 1e9 + 7;

class UFS {
  public:
    void init() {
      iota(fa + 1, fa + 1 + n, 1);
    }
    int find(int x) {
      return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void unionn(int x, int y) {
      int fx = find(x), fy = find(y);
      if (fx != fy) fa[fx] = fy;
    }

    UFS() {}
    UFS(int _n) : n(_n) {}
    ~UFS() {}
  private:
    int n, fa[kMaxN];
} s;

int n, tot, ans;
int p[kMaxN], f[kMaxN][kMaxN], a[kMaxN], idx[kMaxN];
int fac[kMaxN], ifac[kMaxN];

bool check(ll x) {
  int tmp = sqrt(x);
  // if (x == 16) db(tmp);
  return 1ll * tmp * tmp == x;
}

int qpow(int bs, int idx) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod) {
    if (idx &amp; 1) ret = 1ll * ret * bs % kMod;
  }
  return ret % kMod;
}

int inv(int x) {
  return qpow(x, kMod - 2);
}

int C(int m, int n) {
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

int H(int a, int b) {
  return 1ll * fac[a] * C(a - 1, b - 1) % kMod * ifac[b] % kMod;
}

/* ---------- Line ---------- */

bool m_ed;

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; p[i];
  }

  s = UFS(n), s.init();
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = i + 1; j &lt;= n; ++j) {
      if (check(1ll * p[i] * p[j])) {
        s.unionn(i, j);
        // dbg;
      }
    }
  }
  // db(check(p[2] * p[6]));
  // db(check(16));
  for (int i = 1; i &lt;= n; ++i) {
    int fi = s.find(i);
    if (!idx[fi]) {
      idx[fi] = ++tot;
    }
    ++a[idx[fi]];
  }
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    fac[i] = 1ll * fac[i - 1] * i % kMod;
    ifac[i] = inv(fac[i]);
    // db(i), db(fac[i]), db(ifac[i]);
  }
  // db(tot);

  f[0][0] = 1;
  for (int i = 1; i &lt;= tot; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      for (int k = 1; k &lt;= min(j, a[i]); ++k) {
        f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] * H(a[i], k) % kMod) % kMod;
      }
    }
  }
  for (int i = 0; i &lt;= n; ++i) {
    int fl = (i &amp; 1) ? -1 : 1;
    ans += 1ll * f[tot][n - i] * fac[n - i] % kMod * fl;
    ans = (ans % kMod + kMod) % kMod;
  }
  cout &lt;&lt; ans &lt;&lt; endl;
  return summary, 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16631675.html</id>
    <title type="text">20220827 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-07T12:41:00Z</published>
    <updated>2023-10-07T12:41:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16631675.html" />
    <content type="text">## T1 [JOI 2020 Final] 長いだけのネクタイ

### Description

[link](https://www.luogu.com.cn/problem/P6877?contestId=82279)

### Solution

结论题。

设去掉一条领带后的序列为 $c_1,c_2,...,c_n$，那么当答案最小时，$c_1\leq c_2\leq...\leq c_n$，不会证，但是这是对的。

时间复杂度：$O(n\log n)$，瓶颈在 `sort` 上。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

typedef pair&lt;int, int&gt; pii;

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN], b[kMaxN], mx[kMaxN][2], ans[kMaxN];
pii p[kMaxN];

/* ---------- Line ---------- */

bool m_ed;

int main() {
//  freopen("a.txt", "r", stdin);
//  freopen("b.txt", "w", stdout);
  scanf("%d", &amp;n);
  for (int i = 1; i &lt;= n + 1; ++i) {
    scanf("%d", &amp;a[i]);
    p[i] = {a[i], i};
  }
  for (int i = 1; i &lt;= n; ++i) {
    scanf("%d", &amp;b[i]);
  }
  sort(b + 1, b + 1 + n), sort(p + 1, p + 2 + n);
//  mx[0][0] = mx[n + 1][1] = -2e9;
  for (int i = 1; i &lt;= n + 1; ++i) {
    mx[i][0] = max(mx[i - 1][0], p[i].first - b[i]);
  }
  for (int i = n + 1; i; --i) {
    mx[i][1] = max(mx[i + 1][1], p[i].first - b[i - 1]);
  }
  for (int i = 1; i &lt;= n + 1; ++i) {
    ans[p[i].second] = max(mx[i - 1][0], mx[i + 1][1]);
  }
  for (int i = 1; i &lt;= n + 1; ++i) {
    printf("%d ", ans[i]);
  }
  putchar('\n');
  return summary, 0;
}
```

&lt;/details&gt;

## T2 [JOI 2021 Final] 雪玉

### Description

[link](https://www.luogu.com.cn/problem/P7405)

### Solution

容易发现能对雪球产生贡献的雪地一定是连续的，那么我们就可以对于雪球 $i$，二分能对于它产生贡献的雪地的左端点，右端点就是雪球 $i$ 能到的最大的长度和 $i+1$ 的左端点的较小值。

考虑如何二分。假设当前二分雪球 $x$ 的左端点，二分的范围就是 $a[x-1]\sim a[x]$，如果当前的答案是 $k$，那么我们就再用一个二分找到雪球 $i$ 第一次经过 $k$ 的时间，那么只要看 $i-1$ 在这个时间之前（包括这个时间）有没有到过 $k$，如果到过 $k$ 那么就不行，而没到过就表示 $k$ 可行。

时间复杂度：$O(n\log q\log 10^{12})$，这东西显然跑不满，所以能 比 较 快 地通过。

貌似正解是线性的，wtcl/kk

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 2e5 + 5, kInf = 1e18;

int n, q;
int a[kMaxN], w[kMaxN], mx[kMaxN], mi[kMaxN], ml[kMaxN], mr[kMaxN];

bool checkl(int x, int kk) {
  int L = -1, R = q + 1, res = kInf;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (mi[mid] &lt;= kk - a[x]) R = res = mid;
    else L = mid;
  }
  if (res == kInf) return 0;
  if (a[x - 1] + mx[res] &gt; kk) return 0;
  else return 1;
}

int getl(int x) {
  int L = a[x - 1] - 1, R = a[x] + 1, res = a[x];
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (checkl(x, mid)) R = res = mid;
    else L = mid;
  }
  return res;
}

/* ---------- Line ---------- */

bool m_ed;

signed main() {
  cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
  }
  a[0] = -kInf, a[n + 1] = kInf;
  int cur = 0;
  for (int i = 1; i &lt;= q; ++i) {
    cin &gt;&gt; w[i]; cur += w[i];
    mx[i] = max(mx[i - 1], cur), mi[i] = min(mi[i - 1], cur);
  }
  for (int i = 1; i &lt;= n; ++i) {
    ml[i] = getl(i);
  }
  ml[n + 1] = kInf;
  for (int i = 1; i &lt;= n; ++i) {
    mr[i] = min(ml[i + 1], a[i] + mx[q]);
    cout &lt;&lt; mr[i] - ml[i] &lt;&lt; endl;
  }
  return summary, 0;
}
```

&lt;/details&gt;

## T3 [JOISC2020] 首都

### Description

[link](https://www.luogu.com.cn/problem/P7215)

### Solution

前置知识：[线段树优化建图](https://www.cnblogs.com/maoyiting/p/13764109.html#/cnblog/works/article/13764109)，树链剖分，强连通分量，缩点。

首先如果城市 $i$ 里的城镇之间需要经过城市 $j$ 里的城镇，那么就连一条 $i\to j$ 的有向边，表示如果选城市 $i$ 作为首都，那么需要把 $j$ 合并在一起。把这个有向图缩点后，答案就是出度为 $0$ 的点 $sz-1$ 的最小值。
因为如果出度不是 $0$，那么这个点与它连出的所有点都要合并，而那些连出的点又要和它连出的点合并，直到到达出度为 $0$ 的点，所以直接选择出度为 $0$ 的点最为划算。

然后直接建图是 $O(n^2)$ 的，时间和空间都过不了，直接线段树优化建图即可，那么就是 $O(n\log n)$ 的了。

时间复杂度：$O(n\log n)$，瓶颈在建图上。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define dbg debug("*** Passing [%s] in LINE %d\n", __FUNCTION__, __LINE__)
#define summary debug("----------- End -----------\n"), \
                debug("Memory %.5lfMB\n", fabs(&amp;m_ed - &amp;m_st) / 1048576), \
                debug("Time %.2lfs\n", clock() * 1.0 / CLOCKS_PER_SEC)

using namespace std;

bool m_st;

/* ---------- Line ---------- */

const int kMaxN = 1e6 + 5;

struct Node {
  int l, r, ls, rs;
} tr[kMaxN];

int n, k, base, rt, cnt, tot, scccnt, ans;
int col[kMaxN];
int a[kMaxN]; // 线段树
int sz[kMaxN], wson[kMaxN], top[kMaxN], fa[kMaxN], dep[kMaxN], idx[kMaxN], rev[kMaxN]; // 树链剖分
int scc[kMaxN], ins[kMaxN], dfn[kMaxN], low[kMaxN], siz[kMaxN], deg[kMaxN];
stack&lt;int&gt; stk; // Tarjan
vector&lt;int&gt; g[kMaxN], G[kMaxN], v[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

/* ----- 树链剖分 ----- */

void dfs1(int u, int fat) {
  sz[u] = 1, fa[u] = fat, dep[u] = dep[fat] + 1;
  for (auto v : g[u]) {
    if (v == fat) continue ;
    dfs1(v, u), sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) {
      wson[u] = v;
    }
  }
}

void dfs2(int u, int fat, int t) {
  top[u] = t, idx[u] = ++cnt, rev[cnt] = u;
  if (!wson[u]) return ;
  dfs2(wson[u], u, t);
  for (auto v : g[u]) {
    if (v == fat || v == wson[u]) continue ;
    dfs2(v, u, v);
  }
}

int LCA(int u, int v) {
  while (top[u] != top[v]) {
    if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
    u = fa[top[u]];
  }
  if (dep[u] &lt; dep[v]) swap(u, v);
  return v;
}

/* ----- 树链剖分 ----- */

/* ----- 线段树 -----*/

int build(int x, int l, int r) {
  int nw = ++base;
  tr[nw].l = l, tr[nw].r = r;
  if (l == r) {
    return addE(nw, col[rev[l]]), nw;
  }
  int mid = (l + r) &gt;&gt; 1;
  tr[nw].ls = build(x &lt;&lt; 1, l, mid), tr[nw].rs = build(x &lt;&lt; 1 | 1, mid + 1, r);
  addE(nw, tr[nw].ls), addE(nw, tr[nw].rs);
  return nw;
}

void update(int x, int ql, int qr, int u) {
  int l = tr[x].l, r = tr[x].r;
  if (l &gt; qr || r &lt; ql) {
    return ;
  } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
    return addE(u, x);
  }
  update(tr[x].ls, ql, qr, u), update(tr[x].rs, ql, qr, u);
}

void link(int u, int v) {
  int cl = col[u];
  while (top[u] != top[v]) {
    if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
    update(rt, idx[top[u]], idx[u], cl);
    u = fa[top[u]];
  }
  if (dep[u] &gt; dep[v]) swap(u, v);
  update(rt, idx[u], idx[v], cl);
}

/* ----- 线段树 -----*/

/* ----- Tarjan -----*/

void tarjan(int u) {
  dfn[u] = low[u] = ++tot, ins[u] = 1, stk.emplace(u);
  for (auto v : G[u]) {
    if (!dfn[v]) {
      tarjan(v), low[u] = min(low[u], low[v]);
    } else if (ins[v]) {
      low[u] = min(low[u], dfn[v]);
    }
  }
  if (low[u] == dfn[u]) {
    ++scccnt;
    while (!stk.empty()) {
      int tp = stk.top(); stk.pop();
      ins[tp] = 0, scc[tp] = scccnt;
      if (tp == u) break ;
    }
  }
}

/* ----- Tarjan -----*/

/* ---------- Line ---------- */

bool m_ed;

int main() {
  cin &gt;&gt; n &gt;&gt; k; base = k;
  for (int i = 1, u, v; i &lt; n; ++i) {
    cin &gt;&gt; u &gt;&gt; v;
    g[u].emplace_back(v), g[v].emplace_back(u);
  }
  for (int i = 1, c; i &lt;= n; ++i) {
    cin &gt;&gt; c;
    col[i] = c;
    v[c].emplace_back(i);
  }
  dfs1(1, 0), dfs2(1, 0, 1);
  rt = build(1, 1, n);
  for (int i = 1; i &lt;= k; ++i) {
    if (v[i].size() &lt;= 1) continue ;
    int s = v[i][0], tp = -1, nw = 1e9;
    for (int j = 1; j &lt; (int)v[i].size(); ++j) {
      int t = v[i][j], lca = LCA(s, t);
      if (lca != t) link(t, lca);
      if (dep[lca] &lt; nw) nw = dep[lca], tp = lca;
    }
    if (~tp &amp;&amp; tp != s) link(s, tp);
  }
  for (int i = 1; i &lt;= base; ++i) {
    if (!dfn[i]) {
      tarjan(i);
    }
  }
  for (int i = 1; i &lt;= k; ++i) {
    ++siz[scc[i]];
  }
  for (int i = 1; i &lt;= base; ++i) {
    for (auto v : G[i]) {
      if (scc[i] != scc[v]) ++deg[scc[i]];
    }
  }
  ans = 2e9;
  for (int i = 1; i &lt;= k; ++i) {
    if (!deg[scc[i]]) {
      ans = min(ans, siz[scc[i]] - 1);
    }
  }
  cout &lt;&lt; ans &lt;&lt; endl;
  return summary, 0;
}
```

&lt;/details&gt;

## T4 [JOI2018] Snake Escaping

不会。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16663610.html</id>
    <title type="text">20220904 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-09-06T14:42:00Z</published>
    <updated>2022-09-06T14:42:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16663610.html" />
    <content type="text">- [problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/kz2jsqnx)

- [solution](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/o4n1itvq)

## T1

令 $f_{i,j}$ 表示 $i$ 能够进入第 $j$ 轮的概率，然后转移就行。

注：这题没卡精度，`long double` 可过。

我赛时写了个高精然后被卡常了/kk。

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl

using namespace std;

const int kMaxN = 1030;

int n, m;
int x;
int p[kMaxN][kMaxN];
long double f[kMaxN][15];

int rev(int x) {
  if (x &amp; 1) return x + 1;
  else return x - 1;
}

int main() {
  freopen("elimination.in", "r", stdin);
  freopen("elimination.out", "w", stdout);
  cin &gt;&gt; n; m = (1 &lt;&lt; n);
  for (int i = 1; i &lt;= m; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      cin &gt;&gt; p[i][j];
    }
  }
  for (int i = 1; i &lt;= m; ++i) {
    f[i][0] = 1;
  }
  for (int i = 1; i &lt;= n; ++i) {
    int k = (1 &lt;&lt; i - 1);
    for (int j = 1; j &lt;= m; ++j) {
      // db(j);
      int bl = (j - 1) / k + 1, bb = rev(bl);
      int l = (bb - 1) * k + 1, r = bb * k;
      for (int s = l; s &lt;= r; ++s) {
        f[j][i] += p[j][s] * f[s][i - 1] / 100.0;
      }
      f[j][i] *= f[j][i - 1];
    }
  }
  long double mx = 0; int idx = -1;
  for (int i = 1; i &lt;= m; ++i) {
    // print(f[i][n]), putchar('\n');
    if (f[i][n] &gt; mx) {
      mx = f[i][n], idx = i;
    }
  }
  cout &lt;&lt; idx &lt;&lt; endl;
  cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl;
  return 0;
}
```

## T2

令 $s_i$ 表示 $1\sim i$ 种的树的个数。

那么对于每个约束，$s_e\geq s_{b-1}+t$。

跑个最长路就行了。

```cpp
#include &lt;bits/stdc++.h&gt;

#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl

using namespace std;

const int kMaxN = 3e4 + 5, kInf = 0x3f3f3f3f;

int n, m;
vector&lt;pair&lt;int, int&gt;&gt; G[kMaxN];

void addE(int u, int v, int w) {
  G[u].push_back({v, w});
}

namespace SPFA {

int dis[kMaxN];
bool vis[kMaxN];
queue&lt;int&gt; q;

void SPFA() {
  while (!q.empty()) q.pop();
  fill(dis, dis + 2 + n, -kInf);
  fill(vis, vis + 2 + n, 0);
  dis[n + 1] = 0, vis[n + 1] = 1, q.push(n + 1);
  while (!q.empty()) {
    int nf = q.front(); q.pop();
    vis[nf] = 0;
    for (auto p : G[nf]) {
      int v = p.first, w = p.second;
      if (dis[v] &lt; dis[nf] + w) {
        dis[v] = dis[nf] + w;
        if (!vis[v]) q.push(v), vis[v] = 1;
      }
    }
  }
  cout &lt;&lt; dis[n] &lt;&lt; endl;
}

} // namespace SPFA

int main() {
  freopen("tree.in", "r", stdin);
  freopen("tree.out", "w", stdout);
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1, u, v, w; i &lt;= m; ++i) {
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    addE(u - 1, v, w);
  }
  for (int i = 0; i &lt;= n; ++i) {
    addE(n + 1, i, 0);
  }
  for (int i = 0; i &lt; n; ++i) {
    addE(i, i + 1, 0);
    addE(i + 1, i, -1);
  }
  SPFA::SPFA();
  return 0;
}
```

## T3

令 $y=x^x\bmod 1000$，那么答案就是 $C_{y-1}^{k-1}$，写个高精就行了。

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long
#define db(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;

using namespace std;

int x, k;

int qpow(int bs, int idx) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % 1000) {
    if (idx &amp; 1) ret = 1ll * ret * bs % 1000;
  }
  return ret;
}

vector&lt;int&gt; tovec(int x) {
  vector&lt;int&gt; c;
  c.clear();
  if (!x) {
    c.emplace_back(0);
    return c;
  }
  for (; x; x /= 10) {
    c.emplace_back(x % 10);
  }
  return c;
}

vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) {
  vector&lt;int&gt; c, res;
  c.clear(), res.clear();
  c.resize(max(a.size(), b.size()) + 1);
  for (int i = 0; i &lt;= max(a.size(), b.size()) - 1; ++i) {
    if (i &lt; a.size()) c[i] += a[i];
    if (i &lt; b.size()) c[i] += b[i];
    c[i + 1] += c[i] / 10, c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i &lt;= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector&lt;int&gt; mul(vector&lt;int&gt; a, vector&lt;int&gt; b) {
  vector&lt;int&gt; c, res;
  c.clear(), res.clear();
  c.resize(a.size() + b.size() + 2);
  for (int i = 0; i &lt; a.size(); ++i) {
    for (int j = 0; j &lt; b.size(); ++j) {
      c[i + j] += a[i] * b[j];
    }
  }
  for (int i = 0; i &lt; c.size() - 1; ++i) {
    c[i + 1] += c[i] / 10;
    c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i &lt;= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector&lt;int&gt; div(vector&lt;int&gt; a, int x) {
  vector&lt;int&gt; c, res;
  c.clear(), res.clear();
  c.resize(a.size() + 2);
  int nw = 0;
  for (int i = a.size() - 1; ~i; --i) {
    nw = 10 * nw + a[i];
    if (nw &gt;= x) {
      c[i] = nw / x;
      nw %= x;
    } else {
      c[i] = 0;
    }
  }
  for (int i = 0; i &lt; c.size() - 1; ++i) {
    c[i + 1] += c[i] / 10;
    c[i] %= 10;
  }
  int sz = 0;
  for (int i = c.size() - 1; ~i; --i) {
    if (c[i]) {
      sz = i; break ;
    }
  }
  res.resize(sz + 1);
  for (int i = 0; i &lt;= sz; ++i) {
    res[i] = c[i];
  }
  return res;
}

vector&lt;int&gt; C(int m, int n) { // m! / n! / (m - n)!
  if (m &lt; n) return tovec(0);
  vector&lt;int&gt; v = tovec(1);
  for (int i = m; i &gt;= m - n + 1; --i) {
    v = mul(v, tovec(i));
  }
  for (int i = 1; i &lt;= n; ++i) {
    v = div(v, i);
  }
  return v;
}

void print(vector&lt;int&gt; v) {
  for (int i = v.size() - 1; ~i; --i) {
    putchar(v[i] + '0');
  }
  putchar('\n');
}

signed main() {
  freopen("equation.in", "r", stdin);
  freopen("equation.out", "w", stdout);
  cin &gt;&gt; k &gt;&gt; x;
  x %= 1000, x = qpow(x, x);
  if (!x) {
    putchar('0'), putchar('\n');
    return 0;
  }
  print(C(x - 1, k - 1));
  return 0;
}
// ans = C(x - 1, k - 1) = (x - 1)! / (k - 1)! / (x - k)!
```

## T4

令 $f_i$ 表示前 $i$ 天的答案，令 $s(l,r)$ 表示从 $l$ 到 $r$ 天，每天都用同一个路径的最短路。

那么 $f_i=\max\{s(1,i)\times i, f_j+s(j+1,i)\times(i-j)+k\}$。
这样做是 $O(nme)$ 的。

赛时我写了个 $O(2^m\times m\times e)$ 的大常数做法，然后最慢的点跑 $7s$，于是乎就只有 $30$ 分了。

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 114514
#endif

using namespace std;

typedef long long ll;

const int kMaxN = 25, kMaxS = (1 &lt;&lt; 20) + 5, kMaxT = 105, kInf = 0x3f3f3f3f;

int t, n, m, k, d;
int go[kMaxN][kMaxT], nw[kMaxN];
ll f[kMaxT];
vector&lt;pair&lt;int, int&gt;&gt; G[kMaxN];

void addE(int u, int v, int w) {
  G[u].emplace_back(v, w);
}

namespace SPFA {

queue&lt;int&gt; q;
int dis[kMaxN];
bool vis[kMaxN];

void prework(int l, int r) {
  fill(nw + 1, nw + 1 + n, 1);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = l; j &lt;= r; ++j) {
      if (!go[i][j]) nw[i] = 0;
    }
  }
}

int SPFA(int l, int r) {
  prework(l, r);
  while (!q.empty()) q.pop();
  fill(dis + 1, dis + 1 + n, kInf);
  fill(vis + 1, vis + 1 + n, 0);
  q.push(1), dis[1] = 0, vis[1] = 1;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    vis[u] = 0;
    for (auto p : G[u]) {
      int v = p.first, w = p.second;
      if (!nw[v]) continue ;
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) q.push(v), vis[v] = 1;
      }
    }
  }
  return dis[n];
}

} // namespace SPFA

int main() {
  cin &gt;&gt; t &gt;&gt; n &gt;&gt; k &gt;&gt; m;
  for (int i = 1, u, v, w; i &lt;= m; ++i) {
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    addE(u, v, w), addE(v, u, w);
  }
  cin &gt;&gt; d;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= t; ++j) {
      go[i][j] = 1;
    }
  }
  for (int i = 1, p, a, b; i &lt;= d; ++i) {
    cin &gt;&gt; p &gt;&gt; a &gt;&gt; b;
    for (int j = a; j &lt;= b; ++j) {
      go[p][j] = 0;
    }
  }
  for (int i = 1; i &lt;= t; ++i) {
    f[i] = 1ll * SPFA::SPFA(1, i) * i;
    for (int j = 1; j &lt; i; ++j) {
      f[i] = min(f[i], f[j] + 1ll * SPFA::SPFA(j + 1, i) * (i - j) + k);
    }
  }
  cout &lt;&lt; f[t] &lt;&lt; endl;
  cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; endl;
  return 0;
}
```

橙题模拟赛只有 $310$，垫底了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16717160.html</id>
    <title type="text">HDU3085 Nightmare Ⅱ 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-09-21T13:06:00Z</published>
    <updated>2022-09-21T13:06:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16717160.html" />
    <content type="text">## Description

[link](https://acm.hdu.edu.cn/showproblem.php?pid=3085)

## Solution

这是个双向广搜板子题。

首先鬼的分裂实际上就是每一次走两步，由于没有障碍所以直接曼哈顿距离即可。
男孩每一次可以走 3 步，所以直接 bfs 连走 3 步即可。而女孩就只用走一步。

双向广搜需要用 2 个队列分别存储男孩和女孩的状态，不妨设这 2 个队列为 $q_0$ 和 $q_1$

处理答案时，就定义 $step[0/1][x][y]$ 表示 $(x,y)$ 这个格点由 男孩/女孩 走到的最少次数，初始设为无穷大。
如果走了 $s$ 步且当前拓展的点以前有**异性**走过，那么就输出 $s$ 并停止 bfs。
如果 $q_0$ 和 $q_1$ 均为空切没有停止 bfs 时，则男孩和女孩无法相遇，输出 $-1$ 即可。

这样做是 $O(Tnm)$ 的，有个很大的常数，并且这题 $T$ 非常大，需要注意一下常数。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 114514
#endif

using namespace std;

const int kMaxN = 805, kInf = 0x3f3f3f3f;
const pair&lt;int, int&gt; dir[] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

struct Node {
  int x, y, step;
  
  Node() {}
  Node(int _x, int _y, int _step) : x(_x), y(_y), step(_step) {}
  ~Node() {}
};

int T, n, m, ct;
int xx, xy, yx, yy;
int a[kMaxN][kMaxN], step[2][kMaxN][kMaxN];
string s;
char c[kMaxN][kMaxN];
pair&lt;int, int&gt; z[2];
queue&lt;Node&gt; q1, q2;

void init() {
  while (!q1.empty()) q1.pop();
  while (!q2.empty()) q2.pop();
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      step[0][i][j] = step[1][i][j] = kInf;
    }
  }
}

int get(int x, int y, int p) {
  return abs(x - z[p].first) + abs(y - z[p].second);
}

bool check(int x, int y, int p) {
  if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m || a[x][y] == 2) return 0;
  if (get(x, y, 0) &lt;= p * 2 || get(x, y, 1) &lt;= p * 2) return 0;
  return 1;
}

int bfs() {
  init();
  q1.emplace(Node(xx, xy, 0)), q2.emplace(Node(yx, yy, 0));
  step[0][xx][xy] = step[1][yx][yy] = 0;
  int st = 0;
  while (!q1.empty() || !q2.empty()) {
    int x, y; ++st;
    if (!q1.empty()) {
      for (int k = 0; k &lt; 3; ++k) {
        int m3, n3;
        int kk = q1.size();
        for (int hbq = 1; hbq &lt;= kk; ++hbq) {
          auto p1 = q1.front(); q1.pop();
          x = p1.x, y = p1.y;
          if (!check(x, y, st)) continue ;
          for (auto d3 : dir) {
            m3 = x + d3.first, n3 = y + d3.second;
            if (!check(m3, n3, st) || step[0][m3][n3] != kInf) continue ;
            q1.emplace(Node(m3, n3, st)), step[0][m3][n3] = st;
            if (step[1][m3][n3] == kInf) continue ;
            return st;
          }
        }

      }

    }
// =====================
    if (!q2.empty()) {
      int kk = q2.size();
      for (int hbq = 1; hbq &lt;= kk; ++hbq) {
        auto p2 = q2.front(); q2.pop();
        x = p2.x, y = p2.y;
        if (!check(x, y, st)) continue ;
        for (auto d : dir) {
          int tx = x + d.first, ty = y + d.second;
          if (!check(tx, ty, st) || step[1][tx][ty] != kInf) continue ;
          q2.emplace(Node(tx, ty, st)), step[1][tx][ty] = st;
          if (step[0][tx][ty] == kInf) continue ;
          return st;
        }        
      }

    }
  }
  debug(step[0][5][3]);
  return -1;
}

int main() {
  scanf("%d", &amp;T);
  while (T--) {
    ct = 0;
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) {
      scanf("%s", c[i] + 1);
    }
    for (int i = 1; i &lt;= n; ++i) {
      for (int j = 1; j &lt;= m; ++j) {
        if (c[i][j] == '.') {
          a[i][j] = 1;
        } else if (c[i][j] == 'X') {
          a[i][j] = 2;
        } else if (c[i][j] == 'M') {
          a[i][j] = 1, xx = i, xy = j;
        } else if (c[i][j] == 'G') {
          a[i][j] = 1, yx = i, yy = j;
        } else if (c[i][j] == 'Z') {
          a[i][j] = 2, z[ct++] = {i, j};
        } else {
          assert(0);
        }
      }
    }
    printf("%d\n", bfs());
  }
  return 0;
}
/*
1
10 10
..........
..X.......
..M.X...X.
X.........
.X..X.X.X.
.........X
..XX....X.
X....G...X
...ZX.X...
...Z..X..X
*/
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16747724.html</id>
    <title type="text">[NOIP2011 提高组] Mayan 游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-01T12:29:00Z</published>
    <updated>2022-10-01T12:29:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16747724.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P1312)

## Solution

令当当前棋盘为 $a$。

注意到  $n\leq 5$ 且棋盘是 $5\times7$ 的，所以直接爆搜可以做到 $O(35^5)=O(52521875)$，然而这里还有很大的常数，所以需要剪枝。

剪枝 1：对于第 $i$ 列，第 $j$ 行的方块，如果 $a_{i,j}=0$ 就剪掉，这是显然的。

剪枝 2：对于第 $i$ 列，第 $j$ 行的方块，如果 $j\geq 1$ 并且 $a_{i,j-1}=a_{i,j}$ 就剪掉。因为两个相同颜色的块互换没有任何意义。

剪枝 3：对于第 $i$ 列，第 $j$ 行的方块，如果 $j\leq 5$ 并且 $a_{i,j+1}\neq 0$ 就剪掉。因为在 `剪枝2` 中遍历到 $i,j+1$ 时并不会被剪掉，所以这种情况会算重。
并且当 $a_{i,j+1}=0$ 时，遍历到 $i,j+1$ 时会被 `剪枝1` 剪掉，所以这个要算上。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 114514
#endif

using namespace std;

typedef vector&lt;int&gt; ln;
typedef unsigned long long ull;

const int dx[] = {1, -1}, dy[] = {0, 0};

int n, cnt;
int a[6][3];
int l[5][7], nw[5][7];

void print() {
  for (int i = 0; i &lt; 5; ++i, fprintf(stderr, "\n")) {
    fprintf(stderr, "%d : ", i);
    for (int j = 0; j &lt; 7 &amp;&amp; nw[i][j]; ++j, fprintf(stderr, " ")) {
      fprintf(stderr, "%d", nw[i][j]);
    }
  }
}

bool clr() {
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      if (nw[i][j]) return 0;
    }
  }
  return 1;
}

void check() {
  for (int i = 1; i &lt;= n; ++i) {
    cout &lt;&lt; a[i][0] &lt;&lt; ' ' &lt;&lt; a[i][1] &lt;&lt; ' ' &lt;&lt; a[i][2] &lt;&lt; endl;
  }
}

bool chk() {
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      if (!nw[i][j]) continue ;
      if (i - 2 &gt;= 0) {
        if (nw[i][j] == nw[i - 1][j] &amp;&amp; nw[i][j] == nw[i - 2][j]) {
          return 0;
        }
      }
      if (i + 2 &lt;= 4) {
        if (nw[i][j] == nw[i + 1][j] &amp;&amp; nw[i][j] == nw[i + 2][j]) {
          return 0;
        }
      }
      if (j - 2 &gt;= 0) {
        if (nw[i][j] == nw[i][j - 1] &amp;&amp; nw[i][j] == nw[i][j - 2]) {
          return 0;
        }
      }
      if (j + 2 &lt;= 6) {
        if (nw[i][j] == nw[i][j + 1] &amp;&amp; nw[i][j] == nw[i][j + 2]) {
          return 0;
        }
      }
    }
  }
  return 1;
}

void drop() {
  int tmp[7];
  for (int i = 0; i &lt; 5; ++i) {
    int c = 0;
    for (int j = 0; j &lt; 7; ++j) {
      if (nw[i][j]) tmp[c++] = nw[i][j];
    }
    for (int j = 0; j &lt; 7; ++j) {
      if (j &lt; c) nw[i][j] = tmp[j];
      else nw[i][j] = 0;
    }
  }
}

void del() {
  int tmp[5][7];
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      tmp[i][j] = nw[i][j];
    }
  }
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      if (i - 2 &gt;= 0) {
        if (nw[i][j] == nw[i - 1][j] &amp;&amp; nw[i][j] == nw[i - 2][j]) {
          tmp[i][j] = tmp[i - 1][j] = tmp[i - 2][j] = 0;
        }
      }
      if (i + 2 &lt;= 4) {
        if (nw[i][j] == nw[i + 1][j] &amp;&amp; nw[i][j] == nw[i + 2][j]) {
          tmp[i][j] = tmp[i + 1][j] = tmp[i + 2][j] = 0;
        }
      }
      if (j - 2 &gt;= 0) {
        if (nw[i][j] == nw[i][j - 1] &amp;&amp; nw[i][j] == nw[i][j - 2]) {
          tmp[i][j] = tmp[i][j - 1] = tmp[i][j - 2] = 0;
        }
      }
      if (j + 2 &lt;= 6) {
        if (nw[i][j] == nw[i][j + 1] &amp;&amp; nw[i][j] == nw[i][j + 2]) {
          tmp[i][j] = tmp[i][j + 1] = tmp[i][j + 2] = 0;
        }
      }
    }
  }
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      nw[i][j] = tmp[i][j];
    }
  }
  drop();
  if (chk()) return ;
  del();
}

void dfs(int step) {
  if (step == n + 1) {
    if (!clr()) return ;
    return check(), exit(0);
  }
  if (clr()) return ;
  int tmp[5][7];
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      if (!nw[i][j]) break ;
      for (int k = 0; k &lt; 2; ++k) {
        int ti = i + dx[k], tj = j + dy[k];
        if (ti &lt; 0 || ti &gt;= 5 || tj &lt; 0 || tj &gt;= 7) continue ;
        if (dx[k] == 1 &amp;&amp; nw[ti][tj] == nw[i][j] || dx[k] == -1 &amp;&amp; nw[ti][tj]) continue ;
        for (int i = 0; i &lt; 5; ++i) {
          for (int j = 0; j &lt; 7; ++j) {
            tmp[i][j] = nw[i][j];
          }
        }
        a[step][0] = i, a[step][1] = j, a[step][2] = dx[k];   
        swap(nw[i][j], nw[ti][tj]);
        drop(), del();
        dfs(step + 1);
        for (int i = 0; i &lt; 5; ++i) {
          for (int j = 0; j &lt; 7; ++j) {
            nw[i][j] = tmp[i][j];
          }
        }
      }
    }
  }
}

int main() {
  cin &gt;&gt; n;
  for (int i = 0; i &lt; 5; ++i) {
    int x = 1, c = 0;
    while (cin &gt;&gt; x) {
      if (!x || c == 7) break ;
      l[i][c++] = x;
    }
  }
  for (int i = 0; i &lt; 5; ++i) {
    for (int j = 0; j &lt; 7; ++j) {
      nw[i][j] = l[i][j];
    }
  }
  dfs(1);
  puts("-1");
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16749056.html</id>
    <title type="text">[Violet 5]列队春游  题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-02T09:12:00Z</published>
    <updated>2022-10-02T09:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16749056.html" />
    <content type="text">## Description

[link](https://hydro.ac/d/bzoj/p/2720)

## Solution

考虑对于每一个人算贡献。

令 $P(i)$ 表示这个人视野距离为 $i$ 的概率， $Q(i)$ 表示视野距离不小于 $i$ 的概率，令 $k$ 表示能够阻拦这个人视野的人的个数（当然不包括当前人）。

那么贡献即为：

$$
\sum_{i=1}^{n}{i\times P(i)}
$$

把这个式子转化下为：

$$
\sum_{i=1}^{n}{Q(i)}
$$

所以这时候只需要算出来 $Q(i)$ 即可，那么：

$$
Q(i)=\dfrac{(n-i+1)\cdot A_{n-k-1}^{i-1}\cdot (n-i)!}{n!}
$$

这个式子中 $(n-i+1)$ 表示当前人有 $n-i+1$ 个位置可以选。
$A_{n-k-1}^{i-1}$ 表示当前人前面的 $i-1$ 个位置只能由不能阻拦当前人视野的人来选，一共有 $n-k-1$ 个人。
$(n-i)!$ 就表示除了当前人和其前面的 $i-1$ 人外，其他人全排列的方案数。

---

然后化简即可：

$$
\begin{aligned}
ans&amp;=\sum_{i=1}^{n}{\dfrac{(n-i+1)\cdot A_{n-k-1}^{i-1}\cdot (n-i)!}{n!}}\\
&amp;=\sum_{i=1}^{n}{\dfrac{(n-i+1)\cdot\dfrac{(n-k-1)!}{(n-k-i)!}\cdot (n-i)!}{n!}}\\
&amp;=\dfrac{(n-k-1)!}{n!}\cdot\sum_{i=1}^{n}{\dfrac{(n-i+1)!}{(n-k-1)!}}\\
&amp;=\dfrac{(n-k-1)!}{n!}\cdot (k+1)!\cdot\sum_{i=1}^{n}{C_{n-i+1}^{k+1}}
\end{aligned}
$$

---

然后考虑这样一个式子：

$$
\sum_{i=1}^{n}{C_{i}^{k}}
$$

这个式子的组合意义就是在 $n+1$ 个不同元素中选取 $k+1$ 个元素的方案数。这里相当于就是枚举选的元素中编号最大的，假设为 $s$，那么方案数就为 $\sum\limits_{s=1}^{n+1}{C_{s-1}^{k}}=\sum\limits_{i=1}^{n}{C_{i}^{k}}=C_{n+1}^{k+1}$。

所以 $\sum\limits_{i=1}^{n}{C_{n-i+1}^{k+1}}=C_{n+1}^{k+2}$.

---

那么：

$$
\begin{aligned}
ans=&amp;\dfrac{(n-k-1)!}{n!}\cdot (k+1)!\cdot C_{n+1}^{k+2}\\
=&amp;\dfrac{(n-k-1)!}{(k+1)!}\cdot (k+1)!\cdot \dfrac{(n+1)!}{(k+2)!\cdot (n-k-1)!}\\
=&amp;\dfrac{n+1}{k+2}
\end{aligned}
$$

---

所以就可以线性求解了。

## Code

&lt;details&gt;

&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 114514
#endif

using namespace std;

const int kMaxN = 305, kMaxA = 1005;

int n, x;
int sum[kMaxA];
double ans;

int main() {
  cin &gt;&gt; n;
  for (int i = 1, x; i &lt;= n; ++i) {
    cin &gt;&gt; x;
    ++sum[x];
  }
  for (int i = 1; i &lt;= 1000; ++i) {
    ans += sum[i] * (n + 1) * 1.0 / (n - sum[i - 1] + 1);
    sum[i] += sum[i - 1];
  } 
  cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16759944.html</id>
    <title type="text">20221007 模拟赛 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-07T08:11:00Z</published>
    <updated>2022-10-07T08:11:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16759944.html" />
    <content type="text">[problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/5t8063ap)
[官方题解](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/5t8063ap)

## T1

### Solution

容易发现行和列互相是不影响的，所以只需要单独考虑即可。

不妨设当前序列为 $a$，$A$ 为序列的平均数，$x_i$ 为 $i$ 跟 $i$ 左边那个人的交换次数，那么我们要求 $\sum\limits_{i=1}^{n}{x_i}$。

可以列出下面的式子：

$$
\begin{cases}
a_1+x_2-x_1=A\\
a_2+x_3-x_2=A\\
...\\
a_n+x_1-x_n=A
\end{cases}
$$

把这个式子转化一下：

$$
\begin{cases}
x_2=A+x_1-a_1\\
x_3=A+x_2-a_2=x_1-(a_1-A)-(a_2-A)\\
...\\
x_1=x_1-\sum_\limits{i=1}^{n}{(a_i-A)} 
\end{cases}
$$

那么可以设 $b_i=a_i-A$，$c_i=\sum_\limits{j=1}^{i}{b_j}$。

那么要求的式子就变为：$\sum\limits_{i=1}^{n}{|x_1-c_i|}$。由于 $c$ 是确定的，所以当 $x_1$ 取 $c$ 的中位数时最小。

因为有个 `sort` 所以是 $O(n\log n)$ 的。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getchar();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

typedef long long ll;

const int kMaxN = 1e5 + 5;

int n, m, t;
int a[kMaxN], b[kMaxN];
ll s[kMaxN], c[kMaxN];

ll solve(int *a, int n) {
  int A = 0;
  ll x, ret = 0;
  for (int i = 1; i &lt;= n; ++i) {
    A += a[i];
  }
  A /= n;
  for (int i = 1; i &lt;= n; ++i) {
    s[i] = a[i] - A;
    c[i] = s[i] + c[i - 1];
  }
  sort(c + 1, c + 1 + n);
  x = c[(n + 1) / 2];
  for (int i = 1; i &lt;= n; ++i) {
    ret += abs(c[i] - x);
  }
  return ret;
}

int main() {
  file("tanabata");
  n = read(), m = read(), t = read();
  for (int i = 1, x, y; i &lt;= t; ++i) {
    x = read(), y = read();
    ++a[x], ++b[y];
  }
  if (t % n == 0 &amp;&amp; t % m == 0) printf("both %lld\n", solve(a, n) + solve(b, m));
  else if (t % n == 0) printf("row %lld\n", solve(a, n));
  else if (t % m == 0) printf("column %lld\n", solve(b, m));
  else printf("impossible\n"); 
  return 0;
}
```

&lt;/details&gt;

## T2

### Solution

爆搜即可。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...)
#endif

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getchar();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

const int kMaxN = (1 &lt;&lt; 21) + 5;

int n, k;
int a[kMaxN], vis[kMaxN], cp[kMaxN];

int get(int l, int r) {
  int nw = 0;
  if (l &lt;= r) {
    for (int i = l; i &lt;= r; ++i) {
      nw = (nw &lt;&lt; 1) + a[i];
    }    
  } else {
    for (int i = l; i &lt;= n; ++i) {
      nw = (nw &lt;&lt; 1) + a[i];
    }
    for (int i = 1; i &lt;= r; ++i) {
      nw = (nw &lt;&lt; 1) + a[i];
    }
  }
  return nw;
}

void check() {
  for (int s = n - k + 2; s &lt;= n; ++s) {
    if (vis[get(s, s + k - n - 1)]) goto GG;
    vis[get(s, s + k - n - 1)] = 1;
  }
  cout &lt;&lt; n &lt;&lt; ' ';
  for (int i = 1; i &lt;= n; ++i) {
    cout &lt;&lt; a[i];
  }
  exit(0);
  GG:;
  memset(vis, 0, sizeof(vis));
  for (int i = 1; i &lt;= n - k + 1; ++i) {
    vis[get(i, i + k - 1)] = 1;
  }
}

void dfs(int x) {
  if (x == n + 1) return check();
  for (int i = 0; i &lt;= 1; ++i) {
    a[x] = i;
    if (x &lt; k) goto FK;
    if (vis[get(x - k + 1, x)]) continue ;
    vis[get(x - k + 1, x)] = 1;
    FK:;
    dfs(x + 1);
    vis[get(x - k + 1, x)] = 0;
  }
}

int main() {
  file("taiko");
  cin &gt;&gt; k;
  n = (1 &lt;&lt; k);
  dfs(1);
  return 0;
}
```

&lt;/details&gt;

## T3

### Solution

考虑一个最简分数 $\dfrac{p}{q}(p\neq 0)$ 在 $k$ 进制下，如果 $(q,k)=1$ 则无论 $p$ 取任何数，这个分数都是纯循环小数。

那么对于第一问直接模拟相除的过程，每一位除完之后约分即可。如果当前 $q$ 与 $k$ 不互质，则每次都能除掉一个大于 $1$ 的数，所以最多 $\log q$ 次。

---

第一问做完之后 $q$ 与 $k$ 互质，那么循环节就是最小的 $x$，使得 $k^x\equiv 1(\text{mod}\space q)$，直接 BSGS 会被卡常，实测最慢的点跑 $1.8\text{s}$，所以要想一个更快的算法。

考虑到 $k^{\varphi(q)}\equiv 1(\text{mod}\space q)$，根据阶的性质可知最小的 $x$ 整除 $\varphi(q)$，所以可以直接枚举 $\varphi(q)$ 的因数然后取最小值就行了。

虽然这样做还是 $O(\sqrt{n}\log n)$ 的（$\log$ 是快速幂的），但是常数小了很多，可以飞快地通过。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

#define int long long
#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getchar();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

typedef __int128 i128;

int T, a, b, k;
vector&lt;int&gt; p;

int gcd(int m, int n) {
  if (!n) return m;
  int m1 = (m &amp; 1), n1 = (n &amp; 1);
  if (!m1 &amp;&amp; !n1) return gcd(m &gt;&gt; 1, n &gt;&gt; 1) &lt;&lt; 1;
  if (!m1) return gcd(m &gt;&gt; 1, n);
  if (!n1) return gcd(m, n &gt;&gt; 1);
  return gcd(n, m % n);
}

int qpow(int bs, int idx, int mod) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (i128)bs * bs % mod) {
    if (idx &amp; 1) ret = (i128)ret * bs % mod;
  }
  return ret % mod;
}

int phi(int x) {
  p.clear();
  int cx = x;
  for (int i = 2; i * i &lt;= cx; ++i) {
    if (cx % i == 0) {
      p.emplace_back(i);
      while (cx % i == 0) cx /= i;
    }
  }
  if (cx &gt; 1) p.emplace_back(cx);
  for (auto k : p) {
    x = x / k * (k - 1);
  }
  return x;
}

int getm(int &amp;b) {
  int nw = 1;
  if (gcd(b, k) == 1) return 0;
  for (int i = 1; ; ++i) {
    nw = (i128)nw * k % b;
    int d = gcd(b, nw);
    if (nw) b /= d, nw /= d;
    else return i;
    if (gcd(b, k) == 1) return i;
  }
}

bool check(int x) {
  return qpow(k, x, b) == 1;
}

int getr(int b) {
  if (b == 1) return 0;
  int p = phi(b), ans = p;
  for (int i = 1; i * i &lt;= p; ++i) {
    if (p % i == 0) {
      if (check(i)) ans = min(ans, i);
      if (check(p / i)) ans = min(ans, p / i);
    }
  }
  return ans;
}

signed main() {
  file("kubi");
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;
    int d = gcd(a, b);
    a /= d, b /= d;
    cout &lt;&lt; getm(b) &lt;&lt; ' ' &lt;&lt; getr(b) &lt;&lt; endl;
  }
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16760215.html</id>
    <title type="text">20221006 T4 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-07T10:20:00Z</published>
    <updated>2022-10-07T10:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16760215.html" />
    <content type="text">## Description

给定一个 $n\times m(n,m\leq 50)$ 的字符矩阵，`.` 表示平地，`X` 表示障碍，`@` 表示起点，`*` 表示绿洲。从起点出发，每天可以向四周 $8$ 个方向移动，当然需要是合法移动。然而每天还有一个风向，
若你出发时是逆风而行，则需要 $3$ 天才能到达目的地，否则只需 $1$ 天就能到达目的地。你虽然不知道未来的风向如何，但幸运的是风向是确定的，也就是说它不会根据你的决策而改变。问最坏情况下，你要多久才能到达绿洲。

## Solution

注意：风向在每次出发之前是会改变的，所以不能直接枚举风向然后最短路。

那么就要从绿洲开始往出发点跑最短路，那么每次转移有两种情况：逆风还是不逆风。如果逆风，那么上一次的就得在当前点的相邻点中的最短的那个。如果不逆风，那上一个就是当前点的相邻点中第二短的那个，描述一下就是：$dis[x][y]=\max\{dis[x_1][y_1]+3,dis[x_2][y_2]+1\}+1$，因为当前是最坏情况，所以要取 $\max$。

跑个 Bellman-Ford 就行了。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 114514
#endif

using namespace std;

const pair&lt;int, int&gt; kDir[] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                  {0, 1}, {1, -1}, {1, 0}, {1, 1}};

int n, m, stx, sty;
string s;
int a[55][105], dis[55][105];

string work(string s) {
  string ret = "";
  for (int i = 0; i &lt; (int)s.size(); ++i) {
    if (s[i] == '-' || s[i] == 'X' || s[i] == '@' || s[i] == '*') {
      ret += s[i];
    }
  }
  return ret;
}

int get() {
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (a[i][j] == 3) {
        dis[i][j] = 0;
      } else {
        dis[i][j] = 1e9;
      }
    }
  }
  bool rel = 1;
  while (rel) {
    rel = 0;
    for (int i = 1; i &lt;= n; ++i) {
      for (int j = 1; j &lt;= m; ++j) {
        int d1 = 1e9, d2 = 1e9;
        for (auto p : kDir) {
          int ti = i - p.first, tj = j - p.second;
          if (ti &lt; 1 || ti &gt; n || tj &lt; 1 || tj &gt; m || a[ti][tj] == 2) continue ;
          if (dis[ti][tj] &lt;= d1) {
            d2 = d1, d1 = dis[ti][tj];
          } else if (dis[ti][tj] &lt;= d2) {
            d2 = dis[ti][tj];
          }
        }
        int val = min(d1 + 3, d2 + 1);
        if (val &lt; dis[i][j]) {
          dis[i][j] = val, rel = 1;
        }
      }
    }
  }
  return dis[stx][sty] == 1e9 ? -1 : dis[stx][sty];
}

int main() {
  freopen("desert.in", "r", stdin);
  freopen("desert.out", "w", stdout);
  cin &gt;&gt; n; getchar();
  for (int i = 1; i &lt;= n; ++i) {
    getline(cin, s);
    s = work(s), m = s.size();
    s = "#" + s;
    for (int j = 1; j &lt;= m; ++j) {
      if (s[j] == 'X') {
        a[i][j] = 2;
      } else {
        a[i][j] = 1;
        if (s[j] == '@') {
          stx = i, sty = j;
        } else if (s[j] == '*') {
          a[i][j] = 3;
        }
      }
    }
  }
  cout &lt;&lt; get() &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;

## 官方题解

&gt; 设d[i][j]表示当前在(i,j),还需多久才能走到绿洲。
我们可以观察到，因为求的是最坏情况下的解，那么每个状态的决策只有两种
第一种是选择最优的一个相邻状态x，并用x+3更新答案，第二种是使用
次优的相邻状态x'，用x'+1更新答案。
这类似与经典的最短路问题，只是是倒着推的。
因为长,宽&lt;=50,具体实现可以采用bellman-ford。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16760407.html</id>
    <title type="text">[JOI2018] Dango Maker 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-07T13:40:00Z</published>
    <updated>2022-10-07T13:40:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16760407.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P7668)

## Solution

如果两个团子重合肯定是下面三种情况：

```
  R          RGW          R
  G          G           RGW
RGW          W            W
```

我们会发现两个重合团子的 `G` 一定是在从右上到左下的对角线上的，且距离小于等于 $1$。根据这个性质就可以发现任意两个对角线上的团子肯定互不影响，那么对于每一个对角线进行 dp 即可。

其中 $f[i][0/1/2]$ 表示当前对角线上前 $i$ 行，第 $i$ 行的团子 不放/横放/竖放 的最大团子数，依次递推即可。

时间复杂度：$O(nm)$，吊打二分图。
## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getchar();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

const int kMaxN = 3005;

int n, m, ans;
int f[kMaxN][3]; // 0/1/2 : 不放/横放/竖放
char s[kMaxN][kMaxN];

int main() {
  scanf("%d%d", &amp;n, &amp;m);
  for (int i = 1; i &lt;= n; ++i) {
    scanf("%s", s[i] + 1);
  }
  for (int sm = 2; sm &lt;= n + m; ++sm) {
    memset(f, 0, sizeof(f));
    int tmp = 0;
    for (int i = max(1, sm - m), j = sm - i; i &lt;= n &amp;&amp; j; ++i, --j) {
      f[i][0] = max({f[i - 1][0], f[i - 1][1], f[i - 1][2]});
      if (s[i][j] == 'G') {
        if (s[i - 1][j] == 'R' &amp;&amp; s[i + 1][j] == 'W') 
          f[i][1] = max(f[i][1], max(f[i - 1][0], f[i - 1][1]) + 1);
        if (s[i][j - 1] == 'R' &amp;&amp; s[i][j + 1] == 'W')
          f[i][2] = max(f[i][2], max(f[i - 1][0], f[i - 1][2]) + 1);
      }
      tmp = max(tmp, max({f[i][0], f[i][1], f[i][2]}));
    }
    ans += tmp;
  }
  printf("%d\n", ans);
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16767270.html</id>
    <title type="text">[JOI 2020 Final] オリンピックバス 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-07T13:53:00Z</published>
    <updated>2022-10-07T13:53:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16767270.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P6880)

## Solution

可以发现 $m\leq 5\times 10^4$ 所以可以直接枚举 $m$ 来得到答案。

可以建 $4$ 个图，两个正图，两个反图，分别是求 $1\to i$ 的最短路，$i\to n$ 的最短路，$n\to i$ 的最短路，$i\to 1$ 的最短路。

先对于每个图跑最短路并求出最短路径树。

如果当前反转的边是 $(u,v)$，如果这条边在四个图中都不是最短路径树上的边那么翻转当前边对最短路没有影响，否则就把这条边反转后跑最短路，最后取 $\min$ 即可。

由于最短路径树上的边最多 $4(n-1)$ 条，所以最多跑 $4\times n$ 次最短路，所以时间复杂度为 $O(n^3)$。（这里是稠密图，所以直接不加堆优化的 dijkstra 就行）

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

#define int long long
#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

int read() {
  int x = 0, f = 0; char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getchar();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getchar();
  return f ? -x : x;
}

typedef long long ll;

const int kMaxN = 205, kMaxM = 5e4 + 5;
const ll kInf = 1e18;

int n, m;
int u[kMaxM], v[kMaxM], w[kMaxM], d[kMaxM];

struct Graph {
  struct Node {
    int v; ll w; int id;

    Node() {}
    Node(int _v, ll _w, int _id) : v(_v), w(_w), id(_id) {}
    ~Node() {}
  };

  vector&lt;Node&gt; G[kMaxN];
  int s, rv;
  ll dis1[kMaxN], dis2[kMaxN], ed[kMaxN];
  bool vis[kMaxN], tr[kMaxM];

  void addE(int u, int v, int w, int id) {
    G[u].emplace_back(v, w, id);
  }
  void dijkstra1() {
    fill(dis1, dis1 + 1 + n, kInf), fill(vis, vis + 1 + n, 0);
    dis1[s] = 0;
    for (int i = 1; i &lt;= n; ++i) {
      int u = 0;
      for (int j = 1; j &lt;= n; ++j) {
        if (!vis[j] &amp;&amp; dis1[j] &lt; dis1[u]) {
          u = j;
        }
      }
      if (!u) break ;
      vis[u] = 1;
      for (auto [v, w, id] : G[u]) {
        if (dis1[v] &gt; dis1[u] + w) {
          dis1[v] = dis1[u] + w, ed[v] = id;
        }
      }
    }
    for (int i = 1; i &lt;= n; ++i) {
      if (i != s &amp;&amp; dis1[i] != kInf) tr[ed[i]] = 1;
    }
  }
  void dijkstra2() {
    fill(dis2, dis2 + 1 + n, kInf), fill(vis, vis + 1 + n, 0);
    dis2[s] = 0;
    for (int i = 1; i &lt;= n; ++i) {
      int u = 0;
      for (int j = 1; j &lt;= n; ++j) {
        if (!vis[j] &amp;&amp; dis2[j] &lt; dis2[u]) {
          u = j;
        }
      }
      if (!u) break ;
      vis[u] = 1;
      for (auto [v, w, id] : G[u]) {
        if (id == rv) continue ;
        if (dis2[v] &gt; dis2[u] + w) {
          dis2[v] = dis2[u] + w;
        }
      }
    }
  }

  ll solve(int t, int rev) {
    if (!tr[rev]) return dis1[t];
    rv = rev;
    dijkstra2();
    return dis2[t];
  }

} g1, g2, g3, g4; // g1, g3 正图， g2, g4 反图

signed main() {
  n = read(), m = read();
  g1.s = 1, g2.s = n, g3.s = n, g4.s = 1;
  for (int i = 1; i &lt;= m; ++i) {
    u[i] = read(), v[i] = read(), w[i] = read(), d[i] = read();
    g1.addE(u[i], v[i], w[i], i), g3.addE(u[i], v[i], w[i], i);
    g2.addE(v[i], u[i], w[i], i), g4.addE(v[i], u[i], w[i], i);
  }
  g1.dijkstra1(), g2.dijkstra1(), g3.dijkstra1(), g4.dijkstra1();
  ll ans = g1.dis1[n] + g3.dis1[1];
  for (int i = 1; i &lt;= m; ++i) {
    ll dis1 = min(g1.solve(n, i), g1.solve(v[i], i) + w[i] + g2.solve(u[i], i)),
       dis2 = min(g3.solve(1, i), g3.solve(v[i], i) + w[i] + g4.solve(u[i], i));
    ans = min(ans, dis1 + dis2 + d[i]);
  }
  if (ans &gt;= kInf) ans = -1;
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16769883.html</id>
    <title type="text">20221008 模拟赛 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-08T10:46:00Z</published>
    <updated>2022-10-08T10:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16769883.html" />
    <content type="text">[problem](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/jomufkyv)
[官方solution](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/tk5tbz7o)

## T1

### Description

[link](https://hydro.ac/d/bzoj/p/2717)

### Solution

神仙构造题。

第一问：任意两个人之间要站岗 $3$ 次，所以总共有 $C_{n}^{2}\times 3$ 次，而每一天能贡献 $3$ 次，所以最多 $C_{n}^{2}$ 天。

---

第二问：将这 $n$ 排到一个圆环上，那么对于每个 $1\leq s\leq \dfrac{n-1}{2}$ 的 $s$，和所有的人，和其编号加 $s$ 以及编号加 $2\times s$ 站一天岗。

首先，这个肯定是能站满 $n\times\dfrac{n-1}{2}$ 天。并且对于每两个人 $x$ 和 $y$，令 $k=\dfrac{y-x}{2}$，可以容易知道能站如下 $2$ 天：$(x,x+k,y)$,$(y,y+\dfrac{n-1}{2}-k,x)$。

并且如果 $y-x&gt;\dfrac{n-1}{2}$，那么就站 $y,y+\dfrac{n-1}{2}-k,x$。否则就站 $x,y,2\times y-x$。

首先能想到这个肯定要先求出第一问，然后题目要构造的是对称的，所以能想到一种等差数列的构造方法。但是，这非常的神仙。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

const int kMaxN = 1005;

int n, ans;
int cnt[kMaxN][kMaxN];

int get(int x) {
  return (x - 1) % n + 1;
}

int main() {
  freopen("rabbit.in", "r", stdin);
  freopen("rabbit.out", "w", stdout);
  cin &gt;&gt; n;
  ans = n * (n - 1) / 2;
  cout &lt;&lt; ans &lt;&lt; endl;
  for (int s = 1; s &lt;= n / 2; ++s) {
    for (int i = 1; i &lt;= n; ++i) {
      cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; get(i + s) &lt;&lt; ' ' &lt;&lt; get(i + 2 * s) &lt;&lt; endl;
    }
  }
  return 0;
}
```

&lt;/details&gt;

## T2

### Description

[link](https://hydro.ac/d/bzoj/p/2718)

### Solution

首先看到任意两个选的点都不能互相走到，那么我们就可以先对于每一个点，然后跑 dfs，求出这个点不能与哪些点同时选并连边。那么题目就转化为：在一个 $n$ 个点的图里，求它的最大独立集。但是这是个 NP，不可做。

考虑到二分图的最大独立集是可做的，那么就可以直接把每个点拆成两个点，并建一个二分图，那么答案就是 $n-$ 最大匹配。

## T3

### Description

[link](https://hydro.ac/d/bzoj/p/2719)

### Solution

看到第一个操作，如果两个点的横坐标和纵坐标都模 $3$ 同余，那么这两个点就可以看作是等价的，所以搞个数组记一下就可以了。

考虑到 $k\leq 10$ 所以直接暴力搜索就行，是 $O(k!)$ 的，跑的飞快。

注意：当 $n$ 和 $m$ 很小时注意特判。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

const int kMaxN = 105, dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, -1, 1, -1, 1};

struct Node {
  int c[3][3];

  Node() {
    for (int i = 0; i &lt; 3; ++i) {
      for (int j = 0; j &lt; 3; ++j) {
        c[i][j] = 0;
      }
    }
  }

  friend bool operator &lt; (const Node&amp; n1, const Node&amp; n2) {
    for (int i = 0; i &lt; 3; ++i) {
      for (int j = 0; j &lt; 3; ++j) {
        if (n1.c[i][j] != n2.c[i][j]) return n1.c[i][j] &lt; n2.c[i][j];
      }
    }
    return 0;
  }

  void init() {
    for (int i = 0; i &lt; 3; ++i) {
      for (int j = 0; j &lt; 3; ++j) {
        c[i][j] = 0;
      }
    }
  }
} st;

int k, n, m, sx, sy, cnt;
bool fl;
map&lt;Node, bool&gt; mp;

void check() {
  // st.print();
  if (st.c[sx % 3][sy % 3]) {
    fl = 1;
  }
}

int mod(int x) {
  return (x + 3) % 3;
}

void dfs(int x) {
  if (cnt == 1) {
    return check();
  }
  if (fl || mp[st]) return ;
  mp[st] = 1;
  for (int i = 0; i &lt; 3; ++i) {
    for (int j = 0; j &lt; 3; ++j) {
      for (int k = 0; k &lt; 8; ++k) {
        int ti2 = mod(i + 2 * dx[k]), tj2 = mod(j + 2 * dy[k]), ti1 = mod(i + dx[k]), tj1 = mod(j + dy[k]);
        if (!st.c[i][j] || !st.c[ti1][tj1]) continue ;
        --st.c[i][j], --st.c[ti1][tj1], ++st.c[ti2][tj2], --cnt;
        dfs(x + 1);
        ++st.c[i][j], ++st.c[ti1][tj1], --st.c[ti2][tj2], ++cnt;
      }
    }
  }
}

void solve() {
  st.init(), mp.clear();
  for (int i = 1, x, y; i &lt;= k; ++i) {
    cin &gt;&gt; x &gt;&gt; y;
    ++st.c[x % 3][y % 3];
  }
  if (k == 2 &amp;&amp; n == 1 &amp;&amp; m == 3 &amp;&amp; sx == 1 &amp;&amp; sy == 2) {
    puts("No"); return ;
  }
  cnt = k, fl = 0, dfs(1);
  puts(fl ? "Yes" : "No");
}

int main() {
  freopen("galaxy.in", "r", stdin);
  freopen("galaxy.out", "w", stdout);
  while (cin &gt;&gt; k &gt;&gt; n &gt;&gt; m &gt;&gt; sx &gt;&gt; sy) {
    solve();
  }
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16772600.html</id>
    <title type="text">[USACO20DEC] Bovine Genetics G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-09T08:26:00Z</published>
    <updated>2022-10-09T08:26:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16772600.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P7152)

## Solution

容易发现一种结果串的合法分割方案就对应着一种原字符串所以可以考虑 dp。

令 $f[i][a][b][c]$ 表示将 $s[1\sim i]$，且最后一个字串尾字母为 $a$，首字母为 $b$，倒数第 $2$ 段首字母为 $c$。

那么对于 $s[i]$ 则有两种可能：

1. 与 $s[i-1]$ 在同一个字串，则用 $f[i-1][lst][b][c]$ 转移，其中 $lst\neq a$ 且 $b$ 和 $c$ 随便选。
因为如果 $lst=a$，那么就在同一个字串里有两个连续且相同的字符，与题意矛盾。

2. 重新开一个字串，那么 $a$ 必须等于 $b$。用 $f[i-1][lst][b][d]$ 转移，其中 $lst=c$ 且 $d$ 随便选。

然后取和即可，这样做是 $O(64\times n^2)$ 的。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif
#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout)

using namespace std;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x *= f; return 1;
}
template&lt;typename A,typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) || read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A,typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 1e5 + 5, kMod = 1e9 + 7;

int n;
int ss[kMaxN], f[kMaxN][4][4][4];
char s[kMaxN];

int add(int x, int y) {
  return (x + y &gt;= kMod) ? (x + y - kMod) : (x + y);
}

int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  scanf("%s", s + 1);
  n = strlen(s + 1);
  for (int i = 1; i &lt;= n; ++i) {
    if (s[i] == 'A') ss[i] = 0;
    else if (s[i] == 'G') ss[i] = 1;
    else if (s[i] == 'C') ss[i] = 2;
    else if (s[i] == 'T') ss[i] = 3;
    else ss[i] = -1;
  }
  for (int i = 0; i &lt; 4; ++i) {
    if (ss[1] != -1 &amp;&amp; ss[1] != i) continue ;
    for (int j = 0; j &lt; 4; ++j) {
      f[1][i][i][j] = 1;
    }
  }
  for (int i = 2; i &lt;= n; ++i) {
    for (int a = 0; a &lt; 4; ++a) {
      if (ss[i] != -1 &amp;&amp; ss[i] != a) continue ;
      for (int b = 0; b &lt; 4; ++b) { // 不重新开一段
        for (int c = 0; c &lt; 4; ++c) {
          for (int lst = 0; lst &lt; 4; ++lst) {
            if (lst != a) f[i][a][b][c] = add(f[i][a][b][c], f[i - 1][lst][b][c]);
          }
        }
      }
      for (int b = 0; b &lt; 4; ++b) { // 重新开一段
        for (int c = 0; c &lt; 4; ++c) {
          for (int lst = 0; lst &lt; 4; ++lst) {
            if (lst == c) f[i][a][a][b] = add(f[i][a][a][b], f[i - 1][lst][b][c]);
          }
        }
      }
    }
  }
  int ans = 0;
  for (int i = 0; i &lt; 4; ++i) {
    for (int j = 0; j &lt; 4; ++j) {
      ans = add(ans, f[n][i][j][i]);
    }
  }
  write(ans);
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16788839.html</id>
    <title type="text">[ZJOI2007] 报表统计 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-13T09:08:00Z</published>
    <updated>2022-10-13T09:08:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16788839.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P1110)

## Solution

显然是道 DS。

想到建两个个平衡树。一个用来维护所有数的最小差值，插入 $x$ 时，找到 $x$ 的前驱和后继更新答案即可。

另一个用来维护相邻数的最小差值。假设操作时在 $k$ 后插入 $x$，那么 $lst[k]$ 和 $a[k+1]$ 就不再相邻，需要删除，然后插入 $|lst[k]-x|$ 和 $|x-a[k+1]|$，然后将 $lst[k]$ 更新。

用 Splay 写就可以做到均摊 $O(\log n)$，总复杂度 $O((n+m)\log n)$，但有个巨大的常数，所以不开 O2 过不了。（用 multiset 可过）

## Code

&lt;details&gt;
&lt;summary&gt;Splay&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
bool read(char &amp;x) {
  while ((x = getc()) == ' ' || x == '\n' || x == '\r');
  return x != EOF;
}
bool read(char *x) {
  while ((*x = getc()) == '\n' || *x == ' ' || *x == '\r');
  if (*x == EOF) return 0;
  while (!(*x == '\n' || *x == ' ' || *x == '\r' || *x == EOF)) *(++x) = getc();
  *x = 0;
  return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 2e6 + 5;

class Splay {
/********** Need **********
 * Insert
 * Delete
 * GetPre
 * GetNext
 * GetMin
 ********** Need **********/
  public:
    int newnode(int x) {
      val[++tot] = x, sz[tot] = cnt[tot] = 1;
      return tot;
    }
    void pushup(int x) {
      sz[x] = sz[ch[x][0]] + cnt[x] + sz[ch[x][1]];
    }
    int get(int x) {
      return x == ch[fa[x]][1];
    }
    void clear(int x) {
      sz[x] = cnt[x] = val[x] = ch[x][0] = ch[x][1] = fa[x] = 0;
    }
    void rotate(int x) {
      int fl = get(x), y = fa[x], z = fa[y];
      ch[y][fl] = ch[x][fl ^ 1];
      if (ch[x][fl ^ 1]) fa[ch[x][fl ^ 1]] = y;
      ch[x][fl ^ 1] = y;
      if (z) ch[z][get(y)] = x;
      fa[y] = x, fa[x] = z;
      pushup(y), pushup(x);
    }
    void splay(int x) {
      for (int y = fa[x]; y = fa[x], y; rotate(x)) {
        if (fa[y]) rotate(get(x) == get(y) ? y : x);
      }
      rt = x;
    }
    void ins(int x) {
      if (!rt) {
        rt = newnode(x), pushup(rt);
        return ;
      }
      for (int cur = rt, f = 0; ; ) {
        if (val[cur] == x) {
          ++cnt[cur], pushup(cur), pushup(f);
          return splay(cur);
        }
        f = cur;
        cur = ch[cur][val[cur] &lt; x];
        if (!cur) {
          cur = newnode(x), fa[cur] = f, ch[f][val[f] &lt; x] = cur;
          pushup(cur), pushup(f);
          return splay(cur);
        }
      }
    }
    int getrk(int x) {
      int ret = 0;
      for (int cur = rt; cur; ) {
        if (x &lt; val[cur]) {
          cur = ch[cur][0];
        } else if (x == val[cur]) {
          ret += sz[ch[cur][0]] + 1, splay(cur);
          return ret;
        } else {
          ret += sz[ch[cur][0]] + cnt[cur];
          cur = ch[cur][1];
        }
      }
    }
    void _getpre() {
      int cur;
      for (cur = ch[rt][0]; ch[cur][1]; cur = ch[cur][1]) {}
      return splay(cur);
    }
    void del(int x) {
      getrk(x);
      if (cnt[rt] &gt; 1) {
        --cnt[rt];
        return pushup(rt);
      }
      if (!ch[rt][0] &amp;&amp; !ch[rt][1]) {
        clear(rt), rt = 0;
        return ;
      } else if (!ch[rt][0]) {
        int tmp = rt;
        rt = ch[rt][1], fa[rt] = 0;
        return clear(tmp);
      } else if (!ch[rt][1]) {
        int tmp = rt;
        rt = ch[rt][0], fa[rt] = 0;
        return clear(tmp);
      }
      int tmp = rt;
      _getpre();
      fa[ch[tmp][1]] = rt, ch[rt][1] = ch[tmp][1];
      return clear(tmp), pushup(rt);
    }
    int getpre(int x) {
      ins(x);
      if (cnt[rt] &gt; 1) return del(x), x;
      if (!ch[rt][0]) return del(x), -1;
      int ret, cur;
      for (cur = ch[rt][0]; ch[cur][1]; cur = ch[cur][1]) {}
      ret = val[cur], splay(cur);
      del(x);
      return ret;
    }
    int getnxt(int x) {
      ins(x);
      if (cnt[rt] &gt; 1) return del(x), x;
      if (!ch[rt][1]) return del(x), -1;
      int ret, cur;
      for (cur = ch[rt][1]; ch[cur][0]; cur = ch[cur][0]) {}
      ret = val[cur], splay(cur);        
      del(x);
      return ret;
    }
    int getmin() {
      int cur;
      if (!ch[rt][0]) return val[rt];
      for (cur = ch[rt][0]; ch[cur][0]; cur = ch[cur][0]) {}
      return val[cur];
    }
  private:
    int rt, tot, sz[kMaxN], cnt[kMaxN], val[kMaxN], ch[kMaxN][2], fa[kMaxN];
} s1, s2;

int n, m, ans2;
int a[kMaxN], b[kMaxN];
vector&lt;int&gt; v[kMaxN];

int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  read(n, m);
  for (int i = 1; i &lt;= n; ++i) {
    read(a[i]);
    b[i] = a[i];
    v[i].emplace_back(b[i]);
    s1.ins(a[i]);
    if (i &gt; 1) s2.ins(abs(a[i] - a[i - 1]));
  }
  ans2 = INT_MAX;
  sort(b + 1, b + 1 + n);
  for (int i = 1; i &lt; n; ++i) {
    ans2 = min(ans2, b[i + 1] - b[i]);
  }
  while (m--) {
    char op[10]; int x, k;
    read(op);
    if (op[0] == 'I') { // INSERT
      read(x, k);
      int lst = v[x][v[x].size() - 1], pre = s1.getpre(k), nxt = s1.getnxt(k);
      if (x != n) s2.del(abs(a[x + 1] - lst)), s2.ins(abs(k - a[x + 1]));
      s2.ins(abs(k - lst));
      v[x].emplace_back(k);
      if (~pre) ans2 = min(ans2, k - pre);
      if (~nxt) ans2 = min(ans2, nxt - k);
      s1.ins(k);
    } else if (op[4] == 'G') { // MIN_GAP
      write(s2.getmin(), '\n');
    } else { // MIN_SORT_GAP
      write(ans2, '\n');
    }
  }
  return 0;
}
```

&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;multiset&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
bool read(char &amp;x) {
  while ((x = getc()) == ' ' || x == '\n' || x == '\r');
  return x != EOF;
}
bool read(char *x) {
  while ((*x = getc()) == '\n' || *x == ' ' || *x == '\r');
  if (*x == EOF) return 0;
  while (!(*x == '\n' || *x == ' ' || *x == '\r' || *x == EOF)) *(++x) = getc();
  *x = 0;
  return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 5e5 + 5;

int n, m, ans2;
int a[kMaxN], b[kMaxN];
vector&lt;int&gt; v[kMaxN];
multiset&lt;int&gt; s1, s2;

int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  read(n, m);
  for (int i = 1; i &lt;= n; ++i) {
    read(a[i]);
    b[i] = a[i];
    v[i].emplace_back(a[i]), s1.emplace(a[i]);
  }
  ans2 = 1e9;
  sort(b + 1, b + 1 + n);
  for (int i = 1; i &lt;= n - 1; ++i) {
    s2.emplace(abs(a[i + 1] - a[i]));
    ans2 = min(ans2, abs(b[i + 1] - b[i]));
  }
  while (m--) {
    char op[10]; int x, k;
    read(op);
    if (op[0] == 'I') { // INSERT
      read(x, k);
      int lst = v[x][v[x].size() - 1];
      auto it = s1.lower_bound(k);
      if (it != s1.end()) ans2 = min(ans2, *it - k);
      if (it != s1.begin()) --it, ans2 = min(ans2, k - *it);
      auto ii = s2.lower_bound(abs(a[x + 1] - lst));
      if (ii != s2.end()) s2.erase(ii);
      s2.emplace(abs(k - lst));
      if (x != n) s2.emplace(abs(k - a[x + 1]));
      s1.emplace(k), v[x].emplace_back(k);
    } else if (op[4] == 'G') { // MIN_GAP
      write(*s2.begin(), '\n');
    } else { // MIN_SORT_GAP
      write(ans2, '\n');
    }
  }
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16788943.html</id>
    <title type="text">[CERC2016]机棚障碍 Hangar Hurdles 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-13T09:32:00Z</published>
    <updated>2022-10-13T09:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16788943.html" />
    <content type="text">## Description

给定一个 $n\times n$ 的网格图，其中部分格点有障碍物使得箱子不能置于其上。规定箱子是一个奇数边长的正方形，其坐标为其中心格点的坐标。箱子只能上下左右移动，每次询问从一个格点能移动到另一个格点的最大箱子。

## Solution

首先对于每个点 $(x,y)$ 用二分求出以这个点为中心格点的最大边长 $d[x][y]$，是 $O(n^2\log n)$ 的。

然后发现这是多组询问，所以不能暴力。

---

先把这个看成一个普通的无向图，把相邻的格点连无向边，边权为两个点的 $d$ 值取较小值，那么相当于就是询问图上两点的最大瓶颈路径。

这个东西可以用 Kruskal 先跑出最大生成树，然后最大瓶颈路径就是这两点的树上最短路径。

---

证明：

先看到 Kruskal 过程：将边权从大到小排序，然后枚举，如果加上当前边不会出现环，就加边。相当于就是能连边就连边。

假设 $u$ 和 $v$ 所在集合在枚举到从大到小第 $k$ 条边时**第一次**被合并，如果 $u$ 和 $v$ 的最大瓶颈路径小于当前边权，那么这相当于在这条边之前 $u$ 和 $v$ 的集合已经被合并了，那么这与假设矛盾。所以 Kruskal 跑出来的最大生成树就是最大瓶颈生成树。

---

注意：这可能是个森林，所以要对于每棵树都跑一遍最大生成树。

建完最大生成树后，询问就转化为求树上两点路径的最小边权，直接倍增 LCA 即可，每次是 $O(\log n)$ 的。

于是整个程序复杂度就为 $O(n^2\log n)$，由于时限开的很大，所以可以轻松通过。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
bool read(char &amp;x) {
  while ((x = getc()) == ' ' || x == '\n' || x == '\r');
  return x != EOF;
}
bool read(char *x) {
  while ((*x = getc()) == '\n' || *x == ' ' || *x == '\r');
  if (*x == EOF) return 0;
  while (!(*x == '\n' || *x == ' ' || *x == '\r' || *x == EOF)) *(++x) = getc();
  *x = 0;
  return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 1e3 + 5, kMaxS = 1e6 + 5, dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};

class DSU {
  public:
    void init(int n) {
      for (int i = 1; i &lt;= n; ++i) {
        fa[i] = i;
      }
    }
    int find(int x) {
      return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    void unionn(int x, int y) {
      int fx = find(x), fy = find(y);
      if (fx != fy) fa[fx] = fy;
    }
  private:
    int fa[kMaxS];
} d;

int n, q, yxy;
int dis[kMaxS];
char s[kMaxN][kMaxN];
vector&lt;pair&lt;int, int&gt;&gt; G[kMaxS];

int getid(int x, int y) {
  return (x - 1) * n + y;
}

void addE(int u, int v, int w) {
  G[u].emplace_back(v, w);
}

namespace GETDIS {

int sum[kMaxN][kMaxN], d[kMaxN][kMaxN];
queue&lt;pair&lt;int, int&gt;&gt; q;

int get(int m1, int n1, int m2, int n2) {
  return sum[m2][n2] - sum[m1 - 1][n2] - sum[m2][n1 - 1] + sum[m1 - 1][n1 - 1];
}

void solve() {
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + (s[i][j] == '#');
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (s[i][j] == '#') continue ;
      int L = 0, R = min({i - 1, n - i, j - 1, n - j}) + 1, res = 0;
      while (L + 1 &lt; R) {
        int mid = (L + R) &gt;&gt; 1;
        if (!get(i - mid, j - mid, i + mid, j + mid)) L = res = mid;
        else R = mid;
      }
      d[i][j] = dis[getid(i, j)] = 2 * res + 1;
    }
  }
}

} // namespace GETDIS

namespace KRUSKAL {

struct Edge {
  int u, v, w;
} ed[kMaxS &lt;&lt; 2];

DSU dd;

int tot, cnt[kMaxS], tt[kMaxS], fa[kMaxS];

void build() {
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (s[i][j] == '#') continue ;
      for (int k = 0; k &lt; 2; ++k) {
        int tx = i + dx[k], ty = j + dy[k];
        if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; n || s[tx][ty] == '#') continue ;
        int u = getid(i, j), v = getid(tx, ty), w = min(dis[u], dis[v]);
        ed[++tot] = {u, v, w}, d.unionn(u, v);
      }
    }
  }
}

void solve() {
  d.init(n * n), dd.init(n * n), build();
  for (int i = 1; i &lt;= n * n; ++i) {
    if (dis[i]) ++tt[fa[i] = d.find(i)];
  }
  sort(ed + 1, ed + 1 + tot, [&amp;] (Edge e1, Edge e2) { return e1.w &gt; e2.w; });
  for (int i = 1; i &lt;= tot; ++i) {
    int fu = dd.find(ed[i].u), fv = dd.find(ed[i].v);
    if (fu != fv) {
      if (cnt[fa[ed[i].u]] == tt[fa[ed[i].u]] - 1) continue ;
      dd.unionn(ed[i].u, ed[i].v);
      addE(ed[i].u, ed[i].v, ed[i].w), addE(ed[i].v, ed[i].u, ed[i].w);
      ++cnt[fa[ed[i].u]];
    }
  }
}

} // namespace KRUSKAL

namespace LCA {

int lg[kMaxS], dep[kMaxS], mi[kMaxS][22], fa[kMaxS][22];

void getlg() {
  memset(mi, 0x3f, sizeof(mi));
  lg[0] = -1;
  for (int i = 1; i &lt;= n * n; ++i) {
    lg[i] = lg[i &gt;&gt; 1] + 1;
  }
}

void dfs(int u, int fat, int lw) {
  dep[u] = dep[fat] + 1, fa[u][0] = fat, mi[u][0] = lw;
  for (int i = 1; i &lt;= lg[n * n]; ++i) {
    fa[u][i] = fa[fa[u][i - 1]][i - 1];
    mi[u][i] = min(mi[u][i - 1], mi[fa[u][i - 1]][i - 1]);
  }
  for (auto [v, w] : G[u]) {
    if (v == fat) continue ;
    dfs(v, u, w);
  }
}

int LCA(int x, int y) {
  if (dep[x] &lt; dep[y]) swap(x, y);
  for (int i = lg[n * n]; ~i; --i) {
    if (dep[fa[x][i]] &gt;= dep[y]) {
      x = fa[x][i];
    }
  }
  if (x == y) return x;
  for (int i = lg[n * n]; ~i; --i) {
    if (fa[x][i] != fa[y][i]) {
      x = fa[x][i], y = fa[y][i];
    }
  }
  return fa[x][0];
}

int getmx(int x, int y) {
  int lca = LCA(x, y), ret = 1e9;
  for (int i = lg[n * n]; ~i; --i) {
    if (dep[fa[x][i]] &gt; dep[lca]) ret = min(ret, mi[x][i]), x = fa[x][i];
    if (dep[fa[y][i]] &gt; dep[lca]) ret = min(ret, mi[y][i]), y = fa[y][i];
  }
  if (x != lca) ret = min(ret, mi[x][0]);
  if (y != lca) ret = min(ret, mi[y][0]);
  return ret;
}

} // namespace LCA

int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  read(n);
  for (int i = 1; i &lt;= n; ++i) {
    read(s[i] + 1);
  }
  GETDIS::solve(), KRUSKAL::solve(), LCA::getlg();
  for (int i = 1; i &lt;= n * n; ++i) {
    if (dis[i] &amp;&amp; d.find(i) == i) {
      LCA::dfs(i, 0, 1e9);
    }
  }
  read(q);
  while (q--) {
    int s1, t1, s2, t2;
    read(s1, t1, s2, t2);
    int u = getid(s1, t1), v = getid(s2, t2);
    if (d.find(u) == d.find(v)) write(LCA::getmx(getid(s1, t1), getid(s2, t2)), '\n');
    else write(0, '\n');
  }
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16789498.html</id>
    <title type="text">[HAOI2015]数字串拆分 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-13T12:09:00Z</published>
    <updated>2022-10-13T12:09:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16789498.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P3176)

## Solution

首先 $f$ 很好求，$f[i]$ 就等于 $f[i-1]+f[i-2]+...+f[i-m]$，看到 $m$ 很小，所以矩乘优化成 $m^3\log n$ 的复杂度，假设单位矩阵为 $A$。设 $m_i$ 表示 $[f_{i-m+1},f_{i-m+2},...,f_i]$，那么：$m_{i-1}\ast A=m_i$。

由于 $g$ 的式子非常奇怪，所以不能直接搞。注意到 $m_{i}=A^i$，所以 $m_{i+j}=m_i\ast m_j$。

所以可以设 $g_i$ 表示将字符串的前 $i$ 个字符分割的的方案矩阵，那么：

$$
g_i=\sum_{j=0}^{j-1}{g_j\ast D_{j+1,i}}
$$

其中 $D_{j+1,i}$ 表示从 $j+1$ 到 $i$ 的字符的转移矩阵。

这样就可以 $O(n^2\times m^3)$

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x,B &amp;...y) { return read(x) &amp;&amp; read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A,typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMod = 998244353;

struct matrix {
  int a[6][6];

  void clear() {
    memset(a, 0, sizeof(a));
  }
} b, mi[10];

int n, m;
int a[505];
char s[505];
matrix d[505][505], f[505];

int add(int x, int y) {
  return (x + y &gt;= kMod) ? (x + y - kMod) : (x + y);
}

matrix mul(matrix a, matrix b) {
  static matrix c;
  c.clear();
  for (int k = 1; k &lt;= m; ++k) {
    for (int i = 1; i &lt;= m; ++i) {
      for (int j = 1; j &lt;= m; ++j) {
        c.a[i][j] = (c.a[i][j] + 1ll * a.a[i][k] * b.a[k][j] % kMod) % kMod;
      }
    }
  }
  return c;
}

matrix add(matrix a, matrix b) {
  static matrix c;
  c.clear();
  for (int i = 1; i &lt;= m; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      c.a[i][j] = add(a.a[i][j], b.a[i][j]);
    }
  }
  return c;
}

matrix qpow(matrix bs, int idx = 10) {
  matrix ret = bs; --idx;
  for (; idx; idx &gt;&gt;= 1, bs = mul(bs, bs)) {
    if (idx &amp; 1) ret = mul(ret, bs);
  }
  return ret;
}


int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  scanf("%s", s + 1);
  scanf("%d", &amp;m);
  n = strlen(s + 1);
  for (int i = 1; i &lt;= n; ++i) {
    a[i] = s[i] - '0';
  }
  for (int i = 1; i &lt; m; ++i) {
    b.a[i + 1][i] = 1;
  }
  for (int i = 1; i &lt;= m; ++i) {
    b.a[i][m] = 1;
  }
  for (int i = 1; i &lt;= m; ++i) {
    mi[0].a[i][i] = 1;
  }
  for (int i = 1; i &lt;= 9; ++i) {
    mi[i] = mul(mi[i - 1], b);
  }
  for (int i = 1; i &lt;= n; ++i) {
    matrix nw = mi[0];
    for (int j = i; j &lt;= n; ++j) {
      d[i][j] = nw = mul(qpow(nw), mi[a[j]]);
    }
  }
  f[0] = mi[0];
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt; i; ++j) {
      f[i] = add(f[i], mul(f[j], d[j + 1][i]));
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= m; ++i) {
    ans = add(ans, f[n].a[1][i]);
  }
  write(ans);
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/16793743.html</id>
    <title type="text">郁闷的出纳员 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2022-10-15T03:18:00Z</published>
    <updated>2022-10-15T03:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/16793743.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P1486)

## Solution

显然是用平衡树维护，感觉 Splay 比较好维护。

设 $delta$ 表示当前总共加了多少工资，$delta &lt; 0$ 则表示扣了 $-delta$ 的工资。

对于 `I` 操作，直接在平衡树里插入 $k-delta$。

对于 `A` 操作，就将 $delta$ 加 $k$。

对于 `S` 操作，这时可能会有一些员工离开公司，所以可以先把 $minn-delta$ 插入到平衡树，并将其 splay 到根节点，这样左子树就是要去除的，直接将 `ch[rt][0]` 赋为 0，然后再删除 $minn-delta$。剩下的就是还能留在公司的。

对于询问，如果平衡树里的结点个数不少于 $k$ 就直接求即可，否则输出 $-1$。注意：这是求第 $k$ 大的值！（我在询问里把`平衡树里的结点个数`写成了`进入过公司的员工个数`，导致样例  TLE。）

这样就可以做到均摊 $O(\log n)$ 的时间复杂度。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include &lt;debug.h&gt;
#else
#define debug(...) 1
#endif

using namespace std;

const int kMaxN = 1e5 + 5;

class Splay {
  public:
    void pushup(int x) {
      sz[x] = sz[ch[x][0]] + cnt[x] + sz[ch[x][1]];
    }
    int get(int x) {
      return x == ch[fa[x]][1];
    }
    void clear(int x) {
      fa[x] = ch[x][0] = ch[x][1] = sz[x] = val[x] = cnt[x] = 0;
    }
    int newnode(int x) {
      val[++tot] = x, cnt[tot] = sz[tot] = 1;
      return tot;
    }
    void rotate(int x) {
      int fl = get(x), y = fa[x], z = fa[y];
      if (ch[x][fl ^ 1]) fa[ch[x][fl ^ 1]] = y;
      ch[y][fl] = ch[x][fl ^ 1], ch[x][fl ^ 1] = y;
      if (z) ch[z][get(y)] = x;
      fa[y] = x, fa[x] = z;
      pushup(y), pushup(x);
    }
    void splay(int x) {
      for (int y = fa[x]; y; rotate(x), y = fa[x]) {
        if (fa[y]) rotate(get(x) == get(y) ? y : x);
      }
      rt = x;
    }
    void ins(int x) {
      if (!rt) {
        rt = newnode(x);
        return ;
      }
      for (int cur = rt, f = 0; ; ) {
        if (val[cur] == x) {
          ++cnt[cur], pushup(cur), pushup(f);
          return splay(cur);
        }
        f = cur;
        cur = ch[cur][val[cur] &lt; x];
        if (!cur) {
          cur = newnode(x), fa[cur] = f, ch[f][val[f] &lt; x] = cur;
          return pushup(cur), pushup(f), splay(cur);
        }
      }
    }
    int getrk(int x) {
      int ret = 0;
      for (int cur = rt; cur; ) {
        if (x &lt; val[cur]) {
          cur = ch[cur][0];
        } else if (x == val[cur]) {
          ret += sz[ch[cur][0]] + cnt[cur];
          return splay(cur), ret;
        } else {
          ret += sz[ch[cur][0]] + cnt[cur], cur = ch[cur][1];
        }
      }
      return ret;
    }
    int getkth(int x) {
      for (int cur = rt; ; ) {
        if (x &lt;= sz[ch[cur][0]]) {
          cur = ch[cur][0];
        } else if (x &lt;= sz[ch[cur][0]] + cnt[cur]) {
          return splay(cur), val[cur];
        } else {
          x -= sz[ch[cur][0]] + cnt[cur], cur = ch[cur][1];
        }
      }
    }
    void _getpre() {
      int cur = ch[rt][0];
      for (; ch[cur][1]; cur = ch[cur][1]) {}
      splay(cur);
    }
    void del(int x) {
      getrk(x);
      if (cnt[rt] &gt; 1) {
        --cnt[rt], pushup(rt);
        return ;
      }
      if (!ch[rt][0] &amp;&amp; !ch[rt][1]) {
        clear(rt), rt = 0;
        return ;
      } else if (!ch[rt][0]) {
        int tmp = rt; rt = ch[rt][1];
        return fa[rt] = 0, clear(tmp);
      } else if (!ch[rt][1]) {
        int tmp = rt; rt = ch[rt][0];
        return fa[rt] = 0, clear(tmp);
      }
      int oldrt = rt; _getpre();
      ch[rt][1] = ch[oldrt][1], fa[ch[oldrt][1]] = rt;
      clear(oldrt);
      return pushup(rt);
    }
    void yxy() {
      ch[rt][0] = 0, pushup(rt);
    }
    int gettot() {
      return sz[rt];
    }
  public:
    int rt, tot, fa[kMaxN], ch[kMaxN][2], sz[kMaxN], val[kMaxN], cnt[kMaxN];
} s;

int n, mini, nw, k, tot, delta;
char op[10];

int main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  scanf("%d%d", &amp;n, &amp;mini);
  for (int i = 1; i &lt;= n; ++i) {
    scanf("%s%d", op, &amp;k);
    if (op[0] == 'I') { // INSERT
      if (k &lt; mini) continue ;
      ++tot, s.ins(k - delta);
    } else if (op[0] == 'A') { // ADD
      delta += k;
    } else if (op[0] == 'S') { // MINUS
      delta -= k;
      s.ins(mini - delta), s.yxy(), s.del(mini - delta);
    } else { // QUERY
      int sz = s.gettot();
      if (sz &gt;= k) printf("%d\n", s.getkth(sz - k + 1) + delta);
      else puts("-1");
    }
  }
  printf("%d\n", tot - s.gettot());
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17038700.html</id>
    <title type="text">2023.1.8 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-09T14:43:00Z</published>
    <updated>2023-01-09T14:43:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17038700.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/103428/problem/J)

## Solution

注意到这个角度 $\beta$ 反弹后是不会变得，每次只会旋转 $2\beta$ ，所以就是 $\dfrac{2a}{360b}$ 个圆，也就是 $\dfrac{a}{180b}$，所以答案是 $\dfrac{180b}{[a,180b]}$。

## Code

[link](https://codeforces.com/gym/103428/submission/188374509)

# T2

## Description

[link](https://codeforces.com/gym/103428/problem/M)

## Solution

考虑把题目转换为 $\leq k$ 的和 $\leq k - 1$。

然后题目就相当于：求长度为 $n$ 的 $01$ 字符串，一共有 $m$ 个 $1$，每段 $1$ 的长度不超过 $k$ 的方案数。

这个东西一看就不可做，所以可以再转化一下，利用 $0$ 把这个数列分成 $n-m+1$ 个段（相邻的看作 $0$）。

这样的话每个把 $m$ 拆分成 $n-m+1$ 个非负整数的方案就对应一个字符串，然后枚举超过 $k$ 的个数，然后容斥一下即可。

时间复杂度：$O(n)$。

## Code

[link](https://codeforces.com/gym/103428/submission/188392102)

# T3

## Description

[link](https://codeforces.com/gym/103428/problem/E)

## Solution

设 $f[i]$ 表示重新抽取 $i$ 次的期望答案。

首先 $f[0]$ 就是 $\dfrac{2\sum\limits_{i\neq j}{(a_i+a_j)}}{n\times (n-1)}$，也就是 $\dfrac{2\sum{a_i}}{n}$。

然后考虑递推得到 $f[i]$。如果第一次抽取的 $s\geq f[i-1]$，那么显然没有必要重新抽取。如果 $s&lt;f[i-1]$，那么重新抽取期望会比不抽要优，所以要重新抽取。

然后就是求有多少个 $a[i]+a[j]&lt;f[i-1]$，这个可以先把 $a$ `sort` 一下，然后这个满足的最大的 $j$ 就是单调的，这个弄个指针维护一下即可。

时间复杂度：$O(nk+q)$。

## Code

[link](https://codeforces.com/gym/103428/submission/188396023)

# T4

## Description

[link](https://codeforces.com/gym/103428/problem/H)

## Solution

设 $v_{i,p}$ 表示表示距离 $i\leq p$ 的所有点全选，$u_i$ 表示原图的点 $i$。把题目转换为最小割。

1. 从源点向 $v_{i,p}$ 连一条流量为 $v_p-v_{p-1}$ 的边，表示增量收益。
2. 所有 $v_{i,p}$ 向 $v_{i,p-1}$ 连一条容量为无穷大的边，表示只能从大到小放弃。
3. $u_{i}$ 向汇点连一条容量为 $w_i$ 的边，表示选 $i$ 的代价。
4. $v_{i,p}$ 向所有距离 $i$ 为 $p$ 的点连一条容量为无穷大的边，表示选了 $v_{i,p}$ 就必须选这些点。

然后就让总的价值和减去最大流就行。

时间复杂度：Dinic：$O(n^4)$，这个东西根本跑不满。

（貌似用 EK 求最大流会 T）

## Code

[link](https://codeforces.com/gym/103428/submission/188403124)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17038767.html</id>
    <title type="text">2023.1.9 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-09T14:48:00Z</published>
    <updated>2023-01-09T14:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17038767.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/103409/problem/D)

## Solution

直接按照下标从左往右扫，如果 $a_i&lt;b_i$ 就一定不行。

否则再从 $i+1$ 扫到 $n$，如果 $a_j&lt;a_i$ 且 $a_j\geq b_i$ 就将 $i$ 和 $j$ 交换，然后就做完了。

但是我不会证。

时间复杂度：$O(n^2)$。

# T2

## Description

[link](https://codeforces.com/gym/103409/problem/E)

## Solution

对于任意一张图，操作次数不会超过 $2$，因为可以先把所有 $u&lt;v$ 的边删掉，再把 $u&gt;v$ 的边删掉，这样是没有环的并且能全部删掉。

然后如果操作次数是 $2$，那么图中至少有 $1$ 个环，所以直接求出最小环即可。

如果最小环都满足不了要求，那么就是 $0$ 或 $1$。

至于如何求最小环，就是把每个点拆成入点和出点，每个点的入点向出点连一条权值为 $0$ 的有向边。对于每条原图上的边 $(u,v,w)$，就让 $u$ 的出点向 $v$ 的入点连一条权值为 $w$ 的有向边。

然后求全源最短路即可。

时间复杂度：$O(n(n+m)\log n)$。

# T3

## Description

[link](https://codeforces.com/gym/103409/problem/K)

## Solution

先求出最短路，在建一个新图，新图上的边 $(u,v)$ 代表 $v$ 的最短路可以由 $u$ 过来，这个新图是没有环的，而且 $n$ 很小，所以直接 dfs 即可。

时间复杂度：最大是 $O(3^{17})$。

## T4

## Description

[link](https://codeforces.com/gym/103409/problem/B)

## Solution

如果 $a_i+b_i&lt;10$ 那么第 $i$ 位对高位是没有影响的。

如果 $a_i+b_i\geq 10$，那么第 $i$ 位会影响到最大的 $j$，使得 $j&lt;i$ 且 $a_j+b_j\neq 9$。

所以 $c_i = (a_i + b_i + [a_j + b_j \geq 10])\bmod 10$，其中 $j$ 为最小的满足 $j &gt; i$ 且 $a_j + b_j\neq 9$ 的位置 $j$。

所以修改第 $i$ 位，高位发生变化最多只会到最大的 $j&lt;i$ 且 $a_j+b_j\neq 9$ 的 $j$。

这个时候就需要一个支持插入、删除、查询前驱和后继的数据结构，直接 set 即可。

时间复杂度：$O((n+q)\log n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17041533.html</id>
    <title type="text">2023.1.10 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-10T14:15:00Z</published>
    <updated>2023-01-10T14:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17041533.html" />
    <content type="text"># T1

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/K)

## Solution

首先可以把这个排列看成若干个置换环，易知置换环之间是互不影响的。所以只需要考虑每个置换环的答案。

首先可以想到一个不是很优的做法：每次把置换环上相邻的两个点操作，然后每次可以让置换环大小减半，所以只能做到 $\log n$ 次，不是最优的。

这个做法不优是因为有很多操作是不能同时做的，导致浪费了很多次操作。

所以可以这么做：每次从一个置换环上相隔为 $1$ 的两点开始，每次往另一方向跳，然后把跳到的点操作。

最后会变成若干个二元环和一元环，然后就可以 $2$ 次做完了。

时间复杂度：$O(n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e5 + 5;

int n;
int a[kMaxN], b[kMaxN], tmp[kMaxN];
bool vis[kMaxN];
vector&lt;pair&lt;int, int&gt;&gt; v[3];

bool check0() {
  for (int i = 1; i &lt;= n; ++i)
    if (a[i] != i)
      return 0;
  cout &lt;&lt; "0\n";
  return 1;
}

bool check1() {
  int cnt = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (a[i] == i) continue;
    if (a[a[i]] != i) return 0;
    ++cnt;
  }
  cnt /= 2;
  cout &lt;&lt; "1\n" &lt;&lt; cnt &lt;&lt; ' ';
  for (int i = 1; i &lt;= n; ++i) {
    if (a[i] == i) continue;
    if (i &lt; a[i]) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; a[i] &lt;&lt; ' ';
  }
  return 1;
}

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    b[a[i]] = i;
  }
  if (check0()) return 0;
  if (check1()) return 0;
  cout &lt;&lt; "2\n";
  for (int c = 1; c &lt;= 2; ++c) {
    fill(vis + 1, vis + 1 + n, 0);
    for (int i = 1; i &lt;= n; ++i)
      tmp[i] = a[i];
    for (int i = 1; i &lt;= n; ++i) {
      if (a[i] == i || vis[i]) continue;
      bool fl = 0;
      for (int j = i; j != i || !fl; j = a[j]) {
        vis[j] = 1;
        fl = 1;
      }
      if (a[a[i]] == i) {
        v[c].emplace_back(i, a[i]);
        swap(tmp[i], tmp[a[i]]);
      } else {
        int x = a[i], y = b[i];
        for (; x != y; x = a[x], y = b[y]) {
          v[c].emplace_back(x, y);
          swap(tmp[x], tmp[y]);
          if (x == y || y == a[x]) break;
        }
      }
    }
    for (int i = 1; i &lt;= n; ++i)  
      a[i] = tmp[i];
    cout &lt;&lt; v[c].size() &lt;&lt; ' ';
    for (auto [x, y] : v[c]) {
      cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
  return 0;
}
```

&lt;/details&gt;

# T2

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/I)

## Solution

是个模拟题，直接按题意模拟即可，时间复杂度：$O(T\times 34^3\times 25)$，这个跑不满。

## Code

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kC[] = {8, 8, 8, 6};
const char kR[] = "wbsz";

struct Node {
  int cnt[4], a[4][9];
  
  void clear() { memset(cnt, 0, sizeof(cnt)), memset(a, 0, sizeof(a)); }
};

int id[300];

bool check1(Node a) {
  for (int i = 0; i &lt;= 3; ++i)
    if (a.cnt[i] % 3)
      return 0;
  for (int i = 0; i &lt;= 6; ++i)
    if (a.a[3][i] % 3)
      return 0;
  for (int i = 0; i &lt;= 2; ++i) {
    for (int j = 0; j &lt;= 8; ++j) {
      if (a.a[i][j] &lt; 0) return 0;
      a.a[i][j] %= 3;
      if (j + 2 &gt; kC[i] &amp;&amp; a.a[i][j]) return 0;
      if (j + 2 &lt;= kC[i]) a.a[i][j + 1] -= a.a[i][j], a.a[i][j + 2] -= a.a[i][j];
    }
  }
  return 1;
}

bool check(Node a) {
  for (int i = 0; i &lt;= 3; ++i)
    for (int j = 0; j &lt;= kC[i]; ++j) {
      if (a.a[i][j] &lt; 2) continue;
      a.a[i][j] -= 2, a.cnt[i] -= 2;
      if (check1(a)) return 1;
      a.a[i][j] += 2, a.cnt[i] += 2;      
    }
  return 0;
}

Node trans(string s) {
  Node ret;
  ret.clear();
  for (int i = 0; i &lt; s.size(); i += 2) {
    ++ret.cnt[id[s[i + 1]]], ++ret.a[id[s[i + 1]]][s[i] - '1'];
  }
  return ret;
}

void solve(string s) {
  Node ss = trans(s);
  if (check(ss)) {
    cout &lt;&lt; "Tsumo!\n";
    return;
  }
  int tot = 0;
  string res[30];
  for (int i = 0; i &lt;= 3; ++i)
    for (int j = 0; j &lt;= kC[i]; ++j)
      if (ss.a[i][j] &gt;= 1) {
        ss.a[i][j] -= 1, ss.cnt[i] -= 1;
        string ans = "";
        for (int ii = 0; ii &lt;= 3; ++ii)
          for (int jj = 0; jj &lt;= kC[ii]; ++jj)
            if (ii != i || jj != j) {
              ++ss.a[ii][jj], ++ss.cnt[ii];
              if (check(ss)) {
                ans += char(jj + '1');
                ans += kR[ii];
              }
              --ss.a[ii][jj], --ss.cnt[ii];
            }
        if (ans.size() &gt; 0) {
          res[++tot] = char(j + '1');
          res[tot] += kR[i];
          res[tot] += " ";
          res[tot] += ans;
        } 
        ss.a[i][j] += 1, ss.cnt[i] += 1;
      }
  cout &lt;&lt; tot &lt;&lt; '\n';
  for (int i = 1; i &lt;= tot; ++i)
    cout &lt;&lt; res[i] &lt;&lt; '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  id['w'] = 0, id['b'] = 1, id['s'] = 2, id['z'] = 3;
  int T;
  cin &gt;&gt; T;
  while (T--) {
    string s;
    cin &gt;&gt; s;
    solve(s);
  }
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/C)

## Solution

设 $f[l,r]$ 表示操作 $[l,r]$，最后全变成 $a[r]$ 的最小操作次数。

那么可以得到一个朴素的转移：$f[l,r]=\min\big\{f[l,r-1]+1,f[l,k]+f[k+1,r]+[a[k]\neq a[r]]\big\}$。

这里会发现当 $a[k]=a[r]$ 的时候是不用加那个 $1$ 的，所以感性理解一下会发现当 $a[k]=a[r]$ 时是最优决策点。

时间复杂度：$O(15n^2)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 5005;

int T, n;
int a[kMaxN], lst[kMaxN], idx[kMaxN], f[kMaxN][kMaxN];

int main() {
  cin &gt;&gt; T;
  while (T--) {
    cin &gt;&gt; n;
    fill(lst + 1, lst + 1 + n, 0);
    fill(idx + 1, idx + 1 + n, 0);
    for (int i = 1; i &lt;= n; ++i) {
      cin &gt;&gt; a[i];
      lst[i] = idx[a[i]];
      idx[a[i]] = i;
    }
    for (int i = 1; i &lt;= n; ++i)
      for (int j = i; j &lt;= n; ++j)
        f[i][j] = 1e9;
    for (int i = 1; i &lt;= n; ++i)
      f[i][i] = 0;
    for (int len = 2; len &lt;= n; ++len) {
      for (int i = 1; i + len - 1 &lt;= n; ++i) {
        int j = i + len - 1;
        f[i][j] = f[i][j - 1] + 1;
        for (int k = lst[j]; k &gt;= i; k = lst[k]) {
          f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
        }
      }
    }
    cout &lt;&lt; f[1][n] &lt;&lt; '\n';
  }
  return 0;
}
```
&lt;/details&gt;

# T4

## Description

[link](https://ac.nowcoder.com/acm/contest/14055/G)

## Solution

先按生日排序，设 $f_{i,j,k}$ 表示 $1\sim i$ 这些人中，选了 $j$ 个人，总共还剩 $k$ 天剩余的最大收益。$g_{i}$ 表示送 $i$ 个人礼物的最大收益。

那么 $f_{i,j,k}=\max\big\{f_{i-1,j,k-d_i+d_{i-1}}\space,f_{i-1,j-1,k-d_i+d_{i-1}+c_i}+v_i\big\}$。$g_i$ 可以直接暴力求。

把第一维滚掉即可，时间复杂度：$O(n^2d+2^m)$，会 T。

考虑到这里的 $m$ 很小，所以不会有很多的数不选，那么可以把状态改成：$f_{i,j,k}$ 表示 $1\sim i$ 这些人中，有 $j$ 个人没选，总共还剩 $k$ 天剩余的最大收益，其中 $f_{i,m,k}$ 表示至少有 $m$ 人没选的最大收益。

那么  $f_{i,j,k}=\max\big\{f_{i-1,j-1,k-d_i+d_{i-1}}\space,f_{i-1,j,k-d_i+d_{i-1}+c_i}+v_i\big\}$。

$f_{i,m,k}=\max\big\{f_{i-1,m-1,k-d_i+d_{i-1}}\space,f_{i-1,m,k-d_i+d_{i-1}}\space,f_{i-1,m,k-d_i+d_{i-1}+c_i}+v_i\big\}$。

这样做就是 $O(nmd+2^m)$ 了。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 1005, day[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

struct Node {
  int d, c, v;
} a[kMaxN];

int n, m, w, tot;
int b[kMaxN], c[kMaxN], f[2][kMaxN][kMaxN], ff[kMaxN], g[20]; // f[i][j] : 没选 i 个人，有 j 天剩余 

bool cmp(Node a, Node b) {
  return a.d &lt; b.d;
}

void solve() {
  memset(g, 0xcf, sizeof(g));
  memset(f, 0xcf, sizeof(f));
  memset(ff, 0xcf, sizeof(ff));
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; w;
  for (int i = 1; i &lt;= n; ++i) {
    char ch;
    int year, mon, diao;
    cin &gt;&gt; year &gt;&gt; ch &gt;&gt; mon &gt;&gt; ch &gt;&gt; diao &gt;&gt; a[i].c &gt;&gt; a[i].v;
    a[i].d = day[mon - 1] + diao;
    if (mon == 2 &amp;&amp; diao == 29) a[i].d = 3232;
  }
  for (int i = 1; i &lt;= m; ++i)
    cin &gt;&gt; b[i] &gt;&gt; c[i];
  sort(a + 1, a + 1 + n, cmp);
  int cur = 0;
  f[1][0][0] = 0;
  for (int i = 1; i &lt;= n; ++i, cur ^= 1) {
    if (a[i].d == 3232) break;
    tot = i;
    for (int j = 0; j &lt; m; ++j) {
      for (int k = 0; k &lt;= 365; ++k) {
        f[cur][j][k] = -1e9;
        if (j &gt;= 1 &amp;&amp; k &gt;= a[i].d - a[i - 1].d) f[cur][j][k] = f[cur ^ 1][j - 1][k - (a[i].d - a[i - 1].d)];
        if (k + a[i - 1].d - a[i].d + a[i].c &lt;= 365 &amp;&amp; k + a[i - 1].d - a[i].d + a[i].c &gt;= 0)
          f[cur][j][k] = max(f[cur][j][k], f[cur ^ 1][j][k + a[i - 1].d - a[i].d + a[i].c] + a[i].v);
          // x + (a[i].d - a[i - 1].d) - a[i].c = k
      }
    }
    for (int k = 0; k &lt;= 365; ++k) {
      f[cur][m][k] = -1e9;
      if (m &gt;= 1 &amp;&amp; k &gt;= a[i].d - a[i - 1].d)
        f[cur][m][k] = max(f[cur ^ 1][m - 1][k - (a[i].d - a[i - 1].d)], f[cur ^ 1][m][k - (a[i].d - a[i - 1].d)]);
      if (k + a[i - 1].d - a[i].d + a[i].c &lt;= 365 &amp;&amp; k + a[i - 1].d - a[i].d + a[i].c &gt;= 0)
        f[cur][m][k] = max(f[cur][m][k], f[cur ^ 1][m][k + a[i - 1].d - a[i].d + a[i].c] + a[i].v);
    }
  }
  for (int i = 0; i &lt;= m; ++i) {
    for (int j = 0; j &lt;= 365; ++j)
      ff[i] = max(ff[i], f[cur ^ 1][i][j]);
  }
  for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) {
    int sumb = 0, sumc = 0, cnt = 0;
    for (int j = 1; j &lt;= m; ++j) {
      if (i &gt;&gt; (j - 1) &amp; 1) {
        sumb += b[j], sumc += c[j], ++cnt;
      }
    }
    if (sumb &lt;= w) g[cnt] = max(g[cnt], sumc);
  }
  ff[0] = 0;
  int ans = 0;
  for (int i = 0; i &lt;= m; ++i)
    for (int j = 0; j &lt;= m; ++j)
      if (tot - i + j &lt;= tot)
        ans = max(ans, ff[i] + g[j]);
  cout &lt;&lt; ans &lt;&lt; '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  while (T--) solve();
  return 0;
}
```

&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17043805.html</id>
    <title type="text">2023.1.11 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-11T07:00:00Z</published>
    <updated>2023-01-11T07:00:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17043805.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/102900/problem/B)

## Solution

容易发现一个地雷图的 $sum$ 和它的反图是一样的，而且 $B$ 到 $A$ 和到 $A$ 的反图操作次数和是 $nm$，所以必有一个是小于等于 $\lfloor\frac{nm}{2}\rfloor$，判断一下即可。

## Code

[link](https://codeforces.com/gym/102900/submission/188821812)

# T2

## Description

[link](https://codeforces.com/gym/102900/problem/D)

## Solution

如果分类讨论，分 $9$ 种情况会 WA on #8。

考虑左边那个人走了 $[0,x]$，右边那个人走了 $[x,n]$，然后这么走答案就是 $\max\big\{\dfrac{\min\{p_1,x-p_1\}}{v_1},\dfrac{\min\{n-p_2,p_2-x\}}{v_2}\big\}$，随着 $x$ 增大，左边那个会递增，右边那个会递减，所以这是单谷的，直接三分。

时间复杂度：$O(\log_{\frac{3}{2}}{\dfrac{n}{eps}})$。

## Code

[link](https://codeforces.com/gym/102900/submission/188824242)

# T3

## Description

[link](https://codeforces.com/gym/102900/problem/M)

## Solution

建出 Trie 树然后树形 dp 即可。

## Code

[link](https://codeforces.com/gym/102900/submission/188820842)

# T4

## Description

[link](https://codeforces.com/gym/102900/problem/H)

## Solution

容易发现按顺序吃是最优的，所以可以先 $O(k)$ 枚举每个人对应的是哪个。

由于旋转方法必定是先逆时针，再顺时针，所以可以先求出每个人逆时针要转的次数 $x_i$，顺时针转的次数 $y_i$。

这个题目就可以转化为：

&gt; 有 $n$ 个物品的属性为 $a$ 和 $b$，然后把这 $n$ 个物品划分为两个集合，第一个集合的价值是里面物品 $a_i$ 的最大值，第二个是 $b_i$ 的最大值，问两个价值之和最大是多少。

可以直接按 $a$ 从大到小排序，然后钦定第一个集合的价值，就可以求出第二个集合的最小价值。

回到这个题，如果是先逆时针再顺时针，就把 $x_i$ 赋值成 $2x_i$ 做一次上面那个。如果是先顺时针再逆时针就把 $y_i$ 赋值成 $2y_i$ 做一次。

时间复杂度：$O(k^2\log k)$。

## Code

[link](https://codeforces.com/gym/102900/submission/188839276)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17046710.html</id>
    <title type="text">2023.1.12 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-12T07:01:00Z</published>
    <updated>2023-01-12T07:01:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17046710.html" />
    <content type="text"># T1

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/K)

## Solution

由于图中没有奇环等价于图是二分图。

所以直接枚举每个点在左边还是右边，然后判断每条边是否在同一阵营。如果不是，就可以涂它。

时间复杂度：$O(2^n m)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m;
int a[20];
vector&lt;int&gt; G[20];

void solve(int cs) {
  for (int i = 1; i &lt;= n; ++i)
    G[i].clear();
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  int ans = 0;
  for (int s = 0; s &lt; (1 &lt;&lt; n); ++s) {
    for (int i = 1; i &lt;= n; ++i)
      a[i] = (s &gt;&gt; (i - 1) &amp; 1);
    int tmp = 0;
    for (int i = 1; i &lt;= n; ++i)
      for (auto j : G[i])
        if (a[i] != a[j])
          ++tmp;
    ans = max(ans, tmp / 2);
  }
  cout &lt;&lt; "Case #" &lt;&lt; cs &lt;&lt; ": " &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
  int T;
  cin &gt;&gt; T;
  for (int i = 1; i &lt;= T; ++i) solve(i);
  return 0;
}
```
&lt;/details&gt;

# T2

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/D)

## Solution

考虑递推构造。容易知道最多只能做 $\lfloor\frac{n}{2}\rfloor$ 次。

那么 $2k$ 就最多做 $k$ 次。如果已经求出了 $2k$ 的操作方案，那么就在第 $i$ 次的方案里连上 $(2i-1,2k+1)$ 和 $(2i,2k+2)$ 两条边，这样操作后还是一棵树。

然后再加上剩余的边作为最后一次操作，这样就由 $2k$ 推出了 $2k+2$ 的方案。

由 $2k$ 推到 $2k+1$ 就直接在第 $i(1\leq i\leq k)$ 次的方案里连上 $(i,2k+1)$ 即可。

时间复杂度：$O(n^2)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;
using Tree = vector&lt;pair&lt;int, int&gt;&gt;;

int n;

void solve(int cs) {
  vector&lt;Tree&gt; ff;
  cin &gt;&gt; n;
  Tree tmp;
  tmp.emplace_back(1, 2);
  ff.emplace_back(tmp);
  for (int i = 4; i &lt;= n; i += 2) {
    for (int j = 0; j &lt; i / 2 - 1; ++j) {
      auto &amp;vec = ff[j];
      vec.emplace_back(2 * j + 1, i - 1);
      vec.emplace_back(2 * j + 2, i);
    }
    tmp.clear();
    tmp.emplace_back(i - 1, i);
    for (int j = 1; j &lt;= i - 2; ++j) {
      if (j &amp; 1) tmp.emplace_back(j, i);
      else tmp.emplace_back(j, i - 1);
    }
    ff.emplace_back(tmp);
  }
  if (n &amp; 1) {
    for (int j = 0; j &lt; ff.size(); ++j) {
      ff[j].emplace_back(n, j + 1);
    }
  }
  cout &lt;&lt; "Case #" &lt;&lt; cs &lt;&lt; ": " &lt;&lt; ff.size() &lt;&lt; '\n';
  for (auto &amp;vec : ff) {
    for (auto [x, y] : vec) {
      cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
    }
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  for (int i = 1; i &lt;= T; ++i) solve(i);
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/E)

## Solution

设 $f[i,j]$ 表示 $(i,j)$ 这个点第一次是从哪里走过来的。

容易发现 $f$ 数组构成一棵树，如果把起点换一下，就相当于换一个根，树的形态不会变。所以把相邻的点连一条边，然后跑最大生成树即可。由于边权很小，所以排序用桶排会快一些。

时间复杂度：$O(nm\log nm)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 1005, kMaxS = 1e6 + 5, kD[][2] = {{0, 1}, {1, 0}};

struct Edge {
  int u, v, w;
} e[kMaxS &lt;&lt; 2];

int n, m, ed;
int x[kMaxS], fa[kMaxS];

bool cmp(Edge e1, Edge e2) {
  return e1.w &gt; e2.w;
}

void init() {
  ed = 0;
  for (int i = 1; i &lt;= n * m; ++i) {
    fa[i] = i;
  }
}

void addE(int u, int v, int w) {
  e[++ed] = {u, v, w};
}

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

int kruskal() {
  vector&lt;Edge&gt; vec[10005];
  int ret = 0, cnt = 0;
  for (int i = 1; i &lt;= ed; ++i) {
    vec[e[i].w].emplace_back(e[i]);
  }
  ed = 0;
  for (int i = 10000; ~i; --i) {
    for (auto p : vec[i])
      e[++ed] = p;
  }
  for (int i = 1; i &lt;= ed; ++i) {
    int fu = find(e[i].u), fv = find(e[i].v);
    if (fu != fv) {
      fa[fu] = fv;
      ret += e[i].w;
      if (++cnt == n * m - 1) break;
    }
  }
  return ret;
}

void solve(int cs) {
  int sr, sc, tr, tc, A, B, C, P;
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; sr &gt;&gt; sc &gt;&gt; tr &gt;&gt; tc;
  cin &gt;&gt; x[1] &gt;&gt; x[2] &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; P;
  init();
  for (int i = 3; i &lt;= n * m; ++i) {
    x[i] = (A * x[i - 1] % P + B * x[i - 2] % P + C) % P;
  }
  auto getid = [&amp;] (int x, int y) { return (x - 1) * m + y; };
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      for (auto [dx, dy] : kD) {
        int ti = i + dx, tj = j + dy;
        if (ti &lt; 1 || ti &gt; n || tj &lt; 1 || tj &gt; m) continue;
        addE(getid(i, j), getid(ti, tj), x[getid(i, j)] * x[getid(ti, tj)]);
      }
    }
  }
  cout &lt;&lt; "Case #" &lt;&lt; cs &lt;&lt; ": " &lt;&lt; kruskal() &lt;&lt; '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  for (int i = 1; i &lt;= T; ++i) solve(i);
  return 0;
}
```
&lt;/details&gt;


# T4

## Description

[link](https://ac.nowcoder.com/acm/contest/4370/H)

## Solution

首先肯定是二分最大值 $x$。

设 $f[i]$ 表示 $i$ 的子树里，$i$ 所在连通块的最小合法权值。容易发现 $f[i]$ 只跟 $i$ 的儿子有关，所以直接按 $f$ 从小到大排序，能拼就拼，不能拼就割掉。

时间复杂度：$O(n\log n\log\sum{w_i})$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5;

int n, k, x, cnt;
int w[kMaxN], f[kMaxN];
vector&lt;int&gt; G[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

void dfs(int u, int fa) {
  vector&lt;int&gt; vec;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u);
    vec.emplace_back(f[v]);
  }
  sort(vec.begin(), vec.end());
  f[u] = w[u];
  for (int i = 0; i &lt; vec.size(); ++i) {
    if (f[u] + vec[i] &gt; x) {
      cnt += vec.size() - i;
      return;
    } else {
      f[u] += vec[i];
    }
  }
}

bool check(int s) {
  cnt = 0;
  fill(f + 1, f + 1 + n, 0);
  x = s;
  dfs(1, 0);
  return cnt &lt;= k - 1;
}

void solve(int cs) {
  int sum = 0, maxi = 0;
  for (int i = 1; i &lt;= n; ++i)
    G[i].clear();
  cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    cin &gt;&gt; u &gt;&gt; v;
    addE(u, v), addE(v, u);
  }
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; w[i];
    sum += w[i];
    maxi = max(maxi, w[i]);
  }
  int L = maxi - 1, R = sum + 1, res;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (check(mid)) R = res = mid;
    else L = mid;
  }
  cout &lt;&lt; "Case #" &lt;&lt; cs &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n';
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  for (int i = 1; i &lt;= T; ++i) solve(i);
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17050077.html</id>
    <title type="text">2023.1.13 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-13T08:18:00Z</published>
    <updated>2023-01-13T08:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17050077.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/102835/problem/C)

## Solution

容易发现每个点最后的状态只跟它的经过次数有关，所以可以设 $f[i,j]$ 表示经过 $(i,j)$ 的次数。

那么 $f[0][0]=k,f[i,j]=\big\lceil\frac{f[i-1,j]}{2}\big\rceil+\big\lfloor\frac{f[i,j-1]}{2}\big\rfloor$。

时间复杂度：$O(n^2)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e4 + 5;

int n, k;
int f[kMaxN][kMaxN];

void solve() {
  cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i &lt;= n + 1; ++i) {
    for (int j = 1; j + i &lt;= n + 1; ++j)
      f[i][j] = 0;
  }  
  f[1][1] = k;
  int ans = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j + i &lt;= n + 1; ++j) {
      f[i + 1][j] += (f[i][j] + 1) / 2;
      f[i][j + 1] += f[i][j] / 2;
    }
  }
  int x = 1, y = 1;
  for (; x + y &lt;= n;) {
    if (f[x][y] &amp; 1) ++x;
    else ++y;
  }  
  cout &lt;&lt; y - 1 &lt;&lt; '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  while (T--) solve();
  
  cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T2

## Description

[link](https://codeforces.com/gym/102835/problem/E)

## Solution

设 $f[l,r,c]$ 表示把 $a[l,...,r]$ 操作后只剩颜色为 $c$，$c$ 的数量的最大值。

那么 $f[l,r,c]=\max_{k=l}^{r-1}{(f[l][k][c]+f[k+1][r][c])}$。

注意，如果求出 $f[l,r,c]$ 不小于 $m$，那么这个区间其它的颜色数量不会小于 $0$，所以要和 $0$ 取 $\text{max}$。

时间复杂度：$O(n^3)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 505;

int n, m;
int a[kMaxN], b[300], f[kMaxN][kMaxN][8];
string s;

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  b['R'] = 1, b['G'] = 2, b['B'] = 3, b['C'] = 4, b['M'] = 5, b['Y'] = 6, b['K'] = 7;
  cin &gt;&gt; s &gt;&gt; m;
  n = s.size();
  for (int i = 0; i &lt; n; ++i) {
    a[i + 1] = b[s[i]];
  }
  memset(f, 0xcf, sizeof(f));
  for (int i = 1; i &lt;= n; ++i) {
    f[i][i][a[i]] = 1;
    if (m == 1) {
      for (int c = 1; c &lt;= 7; ++c)
        f[i][i][c] = max(f[i][i][c], 0);
    }
  }
  for (int len = 2; len &lt;= n; ++len) {
    for (int i = 1; i + len - 1 &lt;= n; ++i) {
      int j = i + len - 1;
      bool fl = 0;
      for (int c = 1; c &lt;= 7; ++c) {
        for (int k = i; k &lt; j; ++k)
          f[i][j][c] = max(f[i][j][c], f[i][k][c] + f[k + 1][j][c]);
        if (f[i][j][c] &gt;= m) fl = 1;
      }
      if (fl) {
        for (int c = 1; c &lt;= 7; ++c)
          f[i][j][c] = max(f[i][j][c], 0);
      }
    }
  }
  int maxi = 0;
  for (int c = 1; c &lt;= 7; ++c)
    maxi = max(maxi, f[1][n][c]);
  cout &lt;&lt; (maxi &gt;= m ? "Yes\n" : "No\n");
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://codeforces.com/gym/102835/problem/F)

## Solution

如果没有环，就直接设 $f[i,0/1]$ 表示把 $i$ 的子树全控制，$i$ 不选/选的最小答案。

那么 $f[i,0]=\sum{f[j,1]},f[i,1]=\sum{\min\{f[j,0],f[j,1]\}}+1$。

然后找到环上任意一对相邻的点 $x,y$，把这条边断掉，分别以 $x$ 和 $y$ 为根跑一遍上面那个 dp，输出最小值即可。

时间复杂度：$O(n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 2e5 + 5;

int n, m, x, y;
int f[kMaxN][2];
vector&lt;int&gt; G[kMaxN];

void addE(int u, int v) {
  G[u].emplace_back(v);
}

int dfs(int u, int fa) {
  f[u][0] = 0, f[u][1] = 1;
  for (auto v : G[u]) {
    if (v == fa || u == x &amp;&amp; v == y || u == y &amp;&amp; v == x) continue;
    dfs(v, u);
    f[u][0] += f[v][1];
    f[u][1] += min(f[v][0], f[v][1]);
  }
  return f[u][1];
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n + m; ++i) {
    int u, v;
    cin &gt;&gt; u &gt;&gt; v;
    ++u, ++v;
    addE(u, v), addE(v, u);
    if (u &lt;= n &amp;&amp; v &lt;= n) x = u, y = v;
  }
  cout &lt;&lt; min(dfs(x, 0), dfs(y, 0)) &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T4

## Description

[link](https://codeforces.com/gym/102835/problem/H)

## Solution

首先跑一遍最大生成树，把最大瓶颈求出来。然后把所有小于瓶颈的边删掉，跑一遍最小生成树，最小生成树上就是所求的生成树。

然后把边按边权从大到小排序，然后每次算贡献即可。

时间复杂度：$O(m\log m)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e4 + 5, kMaxM = 5e5 + 5;

struct Edge {
  int u, v, w;
} e1[kMaxM], e2[kMaxM], e3[kMaxM];

int n, m, m1, m2, m3, k;
int fa[kMaxN], sz[kMaxN];

void addE(int u, int v, int w) {
  e1[++m1] = {u, v, w};
}

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void getmax1() {
  for (int i = 1; i &lt;= n; ++i)
    fa[i] = i;
  sort(e1 + 1, e1 + 1 + m1, [&amp;] (Edge e1, Edge e2) { return e1.w &gt; e2.w; });
  int cnt = 0;
  for (int i = 1; i &lt;= m1; ++i) {
    int fu = find(e1[i].u), fv = find(e1[i].v);
    e2[++m2] = e1[i];
    if (fu != fv) {
      fa[fu] = fv;
      if (++cnt == n - 1) break;
    }
  }
}

void getmin2() {
  for (int i = 1; i &lt;= n; ++i)
    fa[i] = i;
  sort(e2 + 1, e2 + 1 + m2, [&amp;] (Edge e1, Edge e2) { return e1.w &lt; e2.w; });
  int cnt = 0;
  for (int i = 1; i &lt;= m1; ++i) {
    int fu = find(e2[i].u), fv = find(e2[i].v);
    if (fu != fv) {
      fa[fu] = fv;
      e3[++m3] = e2[i];
      if (++cnt == n - 1) break;
    }
  }
}

void getmax2() {
  for (int i = 1; i &lt;= n; ++i) {
    fa[i] = i;
    sz[i] = 1;
  }
  sort(e3 + 1, e3 + 1 + m3, [&amp;] (Edge e1, Edge e2) { return e1.w &gt; e2.w; });
  int cnt = 0;
  long long ans = 0;
  for (int i = 1; i &lt;= m3; ++i) {
    int fu = find(e3[i].u), fv = find(e3[i].v);
    ans += 1ll * sz[fu] * sz[fv] * e3[i].w; 
    if (fu != fv) {
      fa[fu] = fv;
      sz[fv] += sz[fu];
      if (++cnt == n - 1) break;
    }
  }
  cout &lt;&lt; ans &lt;&lt; '\n';
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    addE(u, v, w);
  }
  getmax1(), getmin2(), getmax2();
  return 0;
}
```
&lt;/details&gt;

# T5

## Description

[link](https://codeforces.com/gym/102835/problem/K)

## Solution

考虑数位 dp。

设 $f[x][s][0/1][0/1]$ 表示从最高位考虑到第 $x$ 位，当前用了的数的二进制状态为 $s$，没到/到了限制，没有/有前导零的数量。

然后枚举当前这一位是哪个数，然后直接 dp 即可。

注意：十六进制输入输出要用 `hex`，用完要重新用 `dec` 转回十进制。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;
using u64 = unsigned long long;

const u64 kInf = 18446744073709551615ull;

int n, t;
int a[30];
u64 f[2][30][1 &lt;&lt; 17];

u64 dfs(int x, int s, bool lim, bool flag, int base) {
/*
  lim=1：到了限制
  lim=0：没到限制
  flag=1：有前导零
  flag=0：没有前导零 
*/
  if (x == 0) return 1;
  int bs = (base == 16);
  if (!lim &amp;&amp; !flag &amp;&amp; f[bs][x][s] != kInf) return f[bs][x][s];
  int up = (lim ? a[x] : (base - 1));
  u64 ret = 0;
  for (int i = 0; i &lt;= up; ++i) {
    if (!i) {
      if (flag) {
        ret += dfs(x - 1, s, (lim &amp;&amp; i == a[x]), (flag &amp;&amp; !i), base);
      } else {
        if (s &gt;&gt; i &amp; 1) continue;
        ret += dfs(x - 1, (s | (1 &lt;&lt; i)), (lim &amp;&amp; i == a[x]), (flag &amp;&amp; !i), base);
      }
    } else {
      if (s &gt;&gt; i &amp; 1) continue;
      ret += dfs(x - 1, (s | (1 &lt;&lt; i)), (lim &amp;&amp; i == a[x]), (flag &amp;&amp; !i), base);
    }
  }
  if (!lim &amp;&amp; !flag) f[bs][x][s] = ret;
  return ret;
}

u64 calc(u64 x, int base) {
  t = 0;
  while (x) {
    a[++t] = x % base;
    x /= base;
  }
  return dfs(t, 0, 1, 1, base);
}

u64 calc(u64 l, u64 r, int base) {
  if (!l) return calc(r, base);
  else return calc(r, base) - calc(l - 1, base);
}

void solve10() {
  int op;
  u64 l, r;
  cin &gt;&gt; op;
  if (op == 0) {
    cin &gt;&gt; dec &gt;&gt; l &gt;&gt; r;
    cout &lt;&lt; dec &lt;&lt; calc(l, r, 10) &lt;&lt; '\n';
  } else {
    cin &gt;&gt; dec &gt;&gt; l;
    if (l == 1) {
      cout &lt;&lt; "0\n";
      return;
    }
    u64 L = 0, R = 1000000001, res; 
    bool fl = 0;
    while (L + 1 &lt; R) {
      u64 mid = L + (R - L) / 2;
      if (calc(mid, 10) &gt;= l) R = res = mid, fl = 1;
      else L = mid;
    }
    if (fl) cout &lt;&lt; dec &lt;&lt; res &lt;&lt; '\n';
    else cout &lt;&lt; "-\n";
  }
}

void solve16() {
  int op;
  u64 l, r;
  cin &gt;&gt; op;
  if (op == 0) {
    cin &gt;&gt; hex &gt;&gt; l &gt;&gt; r;
    cout &lt;&lt; hex &lt;&lt; calc(l, r, 16) &lt;&lt; '\n';
  } else {
    cin &gt;&gt; hex &gt;&gt; l;
    if (l == 1) {
      cout &lt;&lt; "0\n";
      return;
    }
    u64 L = 0, R = kInf - 1, res;
    bool fl = 0;
    while (L + 1 &lt; R) {
      u64 mid = L + (R - L) / 2;
      if (calc(mid, 16) &gt;= l) R = res = mid, fl = 1;
      else L = mid;
    }
    if (fl) cout &lt;&lt; hex &lt;&lt; res &lt;&lt; '\n';
    else cout &lt;&lt; "-\n";
  }
}

void solve() {
  string s;
  cin &gt;&gt; s;
  if (s[0] == 'd') solve10();
  else solve16();
}

int main() {
//  freopen("K.in", "r", stdin);
//  freopen("K.out", "w", stdout);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  memset(f, 0xff, sizeof(f));
  int T;
  cin &gt;&gt; T;
  while (T--) solve();
  return 0;
}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17051855.html</id>
    <title type="text">2023.1.14 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-14T06:46:00Z</published>
    <updated>2023-01-14T06:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17051855.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/102471/problem/A)

## Solution

枚举中点，然后两个端点的 $x$ 之和以及 $y$ 之和都是确定的，乘法原理即可。

时间复杂度：$O(nm)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

int n, m;
int ans, ans1;

signed main() {
  cin &gt;&gt; n &gt;&gt; m;
  ++n, ++m; 
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      ans += min(i - 1, n - i) * min(j - 1, m - j);
      ans1 += min(i - 1, n - i) + min(j - 1, m - j); 
    }
  }
//  cerr &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; ans1 &lt;&lt; '\n';
  cout &lt;&lt; ans * 2ll + ans1 &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T2

## Description

[link](https://codeforces.com/gym/102471/problem/E)

## Solution

容易知道最大流量是 $\dfrac{sum}{len}$。然后把每条路径上的边按边权排序。

那么就可以将 $k$ 条路径当成一条来看。把每条路径的容量，从小到大排序，然后把 $k$ 条路径合在一起。此时，平均流量和总容量的差值，就是需要操作的次数。

这里我们无需关心这个操作是怎么实现的，只需要关注当前状态和最终状态之间的差值即可。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5;

int n, m, cnt, sum;
int a[kMaxN], s[kMaxN];
pair&lt;int, int&gt; nxt[kMaxN];
vector&lt;pair&lt;int, int&gt;&gt; st, G[kMaxN];

signed main() {
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    if (u != 1 &amp;&amp; v != 1) nxt[u] = {v, w};
    else st.emplace_back(v, w), ++cnt;
    sum += w;
  }
  int tot = m / cnt, flow = sum / tot;
//  cerr &lt;&lt; flow &lt;&lt; '\n';
  for (auto [u, w1] : st) {
//    cerr &lt;&lt; "***" &lt;&lt; u &lt;&lt; ' ' &lt;&lt; w1 &lt;&lt; '\n';
    vector&lt;int&gt; tmp;
    int v = u, w = w1;
    for (;; w = nxt[v].second, v = nxt[v].first) {
      tmp.emplace_back(w);
      if (v == n) break;
    }
    sort(tmp.begin(), tmp.end());
    s[0] += tmp[0];
    for (int i = 1; i &lt; tmp.size(); ++i) {
      s[i] += tmp[i] - tmp[i - 1];
    }
  }
//  cerr &lt;&lt; s[0] &lt;&lt; ' ' &lt;&lt; s[1] &lt;&lt; ' ' &lt;&lt; s[2] &lt;&lt; '\n';
  int now = s[0], ans = 0, idx = 0;
  while (now + s[idx + 1] &lt; flow) {
    ++idx;
    now += s[idx];
    ans += idx * s[idx];
  }
//  cerr &lt;&lt; now &lt;&lt; '\n';
  ans += (idx + 1) * (flow - now);
  cout &lt;&lt; ans &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://codeforces.com/gym/102471/problem/H)

## Solution

容易发现当长度不小于 $\dfrac{n}{2}$ 时，必定会有两个相邻或者相隔 $1$ 数，所以可以直接随机化这两个数，然后公比 $q=\dfrac{a[y]}{a[x]}$。

然后分别从 $x-1$ 往前扫以及从 $y+1$ 往后扫即可。错误率为 $\dfrac{1}{2^k}$，其中 $k$ 为随机化次数。

时间复杂度：$O(kn)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 2e5 + 5;

int T, n, p;
int a[kMaxN];
mt19937 rnd(1234);

int qpow(int bs, int idx, int p) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % p)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % p;
  return ret;
}

int inv(int x, int p) {
  return qpow(x, p - 2, p);
}

int calc(int x, int y) {
  int ret = 2, q = 1ll * a[y] * inv(a[x], p) % p, iq = inv(q, p);
  int ned = 1ll * a[x] * iq % p;
//  if (x == 1) cerr &lt;&lt; q &lt;&lt; ' ' &lt;&lt; a[x] &lt;&lt; ' ' &lt;&lt; inv(a[x], p) &lt;&lt; ' ' &lt;&lt; a[x + 1] &lt;&lt; '\n';
  for (int i = x - 1; i; --i) {
    if (a[i] == ned) {
      ++ret;
      ned = 1ll * a[i] * iq % p;
    }
  }
  ned = 1ll * a[y] * q % p;
  for (int i = y + 1; i &lt;= n; ++i) {
    if (a[i] == ned) {
      ++ret;
      ned = 1ll * a[i] * q % p;
    }
  }
  return ret;
}

void solve() {
  cin &gt;&gt; n &gt;&gt; p;
  for (int i = 1; i &lt;= n; ++i)
    cin &gt;&gt; a[i];
  if (n == 2) {
    cout &lt;&lt; "2\n";
    return;
  }
  int ans = 0;
  for (int i = 1; i &lt;= 200; ++i) {
    int k = rnd() % 2 + 1, x = rnd() % (n - k) + 1, y = x + k;
    ans = max(ans, calc(x, y));
  }
  cout &lt;&lt; (ans &gt;= n / 2.0 ? ans : -1) &lt;&lt; '\n';
}

signed main() {
  cin &gt;&gt; T;
//  cerr &lt;&lt; "???" &lt;&lt; qpow(2, 4, 1e9 + 7) &lt;&lt; '\n';
  while (T--) solve();
  return 0;
}
```
&lt;/details&gt;

# T4

## Description

[link](https://codeforces.com/gym/102471/problem/M)

## Solution

如果两个数能够表示成同一个数的次方，那么他们就是互相影响的。思考一下会发现这个影响的关系会形成很多个完全图，其中每个完全图上的都是 $p^1,p^2,...,p^k$。

然后对于每一个完全图分别考虑即可。

时间复杂度：$O(n\sqrt n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long 

using namespace std;

const int kMaxN = 1e5 + 5;

int n, ans;
int a[kMaxN], b[kMaxN], x[kMaxN], y[kMaxN];
bool vis[kMaxN];

bool check(int x, int y) {
  int r = x;
  for (; r &lt;= y; r *= x) {
    
    if (r == y) return 1;
  }
  return 0;
}

signed main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i)  
    cin &gt;&gt; b[i];
  ans = a[1];
  for (int i = 2; i &lt;= n; ++i) {
    int t = 0, tmp = 0;
    if (vis[i]) continue;
    for (int j = i; j &lt;= n; j *= i) {
      vis[j] = 1;
      x[++t] = j;
    }
    for (int s = 0; s &lt; (1 &lt;&lt; t); ++s) {
      int tt = 0, tmpp = 0;
      for (int j = 1; j &lt;= t; ++j)
        if (s &gt;&gt; (j - 1) &amp; 1) {
          y[++tt] = j;
          tmpp += a[x[j]];
        }
      for (int j = 1; j &lt;= tt; ++j) {
        for (int k = 1; k &lt; j; ++k)
          if (y[j] % y[k] == 0)
            tmpp -= b[x[y[j]]];
      }
      tmp = max(tmp, tmpp);
    }
    ans += tmp;
  }
  cout &lt;&lt; ans &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17055619.html</id>
    <title type="text">2023.1.16 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-16T07:52:00Z</published>
    <updated>2023-01-16T07:52:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17055619.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/103185/problem/B)

## Solution

假设当前考虑的是 $1\sim i$，那么区间长度一定是 $i$ 的因数，易知 $1\sim n$ 所有的因数个数和不超过 $n\log n$，所以可以直接暴力枚举。

所以只需要判断一个区间 $[l,r]$ 能否变成山链。

首先先把区间里面所有不是 $-1$ 的数搞出来，如果有两个山顶就肯定不行。如果只有一个山顶，那么肯定可以。如果是单调递减且 $a_l$ 是 $-1$ 或者是单调递增且 $a_r$ 是 $-1$ 也肯定行。

所以维护差分数组的最大值/最小值以及区间内数的最大值即可。

时间复杂度：$O(n\log n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e5 + 5;

int n, lst;
int a[kMaxN], d[kMaxN], pre[kMaxN], nxt[kMaxN], ans[kMaxN], sum[kMaxN];
int lg[kMaxN], st1[kMaxN][20], st2[kMaxN][20], st3[kMaxN][20], idx1[kMaxN][20];
vector&lt;int&gt; v[kMaxN];

void getdick() { // O(n log n)
  for (int i = 3; i &lt;= n; ++i) {
    for (int j = i; j &lt;= n; j += i) {
      v[j].emplace_back(i);
    }
  }
}

void getdiao() { // O(n)
  int lst = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (a[i] != -1) lst = i;
    pre[i] = lst;
  }
  lst = 0;
  for (int i = n; i; --i) {
    if (a[i] != -1) lst = i;
    nxt[i] = lst;
  }
}

void st_prework_1() { // O(n log n)
  lg[0] = -1;
  for (int i = 1; i &lt;= n; ++i) {
    lg[i] = lg[i &gt;&gt; 1] + 1;
    st1[i][0] = a[i];
    idx1[i][0] = i;
    st2[i][0] = d[i];
    if (d[i] == 2e9) st2[i][0] = -2e9;
    st3[i][0] = d[i];

  }
  for (int i = 1; i &lt;= lg[n]; ++i) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) {
      if (st1[j][i - 1] &gt; st1[j + (1 &lt;&lt; i - 1)][i - 1]) {
        st1[j][i] = st1[j][i - 1];
        idx1[j][i] = idx1[j][i - 1];
      } else {
        st1[j][i] = st1[j + (1 &lt;&lt; i - 1)][i - 1];
        idx1[j][i] = idx1[j + (1 &lt;&lt; i - 1)][i - 1];
      }
      st2[j][i] = max(st2[j][i - 1], st2[j + (1 &lt;&lt; i - 1)][i - 1]);
      st3[j][i] = min(st3[j][i - 1], st3[j + (1 &lt;&lt; i - 1)][i - 1]);

    }
  }
}

void st_prework_2() { // O(n log n)
/*
  求区间 d 的最大值 
*/
  for (int i = 1; i &lt;= n; ++i) {
    st2[i][0] = d[i];
    if (d[i] == 2e9) st2[i][0] = -2e9;
  }
  for (int i = 1; i &lt;= lg[n]; ++i) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) {
      st2[j][i] = max(st2[j][i - 1], st2[j + (1 &lt;&lt; i - 1)][i - 1]);
    }
  }
}

void st_prework_3() { // O(n log n)
/*
  求区间 d 的最小值
*/
  for (int i = 1; i &lt;= n; ++i) {
    st3[i][0] = d[i];
  }
  for (int i = 1; i &lt;= lg[n]; ++i) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) {
      st3[j][i] = min(st3[j][i - 1], st3[j + (1 &lt;&lt; i - 1)][i - 1]);
    }
  }
}

pair&lt;int, int&gt; query1(int l, int r) {
  int k = lg[r - l + 1];
//  cerr &lt;&lt; "Fuck " &lt;&lt; st1[l][k] &lt;&lt; ' ' &lt;&lt; st1[r - (1 &lt;&lt; k) + 1][k] &lt;&lt; '\n';
  if (st1[l][k] &gt; st1[r - (1 &lt;&lt; k) + 1][k])
    return {st1[l][k], idx1[l][k]};
  else
    return {st1[r - (1 &lt;&lt; k) + 1][k], idx1[r - (1 &lt;&lt; k) + 1][k]};
}

int query2(int l, int r) {
  int k = lg[r - l + 1];
  return max(st2[l][k], st2[r - (1 &lt;&lt; k) + 1][k]);
}

int query3(int l, int r) {
  int k = lg[r - l + 1];
  return min(st3[l][k], st3[r - (1 &lt;&lt; k) + 1][k]);
}

bool checkinc(int l, int r) { // 判断 [l,r] 是否递增 
//  int x = nxt[l], y = pre[r];
//  if (!x || x &gt; r) return 1; // 全是 -1 
//  if (x == y) return 1; // 只有一个不是 -1 
  if (query3(l + 1, r) &gt;= 0) return 1;
  else return 0;
}

bool checkdec(int l, int r) { // 判断 [l,r] 是否递减 
//  int x = nxt[l], y = pre[r];
//  if (!x || x &gt; r) return 1; // 全是 -1 
//  if (x == y) return 1; // 只有一个不是 -1 
  if (query2(l + 1, r) &lt;= 0) return 1;
  else return 0;
}

bool check(int l, int r) { // 判断 [l,r] 是否是山链 
  if (r - l + 1 &lt;= 2) return 0;
  if (pre[r] &lt; l) return 1;
  auto p = query1(l + 1, r - 1);
//  cerr &lt;&lt; "***" &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
  if (p.first == -1) return 1;
  return checkinc(l, p.second) &amp;&amp; checkdec(p.second, r) || (a[l] == -1 &amp;&amp; checkdec(l, r) || a[r] == -1 &amp;&amp; checkinc(l, r));
}

void solve() {
  for (int i = 3; i &lt;= n; ++i)
    ans[i] = 1;
  for (int i = 3; i &lt;= n; ++i) {
    if (n % i) ans[i] &amp;= (check(n - n % i + 1, n));
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (auto x : v[i]) {
      ans[x] &amp;= check(i - x + 1, i);
    }
  }
//  cerr &lt;&lt; "???" &lt;&lt; ans[3] &lt;&lt; '\n';
  int res = 0;
  for (int i = 3; i &lt;= n; ++i) {
    res |= ans[i];
  }
  cout &lt;&lt; (res ? "Y\n" : "N\n");
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    sum[i] = sum[i - 1];
    if (a[i] != -1) {
      d[i] = a[i] - lst;
      lst = a[i];
    } else {
      d[i] = 2e9;
      ++sum[i];
    }
  }
  getdick(), getdiao();
  st_prework_1();
//  cerr &lt;&lt; checkdec(1, 4) &lt;&lt; '\n';
  solve();
  cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's' &lt;&lt; '\n';
  return 0;
}
/*
4
4 -1 3 3
*/
```
&lt;/details&gt;

# T2

## Description

[link](https://codeforces.com/gym/103185/problem/F)

## Solution

求最大值是个简单的贪心，只需要考虑最小值。

设 $f_{i,j}$ 表示把 $1\sim i$ 划分成 $j$ 段的最小值。

那么 $f_{i,j}=\min\big\{f_{k,j-1}+\max\{a_{k+1},...,a_i\}\big\}$。

可以先钦定 $a_i$ 是最大值，那么可以用单调栈维护能满足 $a_i$ 是最大值的最优决策点。

另外一种可能就是最大值不是 $a_i$，那么维护一下最优决策点即可。

时间复杂度：$O(n^2)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 8005;

int n;
int a[kMaxN], b[kMaxN], f[kMaxN][kMaxN], g[kMaxN], mi[kMaxN];

signed main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    b[i] = a[i];
  }
  memset(f, 0x3f, sizeof(f));
  f[0][0] = 0;
  a[0] = mi[0] = LLONG_MAX / 2;
  for (int i = 1; i &lt;= n; ++i) {
    stack&lt;int&gt; stk;
    stk.emplace(0);
    for (int j = i; j &lt;= n; ++j) {
      mi[j] = f[j - 1][i - 1];
      while (!stk.empty() &amp;&amp; a[stk.top()] &lt; a[j]) {
        mi[j] = min(mi[j], mi[stk.top()]);
        stk.pop();
      }
      f[j][i] = mi[j] + a[j];
      if (!stk.empty()) f[j][i] = min(f[j][i], f[stk.top()][i]);
      stk.emplace(j);
    }
  }
  sort(b + 1, b + 1 + n, greater&lt;int&gt;());
  for (int i = 1; i &lt;= n; ++i)
    g[i] = g[i - 1] + b[i];
  for (int i = 1; i &lt;= n; ++i) {
    cout &lt;&lt; f[n][i] &lt;&lt; ' ' &lt;&lt; g[i] &lt;&lt; '\n';
  }
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://codeforces.com/gym/103185/problem/J)

## Solution

直接暴力即可。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e5 + 5;

int n, k, t;
int c[kMaxN][8], tt[8], cnt[9][9][9][9][9][9][9][9];

void upd(int x, int v) {
  for (int c0 = 0; c0 &lt;= c[x][0]; ++c0) {
    for (int c1 = 0; c1 &lt;= c[x][1]; ++c1) {
      for (int c2 = 0; c2 &lt;= c[x][2]; ++c2) {
        for (int c3 = 0; c3 &lt;= c[x][3]; ++c3) {
          for (int c4 = 0; c4 &lt;= c[x][4]; ++c4) {
            for (int c5 = 0; c5 &lt;= c[x][5]; ++c5) {
              for (int c6 = 0; c6 &lt;= c[x][6]; ++c6) {
                for (int c7 = 0; c7 &lt;= c[x][7]; ++c7) {
                  cnt[c0][c1][c2][c3][c4][c5][c6][c7] += v;
                } 
              }
            } 
          }
        } 
      } 
    } 
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin &gt;&gt; n &gt;&gt; k;
  while (n--) {
    string op;
    int s;
    cin &gt;&gt; op &gt;&gt; s;
    if (op[0] == 'C') {
      ++t;
      for (int i = 1; i &lt;= s; ++i) {
        int tmp;
        cin &gt;&gt; tmp;
        ++c[t][tmp - 1];
      }
      upd(t, 1);
    } else if (op[0] == 'D') {
      upd(s, -1);
    } else {
      tt[0] = tt[1] = tt[2] = tt[3] = tt[4] = tt[5] = tt[6] = tt[7] = 0;
      for (int i = 1; i &lt;= s; ++i) {
        int tmp;
        cin &gt;&gt; tmp;
        ++tt[tmp - 1];
      }
      cout &lt;&lt; cnt[tt[0]][tt[1]][tt[2]][tt[3]][tt[4]][tt[5]][tt[6]][tt[7]] &lt;&lt; '\n';
    }
  }
  return 0;
}
```
&lt;/details&gt;

# T4

## Description

[link](https://codeforces.com/gym/103185/problem/K)

## Solution

设 $f_{i,j}$ 为当前确定了 $1\sim i$ 的字母，末尾为 $j$ 的方案数。

那么 $f_{i,j}$ 能够转移到 $f_{i+1,k}$ 就意味着 $T_{j,k}\in [s_i-L,s_i+L]$。

由于 $T$ 每一行都是单调的，所以可以直接二分能够转移的左端点和右端点，然后差分维护。

时间复杂度：$O(nk\log k)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 1e4 + 5, kMaxK = 755, kMod = 1e9 + 7;

int n, k, ll;
int f[kMaxN][kMaxK], t[kMaxK][kMaxK], p[kMaxN];

int main() {
  cin &gt;&gt; k &gt;&gt; ll;
  for (int i = 1; i &lt;= k; ++i)
    for (int j = 1; j &lt;= k; ++j)
      cin &gt;&gt; t[i][j];
  cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i)
    cin &gt;&gt; p[i];
  f[1][0] = 1;
  for (int i = 1; i &lt; n; ++i) {
    for (int j = 1; j &lt;= k; ++j)
      f[i][j] = (f[i][j] + f[i][j - 1]) % kMod;
    for (int j = 1; j &lt;= k; ++j) {
      // t[j][s] in [p[i]-L,p[i]+L]
      int l = p[i] - ll, r = p[i] + ll;
      int L = 0, R = k + 1, resl = -1, resr = -1;
      while (L + 1 &lt; R) {
        int mid = L + (R - L) / 2;
        if (t[j][mid] &gt;= l) R = resl = mid;
        else L = mid;
      }
      if (resl == -1) continue;
      L = 0, R = k + 1;
      while (L + 1 &lt; R) {
        int mid = L + (R - L) / 2;
        if (t[j][mid] &lt;= r) L = resr = mid;
        else R = mid;
      }
      if (resr == -1) continue;
      f[i + 1][resl] = (f[i + 1][resl] + f[i][j]) % kMod;
      f[i + 1][resr + 1] = (f[i + 1][resr + 1] + kMod - f[i][j]) % kMod;
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= k; ++i) {
    f[n][i] = (f[n][i] + f[n][i - 1]) % kMod;
    ans = (ans + f[n][i]) % kMod;
  }
  cout &lt;&lt; ans &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17057855.html</id>
    <title type="text">2022.1.17 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-01-17T07:04:00Z</published>
    <updated>2023-01-17T07:04:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17057855.html" />
    <content type="text"># T1

## Description

[link](https://codeforces.com/gym/103186/problem/D)

## Solution

由于左边的数不大于右边的数，第二排的数不大于第一排的数。所以从小到大加数时只能靠左放，并且放完后上面的数量不超过下面的数量。

然后就可以 dp 了，设 $f_{i,j}(i\leq j)$ 表示上面放了 $i$ 个数，下面放了 $j$ 个数的方案。

那么 $f_{i,j}$ 就可以转移到所有 $f_{i+s,j+c_k-s}(i+s\leq j+c_k-s)$，暴力转移复杂度是对的。

时间复杂度：$O(n^2)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 5005, kMod = 998244353;

int n;
int a[kMaxN], fac[kMaxN], cnt[kMaxN], sum[kMaxN], f[kMaxN][kMaxN], d[kMaxN][kMaxN];

int main() {
  cin &gt;&gt; n;
  fac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    ++cnt[a[i]];
    fac[i] = 1ll * i * fac[i - 1] % kMod;
  }
  for (int i = 1; i &lt;= n; ++i)
    sum[i] = sum[i - 1] + cnt[i];
  f[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    if (!cnt[i]) continue;
    for (int j = 0, k = sum[i] - cnt[i]; j &lt;= k; ++j, --k) {
      for (int s = 0; s &lt;= cnt[i]; ++s) {
        if (j + s &lt;= k + cnt[i] - s)
          f[j + s][k + cnt[i] - s] = (f[j + s][k + cnt[i] - s] + 1ll * f[j][k] * fac[cnt[i]] % kMod) % kMod;
      }
    }
  }
  cout &lt;&lt; f[n / 2][n / 2] &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T2

## Description

[link](https://codeforces.com/gym/103186/problem/H)

## Solution

考虑二分答案，设当前时间是 $t$。

那么 $i$ 和 $j$ 相遇就等价于 $p_i&lt;p_j$ 并且 $p_i+v_it&gt;p_j+v_jt$，这个东西就可以维护一个以 $p$ 为下标的求区间最大值和最小值的线段树。

又因为类型不能相同，所以需要先按类型排序，然后一个类型一个类型地加到线段树里去判断。

时间复杂度：$O(n\log P\log n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int long long

using namespace std;

const int kMaxN = 1e5 + 5, kInf = LLONG_MAX - 1;

struct Node {
  int p, v, t, vv;
} a[kMaxN];

int n, k, m;
int lsh[kMaxN];
vector&lt;Node&gt; v[kMaxN];

struct SGT {
  int mi[kMaxN &lt;&lt; 2], mx[kMaxN &lt;&lt; 2];
  
  void clear() {
    fill(mi + 1, mi + 1 + m * 4, kInf);
    fill(mx + 1, mx + 1 + m * 4, -kInf);
  }
  void pushup(int x) {
    mi[x] = min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]);
    mx[x] = max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
  }
  void update(int x, int l, int r, int ql, int val) {
    if (l &gt; ql || r &lt; ql) {
      return;
    } else if (l == r) {
      mi[x] = min(mi[x], val);
      mx[x] = max(mx[x], val);
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, val);
    update(x &lt;&lt; 1 | 1, mid + 1, r, ql, val);
    pushup(x);
  }
  int querymin(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) {
      return kInf;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return mi[x];
    }
    int mid = (l + r) &gt;&gt; 1;
    return min(querymin(x &lt;&lt; 1, l, mid, ql, qr), querymin(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
  int querymax(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) {
      return -kInf;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return mx[x];
    }
    int mid = (l + r) &gt;&gt; 1;
    return max(querymax(x &lt;&lt; 1, l, mid, ql, qr), querymax(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} s;

void discrete() {
  for (int i = 1; i &lt;= n; ++i) {
    lsh[++m] = a[i].p;
  }
  sort(lsh + 1, lsh + 1 + m);
  m = unique(lsh + 1, lsh + 1 + m) - (lsh + 1);
  for (int i = 1; i &lt;= n; ++i) {
    a[i].vv = lower_bound(lsh + 1, lsh + 1 + m, a[i].p) - lsh;
  }
}

bool check(int x) {
  s.clear();
  for (int i = 1; i &lt;= k; ++i) {
    for (auto p : v[i]) {
      if (p.vv &lt; m &amp;&amp; s.querymin(1, 1, m, p.vv + 1, m) &lt;= p.p + p.v * x) return 0;
      if (p.vv &gt; 1 &amp;&amp; s.querymax(1, 1, m, 1, p.vv - 1) &gt;= p.p + p.v * x) return 0;
    }
    for (auto p : v[i]) {
      s.update(1, 1, m, p.vv, p.p + p.v * x);
    }
  }
  return 1;
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i].p &gt;&gt; a[i].v &gt;&gt; a[i].t;
  }
  discrete();
  for (int i = 1; i &lt;= n; ++i) {
    v[a[i].t].emplace_back(a[i]);
  }
  int L = 0, R = 2e9 + 1, res = 0;
  if (check(2e9)) {
    cout &lt;&lt; "-1\n";
    return 0;
  }
  while (L + 1 &lt; R) {
    int mid = L + (R - L) / 2;
    if (check(mid)) L = res = mid;
    else R = mid;
  }
  cout &lt;&lt; res &lt;&lt; '\n';
  return 0;
}
```
&lt;/details&gt;

# T3

## Description

[link](https://codeforces.com/gym/103186/problem/J)

## Solution

答案就是

$$
|A|-|S-A|=
\begin{cases}
S\space\space\space\space\space\space\space\space\space\space\space\space(A\geq S)\\
2A-S\space\space(0\leq A&lt;S)\\
-S\space\space\space\space\space\space\space\space\space(A&lt;0)
\end{cases}
$$

容易发现这个东西是单调不减的，所以 Alice 每次选最大的即可。

时间复杂度：$O(n\log n)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int kMaxN = 5005;

int n;
long long sum;
int a[kMaxN];

int main() {
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; a[i];
    sum += a[i];
  }
  sort(a + 1, a + 1 + n);
  if (n &amp; 1) {
    long long ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
      if (i &amp; 1) ans += a[i];
    }
    cout &lt;&lt; -abs(sum - ans) + abs(ans) &lt;&lt; '\n';
  } else {
    long long m1 = 0, m2 = 0;
    for (int i = 1; i &lt;= n; ++i) {
      if (i &amp; 1) m1 += a[i];
      else m2 += a[i];
    }
    cout &lt;&lt; max(abs(m1) - abs(sum - m1), abs(m2) - abs(sum - m2)) &lt;&lt; '\n';
  }
  return 0;
}
```
&lt;/details&gt;

# T4

## Description

[link](https://codeforces.com/gym/103186/problem/K)

## Solution

暴力求出 sg 函数即可。

时间复杂度：$O(能过)$。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

bool operator &lt; (const vector&lt;int&gt; &amp;v1, const vector&lt;int&gt; &amp;v2) {
  if (v1.size() != v2.size()) return v1.size() &lt; v2.size();
  for (int i = 0; i &lt; v1.size(); ++i) {
    if (v1[i] != v2[i]) return v1[i] &lt; v2[i];
  }
  return 1;
}

int n;
string s[15];
map&lt;vector&lt;int&gt;, int&gt; mp;

vector&lt;int&gt; getdiao(string s) {
  vector&lt;int&gt; vec;
  sort(s.begin(), s.end());
  int lst = -1;
  for (int i = 0; i &lt; s.size(); ++i) {
    if (i == (int)s.size() - 1 || s[i] != s[i + 1]) {
      vec.emplace_back(i - lst);
      lst = i;
    }
  }
  sort(vec.begin(), vec.end());
  return vec;
}

vector&lt;int&gt; work(vector&lt;int&gt; vec) {
  vector&lt;int&gt; ret;
  for (auto x : vec)
    if (x &gt; 0)
      ret.emplace_back(x);
  sort(ret.begin(), ret.end());
  return ret;
}

int mex(vector&lt;int&gt; vec) {
  int ret = 0;
  sort(vec.begin(), vec.end());
  for (auto x : vec) {
    if (x &gt; ret) break;
    if (x == ret) ++ret;
  }
  return ret;
}

int dfs(vector&lt;int&gt; vec) {
  if (!vec.size()) return 0;
  if (mp.count(vec)) return mp[vec];
  auto kk = vec;
  vector&lt;int&gt; sg;
  for (int i = 0; i &lt; kk.size(); ++i) {
    --vec[i];
    sg.emplace_back(dfs(work(vec)));
    for (int j = i + 1; j &lt; kk.size(); ++j) {
      --vec[j];
      sg.emplace_back(dfs(work(vec)));
      ++vec[j];
    }
    ++vec[i];
  }
  return mp[kk] = mex(sg);
}

void solve() {
  int ans = 0;
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    cin &gt;&gt; s[i];
    ans ^= dfs(work(getdiao(s[i])));
  }
  cout &lt;&lt; (ans ? "Alice\n" : "Bob\n");
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  cin &gt;&gt; T;
  while (T--) solve();
  return 0;
}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17203791.html</id>
    <title type="text">2023.3.10 模拟赛 T1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-03-10T08:19:00Z</published>
    <updated>2023-03-10T08:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17203791.html" />
    <content type="text">## Description

![image-20230310161208930](https://cdn.staticaly.com/gh/liuziao20081122/images@main/img/202303101612959.png)

$n,b\leq 10^7$。

## Solution

定义 $d_i$ 表示所有模 $n$ 余 $i$ 的数中非零位个数的最小值。

那么很明显把 $i$ 乘 $b$ 不会变大，所以 $d_{ib\bmod n}\leq b_i$。

然后把 $i$ 乘 $b$ 后在最后一位添上一个数，答案最多变化 $1$，所以 $d_{(ib+s)\bmod n}\leq d_i+1(0&lt;s&lt;b)$。

又因为已知 $d_1=d_2=\dots=d_{b-1}=1$，所以直接跑 01BFS 即可。

时间复杂度：$O(nb)$，过不了。

---

有一个显然的事情，上面的第二个式子只会更新一个区间内里还没有走到的数。所以可以用并查集维护每一个大于等于某一个数的最小的还没有走到的数。

每次操作完就把当前数 $x$ 的 $fa[x]$ 赋值成 $find(x+1)$ 即可。

时间复杂度：$O(n\log n)$ 或 $O(n\alpha(n))$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int long long

using namespace std;

const int kMaxN = 2e7 + 5;

int n, b;
int q[kMaxN], fa[kMaxN], dis[kMaxN];
bool vis[kMaxN];

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void bfs() {
  int h = n, t = n - 1;
  for (int i = 1; i &lt;= 2e7; ++i)
    fa[i] = i;
  for (int i = 1; i &lt; b; ++i) {
    dis[i] = 1;
    q[++t] = i;
    fa[i] = b;
  }
  while (h &lt;= t) {
    int c = q[h++], v = dis[c];
    if (vis[c]) continue;
    vis[c] = 1;
    int cc = 1ll * c * b % n;
    if (!cc) {
      dis[0] = v;
      break;
    }
    if (cc + b - 1 &gt;= n &amp;&amp; !dis[0]) {
      dis[0] = v + 1;
      q[++t] = 0;
    }
    if (!dis[cc] || dis[cc] &gt; v) {
      dis[cc] = v;
      if (fa[cc] == cc) fa[cc] = find(cc + 1);
      q[--h] = cc;
    }
    int now = find(cc + 1);
    while (now &lt; min(cc + b, n)) {
      dis[now] = v + 1;
      fa[now] = find(now + 1);
      q[++t] = now;
      now = find(now + 1);
    }
  }
  cout &lt;&lt; dis[0] &lt;&lt; '\n';
}

void dickdreamer() {
  cin &gt;&gt; n &gt;&gt; b;
  bfs();
}

int32_t main() {
  freopen("puzzle.in", "r", stdin);
  freopen("puzzle.out", "w", stdout);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T = 1;
  // cin &gt;&gt; T;
  while (T--) dickdreamer();
  // cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; 's';
  return 0;
}
```
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17585334.html</id>
    <title type="text">P9017 [USACO23JAN] Lights Off G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-07-27T08:27:00Z</published>
    <updated>2023-07-27T08:27:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17585334.html" />
    <content type="text">## Description

给定正整数 $N$，和两个长为 $N$ 的 $01$ 序列 $a$ 和 $b$。定义一次操作为：

1. 将 $b$ 序列中的一个值翻转（即 $0$ 变成 $1$，$1$ 变成 $0$，下同）。
2. 对于 $b$ 序列中每个值为 $1$ 的位置，将 $a$ 序列中对应位置的值翻转。
3. 将 $b$ 序列向右循环移位 $1$ 位。即若当前 $b$ 序列为 $b_1b_2\cdots b_{n}$，则接下来变为 $b_{n}b_1b_2\cdots b_{n-1}$。

有 $T$ 次询问，对每一次询问，你需要回答出至少需要几次操作，才能使 $a$ 序列中每一个位置的值都变为 $0$。

[link](https://www.luogu.com.cn/problem/P9017)

## Solution

显然可以把 $a,b$ 数组看成两个数，操作一就是对 $b$ 的某一位取反，操作二就是让 $a$ 异或 $b$，操作三是让 $b\leftarrow \left\lfloor \frac{b}{2} \right\rfloor$。

容易发现操作数不超过 $3n$，因为可以先用至多 $n$ 次操作把 $b$ 变成 $0$。然后每连续两次操作就让 $b$ 的某一位变成 $1$，把 $a$ 的这一位消掉，然后 $b$ 清空。

然而这样做是 $O(T\cdot n^n)$ 的，过不了且没法优化。

---

观察可知，如果第 $i$ 次操作将第 $j$ 位异或 $1$，总共进行 $s$ 次操作，那么这次操作对最终 $a$ 的贡献就是 $j\sim j+s-i$ 这些位取反（在模 $n$ 意义下）。

这样就可以 dp 了。

设 $f_{i,j}$ 表示进行恰好 $i$ 次操作，能否让 $a$ 变成 $j$，设 $x$ 为任意一个模 $n$ 意义下连续的长度为 $1$ 的数组所对应的状态，那么就让 $f_{i,j}\leftarrow f_{i-1,j\oplus x\oplus b}$。

初始 $f_{0,a}=1$，时间复杂度：$O(T\cdot n\cdot 2^{n})$，过不了。

---

考虑把操作一的贡献和操作二、三的贡献拆开算。操作一所做的贡献就相当于初始 $b=0$ 进行若干次操作对 $a$ 的贡献，显然可以预处理，即设 $f_{i,j}$ 表示 $b$ 初始值为 $0$，对 $a$ 能否做出 $j$ 的贡献。

设 $x$ 为任意一个模 $n$ 意义下连续的长度为 $1$ 的数组所对应的状态，那么就让 $f_{i,j}\leftarrow f_{i-1,j\oplus x}$。

而操作二、三就是对 $b$ 进行这么多操作的异或和，枚举操作次数即可求得。

时间复杂度：$O(n^2\cdot 2^n+Tn)$。

具体实现细节见代码

## Code

```cpp
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;

// #define int int64_t

int n, a, b;
int f[100][1 &lt;&lt; 20];

int shift(int x) {
  return (x &gt;&gt; 1) + (1 &lt;&lt; n - 1) * (x &amp; 1);
}

int tonum(std::string s) {
  int ret = 0;
  for (int i = 0; i &lt; static_cast&lt;int&gt;(s.size()); ++i)
    ret = (ret &lt;&lt; 1) + s[i] - '0';
  return ret;
}

int calc(int a, int b) {
  for (int i = 0; i &lt;= 3 * n; ++i, b = shift(b)) {
    if (f[i][a]) return i;
    a ^= b;
  }
  return -1;
}

void prework() {
  f[0][0] = 1;
  for (int i = 1; i &lt;= 3 * n; ++i) {
    int s = (1 &lt;&lt; ((i - 1) % n + 1)) - 1;
    for (int j = 0; j &lt; n; ++j, s = shift(s)) {
      for (int k = 0; k &lt; (1 &lt;&lt; n); ++k)
        f[i][k] |= f[i - 1][k ^ s];
    }
  }
}

void dickdreamer() {
  int t;
  std::cin &gt;&gt; t &gt;&gt; n;
  prework();
  for (; t; --t) {
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;
    a = tonum(s), b = tonum(t);
    std::cout &lt;&lt; calc(a, b) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17636237.html</id>
    <title type="text">CF932E Team Work 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-08-16T13:22:00Z</published>
    <updated>2023-08-16T13:22:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17636237.html" />
    <content type="text">## Description

给定 $n,k$，求：

$$\displaystyle\sum_{i=1}^{n}{\binom{n}{i}\times i^k}$$

$1\leq k\leq 5000,1\leq n\leq 10^9$。

## Solution

看到那个 $i^k$ 很不爽，但是 $k$ 很小，考虑用斯特林数改写一下：

$$i^k=\sum_{j=0}^{k}{\binom{i}{j}\left \{ {\begin{matrix} k\\ j \end{matrix}} \right \}\cdot j!}$$

代回原式得：

$$\displaystyle
\begin{aligned}
&amp;\sum_{i=0}^{n}{\binom{n}{i}\cdot\sum_{j=0}^{k}{\binom{i}{j}\left \{ {\begin{matrix} k\\ j \end{matrix}} \right \} j!} }\\
=&amp;\sum_{j=0}^{k}{j!\left\{\begin{matrix}k\\j\end{matrix}\right\}\cdot\sum_{i=0}^{n}{\binom{n}{i}\binom{i}{j}}}\\
=&amp;\sum_{j=0}^{k}{j!\left\{\begin{matrix}k\\j\end{matrix}\right\}\cdot\sum_{i=j}^{n}{\frac{n!}{i!(n-i)!}\cdot \frac{i!}{j!(i-j)!}}}\\
=&amp;n!\sum_{j=0}^{k}{\left\{\begin{matrix}k\\j\end{matrix}\right\}\cdot\sum_{i=j}^{n}{\frac{\binom{n-j}{i-j}}{(n-j)!}}}\\
=&amp;n!\sum_{j=0}^{k}{\frac{1}{(n-j)!}\left\{\begin{matrix}k\\j\end{matrix}\right\}\sum_{i=0}^{n-j}{\binom{n-j}{i}}}\\
=&amp;n!\sum_{j=0}^{k}{\frac{2^{n-j}}{(n-j)!}\cdot \left\{\begin{matrix}k\\j\end{matrix}\right\}}\\
\end{aligned}$$

于是直接预处理出斯特林数即可做到 $O(k^2+k\log n)$，如果用卷积预处理的话就可以做到 $O(k\log k+k\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMod = 1e9 + 7;

int s[5005][5005];

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (i64)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (i64)ret * bs % kMod;
  return ret;
}

void dickdreamer() {
  int n, k, ans = 0;
  std::cin &gt;&gt; n &gt;&gt; k;
  s[0][0] = 1;
  for (int i = 1; i &lt;= k; ++i) {
    for (int j = 1; j &lt;= i; ++j) {
      s[i][j] = (s[i - 1][j - 1] + (i64)j * s[i - 1][j] % kMod) % kMod;
    }
  }
  for (int i = 0, c = 1; i &lt;= std::min(n, k); ++i) {
    ans = (ans + (i64)s[k][i] * c % kMod * qpow(2, n - i) % kMod) % kMod;
    c = (i64)c * (n - i) % kMod;
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17666252.html</id>
    <title type="text">2023.8.30 模拟赛 T3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-08-29T23:41:00Z</published>
    <updated>2023-08-29T23:41:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17666252.html" />
    <content type="text">## Description

给定一个有 $n$ 个数的整数数组 $a$，$a_i$ 的值域为 $[1,200]$。现在有 $q$ 次互相独立的操作，每次操作形如 $b,c,d$，表示把 $a$ 的第 $b$ 位删掉，并且把 $a_{b+1\sim n}$ 放到 $a_{1\sim b-1}$ 前面，然后把 $c$ 放到开头，问有多少个以 $d$ 结尾的本质不同子序列。

$n,q\leq 2\times 10^5,m\leq 200$。

## Solution

先考虑朴素 dp。

设新数组为 $b$，$f_{i,j}$ 表示在操作完的数组中，考虑前 $i$ 个数，末尾为 $j$ 的本质不同子序列数，$\text{pre}_i$ 表示上一个和 $i$ 相等的下标。表示么转移方程就是

$$\begin{cases}f_{i,j}=f_{i-1,j}&amp;\left(a_i\neq j\right)\\\displaystyle f_{i,j}=f_{i-1,j}+\sum_{k=0}^{m}{f_{i-1,k}-f_{{\text{pre}}_i,j}}&amp;\left(a_i=j\right)\end{cases}$$

这样就可以做到 $O(nmq)$。

---

注意到上面那个式子其实有很多是重复算了的，因为操作并没有改变很多，只有两段的顺序，考虑预处理来优化复杂度。

设 $g_{i,j}$ 表示原数组里面考虑了 $a_{i\sim n}$，末尾为 $j$ 的本质不同方案数。

那么 $g_{i,j}=2\times g_{i+1,j}-g_{\text{nxt}_i,j}$。

特别的，如果 $\text{nxt}_i=0$，说明 $i$ 后面没有和他相等的数，所以 $g_{i,a_i}=1$。

求完这个就只要对于每个 $j$，求出 $g_{b+1,j}$ 对最终结果贡献的系数。

于是设 $f_{i,j,k}$ 表示 $g_{b+1,k}$ 对 $f_{i,j}$ 这个状态的贡献系数，$\text{sum}_{i,k}=\displaystyle\sum_{j=0}^{m}{f_{i,j,k}}$。那么

$$
\begin{cases}
f_{i,j,k}=f_{i-1,j,k}&amp;\left(a_i\neq j\right)\\
f_{i,j,k}=\text{sum}_{i-1,k}+f_{i-1,j,k}-f_{i,j,k}&amp;\left(a_{i}=j\right)
\end{cases}
$$

由于这里只要求 $f_{i,a_i,k}$ 所以可以设 $h_{i,k}=f_{i,a_i,k}$，那么 $h_{i,k}=\text{sum}_{i-1,k}+f_{i-1,a_i,k}-f_{\text{pre}_i,a_i,k}$，也就是 $\text{sum}_{i-1,k}+f_{\text{pre}_i,a_i,k}-f_{\text{pre}_i,a_i,k}=\text{sum}_{i-1,k}+h_{\text{pre}_i,k}-h_{\text{pre}_i,k}$。

同样的，$\text{sum}_{i,k}=2\times \text{sum}_{i-1,k}-h_{\text{pre}_i,k}$。注意，$k=a_i$ 时 $h_{i,k}$ 时才为 $1$。

时间复杂度：$O\left((n+q)\times m\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxM = 205, kMod = 998244353;

int n, m, q;
int a[kMaxN], sum[kMaxM], k[kMaxN][kMaxM], f[kMaxN][kMaxM], g[kMaxN][kMaxM], ff[kMaxM], noww[kMaxN][kMaxM], gg[kMaxN][kMaxM], pre[kMaxN], nxt[kMaxN], now[kMaxM];

inline int add(int x, int y) { return (x + y &gt;= kMod) ? (x + y - kMod) : (x + y); }
inline int sub(int x, int y) { return (x &gt;= y) ? (x - y) : (x + kMod - y); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  for (int i = 0; i &lt;= m; ++i)
    sum[i] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    pre[i] = gg[i - 1][a[i]];
    for (int j = 0; j &lt;= m; ++j)
      gg[i][j] = gg[i - 1][j];
    gg[i][a[i]] = i;
    for (int j = 0; j &lt;= m; ++j) {
      k[i][j] = sum[j];
      int sb;
      if (pre[i]) sb = k[pre[i]][j];
      else sb = (j == a[i]);
      sum[j] = sub (2ll * sum[j] % kMod, sb);
    }
  }
  for (int i = n; i; --i) {
    nxt[i] = noww[i + 1][a[i]];
    now[a[i]] = i;
    for (int j = 0; j &lt;= m; ++j)
      g[i][j] = sub(2ll * g[i + 1][j] % kMod, bool(nxt[i]) * g[nxt[i] + 1][j]);
    if (!nxt[i]) g[i][a[i]] = 1;
    for (int j = 0; j &lt;= m; ++j)
      noww[i][j] = noww[i + 1][j];
    noww[i][a[i]] = i;
  }
  for (; q; --q) {
    int b, c, d;
    std::cin &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    for (int i = 0; i &lt;= m; ++i)
      ff[i] = sub(add(g[b + 1][i], g[b + 1][i]), bool(noww[b + 1][c]) * g[noww[b + 1][c] + 1][i]);
    if (!noww[b + 1][c]) ff[c] = 1;
    int ans = 0, t = gg[b - 1][d];
    if (!t) {
      std::cout &lt;&lt; ff[d] &lt;&lt; '\n';
      continue;
    }
    ff[0] = 1;
    for (int i = 0; i &lt;= m; ++i)
      inc(ans, (long long)k[gg[b - 1][d]][i] * ff[i] % kMod);
    std::cout &lt;&lt; ans &lt;&lt; '\n';
  }
}

int32_t main() {
  freopen("third.in", "r", stdin);
  freopen("third.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17670268.html</id>
    <title type="text">CF1712F Triameter 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-08-31T11:18:00Z</published>
    <updated>2023-08-31T11:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17670268.html" />
    <content type="text">## Description

你有一棵有 $n$ 个点的树，树上的每条边权值都为 $1$。现在有 $q$ 次询问，每次询问一个整数 $x$，并将叶子结点全部相连上权值为 $x$ 的边（操作不会保留）。问每次操作后图的直径是多少。图的直径定义为 $\underset{1\leq u&lt;v\leq n}{\max}d(u,v)$。

$3\leq n\leq 10^6,1\leq q\leq 10$。

## Solution

考虑转化一下 $d(u,v)$。

设 $h_i$ 表示 $i$ 到叶子节点的最短距离，那么 $d(u,v)$ 就等于 $\min\left\{\text{dist}(u,v),h_u+h_v+x\right\}$。

然后枚举一下 $u$ 和 $v$ 的 $\text{LCA}$，设它为 $k$。那么 $d(u,v)=\min\left\{\text{dep}_u+\text{dep}_v-2\times \text{dep}_k,h_u+h_v+x\right\}$。

如果当前的答案为 $ans$，$d(u,v)$ 只有 $\text{dep}_u+\text{dep}_v-2\times \text{dep}_k&gt;ans$ 且 $h_u+h_v+x&gt;ans$ 时 $ans$ 才可被更新。

设 $M_{i,j}$ 表示 $i$ 子树里面 $h_{x}$ 为 $j$ 的最大的 $\text{dep}_x$。

由于 $i$ 的子树里面不可能 $d$ 全都大于 $d_i$，因为一定有 $0$，并且相邻的两个点 $d$ 值相差不超过 $1$，所以 $0\sim d_i$ 都会在 $i$ 的子树里面出现，那么 $M_{i,j}\geq M_{i,j+1}$。

然后对于 $k$ 的两个个儿子 $a$ 和 $b$，它们子树里如果存在能让 $ans$ 更新的点对，说明存在 $i,j$，使得 $i+j+x&gt;ans$ 且 $M_{a,i}+M_{b,j}-2\times\text{dep}_k&gt;ans$。

移项就得出 $M_{a,i}+M_{b,\max(ans-x-i+1,0)}-2\times \text{dep}_k&gt;ans$。

容易发现 $M_{i,j}$ 不为 $0$ 说明 $j$ 不超过 $i$ 这个子树里面的长链长度，所以直接长剖优化即可。

时间复杂度：$O(nq)$，常数很大。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

int n, ans, x;
int d[kMaxN], dep[kMaxN];
std::vector&lt;int&gt; G[kMaxN], f[kMaxN];

void dfs1(int u, int fa) {
  dep[u] = dep[fa] + 1;
  if (G[u].size() != 1) d[u] = 1e9;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    d[u] = std::min(d[u], d[v] + 1);
  }
}

void dfs2(int u, int fa) {
  for (auto v : G[u]) {
    if (v == fa) continue;
    d[v] = std::min(d[v], d[u] + 1);
    dfs2(v, u);
  }
}

void merge(int u, int v) {
  for (int i = 0; i &lt; static_cast&lt;int&gt;(f[v].size()); ++i) {
    for (;;) {
      int j = std::max(ans - x - i + 1, 0);
      if (j &lt; static_cast&lt;int&gt;(f[u].size()) &amp;&amp; f[v][i] + f[u][j] - 2 * dep[u] &gt; ans) ++ans;
      else break;
    }
  }
  for (int i = 0; i &lt; static_cast&lt;int&gt;(f[v].size()); ++i)
    f[u][i] = std::max(f[u][i], f[v][i]);
}

void dfs3(int u, int fa) {
  int mxid = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs3(v, u);
    if (f[v].size() &gt; f[mxid].size()) mxid = v;
  }
  std::swap(f[u], f[mxid]);
  for (auto v : G[u]) {
    if (v == fa || v == mxid) continue;
    merge(u, v);
  }
  for (;;) {
    int i = std::max(ans - x - d[u] + 1, 0);
    if (i &lt; static_cast&lt;int&gt;(f[u].size()) &amp;&amp; f[u][i] - dep[u] &gt; ans) ++ans;
    else break;
  }
  if (d[u] == static_cast&lt;int&gt;(f[u].size()))
    f[u].emplace_back(dep[u]);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 2; i &lt;= n; ++i) {
    int p;
    std::cin &gt;&gt; p;
    G[p].emplace_back(i), G[i].emplace_back(p);
  }
  dfs1(1, 0), dfs2(1, 0);
  int q;
  std::cin &gt;&gt; q;
  for (; q; --q) {
    std::cin &gt;&gt; x;
    for (int i = 1; i &lt;= n; ++i) {
      f[i].clear(), f[i].shrink_to_fit();
    }
    ans = 0;
    dfs3(1, 0);
    std::cout &lt;&lt; ans &lt;&lt; ' ';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17672813.html</id>
    <title type="text">CF797F Mice and Holes 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-01T12:35:00Z</published>
    <updated>2023-09-01T12:35:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17672813.html" />
    <content type="text">## Description

有一天 Masha 回到家，发现有 $n$ 只老鼠在它公寓的走廊上，她大声呼叫，所以老鼠们都跑进了走廊的洞中。

这个走廊可以用一个数轴来表示，上面有 $n$ 只老鼠和 $m$ 个老鼠洞。第 $i$ 只老鼠有一个坐标 $x_i$ ，第 $j$ 个洞有一个坐标 $y_j$ 和容量 $c_j$ 。容量表示最多能容纳的老鼠数量。

找到让老鼠们全部都进洞的方式，使得所有老鼠运动距离总和最小。老鼠 $i$ 进入洞 $j$ 的运动距离 为 $|x_i − y_j|$。

无解输出 $-1$。

$n,m\leq 10^6$。

## Solution

首先直接贪心就考虑每只老鼠选离它左边最近的或右边最近的钻，但是这样不是全局最优的。

考虑反悔贪心。

先把老鼠和洞放到一起按坐标从小到大排序，然后从前往后扫。设 $lstx_i$ 表示第 $i$ 只老鼠当前的最优答案，$lsty_i$ 表示第 $i$ 个洞当前的最优答案。然后用两个堆分别维护老鼠和洞的信息。

如果当前枚举到了第 $i$ 只老鼠，那么就要选一个洞匹配，设其为 $j$，那么匹配 $(i,j)$ 对答案的贡献就是 $(x_i-y_j)-lsty_j=x_i-(y_j+lsty_j)$，于是只要用洞堆维护最大的 $y_j+lsty_j$，然后把答案加上 $x_i-(y_j+lsty_j)$，同时 $lstx_i\leftarrow x_i-lsty_j$。由于当前老鼠还要反悔，所以把 $x_i+lstx_i$ 放到老鼠堆里面。

如果枚举到了第 $i$ 个洞是一样的，如果选了 $j$ 号老鼠，贡献就是 $y_i-(x_j+lstx_j)$，用老鼠堆维护最大的 $x_j+lstx_j$ 即可，然后把答案加上 $y_i-(x_j+lstx_j)$，同时 $lsty_i\leftarrow y_i-lstx_j$。

至于如何处理有一个坐标有很多个洞的问题，就每次只往堆里面放一个洞，如果这个匹配了就把匹配的放进去，然后如果还有洞就再选一个没匹配的洞放进去。

时间复杂度：$O((n+m)\log (n+m))$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e6 + 5, kInf = 1e16;

int n, m, mm;
int x[kMaxN];
std::pair&lt;int, int&gt; h[kMaxN], a[kMaxN];
std::priority_queue&lt;int&gt; qm;
std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; qh;

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; x[i];
    a[++mm] = {x[i], 0};
  }
  int sumc = 0;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; h[i].first &gt;&gt; h[i].second;
    a[++mm] = {h[i].first, i};
    sumc += h[i].second;
  }
  if (sumc &lt; n) {
    std::cout &lt;&lt; "-1\n";
    return;
  }
  std::sort(a + 1, a + 1 + mm);
  int ans = 0;
  for (int i = 1; i &lt;= mm; ++i) {
    if (!a[i].second) { // 老鼠
      int val = kInf;
      if (!qh.empty()) {
        auto [p, id] = qh.top();
        qh.pop();
        val = a[i].first - p;
        if (h[id].second) --h[id].second, qh.emplace(h[id].first, id);
      }
      ans += val;
      qm.emplace(a[i].first + val);
    } else { // 洞
      int val;
      while (!qm.empty() &amp;&amp; h[a[i].second].second &amp;&amp; (val = a[i].first - qm.top()) &lt; 0) {
        --h[a[i].second].second;
        ans += val;
        qm.pop();
        qh.emplace(a[i].first + val, 0);
      }
      if (h[a[i].second].second) --h[a[i].second].second, qh.emplace(a[i].first, a[i].second);
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17680999.html</id>
    <title type="text">正睿 2023 noip 10 连 Day2 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-05T14:17:00Z</published>
    <updated>2023-09-05T14:17:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17680999.html" />
    <content type="text">## Description

对于一个个体，定义以下四种操作：

1. 睡觉：此时会进入深一层的梦境

2. 起床：此时会从深一层的梦境中醒过来，也就是进入浅一层的梦境

3. 打标记：当前层梦境会留下一个标记，这个标记会在第一次进入更浅层或者进行操作4的时候消失(这里的更浅层是相对标记来说)

4. 回归：回到最浅的有标记的层数，并且删除这层的标记，如果没有标记，忽略这次操作

5. 查询：查询当前的梦境层数

现在有 $n$ 个个体，编号从 $1$ 到 $n$，要执行 $q$ 次区间操作，查询仍然是单点的。

为了保证不会存在进入负层梦境的问题，所有个体在开始前都会进行 $5\times 10^5$ 次1操作。

$n,q\leq 5\times 10^5$，数据随机。

## Solution

容易发现对于每个个体只要维护他到当前最浅标记的距离，如果没有标记设为 $-1$。

那么操作 $1$ 和操作 $2$ 就对于所有距离不是 $-1$ 的直接加减。

操作 $3$ 如果没有标记那么就把距离设为 $0$，操作 $4$ 如果有标记就把位置减去距离最浅标记的距离，然后把距离最浅标记的距离设为 $-1$。

考虑用珂朵莉树维护所有距离最浅标记距离相同的区间。

设询问区间为 $[l,r]$，然后对于 $[l,r]$ 的距离做上面的操作，对于操作 $1,2,3$ 的区间加减可以用树状数组维护。

如果是操作 $4$ 由于 $[l,r]$ 全是 $-1$ 就直接删掉所有原来构成 $[l,r]$ 的区间，然后重构一个 $[l,r,-1]$，即可保证复杂度。

时间复杂度：$O(n\log n\log\log n)$。

注意对于没有 $3,4$ 操作时特判，因为这样每次都有可能遍历所有区间，然后就 T 了。

## Code

```cpp
#pragma GCC optimize(2)
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

struct Node {
  int l;
  mutable int r, v;

  Node(int _l, int _r, int _v) : l(_l), r(_r), v(_v) {}

  friend bool operator &lt;(const Node &amp;n1, const Node &amp;n2) {
    return n1.l &lt; n2.l;
  }
};

int n, q;
int c[kMaxN], op[kMaxN], l[kMaxN], r[kMaxN];
std::set&lt;Node&gt; s;

namespace BIT {
void upd(int x, int v) {
  for (; x &lt;= n; x += x &amp; -x)
    c[x] += v;
}
void upd(int l, int r, int v) { upd(l, v), upd(r + 1, -v); }

int qry(int x) {
  int ret = 5e5;
  for (; x; x -= x &amp; -x)
    ret += c[x];
  return ret;
}
} // namespace BIT

auto split(int x) {
  if (x &gt; n) return s.end();
  auto it = std::prev(s.upper_bound({x, 0, 0}));
  if (it-&gt;l == x) return it;
  int r = it-&gt;r;
  it-&gt;r = x - 1;
  return s.emplace(x, r, it-&gt;v).first;
}

void inc(int l, int r) {
  BIT::upd(l, r, 1);
  auto itl = split(l), itr = split(r + 1);
  for (auto it = itl; it != itr; ++it)
    if (~it-&gt;v)
      ++it-&gt;v;
}

void dec(int l, int r) {
  BIT::upd(l, r, -1);
  auto itl = split(l), itr = split(r + 1);
  for (auto it = itl; it != itr; ++it)
    if (~it-&gt;v)
      --it-&gt;v;
}

void addtag(int l, int r) {
  auto itl = split(l), itr = split(r + 1);
  for (auto it = itl; it != itr; ++it)
    if (!~it-&gt;v)
      it-&gt;v = 0;
}

void goback(int l, int r) {
  auto itl = split(l), itr = split(r + 1);
  for (auto it = itl; it != itr; ++it)
    if (~it-&gt;v)
      BIT::upd(it-&gt;l, it-&gt;r, -it-&gt;v);
  s.erase(itl, itr), s.emplace(l, r, -1);
}

bool check() {
  for (int i = 1; i &lt;= q; ++i)
    if (op[i] == 3 || op[i] == 4)
      return 0;
  for (int i = 1; i &lt;= q; ++i) {
    if (op[i] == 1) {
      BIT::upd(l[i], r[i], 1);
    } else if (op[i] == 2) {
      BIT::upd(l[i], r[i], -1);
    } else {
      std::cout &lt;&lt; BIT::qry(l[i]) &lt;&lt; '\n';
    }
  }
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i)
    std::cin &gt;&gt; op[i] &gt;&gt; l[i] &gt;&gt; r[i];
  if (check()) return;
  s.emplace(1, n, -1);
  for (int i = 1; i &lt;= q; ++i) {
    if (op[i] == 1) {
      inc(l[i], r[i]);
    } else if (op[i] == 2) {
      dec(l[i], r[i]);
    } else if (op[i] == 3) {
      addtag(l[i], r[i]);
    } else if (op[i] == 4) {
      goback(l[i], r[i]);
    } else {
      std::cout &lt;&lt; BIT::qry(l[i]) &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17686274.html</id>
    <title type="text">P9189 [USACO23OPEN] Custodial Cleanup G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-07T14:30:00Z</published>
    <updated>2023-09-07T14:30:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17686274.html" />
    <content type="text">## Description

奶牛旅馆可以被看作一个 $N$ 个节点 $M$ 条边的无向简单图，其中每个房间有一个颜色 $C_i$，以及一个钥匙，颜色为 $S_i$， FJ 最初在 $1$ 号节点，手上一把钥匙都没有。

FJ 可以进行无数次以下操作：

- 捡起当前房间的钥匙。（FJ 可以同时手持多个钥匙）

- 将部分或全部手上的钥匙放在当前房间。 (房间内可以同时放多把钥匙)

- 通过一条边，移到一个相邻的房间，前提是目标房间是房间 $1$, 或者 FJ 拥有至少一个目标房间颜色的钥匙。

已知 $F$ 是 $S$ 的排列， FJ 想要让每个房间里面都恰好有一个 $F_i$ 颜色的钥匙，求是否可能。

有 $T$ 组数据，每组数据由一个空行开始，接着先给定 $3$ 行每行 $N$ 个整数，分别表示 $C$,$S$,$F$，最后给定 $M$ 行，每行两个整数表示一条边。

$0 \le M \le 10^5$, $1 \le C_i, S_i, F_i, u_i, v_i \le N \le 10^5$。
$1 \le T \le 100$, $1 \le \sum N \le 10^5$, $1 \le \sum M \le 2\cdot 10^5$。

## Solution

首先如果一边捡钥匙一边放钥匙一定是不优的，因为如果不放当前的钥匙，那么后面能捡的钥匙一定不会减少，还会多出一些额外的钥匙。那么如果只捡钥匙都捡不全的话其他所有的方案也一定不可能成功。

---

先考虑怎么才能捡到能捡到的所有钥匙。

设 $p_i$ 表示捡钥匙序列的前 $i$ 个钥匙颜色组成的集合，那么如果第 $i$ 个钥匙是 $s_v$，一定要满足 $c_v\in p_{i-1}$ 才能捡 $s_v$。

于是 bfs 就呼之欲出了，每次直接跑当前已经捡了钥匙的点的所有邻居，如果能捡就捡。

但是这样有个问题，如果一个钥匙颜色为 $1$ 的点旁边有很多颜色为 $2$ 的点，但是 $1$ 点走很多步能到达一个钥匙颜色为 $2$ 的点 $u$，且 $u$ 与这些颜色为 $2$ 的点不相邻，这个做法就无法捡到所有钥匙。

考虑用一个 vector $st_i$ 维护当前所有遍历过的点中，颜色为 $i$ 的点中有多少还不能捡，那么每次从队列里取出一个点 $u$，就可以先把所有 $st_{s_u}$ 里的点捡了，然后继续像上面那样遍历即可。

---

然后是怎么尽可能地把捡来的钥匙放到每个点上。

设 $p_i$ 表示放钥匙序列的前 $i$ 个钥匙颜色组成的集合，$q_i$ 表示放钥匙序列的从 $i$ 开始的后缀组成的集合，那么如果第 $i$ 个钥匙是 $s_v$，一定要满足 $c_v\in \text{total}-p_{i-1}=q_{i}$ 才能放 $f_v$。

于是只要向刚才那样从 $1$ 开始跑一遍 bfs 即可，注意如果 $f_v\notin q_{i+1}$ 但是 $f_v=c_v$ 的话同样是可以放到队列里的。

---

还有个细节就是不一定能捡到全部的钥匙，那么说明第一次 bfs 中没有被捡的点一定不会再被改变，那么如果它们的初始钥匙和结束钥匙颜色不同就说明一定不合法。而且第二次 bfs 如果遇到了个不可能被经过的点就直接跳过，否则有可能 bfs 到一个不可能经过的点 $v$，满足 $c_v\notin \text{total}$，但是如果 $c_v=s_v=f_v$ 的话会误判为可以经过。

时间复杂度：$O\left(n+m\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, m;
int c[kMaxN], s[kMaxN], f[kMaxN];
bool have[kMaxN], vis[kMaxN], v1[kMaxN];
std::vector&lt;int&gt; G[kMaxN], st[kMaxN];

bool bfs1() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    st[i].clear();
    have[i] = vis[i] = v1[i] = 0;
  }
  q.emplace(1), vis[1] = have[s[1]] = 1;
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (auto v : st[s[u]])
      if (!vis[v]) q.emplace(v), vis[v] = have[s[v]] = 1;
    st[s[u]].clear();
    for (auto v : G[u]) {
      if (vis[v]) continue;
      if (have[c[v]]) q.emplace(v), vis[v] = have[s[v]] = 1;
      else st[c[v]].emplace_back(v);
    }
  }
  for (int i = 1; i &lt;= n; ++i)
    if (!vis[i])
      v1[i] = 1;
  for (int i = 1; i &lt;= n; ++i)
    if (!vis[i] &amp;&amp; s[i] != f[i])
      return 0;
  return 1;
}

bool bfs2() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    st[i].clear();
    have[i] = vis[i] = 0;
  }
  q.emplace(1), vis[1] = have[f[1]] = 1;
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (auto v : st[f[u]])
      if (!vis[v]) q.emplace(v), vis[v] = have[f[v]] = 1;
    st[f[u]].clear();
    for (auto v : G[u]) {
      if (vis[v] || v1[v]) continue;
      if (have[c[v]] || c[v] == f[v]) q.emplace(v), vis[v] = have[f[v]] = 1;
      else st[c[v]].emplace_back(v);
    }
  }
  for (int i = 1; i &lt;= n; ++i)
    if (!vis[i] &amp;&amp; s[i] != f[i])
      return 0;
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i)
    G[i].clear();
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; c[i];
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; s[i];
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; f[i];
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  std::cout &lt;&lt; ((bfs1() &amp;&amp; bfs2()) ? "YES\n" : "NO\n");
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17700665.html</id>
    <title type="text">20230909 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-13T12:28:00Z</published>
    <updated>2023-09-13T12:28:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17700665.html" />
    <content type="text">## Description

![image](https://img2023.cnblogs.com/blog/2268753/202309/2268753-20230913201030446-1357891809.png)

$1\leq t,n\leq 10^6,1\leq a_i\leq b_i\leq t,1\leq c_i,v_i,h_i\leq 10^9$。

## Solution

考虑先把药水按照 $c$ 排个序，然后双指针，即对于 $l$，求出一个最小的 $r$ 使得 $[l,r]$ 这些药水能够满足条件，于是题目就转化成这这个：

&gt; 给定长度为 $n$ 的序列 $\{h_i\}$ 的初值，有 $\Theta(q)$ 次操作：
&gt; 
&gt; 1. 插入一个操作：给定 $l, r, v$，将 $[l, r]$ 中 $h_i \leqslant v$ 的 $h_i$ 修改为 $0$。
&gt; 2. 查询在当前操作集合下 $\max h_i$ 是否为 $0$。
&gt; 3. 删除最早的一个操作。

注意到对于前面两个操作只要在线段树上维护一个 maxh 和 maxv，然后如果当前的 $maxh\leq maxv$ 就把这个区间的 maxh 置为 $0$，但是有删除就要维护覆盖了这个区间的所有的 $v$，每次要把线段树里面所有含有删掉这个元素的东西给处理掉，然后还要重构整棵线段树，时间复杂度 $O(n^2\log n)$。

---

这个做法退化得与暴力差不多，因为它每次下传标记会把 $v$ 放到很多个线段树节点上，因此我们思考，不下传标记能不能做呢？

考虑标记永久化，每次添加后不下传标记，然后对于每个节点维护一个单调队列，显然总的 $v$ 个数为 $O(n\log t)$ 级别。

添加到一个线段树节点后就重构单调队列，然后把 maxh 和 maxv 更新。删除就考虑删除队头然后更新 maxh 和 maxv。

那么这样做为什么是对的呢？考虑对于每一个 $h_i$，从 $[i,i]$ 到线段树根节点的这条路径上一定涵盖了所有覆盖了它的 $v$ 值，如果路径上某一个节点的 $maxv&gt;h_i$ 则这个 $h_i$ 一定就变成 $0$ 了，所以对于某个节点 $[l,r]$，如果 $\max\{h_l,\dots,h_r\}\leq maxv$ 说明这个区间全为 $0$，否则说明以 $[l,r]$ 为根的子树里的 $v$ 不足以干掉 $h_{l\sim r}$，就往上继续。

然后由于这是标记永久化，所以如果一个 $v$ 添加或删除到了 $[l,r]$，那么 $[l,r]$ 所有子孙节点的 maxh 一定不变，所以重构后再跑一定是对的。

时间复杂度：$O\left((n+t)\log t\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

struct Node {
  int l, r, c, v;
} a[kMaxN];

int t, n;
int h[kMaxN], maxh[kMaxN &lt;&lt; 2], maxv[kMaxN &lt;&lt; 2];
std::list&lt;int&gt; q[kMaxN &lt;&lt; 2];

void pushup(int x) {
  maxh[x] = std::max(maxh[x &lt;&lt; 1], maxh[x &lt;&lt; 1 | 1]);
}

void build(int x, int l, int r) {
  if (l == r) {
    maxh[x] = h[l];
    return;
  }
  int mid = (l + r) &gt;&gt; 1;
  build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  pushup(x);
}

void addv(int x, int l, int r, int ql, int qr, int k) {
  if (l &gt; qr || r &lt; ql) {
    return;
  } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
    for (; !q[x].empty() &amp;&amp; a[q[x].back()].v &lt;= a[k].v; q[x].pop_back()) {}
    q[x].emplace_back(k);
    maxv[x] = a[q[x].front()].v;
    if (maxh[x] &lt;= maxv[x]) maxh[x] = 0;
    return;
  }
  int mid = (l + r) &gt;&gt; 1;
  addv(x &lt;&lt; 1, l, mid, ql, qr, k), addv(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, k);
  pushup(x);
  if (maxh[x] &lt;= maxv[x]) maxh[x] = 0;
} 

void delv(int x, int l, int r, int ql, int qr, int k) {
  if (l &gt; qr || r &lt; ql) {
    return;
  } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
    for (; !q[x].empty() &amp;&amp; q[x].front() &lt;= k; q[x].pop_front()) {}
    if (q[x].empty()) maxv[x] = 0;
    else maxv[x] = a[q[x].front()].v;
    if (l == r) maxh[x] = h[l];
    else pushup(x);
    if (maxh[x] &lt;= maxv[x]) maxh[x] = 0;
    return;
  }
  int mid = (l + r) &gt;&gt; 1;
  delv(x &lt;&lt; 1, l, mid, ql, qr, k), delv(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, k);
  pushup(x);
  if (maxh[x] &lt;= maxv[x]) maxh[x] = 0;
}

void dickdreamer() {
  std::cin &gt;&gt; t &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c &gt;&gt; a[i].v; 
  for (int i = 1; i &lt;= t; ++i)
    std::cin &gt;&gt; h[i];
  std::sort(a + 1, a + 1 + n, [&amp;] (const Node &amp;n1, const Node &amp;n2) { return n1.c &lt; n2.c; });
  build(1, 1, t);
  int ans = 1e9;
  for (int l = 1, r = 0; l &lt;= n; delv(1, 1, t, a[l].l, a[l].r, l), ++l) {
    for (; r &lt; n &amp;&amp; maxh[1]; ++r, addv(1, 1, t, a[r].l, a[r].r, r)) {}
    if (!maxh[1]) ans = std::min(ans, a[r].c - a[l].c);
  }
  std::cout &lt;&lt; (ans == 1e9 ? -1 : ans) &lt;&lt; '\n';
}

int32_t main() {
  freopen("game.in", "r", stdin);
  freopen("game.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17700689.html</id>
    <title type="text">20230913 模拟赛 T4 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-13T12:38:00Z</published>
    <updated>2023-09-13T12:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17700689.html" />
    <content type="text">## Description

![image](https://img2023.cnblogs.com/blog/2268753/202309/2268753-20230913203718264-15641136.png)

$1\leq n,x_i,y_i\leq 5\times 10^5$。

## Solution

注意到每个棋子只会被吃一次，那么只要考虑把白棋放到某个黑棋上，然后在这个基础上继续吃黑棋。

那么如果黑棋 $i$ 能够吃掉黑棋 $j$ 就意味着 $|y_i-y_j|=1$ 且 $x_j&gt;x_i$，然后连一条从 $i$ 到 $j$ 的有向边，容易发现会形成一个 DAG，而答案就是这个 DAG 的最小不相交链覆盖，建出二分图跑最大匹配可以做到 $O(n^2\sqrt{n})$。

---

注意到这个最大匹配很难发现性质，考虑把答案转化为最大独立集，答案=$n-最大匹配=n-(2n-最大独立集)=最大独立集-n$，这样做后会发现如果右边的第 $i$ 个点在最大独立集里，说明左边没有能够吃掉 $i$ 的点，那么原图里面 $y_j=y_i$ 且 $x_j&gt;x_i$ 的 $j$ 在右边对应的点也在最大独立集里。

所以如果把右边 $y$ 值相同的放在一起，那么对于每一个 $y$ 放到最大独立集里的一定是一个后缀。同理，左边的一定是个前缀。

然后考虑从前往后对于每一个列进行 dp。设 $f_{i,j,0/1}$ 表示考虑了 $1\sim i$ 列，第 $i$ 列选了前缀/后缀 $j$ 个，当前考虑的是第 $i$ 的左边/右边。

那么 $f_{i,j,0}=\min\left\{f_{i-1,k,1}+j\right(a_{i-1,k}\geq a_{i,j})\},f_{i,j,1}=\min\left\{f_{i-1,k,0}+j\right(a_{i-1,k}\leq a_{i,j})\}$。

设 $m$ 为 $y_i$ 的值域，然后对于 $f_{1,j,0},f_{2,j,1},f_{3,j,0},\dots,f_{m,j,1-(m\bmod 2)}$ 和 $f_{1,j,1},f_{2,j,0},f_{3,j,1},\dots,f_{m,j,m\bmod 2}$ 分别 dp 即可。

时间复杂度：$O(n+V)$，实测桶排没有 sort 快。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m;
int x[kMaxN], y[kMaxN], sz[kMaxN], f[2][kMaxN];
std::vector&lt;int&gt; v[kMaxN], buc[kMaxN];

int solve(int o) { // 0 : 从下到上，1 : 从上到下
  memset(f, 0xcf, sizeof(f));
  if (!o) {
    for (int i = 0; i &lt;= sz[1]; ++i)
      f[o][i] = i;
  } else {
    for (int i = 1; i &lt;= sz[1] + 1; ++i)
      f[o][i] = sz[1] - i + 1;
  }
  for (int i = 2; i &lt;= m; ++i) {
    o ^= 1;
    for (int j = 0; j &lt;= sz[i] + 1; ++j)
      f[o][j] = -1e9;
    if (!o) { // v[i - 1][k] &gt;= v[i][j]
      for (int j = sz[i], k = sz[i - 1] + 1; ~j; --j) {
        for (; k &gt; 1 &amp;&amp; v[i - 1][k - 1] &gt;= v[i][j]; --k) {}
        f[o][j] = f[o ^ 1][k] + j;
      }
      for (int j = 1; j &lt;= sz[i]; ++j)
        f[o][j] = std::max(f[o][j], f[o][j - 1]);
    } else { // v[i - 1][k] &lt;= v[i][j]
      for (int j = 1, k = 0; j &lt;= sz[i] + 1; ++j) {
        for (; k &lt; sz[i - 1] &amp;&amp; v[i - 1][k + 1] &lt;= v[i][j]; ++k) {}
        f[o][j] = f[o ^ 1][k] + sz[i] - j + 1;
      }
      for (int j = sz[i]; j &gt;= 1; --j)
        f[o][j] = std::max(f[o][j], f[o][j + 1]);
    }
  }
  return (o ? f[o][1] : f[o][sz[m]]);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  int mx = 0;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; x[i] &gt;&gt; y[i];
    buc[x[i]].emplace_back(y[i]);
    m = std::max(m, y[i]);
    mx = std::max(mx, x[i]);
    ++sz[y[i]];
  }
  for (int i = 1; i &lt;= m; ++i)
    v[i].emplace_back(-1e9);
  for (int i = 1; i &lt;= mx; ++i)
    for (auto y : buc[i])
      v[y].emplace_back(i);
  for (int i = 1; i &lt;= m; ++i)
    v[i].emplace_back(1e9);
  std::cout &lt;&lt; solve(0) + solve(1) - n &lt;&lt; '\n';
}

int32_t main() {
  freopen("orz.in", "r", stdin);
  freopen("orz.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17706066.html</id>
    <title type="text">网络流-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-16T01:19:00Z</published>
    <updated>2023-09-16T01:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17706066.html" />
    <content type="text"># 1. 最大匹配 = 最小点覆盖。
# 2. 最小割 = 最大匹配
# 3. 二分图最大独立集 = 点数 - 最大匹配。
# 4. 二分图最大团 = 补图最大独立集。
# 5. DAG 最小链覆盖 = n - 拆点后二分图最大匹配。
# 6. 最大权闭合子图 = 正权和 - 最小割

## 网络流 24 题

- ### [负载平衡问题](https://www.luogu.com.cn/problem/P4016)

这个其实不是网络流......

直接设 $k_i$ 表示 $i$ 向 $i + 1$ 搬运量，然后可以得出等式 $k_i+a_{i-1}-a_i=avg$，推下式子即可。

时间复杂度：$O(n\log n)$。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 105;

int n;
int a[kMaxN], c[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  int sum = 0, avg;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    sum += a[i];
  }
  avg = sum / n;
  std::vector&lt;int&gt; v = {0};
  int sc = 0;
  for (int i = 2; i &lt;= n; ++i) {
    c[i] = a[i] - avg;
    sc += c[i];
    v.emplace_back(sc);
  }
  std::sort(v.begin(), v.end());
  int x = v[v.size() / 2], ans = 0;
  for (auto y : v)
    ans += abs(y - x);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

---

- ### [飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)

二分图最大匹配板子。

---

- ### [试题库问题](https://www.luogu.com.cn/problem/P2763)

直接把试题放左边，类型放右边，让每个试题与它所属的类型连一条流量为 $1$ 的边，源点向每个试题连流量为 $1$ 的边，每个类型向汇点连流量为它所需个数的边，跑最大流即可。

输出方案就在残余网络上找满流的边即可。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e3 + 5, kMaxM = 3e4 + 5, kInf = 0x3f3f3f3f;

struct Edge {
  int v, w, pre;
} e[kMaxM];

int k, n, m, s, t, tot = 1;
int tail[kMaxN], cur[kMaxN], idx[kMaxN][kMaxN], dep[kMaxN];
bool vis[kMaxN];

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = idx[u][v] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  for (int i = 1; i &lt;= t; ++i)
    cur[i] = tail[i], vis[i] = 0, dep[i] = kInf;
  std::queue&lt;int&gt; q;
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || vis[v]) continue;
      dep[v] = dep[u] + 1, q.emplace(v), vis[v] = 1;
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = kInf;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; k &gt;&gt; n;
  s = n + k + 1, t = n + k + 2;
  for (int i = 1; i &lt;= k; ++i) {
    int x;
    std::cin &gt;&gt; x;
    add(i + n, t, x);
    m += x;
  }
  for (int i = 1; i &lt;= n; ++i) {
    int p, x;
    std::cin &gt;&gt; p;
    for (; p; --p) {
      std::cin &gt;&gt; x;
      add(i, x + n, kInf);
    }
    add(s, i, 1);
  }
  int ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  if (ans &lt; m) {
    std::cout &lt;&lt; "No Solution!\n";
    return;
  }
  for (int i = 1; i &lt;= k; ++i) {
    std::cout &lt;&lt; i &lt;&lt; ": ";
    for (int j = 1; j &lt;= n; ++j)
      if (e[idx[i + n][j]].w)
        std::cout &lt;&lt; j &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

---

- ### [运输问题](https://www.luogu.com.cn/problem/P4015) &amp; [分配问题](https://www.luogu.com.cn/problem/P4014)

费用流板子

---

- ### [圆桌问题](https://www.luogu.com.cn/problem/P3254)

每个代表向每个餐桌连流量为 $1$ 的边然后跑最大流即可。

---

- ### [太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)

最大权闭合子图板子。

考虑让答案为总和-最小割。

源点向所有实验 $i$ 连流量为其奖金的边，实验 $i$ 向它所有所需仪器连流量为 $+\infty$ 表示不能断这条边，然后仪器 $j$ 向汇点连流量为其费用的边。

那么由于断不了中间的边，所以对于实验 $i$，要让它不连通，要么断掉源点连它的边，表示不做这个实验。要么断掉它所有所需仪器向汇点连的边，表示要买这些仪器。

会发现答案 = 奖金和 - 左边割 - 右边割 = 奖金和 - 最小割。

跑最大流即可。

输出方案就找在残余网络上和源点连通的实验说明它没割，和源点连通的仪器说明割了。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 105, kMaxM = 1e5 + 5, kInf = 1e9;

struct Edge {
  int v, w, pre;
} e[kMaxM];

int n, m, s, t, sum, tot = 1;
int tail[kMaxN], cur[kMaxN], idx[kMaxN][kMaxN], dep[kMaxN];
bool vis[kMaxN];

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = idx[u][v] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  for (int i = 1; i &lt;= t; ++i)
    cur[i] = tail[i], vis[i] = 0, dep[i] = kInf;
  std::queue&lt;int&gt; q;
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || vis[v]) continue;
      dep[v] = dep[u] + 1, q.emplace(v), vis[v] = 1;
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = kInf;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  s = n + m + 1, t = n + m + 2;
  for (int i = 1; i &lt;= n; ++i) {
    int num = 0, fl = 0;
    std::string str;
    getline(std::cin, str);
    while (!str.size()) getline(std::cin, str);
    str += '\n';
    for (auto c : str) {
      if (isdigit(c)) {
        num = 10 * num + c - '0';
      } else {
        if (!fl) add(s, i, num), sum += num, fl = 1;
        else add(i, num + n, kInf);
        num = 0;
      }
    }
  }
  for (int i = 1; i &lt;= m; ++i) {
    int val;
    std::cin &gt;&gt; val;
    add(i + n, t, val);
  }
  int ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  for (int i = 1; i &lt;= n; ++i)
    if (dep[i] &lt;= t)
      std::cout &lt;&lt; i &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
  for (int i = 1; i &lt;= m; ++i)
    if (dep[i + n] &lt;= t)
      std::cout &lt;&lt; i &lt;&lt; ' ';
  std::cout &lt;&lt; '\n' &lt;&lt; sum - ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

---

- ### [骑士共存问题](https://www.luogu.com.cn/problem/P3355)

最大独立集板子。

观察可知对棋盘黑白染色后，两个可以互相吃掉的马颜色一定不同，所以把黑的放左边，白的放右边，能互相吃掉的就连边，答案就是 $n^2-m-最大流$。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 4e4 + 5, kMaxM = 1e6 + 5, kInf = 1e9;
const int kD[][2] = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

struct Edge {
  int v, w, pre;
} e[kMaxM];

int n, m, s, t, tot = 1;
int cnt[2], idx[205][205], tail[kMaxN], cur[kMaxN], dep[kMaxN];
bool ob[205][205], vis[kMaxN];

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= t; ++i)
    vis[i] = 0, dep[i] = kInf, cur[i] = tail[i];
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || vis[v]) continue;
      vis[v] = 1, dep[v] = dep[u] + 1, q.emplace(v);
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = kInf;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    ob[x][y] = 1;
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (ob[i][j]) continue;
      idx[i][j] = ++cnt[(i + j) &amp; 1];
    }
  }
  s = cnt[0] + cnt[1] + 1, t = cnt[0] + cnt[1] + 2;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (ob[i][j]) continue;
      if ((i + j) &amp; 1) idx[i][j] += cnt[0];
    }
  }
  for (int i = 1; i &lt;= cnt[0]; ++i)
    add(s, i, 1);
  for (int i = 1; i &lt;= cnt[1]; ++i)
    add(i + cnt[0], t, 1);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (ob[i][j] || ((i + j) &amp; 1)) continue;
      for (auto [dx, dy] : kD) {
        int ti = i + dx, tj = j + dy;
        if (ti &lt; 1 || ti &gt; n || tj &lt; 1 || tj &gt; n || ob[ti][tj]) continue;
        add(idx[i][j], idx[ti][tj], 1);
      }
    }
  }
  int ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  std::cout &lt;&lt; cnt[0] + cnt[1] - ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

---

- ### [方格取数问题](https://www.luogu.com.cn/problem/P2774)

考虑黑白染色，然后把相邻的点连一条流量为 $+\infty$ 的边，然后源点向黑点连流量为其权值的边，白点向汇点也连流量为其权值的边。

然后答案就是总和 - 最小割。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e4 + 5, kMaxM = 1e5 + 5, kInf = 1e9;
const int kD[][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

struct Edge {
  int v, w, pre;
} e[kMaxM];

int n, m, s, t, sum, tot = 1;
int cnt[2], a[105][105], idx[105][105];
int tail[kMaxN], cur[kMaxN], dep[kMaxN];
bool vis[kMaxN];

int getid(int x, int y) {
  return (x - 1) * m + y;
}

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= t; ++i)
    vis[i] = 0, dep[i] = kInf, cur[i] = tail[i];
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || vis[v]) continue;
      vis[v] = 1, dep[v] = dep[u] + 1, q.emplace(v);
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = kInf;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  s = n * m + 1, t = n * m + 2;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      std::cin &gt;&gt; a[i][j];
      sum += a[i][j];
      if ((i + j) &amp; 1) add(s, getid(i, j), a[i][j]);
      else add(getid(i, j), t, a[i][j]);
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (!((i + j) &amp; 1)) continue;
      for (auto [dx, dy] : kD) {
        int ti = i + dx, tj = j + dy;
        if (ti &lt; 1 || ti &gt; n || tj &lt; 1 || tj &gt; m) continue;
        add(getid(i, j), getid(ti, tj), kInf);
      }
    }
  }
  int ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  std::cout &lt;&lt; sum - ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

---

- ### [最长不下降子序列问题](https://www.luogu.com.cn/problem/P2766)

第一问直接 DP。

对于第二问，设 $f_{i}$ 表示以 $i$ 开头的最长不下降子序列，那么如果 $j&gt;i$ 并且 $a_j\geq a_i,f_j=f_i-1$ 就连一条从 $i$ 到 $j$ 的边，容易发现形成了一张 DAG。

定义一个合法的链表示 $f_{起点}=mx,f_{终点}=1$，原题就转化为问能把 DAG 划分为最多多少条互不相交的链。

考虑把由于每个点最多出现 $1$ 次，那么就把每个点拆成入点和出点，入点向出点连一条长度为 $1$ 的边，如果有一条 $i\to j$ 的边，就连一条出点 $i$ 到入点 $j$ 的流量为 $1$ 的边。

然后源点向 $f_i=mx$ 的入点 $i$ 连一条流量为 $1$ 的边，表示可以从这里开始。$f_j=1$ 的出点 $j$ 向汇点连一条流量为 $1$ 的边，表示可以从这里结束。

跑最大流就是答案。

对于第三问直接把源点向入点 $1$、入点 $1$ 向出点 $1$、入点 $n$ 向出点 $n$ 和出点 $n$ 向汇点的流量改成 $+\infty$ 再跑最大流即可。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1005, kMaxM = 1e6 + 5, kInf = 1e9;

struct Edge {
  int v, w, pre;
} e[kMaxM];

int n, s, t, tot = 1;
int a[kMaxN], f[kMaxN];
int tail[kMaxN], cur[kMaxN], dep[kMaxN];
bool vis[kMaxN];

void init() {
  tot = 1;
  memset(tail, 0, sizeof(tail));
}

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= t; ++i)
    vis[i] = 0, dep[i] = kInf, cur[i] = tail[i];
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || vis[v]) continue;
      vis[v] = 1, dep[v] = dep[u] + 1, q.emplace(v);
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = kInf;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  s = 2 * n + 1, t = 2 * n + 2;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  if (n == 1) { std::cout &lt;&lt; "1\n1\n1\n"; return; }
  int mx = 0;
  for (int i = n; i; --i) {
    f[i] = 1;
    for (int j = i + 1; j &lt;= n; ++j) {
      if (a[j] &gt;= a[i] &amp;&amp; f[j] + 1 &gt; f[i])
        f[i] = f[j] + 1;
    }
    mx = std::max(mx, f[i]);
  }
  std::cout &lt;&lt; mx &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i) {
    if (f[i] == mx) add(s, i, 1);
    if (f[i] == 1) add(i + n, t, 1);
    add(i, i + n, 1);
    for (int j = i + 1; j &lt;= n; ++j)
      if (a[j] &gt;= a[i] &amp;&amp; f[j] + 1 == f[i])
        add(i + n, j, 1);
  }
  int ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  std::cout &lt;&lt; ans &lt;&lt; '\n';
  init();
  for (int i = 1; i &lt;= n; ++i) {
    if (f[i] == mx) add(s, i, (i == 1 ? kInf : 1));
    if (f[i] == 1) add(i + n, t, (i == n ? kInf : 1));
    add(i, i + n, (i == 1 || i == n) ? kInf : 1);
    for (int j = i + 1; j &lt;= n; ++j)
      if (a[j] &gt;= a[i] &amp;&amp; f[j] + 1 == f[i])
        add(i + n, j, 1);
  }
  ans = 0;
  for (; bfs(); ans += dfs(s, kInf)) {}
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

- ### [餐巾计划问题](https://www.luogu.com.cn/problem/P1251)


考虑费用流，然后把每天拆成早上和晚上。

早上表示当天所有的干净餐巾，晚上表示当天所有的脏餐巾。

为了保证每天都有足够的餐巾，就要让早上 $i$ 向汇点连一条流量为 $r_i$ 的边，那么这样的话流量就少了 $r_i$，考虑从源点向晚上 $i$ 连一条流量为 $r_i$ 且费用为 $0$ 的边，补上丢失的流量，可以理解为顾客把 $r_i$ 个脏餐巾还给了饭店。

然后就让早上 $i$ 向早上 $i+1$ 连一条流量为 $+\infty$ 费用为 $0$ 的边表示今天没用的餐巾可以留到明天用。晚上 $i$ 向晚上 $i+1$ 连一条流量 $+\infty$ 费用为 $0$ 的边表示这些餐巾可以延迟送洗。

源点向早上 $i$ 连一条流量为 $+\infty$ 费用为 $p$ 的边，表示可以买新餐巾。晚上 $i$ 向早上 $i+m$ 连一条流量为 $+\infty$ 费用为 $f$ 的边，表示可以把脏餐巾送到快洗店。同理，晚上 $i$ 向早上 $i+n$ 连一条流量为 $+\infty$ 费用为 $s$ 的边，表示可以把脏餐巾送到慢洗店。

然后跑最小费用最大流即可。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e4 + 5, kMaxM = 1e5 + 5, kInf = 1e9;

struct Edge {
  int v, flow, cost, pre;
} e[kMaxM];

int n, s, t, tot = 1, ans;
int _p, _m, _f, _n, _s, r[kMaxN];
int tail[kMaxN], cur[kMaxN], dis[kMaxN];
bool inq[kMaxN], vis[kMaxN];

int getid(int x, int op) { // 0 : 早, 1 : 晚
  return x + op * n;
}

void adde(int u, int v, int f, int c) { e[++tot] = {v, f, c, tail[u]}, tail[u] = tot; }
void add(int u, int v, int f, int c) { adde(u, v, f, c), adde(v, u, 0, -c); }

bool spfa() {
  for (int i = 1; i &lt;= t; ++i) {
    inq[i] = vis[i] = 0;
    cur[i] = tail[i];
    dis[i] = kInf;
  }
  std::queue&lt;int&gt; q;
  q.emplace(s), dis[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    vis[u] = 0;
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v, w = e[i].cost, f = e[i].flow;
      if (!f) continue;
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) q.emplace(v), vis[v] = 1;
      }
    }
  }
  return dis[t] != kInf;
}

int dfs(int u, int lim) {
  if (u == t || !lim) {
    ans += dis[t] * lim;
    return lim;
  }
  vis[u] = 1;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v;
    if (dis[v] == dis[u] + e[i].cost &amp;&amp; e[i].flow &amp;&amp; !vis[v]) {
      int fl = dfs(v, std::min(lim, e[i].flow));
      e[i].flow -= fl, e[i ^ 1].flow += fl;
      flow += fl, lim -= fl;
      if (!lim) break;
    }
  }
  vis[u] = 0;
  return flow;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  s = 2 * n + 1, t = 2 * n + 2;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; r[i];
    add(s, getid(i, 1), r[i], 0);
    add(getid(i, 0), t, r[i], 0);
    if (i &lt; n) {
      add(getid(i, 0), getid(i + 1, 0), kInf, 0);
      add(getid(i, 1), getid(i + 1, 1), kInf, 0);
    }
  }
  std::cin &gt;&gt; _p &gt;&gt; _m &gt;&gt; _f &gt;&gt; _n &gt;&gt; _s;
  for (int i = 1; i &lt;= n; ++i) {
    add(s, getid(i, 0), kInf, _p);
    if (i &lt;= n - _m) add(getid(i, 1), getid(i + _m, 0), kInf, _f);
    if (i &lt;= n - _n) add(getid(i, 1), getid(i + _n, 0), kInf, _s);
  }
  for (; spfa(); dfs(s, kInf)) {}
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

- ## [航空路线问题](https://www.luogu.com.cn/problem/P2770)

原题可以转化为找两条点数最多的从 $1$ 到 $n$ 从小到大走的路径，且这两条路径除了 $1$ 和 $n$，其余点不交。

套路拆点，然后最大流钦定找到 $2$ 跳路径，最大费用用来找到尽可能多的点。

入点向出点连一条 $(1,1)$ 的边，特别的 $1$ 和 $n$ 是 $(2,1)$。

然后如果 $u$ 和 $v$ 有边，那么就出点 $u$ 和入点 $v$ 连一条 $(1, 0)$ 的边。

然后源点向入点 $1$ 连一条 $(2, 0)$ 的边，出点 $n$ 向汇点也连 $(2,0)$ 的边，表示要找到两条合法路径。

然后跑最大费用最大流。

容易发现总点数是最大费用 - 2。

输出方案就在残余网络上找，如果 $(出u,入v)$ 满流了，就说明走了 $(u,v)$ 这条路径。

于是直接 dfs 两遍即可。

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 205, kMaxM = 1e5 + 5, kInf = 1e9;

struct Edge {
  int v, flow, cost, pre;
} e[kMaxM];

int n, m, s, t, tot = 1;
int tail[kMaxN], cur[kMaxN], dis[kMaxN], ed[kMaxN][kMaxN];
std::string name[kMaxN];
bool vis[kMaxN];
std::map&lt;std::string, int&gt; idx;
std::vector&lt;int&gt; v[2];

void adde(int u, int v, int f, int c) { e[++tot] = {v, f, c, tail[u]}, tail[u] = tot, ed[u][v] = tot; }
void add(int u, int v, int f, int c) { adde(u, v, f, c), adde(v, u, 0, -c); }

bool spfa() {
  for (int i = 1; i &lt;= t; ++i) {
    vis[i] = 0, dis[i] = -kInf, cur[i] = tail[i];
  }
  std::queue&lt;int&gt; q;
  q.emplace(s), dis[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    vis[u] = 0;
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v, w = e[i].cost, f = e[i].flow;
      if (!f) continue;
      if (dis[v] &lt; dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) q.emplace(v), vis[v] = 1;
      }
    }
  }
  return dis[t] != -kInf;
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  vis[u] = 1;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v;
    if (dis[v] == dis[u] + e[i].cost &amp;&amp; e[i].flow &amp;&amp; !vis[v]) {
      int fl = dfs(v, std::min(lim, e[i].flow));
      if (!fl) dis[v] = kInf;
      e[i].flow -= fl, e[i ^ 1].flow += fl;
      flow += fl, lim -= fl;
      if (!lim) break;
    }
  }
  vis[u] = 0;
  return flow;
}

bool check(int u, int v) {
  return e[ed[u][v + n] ^ 1].flow;
}

void _dfs(int u, int o) {
  if (u == n) return;
  v[o].emplace_back(u);
  vis[u] = 1;
  for (int i = u + 1; i &lt;= n; ++i) {
    if (!vis[i] &amp;&amp; check(u, i)) {
      return _dfs(i, o);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  s = 2 * n + 1, t = 2 * n + 2;
  for (int i = 1; i &lt;= n; ++i) {
    std::string str;
    std::cin &gt;&gt; str;
    name[i] = str;
    idx[str] = i;
    add(i + n, i, 1 + (i == n), 1);
  }
  for (int i = 1; i &lt;= m; ++i) {
    std::string s, t;
    int u, v;
    std::cin &gt;&gt; s &gt;&gt; t;
    u = idx[s], v = idx[t];
    if (u &gt; v) std::swap(u, v);
    add(u, v + n, kInf, 0);
  }
  add(s, 1, 2, 0), add(n, t, 2, 0);
  int flow = 0;
  for (; spfa(); flow += dfs(s, kInf)) {}
  if (flow &lt; 2) {
    std::cout &lt;&lt; "No Solution!\n";
    return;
  }
  assert(flow == 2);
  memset(vis, 0, sizeof(vis));
  _dfs(1, 0), _dfs(1, 1);
  std::reverse(v[1].begin(), v[1].end());
  std::cout &lt;&lt; v[0].size() + v[1].size() &lt;&lt; '\n';
  for (auto x : v[0]) std::cout &lt;&lt; name[x] &lt;&lt; '\n';
  std::cout &lt;&lt; name[n] &lt;&lt; '\n';
  for (auto x : v[1]) std::cout &lt;&lt; name[x] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17720956.html</id>
    <title type="text">20230921 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-21T12:58:00Z</published>
    <updated>2023-09-21T12:58:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17720956.html" />
    <content type="text">## Description

给你一颗有 $n$ 个点的树，其中 $1$ 号点为根节点，每个点都有一个权值 $val[i]$。

你可以从树中选择一些点， 注意如果 $i$ 与 $j$ 都被选中且 $j$ 在 $i$ 的子树内，那么必须满足 $val[i] &gt; val[j]$。

请你求出最多能同时选出多少个点

$n\leq 10^5$。

## Solution

考虑 Dilworth 定理。

如果 $j$ 在 $i$ 的子树里，且 $val[i]\leq val[j]$ 那么连一条从 $i$ 到 $j$ 的边。

那么原题就相当于找最多的点，使得对于任意两点 $i,j(dep[i]&lt;dep[j])$，要么 $i,j$ 都不在对方子树里，要么 $val[i]&gt;val[j]$，也就是两两不可到达，根据 Dilworth 定理，就是原来那个 DAG 的最小链覆盖。

于是答案就是在原树里面用最少的从叶子到根的不上升子序列来覆盖所有点的序列数。

考虑对于每个点维护一个 multiset，这个点对应子树的最小链覆盖的末尾值。

那么对于一个点 $u$，先把 $u$ 所有儿子的 multiset 合并，然后 $u$ 优先要找子树里面的链末尾最小的去接上，也就是找 $\geq val[u]$ 的最小的那个末尾去接，如果找不到，就只能新建一条链。

至于为什么要找到 $\geq val[u]$ 的最小的末尾接，是因为如果能接，那么肯定是把某个大于等于 $val[u]$ 的替换成 $val[u]$，由于大的到后面能接的肯定比小的要多，所以肯定是找到最小的且能接的去接。

至于合并 multiset，直接 dsu on tree 即可。

时间复杂度：$O(n\log^2 n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n;
int val[kMaxN], sz[kMaxN], wson[kMaxN];
std::vector&lt;int&gt; G[kMaxN];
std::multiset&lt;int&gt; st[kMaxN];

void dfs1(int u) {
  sz[u] = 1;
  for (auto v : G[u]) {
    dfs1(v);
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, std::multiset&lt;int&gt; &amp;s) {
  if (wson[u]) dfs2(wson[u], s);
  for (auto v : G[u]) {
    if (v == wson[u]) continue;
    dfs2(v, st[v]);
    for (auto x : st[v]) s.emplace(x);
  }
  auto it = s.lower_bound(val[u]);
  if (it != s.end()) s.erase(it);
  s.emplace(val[u]);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    int p;
    std::cin &gt;&gt; val[i] &gt;&gt; p;
    if (p) G[p].emplace_back(i);
  }
  dfs1(1), dfs2(1, st[1]);
  std::cout &lt;&lt; st[1].size() &lt;&lt; '\n';
}

int32_t main() {
  freopen("tree.in", "r", stdin);
  freopen("tree.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17731092.html</id>
    <title type="text">20230926 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-26T12:29:00Z</published>
    <updated>2023-09-26T12:29:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17731092.html" />
    <content type="text">## Description

给定一个由 $n$ 个点 $m$ 条边组成的边带权森林，有 $q$ 次询问，每次询问给定 $x,y$，现在随机在 $x$ 和 $y$ 所在子树之间添加一条长度为 $1$ 的边，问这个大连通块的直径的期望值是多少，对 $10^9+7$ 取模。

$1\leq n,m,q\leq 2\times 10^5,1\leq w\leq 10^9$。

## Solution

首先可以换根 dp 预处理出 $f_i$ 表示 $i$ 到 $i$ 所在的树最远距离，$l_i$ 表示第 $i$ 棵树的直径。

设 $A$ 表示 $x$ 所在子树，$B$ 表示 $y$ 所在子树，$L$ 表示 $\min\{l_A,l_B\}$。

那么答案就是：

$$
\frac{\sum_{u\in A}\sum_{v\in B}{\min\{f_u+f_v+1,L\}}}{\text{size}_x\times \text{size}_y}
$$

显然对于 $A$ 和 $B$ 中的点按照 $f$ 值从小到大排序之后使用双指针+前缀和可以做到 $O(\text{size}_x+\text{size}_y)$。

但是这样做过不了。

---

思考上面那个做法为什么慢。

原因是对于 $\text{size}$ 很大的子树每次循环是很慢的，但是 $\text{size}$ 很大的子树很少，所以考虑用根号分治优化上面那个东西。

注意到 $\text{size}&gt;\sqrt n$ 的子树最多 $\sqrt n$ 个，于是可以对于 $\text{size}&gt;\sqrt n$ 的子树之间的询问预处理。

那么没有预处理的询问就一定满足 $\min\{\text{size}_x,\text{size}_y\}\leq \sqrt n$，所以直接对那个 $\text{size}$ 较小的树暴力循环，然后对那个大一点的树二分即可。

时间复杂度：$O(n\sqrt n+q\sqrt n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template &lt;class T&gt;
bool read(T &amp;x) {
  x = 0;
  int f = 0;
  char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x);
  return 1;
}
template &lt;typename A, typename... B&gt;
bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }

char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) {
  *o1++ = x;
  if (o1 == o2) flush();
}
template &lt;class T&gt;
void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40];
  int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) {
  while (*x) putc(*x++);
}
void write(const char *x) {
  while (*x) putc(*x++);
}
template &lt;typename A, typename... B&gt;
void write(A x, B... y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
}  // namespace FASTIO
using FASTIO::putc;
using FASTIO::read;
using FASTIO::write;

const int kMaxN = 2e5 + 5, kMod = 1e9 + 7;

int n, m, q, k, b;
int f[kMaxN], g[kMaxN], bel[kMaxN], mx[kMaxN], sz[kMaxN], bf[kMaxN];
std::vector&lt;int&gt; ff[kMaxN], gg[kMaxN], idx[kMaxN], ss[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];
std::map&lt;std::pair&lt;int, int&gt;, int&gt; mp;

int fix(int x) { return (x % kMod + kMod) % kMod; }
int add(int x, int y) { return (x + y &gt;= kMod) ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x &lt; y) ? (x - y + kMod) : (x - y); }
int mul(int x, int y) { return 1ll * fix(x) * fix(y) % kMod; }
void inc(int x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }
void dec(int x, int y) { (x -= y) &lt; 0 ? (x += kMod) : x; }

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}

void dfs1(int u, int fa) {
  bel[u] = k;
  ++sz[k];
  idx[k].emplace_back(u);
  std::vector&lt;int&gt; pre(G[u].size()), suf(G[u].size());
  for (int i = 0; i &lt; static_cast&lt;int&gt;(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (v == fa) continue;
    dfs1(v, u);
    f[u] = std::max(f[u], f[v] + w);
  }
  for (int i = 0; i &lt; static_cast&lt;int&gt;(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (!i)
      pre[i] = f[v] + w;
    else
      pre[i] = std::max(pre[i - 1], f[v] + w);
  }
  for (int i = (int)G[u].size() - 1; ~i; --i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (i + 1 == G[u].size())
      suf[i] = f[v] + w;
    else
      suf[i] = std::max(suf[i + 1], f[v] + w);
  }
  for (int i = 0; i &lt; static_cast&lt;int&gt;(G[u].size()); ++i) {
    if (i) ff[u][i] = std::max(ff[u][i], pre[i - 1]);
    if (i + 1 &lt; G[u].size()) ff[u][i] = std::max(ff[u][i], suf[i + 1]);
  }
}

void dfs2(int u, int fa, int id, int ww) {
  mx[k] = std::max(mx[k], g[u]);
  if (fa) {
    for (int i = 0; i &lt; G[u].size(); ++i)
      gg[u][i] = std::max(gg[fa][id] + ww, ff[u][i]);
  }
  for (int i = 0; i &lt; static_cast&lt;int&gt;(G[u].size()); ++i) {
    int v = G[u][i].first, w = G[u][i].second;
    if (v == fa) continue;
    g[v] = std::max(f[v], gg[u][i] + w);
    dfs2(v, u, i, w);
  }
}

int solve_bf(int x, int y) {
  int sum = 0, mxx = std::max(mx[x], mx[y]);
  for (int i = sz[x] - 1, j = -1; ~i; --i) {
    for (; j + 1 &lt; sz[y] &amp;&amp; g[idx[x][i]] + g[idx[y][j + 1]] + 1 &lt;= mxx; ++j) {
    }
    sum += fix(mxx) * fix(j + 1) % kMod + fix(g[idx[x][i]] + 1) * fix(sz[y] - 1 - j) % kMod + sub(ss[y].back(), (~j ? ss[y][j] : 0));
    sum = fix(sum);
  }
  return fix(sum) * qpow(1ll * sz[x] * sz[y] % kMod) % kMod;
}

int solve_small(int x, int y) {
  int sum = 0, mxx = std::max(mx[x], mx[y]);
  if (sz[x] &gt; sz[y]) std::swap(x, y);
  for (int i = 0; i &lt; sz[x]; ++i) {
    int L = -1, R = sz[y], res = -1;
    for (; L + 1 &lt; R;) {
      int mid = (L + R) &gt;&gt; 1;
      if (g[idx[x][i]] + g[idx[y][mid]] + 1 &lt;= mxx)
        L = res = mid;
      else
        R = mid;
    }
    sum += fix(mxx) * fix(res + 1) % kMod + fix(g[idx[x][i]] + 1) * fix(sz[y] - 1 - res) % kMod + sub(ss[y].back(), (~res ? ss[y][res] : 0));
    sum = fix(sum);
  }
  return sum % kMod * qpow(1ll * sz[x] * sz[y] % kMod) % kMod;
}

void prework() {
  for (int i = 1; i &lt;= n; ++i) {
    if (!bel[i]) {
      ++k;
      dfs1(i, 0);
      g[i] = f[i], gg[i] = ff[i];
      dfs2(i, 0, -1, 0);
      std::sort(idx[k].begin(), idx[k].end(), [&amp;] (const int a, const int b) { return g[a] &lt; g[b]; });
      ss[k].resize(idx[k].size());
      ss[k][0] = g[idx[k][0]] % kMod;
      for (int i = 1; i &lt; idx[k].size(); ++i)
        ss[k][i] = (ss[k][i - 1] + g[idx[k][i]] % kMod) % kMod;
    }
  }
  for (int i = 1; i &lt;= k; ++i) {
    if (sz[i] &lt; b) continue;
    for (int j = i + 1; j &lt;= k; ++j) {
      if (sz[j] &lt; b) continue;
      mp[{i, j}] = mp[{j, i}] = solve_bf(i, j);
    }
  }
}

void dickdreamer() {
  read(n, m, q);
  b = sqrt(n) / 2;
  mp.clear();
  for (int i = 1; i &lt;= n; ++i) {
    G[i].clear(), ff[i].clear(), gg[i].clear(), idx[i].clear(), ss[i].clear();
    f[i] = g[i] = mx[i] = bel[i] = sz[i] = 0;
  }
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    read(u, v, w);
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    ff[u].emplace_back(0), ff[v].emplace_back(0);
    gg[u].emplace_back(0), gg[v].emplace_back(0);
  }
  prework();
  for (; q; --q) {
    int x, y, sum = 0;
    read(x, y);
    x = bel[x], y = bel[y];
    if (sz[x] &gt; sz[y]) std::swap(x, y);
    if (x == y) {
      write("-1\n");
    } else if (sz[x] &gt; b) {
      write(mp[{x, y}], '\n');
    } else {
      write(solve_small(x, y), '\n');
    }
  }
}

int32_t main() {
  freopen("blade.in", "r", stdin);
  freopen("blade.out", "w", stdout);
  // std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int sid, T = 1;
  read(sid, T);
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17734426.html</id>
    <title type="text">20230927 模拟赛 T1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-27T13:59:00Z</published>
    <updated>2023-09-27T13:59:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17734426.html" />
    <content type="text">## Description

给定一个长为 $n$ 的括号串，其中有一些是 `?`。给定常数 $a,b$。你要取出其中若干不交的子段，使得每一段都存在把 `?` 换成括号的方法使之成为合法括号串。长度为 $i$ 的段的收益 $ai+b$，一个方案的收益是所有段的收益和。求最大的收益。

$1\leq n\leq 5\times 10^5$，$|a|,|b|\leq 10^6$。

## Solution

考虑如何判断一个子串能变成合法括号串。

由于合法括号串的判定条件就是把 `(` 看成 $1$，`)` 看成 $-1$，那么所有的前缀和都 $\geq 0$ 且总和为 $0$。

但是这里有一些问号还没填。

注意到 `(` 是一定的，所以肯定要尽量让左括号放前面，右括号放后面。

那么可以得到一个判定条件就是把所有的 `?` 替换成 `(` 后所有前缀和都 $\geq 0$，至于总和可能大于 $0$，容易发现可以把后面的几个被替换成 `(` 调整成 `)` 即可。

但是这样是很难判断的。

考虑转化一下，设 $s_i$ 表示把字符串的 `?` 替换成 `(` 的前缀和，$t_i$ 表示把字符串的 `?` 替换成 ')' 后把 `(` 看成 $-1$，`)` 看成 $1$ 的后缀和。

容易发现两种替换方案的**调整**括号个数就是总问号的个数。

那么一个问号不可能被调整两次。

所以如果 $i$ 之前有替换方案 1 中调整的括号，由于 $s_i=t_{i+1}$，所以预处理出的 $t_{i+1}$ 就是替换方案 1 调整后 $i$ 的前缀和。

所以一个子串合法的条件就是所有 $s_i,t_i\geq 0$ 且长度为偶数。

线段树维护即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 5e5 + 5;

int n, A, B;
int a[kMaxN], s1[kMaxN], s2[kMaxN], l[kMaxN], r[kMaxN];
i64 f[kMaxN], g[kMaxN];
int lg[kMaxN], mi1[kMaxN][20], mi2[kMaxN][20];
std::string s;
std::vector&lt;int&gt; add[kMaxN], del[kMaxN];

void prework() {
  lg[0] = -1;
  for (int i = 1; i &lt;= n; ++i) {
    lg[i] = lg[i &gt;&gt; 1] + 1;
    mi1[i][0] = s1[i];
    mi2[i][0] = s2[i];
  }
  for (int i = 1; i &lt;= lg[n]; ++i) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) {
      mi1[j][i] = std::min(mi1[j][i - 1], mi1[j + (1 &lt;&lt; i - 1)][i - 1]);
      mi2[j][i] = std::min(mi2[j][i - 1], mi2[j + (1 &lt;&lt; i - 1)][i - 1]);
    }
  }
}

int query1(int l, int r) {
  int k = lg[r - l + 1];
  return std::min(mi1[l][k], mi1[r - (1 &lt;&lt; k) + 1][k]);
}

int query2(int l, int r) {
  int k = lg[r - l + 1];
  return std::min(mi2[l][k], mi2[r - (1 &lt;&lt; k) + 1][k]);
}

struct SGT {
  i64 mx[kMaxN &lt;&lt; 2];

  void pushup(int x) {
    mx[x] = std::max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
  }

  void update(int x, int l, int r, int ql, i64 v) {
    if (l == r) {
      mx[x] = v;
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update(x &lt;&lt; 1, l, mid, ql, v);
    else update(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  i64 query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql || ql &gt; qr) {
      return -1e9;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return mx[x];
    }
    int mid = (l + r) &gt;&gt; 1;
    return std::max(query(x &lt;&lt; 1, l, mid, ql, qr), query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt[2];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; A &gt;&gt; B &gt;&gt; s;
  s = " " + s;
  for (int i = 1; i &lt;= n; ++i)
    s1[i] = s1[i - 1] + ((s[i] == '(' || s[i] == '?') ? 1 : -1);
  for (int i = n; i; --i)
    s2[i] = s2[i + 1] + ((s[i] == ')' || s[i] == '?') ? 1 : -1);
  prework();
  for (int i = 0; i &lt;= n; ++i) {
    int L = i, R = n + 1, res = i;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (query1(i + 1, mid) &gt;= s1[i]) L = res = mid;
      else R = mid;
    }
    r[i] = res;
    if (res != i) add[i].emplace_back(i), del[r[i]].emplace_back(i);
  }
  for (int i = 1; i &lt;= n; ++i) {
    int L = -1, R = i, res = i;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (query2(mid + 1, i) &gt;= s2[i + 1]) R = res = mid;
      else L = mid;
    }
    l[i] = res;
  }
  memset(sgt[0].mx, 0xcf, sizeof(sgt[0].mx));
  memset(sgt[1].mx, 0xcf, sizeof(sgt[1].mx));
  for (int i = 0; i &lt;= n; ++i) {
    if (i &gt;= 2) f[i] = sgt[i &amp; 1].query(1, 0, n, l[i] - 1, i - 1) + (i64)A * i + B;
    if (f[i] &lt; 0) f[i] = 0;
    g[i] = std::max(i ? g[i - 1] : 0, f[i]);
    for (auto x : add[i]) sgt[i &amp; 1].update(1, 0, n, x, g[x] - (i64)A * x);
    for (auto x : del[i]) sgt[i &amp; 1].update(1, 0, n, x, -1e9);
  }
  std::cout &lt;&lt; std::max(g[n], g[n - 1]) &lt;&lt; '\n';
}

int32_t main() {
  freopen("bracket.in", "r", stdin);
  freopen("bracket.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17736585.html</id>
    <title type="text">20230927 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-28T14:46:00Z</published>
    <updated>2023-09-28T14:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17736585.html" />
    <content type="text">## Description

给出一个 $1,\dots,n+1$ 的排列 $v_{1,\dots,n+1}$，与两组权值 $a_{1,\dots,n}$、$b_{1,\dots,n}$。满足 $v_{n+1}=n+1$。

构造一张 $n+1$ 个点的 **有向图**：

+ 对于 $i=1,\dots,n$，从 $i$ 向 $i+1$ 连一条权值为 $a_i$ 的边；
+ 对于 $i=1,\dots,n$，找到最小的 $i &lt; j \le n+1$ 满足 $v_j&gt;v_i$，从 $i$ 向 $j$ 连一条权值为 $b_i$ 的边。

一条路径的权值为路径上边权的 **最大值**。特别地，若一条路径不包含任何边，则其权值为 $0$。

有 $q$ 次询问，每次询问给出 $x,y$（$x \le y$），求 $x$ 到 $y$ 的权值最小的路径的权值。

## Solution

设 $p_i$ 表示 $i$ 后面第一个 $v_j&gt;v_i$ 的 $j$。

首先如果 $i$ 要走到 $j$，且 $v_j&gt;v_i$，那么这条路径一定会经过 $p_i$。

原因是如果没经过 $p_i$，设 $x,y$ 满足存在 $x\to y$ 的边且 $x&lt;p_i&lt;y$，那么一定要满足 $p_x=y$，又因为 $v_x&lt;v_i&lt;v_{p_i}$，所以 $y$ 一定不为 $p_x$，就矛盾了。

有了这个引理，还是求不了最终的距离，考虑求出 $d_i$ 为 $i$ 到 $p_i$ 的距离。

如果是一步到 $p_i$，代价就是 $b_i$。否则就是 $i$ 先走到 $i+1$ 再走到 $p_i$。

会发现这样还是不好搞。

但是经过观察会发现 $v_{i+1}&lt;v_{p_i}$，所以设 $nxt_i$ 表示 $i$ 后面第一个 $p_j$ 与 $p_i$ 相同的 $j$。

会发现 $i&lt;i+1&lt;nxt_i$ 并且 $v_{i+1}&lt;v_{nxt_i}$，因为如果 $v_{i+1}&gt;v_{nxt_i}$，那么 $p_{nxt_i}&lt;p_{i+1}&lt;p_i$，这是不可能的。所以 $nxt_i$ 一定是 $i+1$ $p$ 数组的某个祖先。

所以 $i+1$ 走到 $p_i$ 一定会经过 $nxt_i$，这个直接倍增即可。

所以 $d_i=\min\{b_i,\max\{a_i,\text{dis}_{i+1\to nxt_i},d_{nxt_i}\}\}$。

---

然后考虑怎么求一条普通路径的答案。

先把询问离线下来，然后重新跑一边单调栈的过程，单调栈循环到询问的右端点时去处理这个询问。

假设是从 $i\to j$，且 $x$ 表示 $i\sim j$ 中 $v$ 值最大的下标。

那么由于 $x$ 为当前权值最大的点，所以 $i$ 往后跳一定会经过 $x$，因为要想逾越 $v_x$ 就要跳 $p$，但是它又是最大的，所以矛盾。

于是 $x$ 一定是当前 $x$ 的 $p$ 树祖先，那么 $i\to x$ 的权值就直接倍增处理即可。

然后考虑怎么求 $x\to j$ 的最小权值。

注意到当前单调栈只扫到了 $j$，那么设 $y_1,\dots,y_{t}$ 表示还没找到 $p$ 且 $\geq i$ 的所有点，那么 $y_1=x,y_t=j$。

所以 $x$ 下一步一定是到 $x+1$，然后发现如果 $y_2=x+1$ 是很好搞的。

否则 $x+1$ 一定找到了 $p$，所以 $x+1$ 往后走一定会经过 $p_{p\dots p_{x+1}}$ 直到没有 $p$ 了为止。

容易发现这么跳 $p$ 的终点就是 $y_2$，所以 $x\to y_2$ 的权值就是 $\min\{a_x,\text{dis}_{x+1\to y_2}\}$，这个是很好求的。

然后 $i\to j$ 的答案就是 $\min\{\text{dis}_{i\to x},\text{dis}_{y_1\to y_2},\dots,\text{dis}_{y_{t-1},j}\}$。

这个玩意可以用一个线段树维护。

时间复杂度：$O((n+m)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, q, S, top;
int v[kMaxN], a[kMaxN], b[kMaxN], ans[kMaxN];
int lg[kMaxN], mx[kMaxN][20], idx[kMaxN][20];
int p[kMaxN][20], d[kMaxN][20], nxt[kMaxN], stk[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; qq[kMaxN];

struct SGT {
  int mx[kMaxN &lt;&lt; 2];

  void pushup(int x) {
    mx[x] = std::max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
  }

  void update(int x, int l, int r, int ql, int v) {
    if (l == r) {
      mx[x] = v;
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update(x &lt;&lt; 1, l, mid, ql, v);
    else update(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  int query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql || ql &gt; qr) {
      return 0;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return mx[x];
    }
    int mid = (l + r) &gt;&gt; 1;
    return std::max(query(x &lt;&lt; 1, l, mid, ql, qr), query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

void st_prework() {
  lg[0] = -1;
  for (int i = 1; i &lt;= n + 1; ++i) {
    lg[i] = lg[i &gt;&gt; 1] + 1;
    mx[i][0] = v[i];
    idx[i][0] = i;
  }
  for (int i = 1; i &lt;= lg[n + 1]; ++i) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n + 1; ++j) {
      if (mx[j][i - 1] &gt;= mx[j + (1 &lt;&lt; i - 1)][i - 1]) {
        mx[j][i] = mx[j][i - 1], idx[j][i] = idx[j][i - 1];
      } else {
        mx[j][i] = mx[j + (1 &lt;&lt; i - 1)][i - 1], idx[j][i] = idx[j + (1 &lt;&lt; i - 1)][i - 1];
      }
    }
  }
}

int getpos(int l, int r) { // l -&gt; r 中 v 最大的编号
  int k = lg[r - l + 1];
  if (mx[l][k] &gt;= mx[r - (1 &lt;&lt; k) + 1][k]) return idx[l][k];
  else return idx[r - (1 &lt;&lt; k) + 1][k];
}

int getdis1(int x, int y) { // x -&gt; y 且 y 是 x 的 p 祖先
  if (!y || x == y) return 0;
  int ret = 0;
  for (int i = 19; ~i; --i) {
    if (p[x][i] &amp;&amp; p[x][i] &lt;= y) {
      ret = std::max(ret, d[x][i]);
      x = p[x][i];
    }
  }
  return ret;
}

int getdis2(int x, int y) { // x -&gt; y
  if (x == y) return 0;
  int mxid = getpos(x, y), dis1 = getdis1(x, mxid);
  int it = std::lower_bound(stk + 1, stk + 1 + top, mxid) - stk;
  return std::max(dis1, sgt.query(1, 1, n + 1, it + 1, top));
}

void prework() {
  st_prework();
  top = 0;
  for (int i = 1; i &lt;= n + 1; ++i) {
    int lst = 0;
    for (; top &amp;&amp; v[stk[top]] &lt; v[i]; --top) {
      if (lst) nxt[stk[top]] = lst;
      lst = stk[top];
      p[stk[top]][0] = i;
    }
    stk[++top] = i;
  }
  for (int i = 1; i &lt;= 19; ++i)
    for (int j = 1; j &lt;= n; ++j)
      p[j][i] = p[p[j][i - 1]][i - 1];
  for (int i = n; i; --i) {
    d[i][0] = std::min(b[i], std::max({a[i], getdis1(i + 1, nxt[i]), d[nxt[i]][0]}));
    for (int j = 1; j &lt;= 19; ++j)
      d[i][j] = std::max(d[i][j - 1], d[p[i][j - 1]][j - 1]);
  }
  top = 0;
  for (int i = 1; i &lt;= n + 1; ++i) {
    for (; top &amp;&amp; v[stk[top]] &lt; v[i]; --top) {}
    stk[++top] = i;
    if (top != 1)
      sgt.update(1, 1, n + 1, top, std::max(a[stk[top - 1]], getdis1(stk[top - 1] + 1, stk[top])));
    for (auto [x, id] : qq[i])
      ans[id] = getdis2(x, i);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; S;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; v[i];
  v[n + 1] = n + 1;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; b[i];
  for (int i = 1; i &lt;= q; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    qq[y].emplace_back(x, i);
  }
  prework();
  for (int i = 1; i &lt;= q; ++i)
    std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
  freopen("jump.in", "r", stdin);
  freopen("jump.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17737415.html</id>
    <title type="text">P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-09-29T13:46:00Z</published>
    <updated>2023-09-29T13:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17737415.html" />
    <content type="text">## Description

给你一个长为 $n$ 的**排列**，$m$ 次询问，每次查询一个区间的逆序对数，强制在线。

[link](https://www.luogu.com.cn/problem/P5046)

$1\leq n,m\leq 10^5$。

## Solution

考虑分块。

首先如果 $l,r$ 在同一个块内，可以对于每个块暴力二维前缀和预处理。

如果 $l,r$ 在不同的块内。

设 $bel[l]=x,bel[r]=y$。

首先考虑 $x+1\sim y-1$ 块内的贡献，这个显然可以预处理。

然后是 $l\sim R_x$ 和 $L_y\sim r$ 的块内贡献，这个可以预处理 $A_i$ 表示 $i$ 到 $i$  所在块的末尾这些数的逆序对个数，$B_i$ 表示 $i$ 到这个块开头的逆序对数。

这两个还是可以预处理。

然后就是 $x+1\sim y-1$ 块之间的贡献，维护 $f_{i,j}$ 表示前 $i$ 个块到和前 $j$ 个块的逆序对数。

这个显然可以先枚举 $i$ 块，维护一个值域数组，然后暴力枚举其他的块统计答案，最后做个二维前缀和即可。

注意到这个玩意是没有顺序的，所以统计答案时要除以 $2$。

---

随后是 $[l,R_x],[L_y,r]$ 到 $[x+1,y-1]$ 块的贡献。

这个可以预处理 $g_{i,j}$ 表示前 $i$ 个块到和前 $j$ 个**数**的逆序对数，同样可以二维前缀和搞。

容易发现这个东西是不要除以 $2$ 的。

---

最后是 $[l,R_x]$ 和 $[L_y,r]$ 之间的贡献。

这个东西考虑把 $[l,R_x]$ 和 $[L_y,r]$ 都 sort 一遍然后跑双指针。

但这样就带 $\log$ 了。

解决方案是初始时对于每个块维护一个 sort 后的 pair 数组，第一维是权值，第二维是下标。

然后从前到后枚举 $x$ 和 $y$ 块的 pair 数组，如果下标在 $[l,r]$ 里就把权值加到新数组里即可。

时间复杂度：$O((n+q)\sqrt n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 1e5 + 5, kMaxB = 320;

int n, m, bl, tot;
int a[kMaxN], bel[kMaxN], L[kMaxB], R[kMaxB], sz[kMaxB], suf[kMaxN], cnt5[kMaxB][kMaxB][kMaxB];
std::pair&lt;int, int&gt; b[kMaxN];
i64 cnt1[kMaxB], cnt2[kMaxB][kMaxB], cnt3[kMaxN], cnt4[kMaxN], cnt6[kMaxB][kMaxN];

/*
  cnt1[i] : 前 i 个块内部的逆序对数量和
  cnt2[i][j] : 前 i 个块跟前 j 个块的逆序对数量和
  cnt3[i] : i 到 i 所在块结尾这些数的逆序对数量
  cnt4[i] : i 到 i 所在块开头这些数的逆序对数量
  cnt5[i][j][k] : 第 i 个块前 j 个数到前 k 个数的逆序对数量
  cnt6[i][j] : 前 i 个块跟前 j 个数的逆序对数量和
*/

struct BIT {
  int c[kMaxN];

  void upd(int x, int v) {
    for (; x &lt;= n; x += x &amp; -x)
      c[x] += v;
  }

  int qry(int x) {
    int ret = 0;
    for (; x; x -= x &amp; -x)
      ret += c[x];
    return ret;
  }
  int qry(int l, int r) { return qry(r) - qry(l - 1); }
} bit;

i64 brute_force(int *a, int l1, int r1, int *b, int l2, int r2) {
  i64 ret = 0;
  int p = l2 - 1;
  for (int i = l1; i &lt;= r1; ++i) {
    for (; p &lt; r2 &amp;&amp; b[p + 1] &lt; a[i]; ++p) {}
    ret += p - l2 + 1;
  }
  return ret;
}

void prework() {
  bl = sqrt(n), tot = (n - 1) / bl + 1;
  for (int i = 1; i &lt;= n; ++i)
    b[i] = {a[i], i};
  for (int i = 1; i &lt;= tot; ++i) {
    L[i] = R[i - 1] + 1, R[i] = std::min(i * bl, n);
    std::sort(b + L[i], b + R[i] + 1);
    for (int j = L[i]; j &lt;= R[i]; ++j)
      bel[j] = i;
  }
  for (int i = 1; i &lt;= tot; ++i) {
    cnt1[i] = cnt1[i - 1];
    for (int j = L[i]; j &lt;= R[i]; ++j)
      for (int k = j + 1; k &lt;= R[i]; ++k)
        if (a[j] &gt; a[k])
          ++cnt1[i], ++cnt5[i][j - L[i] + 1][k - L[i] + 1];
    for (int j = 1; j &lt;= bl; ++j)
      for (int k = 1; k &lt;= bl; ++k)
        cnt5[i][j][k] += cnt5[i][j - 1][k] + cnt5[i][j][k - 1] - cnt5[i][j - 1][k - 1];

    for (int j = R[i]; j &gt;= L[i]; --j) {
      if (j &lt; R[i]) cnt3[j] = cnt3[j + 1] + bit.qry(a[j] - 1);
      bit.upd(a[j], 1);
    }
    for (int j = L[i]; j &lt;= R[i]; ++j)
      bit.upd(a[j], -1);
    for (int j = L[i]; j &lt;= R[i]; ++j) {
      if (j &gt; L[i]) cnt4[j] = cnt4[j - 1] + bit.qry(a[j] + 1, n);
      bit.upd(a[j], 1);
    }
    for (int j = L[i]; j &lt;= R[i]; ++j)
      bit.upd(a[j], -1);
  
    for (int j = L[i]; j &lt;= R[i]; ++j)
      ++suf[a[j]];
    for (int j = n; j; --j)
      suf[j] += suf[j + 1];
    for (int j = 1; j &lt;= n; ++j) {
      if (bel[j] &gt; i) cnt2[i][bel[j]] += suf[a[j] + 1], cnt6[i][j] += suf[a[j] + 1];
      else if (bel[j] &lt; i) cnt2[i][bel[j]] += suf[1] - suf[a[j]], cnt6[i][j] += suf[1] - suf[a[j]];
    }
    std::fill_n(suf + 1, n, 0);
  }
  for (int i = 1; i &lt;= tot; ++i)
    for (int j = 1; j &lt;= tot; ++j)
      cnt2[i][j] += cnt2[i - 1][j] + cnt2[i][j - 1] - cnt2[i - 1][j - 1];
  for (int i = 1; i &lt;= tot; ++i)
    for (int j = 1; j &lt;= n; ++j)
      cnt6[i][j] += cnt6[i - 1][j] + cnt6[i][j - 1] - cnt6[i - 1][j - 1];
}

i64 query(int l, int r, int cs) {
  static int tmpa[kMaxN], tmpb[kMaxN];
  int x = bel[l], y = bel[r];
  if (x == y) {
    int pl = l - L[x] + 1, pr = r - L[x] + 1;
    return cnt5[x][pr][pr] - cnt5[x][pl - 1][pr] - cnt5[x][pr][pl - 1] + cnt5[x][pl - 1][pl - 1];
  } else {
    i64 ret = 0;
    ret += cnt3[l] + cnt4[r] + cnt1[y - 1] - cnt1[x];
    ret += ((cnt2[y - 1][y - 1] - cnt2[x][y - 1]) - (cnt2[y - 1][x] - cnt2[x][x])) / 2;
    ret += (cnt6[y - 1][r] - cnt6[x][r]) - (cnt6[y - 1][L[y] - 1] - cnt6[x][L[y] - 1]);
    ret += (cnt6[y - 1][R[x]] - cnt6[x][R[x]]) - (cnt6[y - 1][l - 1] - cnt6[x][l - 1]);
    int ca = 0, cb = 0;
    for (int i = L[x]; i &lt;= R[x]; ++i)
      if (b[i].second &gt;= l &amp;&amp; b[i].second &lt;= R[x])
        tmpa[++ca] = b[i].first;
    for (int i = L[y]; i &lt;= R[y]; ++i)
      if (b[i].second &gt;= L[y] &amp;&amp; b[i].second &lt;= r)
        tmpb[++cb] = b[i].first;
    ret += brute_force(tmpa, 1, ca, tmpb, 1, cb);
    return ret;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  prework();
  i64 lastans = 0;
  for (int i = 1; i &lt;= m; ++i) {
    i64 l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    l ^= lastans, r ^= lastans;
    std::cout &lt;&lt; (lastans = query(l, r, i)) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17739681.html</id>
    <title type="text">后缀数组学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-01T23:37:00Z</published>
    <updated>2023-10-01T23:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17739681.html" />
    <content type="text">- ### 基数排序

利用桶的单调性，从低位到高位依次将整数放到对应数位的桶中。

- ### 后缀数组

 定义：对于字符串 $s$，定义 $sa[i]$ 表示 $s$ 的 $n$ 个后缀按字典序排序后的第 $i$ 个后缀在 $s$ 中的**下标**，$rk[i]$ 表示从 $s_i$ 开始的后缀在**后缀数组**中的下标。

- ### 倍增求 $sa$：

不妨设 $sa_{w,i}$ 表示只取每个后缀的前 $w$ 个字符排序后第 $i$ 个后缀在 $s$ 中的下标。

考虑通过 $sa_w$ 求出 $sa_{2w}$。

容易发现如果 $rk_{w,i}&lt;rk_{w,j}$ 那么 $s[i,\dots,i+w-1]$ 一定小于 $s[j,\dots,j+w-1]$。

所以可以把每个长度为 $2w$ 的子串拆成两个长度为 $w$ 的子串。

那么判断两个长度为 $2w$ 的子串 $s[i,\dots,i+2w-1]$ 和 $s[j,\dots,j+2w-1]$ 的字典序就只要判断 $rk_{w,i},rk_{w,i+w},rk_{w,j},rk_{w,j+w}$ 之间的关系。

如果 $i$ 比 $j$ 小，那么 $rk_{w,i}&lt;rk_{w,j}$ 或者 $rk_{w,i}=rk_{w,j}$ 并且 $rk_{w,i+w}&lt;rk_{w,j+w}$。

所以可以直接双关键字排序。

时间复杂度：$O(n\log^2 n)$。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

int n;
int sa[kMaxN &lt;&lt; 2], rk[kMaxN &lt;&lt; 2], nrk[kMaxN &lt;&lt; 2];
std::string s;

void dickdreamer() {
  std::cin &gt;&gt; s;
  n = s.size();
  s = " " + s;
  for (int i = 1; i &lt;= n; ++i) {
    sa[i] = i;
    rk[i] = s[i];
  }
  for (int w = 1; w &lt;= n; w &lt;&lt;= 1) {
    auto cmp = [&amp;] (const int x, const int y) {
      return rk[x] == rk[y] ? rk[x + w] &lt; rk[y + w] : rk[x] &lt; rk[y];
    };
    std::sort(sa + 1, sa + 1 + n, cmp);
    int c = 0;
    for (int i = 1; i &lt;= n; ++i)
      nrk[sa[i]] = (rk[sa[i]] == rk[sa[i - 1]] &amp;&amp; rk[sa[i] + w] == rk[sa[i - 1] + w] ? c : ++c);
    for (int i = 1; i &lt;= n; ++i)
      rk[i] = nrk[i];
  }
  for (int i = 1; i &lt;= n; ++i)
    std::cout &lt;&lt; sa[i] &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

- ### 优化

容易发现像上面那样求 $rk$，每个 $rk$ 的值域是 $[1,n]$，所以直接先对第二关键字排序，再对第一关键字排序即可。

时间复杂度：$O(n\log n)$。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
void suffix_sort(std::string s, int *sa, int *rk) {
  static int cnt[kMaxN], ork[kMaxN &lt;&lt; 1], id[kMaxN];
  memset(cnt, 0, sizeof(cnt));
  int n = static_cast&lt;int&gt;(s.size()) - 1;
  for (int i = 1; i &lt;= n; ++i) {
    rk[i] = s[i];
    ++cnt[rk[i]];
  }
  for (int i = 1; i &lt;= 128; ++i)
    cnt[i] += cnt[i - 1];
  for (int i = n; i; --i)
    sa[cnt[rk[i]]--] = i;
  for (int i = 1; i &lt;= n; ++i)
    ork[i] = rk[i];
  int m = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (ork[sa[i]] == ork[sa[i - 1]]) {
      rk[sa[i]] = m;
    } else {
      rk[sa[i]] = ++m;
    }
  }
  for (int w = 1; w &lt; n; w &lt;&lt;= 1) {
    memset(cnt, 0, sizeof(cnt));
    for (int i = 1; i &lt;= n; ++i)
      id[i] = sa[i];
    for (int i = 1; i &lt;= n; ++i)
      ++cnt[rk[id[i] + w]];
    for (int i = 1; i &lt;= m; ++i)
      cnt[i] += cnt[i - 1];
    for (int i = n; i; --i)
      sa[cnt[rk[id[i] + w]]--] = id[i];

    memset(cnt, 0, sizeof(cnt));
    for (int i = 1; i &lt;= n; ++i)
      id[i] = sa[i];
    for (int i = 1; i &lt;= n; ++i)
      ++cnt[rk[id[i]]];
    for (int i = 1; i &lt;= m; ++i)
      cnt[i] += cnt[i - 1];
    for (int i = n; i; --i)
      sa[cnt[rk[id[i]]]--] = id[i];
    
    for (int i = 1; i &lt;= n; ++i)
      ork[i] = rk[i];
    m = 0;
    for (int i = 1; i &lt;= n; ++i) {
      if (ork[sa[i]] == ork[sa[i - 1]] &amp;&amp; ork[sa[i] + w] == ork[sa[i - 1] + w]) {
        rk[sa[i]] = m;
      } else {
        rk[sa[i]] = ++m;
      }
    }
  }
}
```
&lt;/details&gt;

但是这么做常数很大，并且实测还没直接 sort 快，因为做两次基数排序是很慢的。

注意到第一次排序相当于把 $i+w&gt;n$ 的 $i$ 放前面，并且把其他的 $i$ 按照 $rk[i+w]$ 的顺序排序。

又因为原来的 $sa$ 数组就已经按照 $rk$ 排好序了，所以直接从前往后扫 $sa$ 数组，如果 $sa[i]&gt;w$ 就把 $sa[i]-w$ 放到新数组中即可。

还有个小优化是如果当前的 $rk$ 总共出现 $n$ 次就说明已经排序完成，那么 break 就可以了。

这样做就比直接 sort 要快很多了。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
void getsa(std::string s, int *sa, int *rk) {
  static int cnt[kMaxN], ork[kMaxN &lt;&lt; 1], id[kMaxN];
  memset(cnt, 0, sizeof(cnt));
  int n = static_cast&lt;int&gt;(s.size()) - 1, m = 0;
  for (int i = 1; i &lt;= n; ++i) {
    rk[i] = s[i];
    ++cnt[rk[i]];
  }
  for (int i = 1; i &lt;= 128; ++i)
    cnt[i] += cnt[i - 1];
  for (int i = n; i; --i)
    sa[cnt[rk[i]]--] = i;
  std::copy_n(rk + 1, n, ork + 1);
  for (int i = 1; i &lt;= n; ++i) {
    if (ork[sa[i]] == ork[sa[i - 1]]) {
      rk[sa[i]] = m;
    } else {
      rk[sa[i]] = ++m;
    }
  }
  for (int w = 1; m &lt; n; w &lt;&lt;= 1) {
    int p = 0;
    for (int i = n - w + 1; i &lt;= n; ++i)
      id[++p] = i;
    for (int i = 1; i &lt;= n; ++i)
      if (sa[i] &gt; w)
        id[++p] = sa[i] - w;
    std::fill_n(cnt + 1, n, 0);
    for (int i = 1; i &lt;= n; ++i)
      ++cnt[rk[id[i]]];
    for (int i = 1; i &lt;= m; ++i)
      cnt[i] += cnt[i - 1];
    for (int i = n; i; --i)
      sa[cnt[rk[id[i]]]--] = id[i];
    
    m = 0;
    std::copy_n(rk + 1, n, ork + 1);
    for (int i = 1; i &lt;= n; ++i) {
      if (ork[sa[i]] == ork[sa[i - 1]] &amp;&amp; ork[sa[i] + w] == ork[sa[i - 1] + w]) {
        rk[sa[i]] = m;
      } else {
        rk[sa[i]] = ++m;
      }
    }
  }
}
```
&lt;/details&gt;

- ### $height$ 数组

定义：$sa[i-1]$ 和 $sa[i]$ 的最长公共前缀长度。

- ### 求 $height$

引理：$height[rk[i]]\geq height[rk[i-1]]-1$。

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

$height[rk[i]]$ 就是 $s_i$ 与 $sa$ 中 $i$ 前面的后缀的 LCP，$height[rk[i-1]]$ 是 $s_{i-1}$ 与 $sa$ 中 $i-1$ 前面的后缀的 LCP。

如果 $height[rk[i-1]]=0$，那么显然成立。

如果 $height[rk[i-1]]&gt;0$，那么 $i-1$ 和前面的后缀第一位一定相同，而第二位后的 LCP 就是 $height[rk[i-1]]-1$。

又因为 $i-1$ 在 $sa$ 前面的那个后缀删掉最前面的字符还是一个后缀，所以 $i$ 与其它后缀的最大 LCP $\geq height[rk[i-1]]-1$，感性理解一下这是对的。

&lt;/details&gt;

于是按照这个引理求就可以做到 $O(n)$。

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```
void getheight(std::string s, int *height) {
  int n = static_cast&lt;int&gt;(s.size()) - 1;
  for (int i = 1, p = 0; i &lt;= n; ++i) {
    if (p) --p;
    for (; i + p &lt;= n &amp;&amp; sa[rk[i] - 1] + p &lt;= n &amp;&amp; s[i + p] == s[sa[rk[i] - 1] + p]; ++p) {}
    height[rk[i]] = p;
  }
}
```
&lt;/details&gt;

- ### 一些应用

1. 一个长度为 $n$ 的本质不同子串数是 $\dfrac{n(n+1)}{2}-\sum\limits_{i=2}^{n}{height[i]}$。

2. $sa[i]$ 和 $sa[j]$ 的 LCP 是 $\min\limits_{k=i+1}^{j}{height[k]}$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17742848.html</id>
    <title type="text">P9019 [USACO23JAN] Tractor Paths P 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-04T14:22:00Z</published>
    <updated>2023-10-04T14:22:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17742848.html" />
    <content type="text">## Description

有 $n$ 个区间，第 $i$ 个区间为 $[l_i,r_i]$。保证 $l_1&lt;l_2&lt;\cdots&lt;l_n$ 且 $r_1&lt;r_2&lt;\cdots&lt;r_n$。其中一部分区间是特殊的，输入会给定。

如果第 $i$ 个区间和第 $j$ 个区间相交，那么 $i,j$ 之间有一条边。保证 $1,n$ 联通。 

给定 $Q$ 组询问，每次给定 $a,b$ 满足 $1\le a &lt; b\le n$，你需要回答 $a$ 到 $b$ 至少要经过多少条边，以及有多少个特殊区间对应的点，使得这个点可能在 $a$ 到 $b$ 的最短路径上。

$n,Q\le 2\times 10^5$。

## Solution

显然一个区间肯定是尽量跳能跳的最远的区间，那么设 $nxt_{i}$ 表示区间 $i$ 能跳的最远的区间，第一问就可以直接倍增求了。

第二问实际上是求：

$$
\sum_{i=a}^{b}{a_i\times [dis(a,i)+dis(i,b)=dis(a,b)]}
$$

设 $dis(a,b)=len$，钦定 $dis(a,i)=x,dis(i,b)=len-x$，还是不好做。

容易发现 $\forall i\in[a,b],dis(a,i)+dis(i,b)\geq dis(a,b)$，所以只要满足 $dis(a,i)\leq x,dis(i,b)\leq len-x$ 即可。

如果设 $L_{i,j}$ 表示 $i$ 往左跳 $2^j$ 步到达的点，$R_{i,j}$ 表示 $i$ 往右跳 $2^j$ 步到达的点，那么满足条件的 $i$ 要满足 $i\in[L_{b,len-x},R_{a,x}]$，答案就是：$\sum\limits_{i=1}^{len-1}{cnt(L_{b,len-x},R_{a,x})}$

考虑设 $sum_i$ 表示前 $i$ 个区间的特殊区间的个数，$sl_{i,j}=\sum\limits_{k=i-2^j}^{i-1}{sum_{k-1}},sr_{i,j}=\sum\limits_{k=i+1}^{i+2^j}{sum_k}$。

预处理后只要在询问里面倍增即可。

时间复杂度：$O((n+q)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, q;
int a[kMaxN], l[kMaxN], r[kMaxN], sum[kMaxN];
int nxt[kMaxN][20], pre[kMaxN][20], sumn[kMaxN][20], sump[kMaxN][20];

int getdis(int s, int t) {
  if (s == t) return 0;
  int ret = 1;
  for (int i = 19; ~i; --i)
    if (nxt[s][i] &lt; t)
      s = nxt[s][i], ret += (1 &lt;&lt; i);
  return ret;
}

void dickdreamer() {
  std::string str1, str2;
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; str1 &gt;&gt; str2;
  int ccl = 0, ccr = 0;
  for (int i = 1; i &lt;= 2 * n; ++i) {
    if (str1[i - 1] == 'L') {
      l[++ccl] = i;
    } else {
      r[++ccr] = i;
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    a[i] = (str2[i - 1] == '1');
    sum[i] = sum[i - 1] + a[i];
  }
  for (int i = 1; i &lt;= n; ++i) {
    int L = i, R = n + 1, res = i;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (l[mid] &lt;= r[i]) L = res = mid;
      else R = mid;
    }
    nxt[i][0] = res;
    sumn[i][0] = sum[res];
    L = 0, R = i, res = i;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (r[mid] &gt;= l[i]) R = res = mid;
      else L = mid;
    }
    pre[i][0] = res;
    sump[i][0] = sum[res - 1];
  }
  for (int i = 1; i &lt;= 19; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      nxt[j][i] = nxt[nxt[j][i - 1]][i - 1];
      pre[j][i] = pre[pre[j][i - 1]][i - 1];
      sumn[j][i] = sumn[j][i - 1] + sumn[nxt[j][i - 1]][i - 1];
      sump[j][i] = sump[j][i - 1] + sump[pre[j][i - 1]][i - 1];
    }
  }
  for (int cs = 1; cs &lt;= q; ++cs) {
    int s, t;
    std::cin &gt;&gt; s &gt;&gt; t;
    int mi = getdis(s, t), cnt = a[s] + a[t];
    for (int i = 19; ~i; --i)
      if ((mi - 1) &gt;&gt; i &amp; 1)
        cnt -= sump[t][i], t = pre[t][i];
    for (int i = 19; ~i; --i)
      if ((mi - 1) &gt;&gt; i &amp; 1)
        cnt += sumn[s][i], s = nxt[s][i];
    std::cout &lt;&lt; mi &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17747398.html</id>
    <title type="text">CF1844E Great Grids 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-07T12:35:00Z</published>
    <updated>2023-10-07T12:35:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17747398.html" />
    <content type="text">## Description

定义一个矩形 $a$ 是好的，当且仅当其满足以下条件：

1. 矩形中每一个元素 $x$ 都为 $A,B,C$ 其中之一
2. 每一个 $2\times 2$ 的子矩形都必须包含三个不同的字符
3.  共用一条边的两个元素不相等

给定 $k$ 个限制条件，限制条件分为两类：

1. $(x,x+1,y,y+1)$，限制 $a[x,y]= a[x+1,y+1]$
2. $(x,x+1,y,y-1)$，限制 $a[x,y]= a[x+1,y-1]$ 

求满足所有条件的矩形是否存在。

[link](https://codeforces.com/problemset/problem/1844/E)

## Solution

先不考虑限制条件，思考一个 $2\times 2$ 的子矩形怎样才能包含三个不同的字符。

不妨设左上角为 $0$，那么这个子矩形一定长这样：

$$
\begin{bmatrix}
0\ \ 1\\
1\ \ 2
\end{bmatrix}

\begin{bmatrix}
0\ \ 2\\
2\ \ 1
\end{bmatrix}

\begin{bmatrix}
0\ \ 1\\
2\ \ 0
\end{bmatrix}

\begin{bmatrix}
0\ \ 2\\
1\ \ 0
\end{bmatrix}
$$

观察到左上角+右下角=右上角+左下角，所以 $a_{x,y}+a_{x+1,y+1}=a_{x,y+1}+a_{x+1,y}$，得到：$a_{x,y+1}-a_{x,y}=a_{x+1,y+1}-a_{x+1}{y}$ 且 $a_{x+1,y}-a_{x,y}=a_{x+1,y+1}-a_{x,y+1}$。

所以每行和每列的差都相等，设 $b_{x}=a_{x+1,y}-a_{x,y},c_{y}=a_{x,y+1}-a_{x,y}$。

由于相邻的不能相等，所以 $b_x$ 和 $c_y$ 只能为 $1,2$。

---

然后考虑那个限制条件。

对于限制 1，会发现 $a_{x,y}=a_{x+1,y},a_{x+1,y}\neq a_{x,y+1}\neq a_{x,y}$，所以 $b_x\neq c_y$。

对于限制 2，满足 $a_{x,y+1}=a_{x+1,y},a_{x,y}\neq a_{x+1,y+1}\neq a_{x,y+1}$，所以 $b_x= c_y$。

容易发现存在 $b,c$ 数组满足所有的条件，就是原题能构造出矩形的充要条件。

然后跑二分图染色即可。

时间复杂度：$O(n+m+k)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxK = 4e3 + 5;

int n, m, k;
bool fl;
int col[kMaxK], xx[kMaxK], yx[kMaxK], xy[kMaxK], yy[kMaxK];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxK];

void dfs(int u) {
  for (auto [v, w] : G[u]) {
    if (~col[v] &amp;&amp; col[v] != (col[u] ^ w)) {
      fl = 0;
    } else if (!~col[v]) {
      col[v] = col[u] ^ w;
      dfs(v);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= n + m; ++i) {
    G[i].clear();
    col[i] = -1;
  }
  for (int i = 1; i &lt;= k; ++i) {
    std::cin &gt;&gt; xx[i] &gt;&gt; yx[i] &gt;&gt; xy[i] &gt;&gt; yy[i];
    if (yy[i] == yx[i] - 1) {
      G[xx[i]].emplace_back(yy[i] + n, 0);
      G[yy[i] + n].emplace_back(xx[i], 0);
    } else {
      G[xx[i]].emplace_back(yx[i] + n, 1);
      G[yx[i] + n].emplace_back(xx[i], 1);
    }
  }
  fl = 1;
  for (int i = 1; i &lt;= n + m; ++i)
    if (!~col[i]) col[i] = 0, dfs(i);
  std::cout &lt;&lt; (fl ? "YES\n" : "NO\n");
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17753321.html</id>
    <title type="text">正睿 NOIP2023 20连 Day1 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-09T14:23:00Z</published>
    <updated>2023-10-09T14:23:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17753321.html" />
    <content type="text">## Description

有一面由 $n\times m$ 个格子组成的墙，每个格子要么是黑色，要么是白色。你每次将会进行这样的操作：等概率随机选择一个位置 $(x,y)$，和一个颜色 $c$（黑色或者白色），（$1 \leq x \leq n, 1 \leq y \leq m$, 任意 $(x,y,c)$ 的组合选择它的概率均为 $\frac {1} {2\times n\times m}$），然后将在 $(x,y)$ 左上角的所有格子的颜色涂成 $c$。

即将所有满足 $1 \leq x' \leq x, 1 \leq y' \leq y$ 的 $(x',y')$ 格子上的颜色涂成 $c$。

这次操作的代价为涂的格子的数量，即 $x\times y$。给定初始状态和终止状态，问期望要花费多少代价才能将墙面从初始状态涂成终止状态。

$n,m\leq 5$，对 $998244353$ 取模。

## Solution

首先有个显然的想法就是对所有的状态直接状压然后高斯消元解方程。

但是这样做时间复杂度是 $O(2^{3nm})$，过不了。

---

考虑优化这个状压方式，即找到一种等价类，使得同一等价类会转移到同一个等价类。

注意到如果一个点右下方有一个初始状态与结束状态不同，那么这个点当前的状态就没用了，因为右上方的一定会覆盖它。

设 $p_{i,j}$ 表示 $(i,j)$ 右下方是否**全部**满足当前状态 $=$ 结束状态。

容易发现 $p$ 值为 $1$ 的一定是一个在右下角的阶梯，那么状态数总共就只有 $C_{n+m}^{n}$ 了。

然后考虑转移，假设是操作 $(x,y,c)$，那么不在操作区域内的 $p$ 值一定不变。

对于一个 $(i,j)$ 满足 $1\leq i\leq x,1\leq j\leq y$，$p_{i,j}$ 操作后为 $1$ 当且仅当 $(i,j)-(x,y)$ 这个矩形的最终状态全为 $c$ 并且 $p_{x+1,j}$ 和 $p_{i,y+1}$ 都为 $1$。

容易发现这样做是对的。

然后对这个状态做高斯消元即可。

时间复杂度：$O\left((C_{n+m}^{n}) ^3\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxS = 505, kMod = 998244353;

int n, m, tot;
int a[10][10], b[10][10], pp[kMaxS][10], idx[kMaxS], w[kMaxS][kMaxS], res[kMaxS];
std::unordered_map&lt;int, int&gt; mp;

int fix(int x) { return (x % kMod + kMod) % kMod; }
int add(int x, int y) { return (x + y) &gt;= kMod ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x - y) &lt; 0 ? (x - y + kMod) : (x - y); }
void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }
void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? (x += kMod) : x; }

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1) ret = 1ll * ret * bs % kMod;
  return ret;
}

int gethash(int *p) {
  int ret = 0;
  for (int i = 1; i &lt;= n; ++i) ret = ret * (m + 1) + p[i];
  return ret;
}

void dfs(int x) {
  static int p[10] = {0};
  if (x == n + 1) {
    int val = gethash(p);
    mp[val] = ++tot;
    idx[tot] = val;
    return;
  }
  for (int i = p[x - 1]; i &lt;= m; ++i) {
    p[x] = i;
    dfs(x + 1);
  }
}

int getstate(int a[10][10]) {
  static int p[10];
  for (int i = n; i; --i) {
    p[i] = 0;
    for (int j = m; j; --j) {
      if (a[i][j] == b[i][j]) {
        p[i] = m - j + 1;
      } else {
        break;
      }
    }
    if (i &lt; n) p[i] = std::min(p[i], p[i + 1]);
  }
  return mp[gethash(p)];
}

int work(int s, int x, int y, int c) {
  static int p[10], pp[10][10];
  s = idx[s];
  for (int i = n; i; --i) {
    p[i] = s % (m + 1);
    s /= (m + 1);
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = m; j &gt;= m - p[i] + 1; --j) pp[i][j] = 1;
    for (int j = 1; j &lt;= m - p[i]; ++j) pp[i][j] = 0;
  }
  for (int i = 1; i &lt;= x; ++i) {
    for (int j = 1; j &lt;= y; ++j) {
      bool fl = 1;
      if (x &lt; n) fl &amp;= pp[x + 1][j];
      if (y &lt; m) fl &amp;= pp[i][y + 1];
      for (int xx = i; xx &lt;= x; ++xx)
        for (int yy = j; yy &lt;= y; ++yy)
          fl &amp;= (b[xx][yy] == c);
      pp[i][j] = fl;
    }
  }
  for (int i = n; i; --i) {
    p[i] = 0;
    for (int j = m; j; --j) {
      if (pp[i][j]) {
        p[i] = m - j + 1;
      } else {
        break;
      }
    }
    if (i &lt; n) p[i] = std::min(p[i], p[i + 1]);
  }
  return mp[gethash(p)];
}

void gauss() {
  for (int i = 1; i &lt;= tot; ++i) {
    if (!w[i][i]) {
      for (int j = i + 1; j &lt;= tot; ++j) {
        if (w[j][i]) {
          std::swap(w[i], w[j]);
          break;
        }
      }
    }
    for (int j = i + 1; j &lt;= tot; ++j) {
      int val = 1ll * w[j][i] * qpow(w[i][i]) % kMod;
      dec(w[j][0], 1ll * w[i][0] * val % kMod);
      for (int k = i; k &lt;= tot; ++k)
        dec(w[j][k], 1ll * w[i][k] * val % kMod);
    }
  }
  for (int i = tot; i; --i) {
    for (int j = i + 1; j &lt;= tot; ++j) {
      dec(w[i][0], 1ll * res[j] * w[i][j] % kMod);
    }
    res[i] = 1ll * w[i][0] * qpow(w[i][i]) % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) {
    std::string s;
    std::cin &gt;&gt; s;
    for (int j = 1; j &lt;= m; ++j)
      a[i][j] = (s[j - 1] == 'B');
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::string s;
    std::cin &gt;&gt; s;
    for (int j = 1; j &lt;= m; ++j)
      b[i][j] = (s[j - 1] == 'B');
  }
  dfs(1);
  int iv = qpow(2 * n * m);
  for (int i = 1; i &lt;= tot; ++i) {
    if (i == tot) {
      w[i][i] = 1;
    } else {
      w[i][i] = 1;
      for (int x = 1; x &lt;= n; ++x) {
        for (int y = 1; y &lt;= m; ++y) {
          for (int c = 0; c &lt;= 1; ++c) {
            int j = work(i, x, y, c);
            dec(w[i][j], iv);
            inc(w[i][0], 1ll * x * y * iv % kMod);
          }
        }
      }
    }
  }
  gauss();
  std::cout &lt;&lt; res[getstate(a)] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17760767.html</id>
    <title type="text">正睿 NOIP2023 20连 Day4 T3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-12T14:42:00Z</published>
    <updated>2023-10-12T14:42:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17760767.html" />
    <content type="text">## Description

称一个正整数对 $(a, b)$ 合法，当且仅当存在正整数 $k$ 和 $k$ 组正整数对 $(h_1, w_1), (h_2, w_2), \cdots, (h_k, w_k)$，使得：

- $\sum_{i = 1} ^ k h_iw_i = a$。
- $\sum_{i = 1} ^ k 2(h_i + w_i) = b$。

给定 $s, c$，求满足 $a \in [1, s], b \in [1, c]$ 的正整数对中有多少是合法的。

对于 $100\%$ 的数据，满足 $1 \le s \le 2 \times 10^5, 1 \le c \le 4 \times 10^5, 2 \mid c$。

## Solution

这里先把 $c$ 除以 $2$。

不妨设 $h_i\leq w_i$，易知 $h_i\leq \sqrt s$。

如果存在 $h_i=h_j$，那么 $(h_i,w_i),(h_i,w_j)$ 可以修改为 $(h_i,w_i+w_j-1),(1,h_i)$。

然后 $1$ 的情况也可以消，$(1,x),(1,y)$ 可以变为 $(1,x+y-1),(1,1)$，所以如果把 $(1,1)$ 删掉，对于每个 $h$，只有唯一的一个 $w$ 与之对应。

如果把 $(1,1)$ 加上，会发现 $2a-b$ 的值不会变，所以可设 $f_i$ 表示当前 $2a-b=i$ 的最小的 $b$。

然后枚举 $h,w$，可以得到转移方程：$f_i\leftarrow f_{i-(2hw-h-w)}+h+w$。

把底下那玩意拆开，$f_i\leftarrow f_{i+h-w(2h-1)}+h+w$。

这样就只要枚举 $h$，令 $g_i$ 表示 $j+h-w(2h-1)=i$ 的最小的 $f_j+w$，那么 $g_i=\min\{f_i,g_{i-(2h-1)}+1\}$。

所以 $f_i=g_{i+h}+h$。

然后统计答案就枚举那个 $2a-b$，不妨设为 $i$，$b$ 要满足 $2|(i+b)$ 且 $f_i\leq b\leq 2n-i$。

时间复杂度：$O(s\sqrt s)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m;
int f[kMaxN], g[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  m /= 2;
  memset(f, 0x3f, sizeof(f));
  for (int i = 1; i &lt;= n; ++i)
    f[i - 1] = i + 1;
  for (int h = 2; h * h &lt;= n; ++h) {
    std::swap(f, g);
    for (int i = 0; i &lt;= 2 * n; ++i)
      f[i] = g[i];
    g[0] = 0;
    for (int i = 0; i &lt;= 2 * n + h; ++i) {
      if (i &gt; 2 * n) g[i] = 1e9;
      if (i &gt;= 2 * h - 1) g[i] = std::min(g[i], g[i - (2 * h - 1)] + 1);
    }
    for (int i = 0; i &lt;= 2 * n; ++i)
      f[i] = std::min(f[i], g[i + h] + h);
  }
  int64_t ans = 0;
  for (int i = 0; i &lt;= 2 * n; ++i) {
    int l = f[i] + ((i + f[i]) &amp; 1), r = std::min(m, 2 * n - i);
    if (l &lt;= r) ans += (r - l) / 2 + 1;
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17775511.html</id>
    <title type="text">[AGC002F] Leftmost Ball 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-19T12:19:00Z</published>
    <updated>2023-10-19T12:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17775511.html" />
    <content type="text">## Description

给你 $n$ 种颜色的球，每种颜色的球有 $k$ 个，把这 $n\times k$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色（初始球不包含白色），求有多少种不同的颜色序列，答案对 $10^9+7$ 取模。

$1\leq n, k\leq 2000$。

## Solution

思考怎样的序列是满足条件的。

假设第 $i$ 个白球的位置为 $p_i$。

那么如果存在一个 $i$，使得 $[1,p_i-1]$ 中出现了 $\geq i$ 种彩球，那么这些球显然找不到它的最左边的白球，自然就不合法了。

否则把每种彩球**第一次**出现的位置排序后把白球顺次染成排序后的颜色即可还原序列。

然后就是计数了。

设 $f_{i,j}$ 表示当前放了 $i$ 个白球，$j$ **种**彩球的合法方案数。

考虑每次在当前没放球的最左边的位置放球。

如果这个位置放白球，那么 $f_{i+1,j}\leftarrow f_{i,j}$。

如果这个位置放彩球，首先要选择这个位置的颜色，为 $n-j$ 种，然后在剩余 $nk-j(k-1)-1$ 个位置放剩下的 $k-2$ 种彩球，方案数就是 $(n-j)\times C_{nk-j(k-1)-1}^{k-2}$，所以 $f_{i,j+1}\leftarrow f_{i,j}\times (n-j)\times C_{nk-j(k-1)-1}^{k-2}$。

---

容易发现这样转移是对的。

首先由于是按顺序放球，所以一定不会算重。然后由于每次放球时，它放的位置都是当前能放的最左边的，所以每次放白球时它左边的彩球数一定是确定的，就是当前所有的彩球数，所以只要 $j\leq i$ 就可以满足 $f_{i,j}$ 状态合法。

时间复杂度：$O(n^2+nk)$。

## Code

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e3 + 5, kMod = 1e9 + 7;

namespace Modular {
template&lt;class T&gt;
T qpow(T bs, T idx, T kMod) {
  bs %= kMod;
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}
int inv(int x, int kMod) {
  x %= kMod;
  if (!x) { std::cerr &lt;&lt; "inv error\n"; return 0; }
  return qpow(x, kMod - 2, kMod);
}
template&lt;class T, const T kMod&gt;
T add(T x, T y) {
  if (x + y &gt;= kMod) return x + y - kMod;
  else return x + y;
}

template&lt;class T, const T kMod&gt;
T sub(T x, T y) {
  if (x - y &lt; 0) return x - y + kMod;
  else return x - y;
}

template&lt;class T, const T kMod&gt;
struct Mint {
  T x;

  Mint() { x = 0; }
  template&lt;class _T&gt; Mint(_T _x) { x = _x; }

  friend Mint operator +(Mint m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator -(Mint m1, Mint m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator *(Mint m1, Mint m2) { return Mint(1ll * m1.x * m2.x % kMod); }
  friend Mint operator /(Mint m1, Mint m2) { return Mint(1ll * m1.x * inv(m2.x, kMod) % kMod); }
  Mint operator +=(Mint m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2.x); }
  Mint operator -=(Mint m2) { return x = Modular::sub&lt;T, kMod&gt;(x, m2.x); }
  Mint operator *=(Mint m2) { return x = 1ll * x * m2.x % kMod; }
  Mint operator /=(Mint m2) { return x = 1ll * x * inv(m2.x, kMod) % kMod; }

  template&lt;class _T&gt; friend Mint operator +(Mint m1, _T m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator -(Mint m1, _T m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator *(Mint m1, _T m2) { return Mint(1ll * m1.x * m2 % kMod); }
  template&lt;class _T&gt; friend Mint operator /(Mint m1, _T m2) { return Mint(1ll * m1.x * inv(m2, kMod) % kMod); }
  template&lt;class _T&gt; Mint operator +=(_T m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator -=(_T m2) { return x = Modular::sub&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator *=(_T m2) { return x = 1ll * x * m2 % kMod; }
  template&lt;class _T&gt; Mint operator /=(_T m2) { return x = 1ll * x * inv(m2, kMod) % kMod; }
  template&lt;class _T&gt; friend Mint operator +(_T m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1 % kMod, m2.x)); }
  template&lt;class _T&gt; friend Mint operator -(_T m1, Mint m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1 % kMod, m2)); }
  template&lt;class _T&gt; friend Mint operator *(_T m1, Mint m2) { return Mint(1ll * m1 * m2.x % kMod); }
  template&lt;class _T&gt; friend Mint operator /(_T m1, Mint m2) { return Mint(1ll * m1 * inv(m2.x, kMod) % kMod); }
  friend Mint operator -(Mint &amp;m1) { return Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator --(Mint &amp;m1) { return m1 = Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator ++(Mint &amp;m1) { return m1 = Mint(m1.x == (kMod - 1) ? 0 : (m1.x + 1)); }
  friend bool operator ==(Mint m1, Mint m2) { return m1.x == m2.x; }

  friend std::istream &amp;operator &gt;&gt;(std::istream &amp;is, Mint &amp;m) {
    int x;
    is &gt;&gt; x;
    m = Mint(x);
    return is;
  }
  friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;os, Mint m) {
    os &lt;&lt; m.x;
    return os;
  }
};
} // namespace Modular

using mint = Modular::Mint&lt;int, kMod&gt;;

int n, k;
mint f[kMaxN][kMaxN], fac[kMaxN * kMaxN], ifac[kMaxN * kMaxN], inv[kMaxN * kMaxN];

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= n * k; ++i) {
    inv[i] = (kMod - kMod / i) * inv[kMod % i];
    fac[i] = i * fac[i - 1];
    ifac[i] = inv[i] * ifac[i - 1];
  }
}

mint C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return fac[m] * ifac[n] * ifac[m - n];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  if (k == 1) { std::cout &lt;&lt; "1\n"; return; }
  prework();
  f[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= i; ++j) {
      f[i][j] = f[i - 1][j];
      if (j) f[i][j] += f[i][j - 1] * (n - j + 1) * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2);
    }
  }
  std::cout &lt;&lt; f[n][n] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17781279.html</id>
    <title type="text">P9755 [CSP-S 2023] 种树 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-22T14:19:00Z</published>
    <updated>2023-10-22T14:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17781279.html" />
    <content type="text">## Description

你是一个森林养护员，有一天，你接到了一个任务：在一片森林内的地块上种树，并养护至树木长到指定的高度。

森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。最开始，每片地块上都没有树木。

你的目标是：在每片地块上均种植一棵树木，并使得 $i$ 号地块上的树的高度生长到不低于 $a_i$ 米。

你每天可以选择一个未种树且**与某个已种树的地块直接邻接**（**即通过单条道路相连**）的地块，种一棵高度为 $0$ 米的树。如果所有地块均已种过树，则你当天不进行任何操作。特别地，第 $1$ 天你只能在 $1$ 号空地种树。

对每个地块而言，从该地块被种下树的当天开始，该地块上的树每天都会生长一定的高度。由于气候和土壤条件不同，在第 $x$ 天，$i$ 号地块上的树会长高 $\max(b_i + x \times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。

你想知道：最少需要多少天能够完成你的任务？

$1\leq n \leq 10^5，1 \leq a_i \leq 10^{18}, 1 \leq b_i \leq 10^9，0 \leq |c_i| \leq 10^9, 1 \leq u_i, v_i \leq n$。保证存在方案能在 $10^9$ 天内完成任务。

## Solution

考虑二分答案。

容易发现那个相邻块的限制就是每个点选的时间不早于它的所有祖先。

设 $t_i$ 表示第 $i$ 个人需要完成任务的最晚开始时间，这个同样可以二分求得。

然后思考怎样 check。

有一个想法是把 $t$ 从小到大排序，然后判断如果所有 $t_i$ 都有 $i\leq t_i$ 则合法，否则不合法。

但是这样做不能保证子孙在祖先之后。

---

容易发现 $t_i\leq \min_{j\in son(i)}\{t_j-1\}$，于是用一遍 dfs 把这个限制加上就会发现所有原始的 $t_i$ 都满足祖先 $&lt;$ 子孙。

这样再 sort 一遍就一定会满足原题相邻块的限制条件了。

时间复杂度：$O(n\log^2 V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n;
int a[kMaxN], b[kMaxN], c[kMaxN], t[kMaxN], buc[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

__int128 getval(int t, int b, int c) {
  int lim;
  if (c &gt;= 0) lim = t;
  else lim = std::min(t, (b - 1) / (-c));
  return b * lim + (__int128)lim * (lim + 1) / 2 * c + t - lim;
}

bool chk(int l, int r, int a, int b, int c) {
  return getval(r, b, c) - getval(l - 1, b, c) &gt;= a;
}

void dfs(int u, int fa) {
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u);
    t[u] = std::min(t[u], t[v] - 1);
  }
}

bool check(int x) {
  static int tt[kMaxN];
  for (int i = 1; i &lt;= n; ++i) {
    int L = 0, R = x + 1, res = -1e9;
    if (!chk(1, x, a[i], b[i], c[i])) return 0;
    __int128 tot = getval(x, b[i], c[i]);
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (tot - getval(mid - 1, b[i], c[i]) &gt;= a[i]) L = res = mid;
      else R = mid;
    }
    t[i] = res;
  }
  dfs(1, 0);
  int m1 = 0, m2 = n;
  for (int i = 1; i &lt;= n; ++i) {
    if (t[i] &lt;= 0) {
      return 0;
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    if (t[i] &gt; n) tt[m2--] = t[i];
    else ++buc[t[i]];
  }
  for (int i = 1; i &lt;= n; ++i)
    for (; buc[i]; --buc[i])
      tt[++m1] = i;
  for (int i = 1; i &lt;= n; ++i)
    t[i] = tt[i];
  // std::sort(t + 1, t + 1 + n);
  for (int i = 1; i &lt;= n; ++i)
    if (t[i] &lt; i)
      return 0;
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  int L = 0, R = 1e9 + 1, res = 1e9;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (check(mid)) R = res = mid;
    else L = mid;
  }
  std::cout &lt;&lt; res &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17781303.html</id>
    <title type="text">正睿 2023 noip 10 连 Day7 T3-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-22T14:38:00Z</published>
    <updated>2023-10-22T14:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17781303.html" />
    <content type="text">## Description

给定一个 $n\times m$ 的网格以及 $q$ 个矩形。记第 $x$ 行第 $y$ 列的格子为 $(x,y)$。

考虑一个 $n\times m$ 的有向无环图，点 $(x_1,y_1)$ 向 $(x_2,y_2)$ 有连边当且仅当 $x_1&lt;x_2,y_1&lt;y_2$ 且存在一个矩形同时包含 $(x_1,y_1)$ 与 $(x_2,y_2)$。定义矩形 $(x_1,y_1,x_2,y_2)$ 包含了所有 $x\in [x_1,x_2],y\in [y_1,y_2]$ 的 $(x,y)$。

定义路径长度为路径包含的节点个数。请求出该图中的最长路径，以及长度最长的路径共有多少条。路径条数对 $10^9 + 7$ 取模。

保证 $1\leq T \leq 10^5,1\leq \sum nm \leq 1.2 \times 10^7,1\leq \sum q \leq 5\times 10^5$。

## Solution

设 $f_{i,j}$ 表示结尾为 $(i,j)$ 的最长路径长度，$g_{i,j}$ 表示 $(i,j)$ 最长路径的方案数。

容易发现 $(i,j)$ 的上一步一定是 $(i-1,?)$ 或者 $(?,j-1)$。

因为如果上一步的 $(x,y)$ 满足 $x\leq i-2,y\leq j-2$ 的话，他们中间一定还可以加点，就不是最优的了。

然后考虑 $f_{i-1,x}$ 的转移。容易发现 $x$ 的取值一定是一段以 $j-1$ 结尾的区间。

不妨设区间为 $[lx_{i,j},j-1]$。

容易发现 $lx_{i,j}$ 单调不减，所以可以单调队列优化 dp。

---

然后思考怎么求出 $lx_{i,j}$。

对于一个矩形 $(x_1,y_1,x_2,y_2)$ 对 $lx$ 造成的影响就是对 $(x_1+1,y_1,x_2,y_2)$ 这个矩形的 $lx$ 与 $y_1$ 取 min。

容易发现这个等价于对 $(x_1+1,1,x_2,y_2)$ 取 min。

于是对于每个 $y$ 维护一个吉司机线段树，然后对所有的 $x$ 取后缀 min 即可。

时间复杂度：$O(nm+q\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }
} // namespace FASTIO
using FASTIO::read;

const int kMaxN = 2e3 + 5, kMod = 1e9 + 7;

int n, m, q;
int f[kMaxN][kMaxN], g[kMaxN][kMaxN], lx[kMaxN][kMaxN], ly[kMaxN][kMaxN];
int qx[kMaxN][kMaxN], qy[kMaxN][kMaxN], hx[kMaxN], tx[kMaxN], hy[kMaxN], ty[kMaxN];
int cntx[kMaxN][kMaxN], cnty[kMaxN][kMaxN];

struct SGT {
  int mxx, mx[kMaxN &lt;&lt; 2], se[kMaxN &lt;&lt; 2], tag[kMaxN &lt;&lt; 2], idx[kMaxN];
  bool have[kMaxN &lt;&lt; 2];

  void pushup(int x) {
    if (mx[x &lt;&lt; 1] == mx[x &lt;&lt; 1 | 1]) {
      mx[x] = mx[x &lt;&lt; 1], se[x] = std::max(se[x &lt;&lt; 1], se[x &lt;&lt; 1 | 1]);
    } else if (mx[x &lt;&lt; 1] &gt; mx[x &lt;&lt; 1 | 1]) {
      mx[x] = mx[x &lt;&lt; 1], se[x] = std::max(se[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
    } else {
      mx[x] = mx[x &lt;&lt; 1 | 1], se[x] = std::max(mx[x &lt;&lt; 1], se[x &lt;&lt; 1 | 1]);
    }
  }

  void addtag(int x, int v) {
    if (mx[x] &lt;= v) return;
    mx[x] = tag[x] = v;
  }

  void pushdown(int x) {
    if (!~tag[x]) return;
    addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
    tag[x] = -1;
  }

  void build(int x, int l, int r) {
    mx[x] = 1e9, se[x] = 0, tag[x] = -1, mxx = std::max(mxx, x);
    have[x] = (l != r);
    if (l == r) {
      idx[l] = x;
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) {
      return;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      if (v &gt;= mx[x]) return;
      else if (v &gt; se[x]) return addtag(x, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  void pushall() {
    for (int i = 1; i &lt;= mxx; ++i)
      if (have[i])
        pushdown(i);
    for (int i = mxx; i; --i)
      if (have[i])
        pushup(i);
  }

  int query(int x) { return mx[idx[x]]; }
} sx[kMaxN], sy[kMaxN];

void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }
void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? (x += kMod) : x; }

void solve() {
  for (int i = 0; i &lt;= n; ++i) {
    hx[i] = 1, tx[i] = 0;
    std::fill_n(cntx[i], std::max(n, m) + 1, 0);
  }
  for (int i = 0; i &lt;= m; ++i) {
    hy[i] = 1, ty[i] = 0;
    std::fill_n(cnty[i], std::max(n, m) + 1, 0);
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (i &gt; 1) { // qx
        if (j &gt; 1) {
          for (; hx[i - 1] &lt;= tx[i - 1] &amp;&amp; f[i - 1][qx[i - 1][tx[i - 1]]] &lt; f[i - 1][j - 1]; --tx[i - 1]) {
            dec(cntx[i - 1][f[i - 1][qx[i - 1][tx[i - 1]]]], g[i - 1][qx[i - 1][tx[i - 1]]]);
          }
          qx[i - 1][++tx[i - 1]] = j - 1;
          inc(cntx[i - 1][f[i - 1][j - 1]], g[i - 1][j - 1]);
        }
        for (; hx[i - 1] &lt;= tx[i - 1] &amp;&amp; qx[i - 1][hx[i - 1]] &lt; lx[i][j]; ++hx[i - 1]) {
          dec(cntx[i - 1][f[i - 1][qx[i - 1][hx[i - 1]]]], g[i - 1][qx[i - 1][hx[i - 1]]]);
        }
        if (hx[i - 1] &lt;= tx[i - 1]) {
          int mx = f[i - 1][qx[i - 1][hx[i - 1]]] + 1, cnt = cntx[i - 1][mx - 1];
          if (mx &gt; f[i][j]) {
            f[i][j] = mx, g[i][j] = cnt;
          } else if (mx == f[i][j]) {
            inc(g[i][j], cnt);
          }
        }
      }
      if (j &gt; 1) { // qy
        if (i &gt; 2) {
          for (; hy[j - 1] &lt;= ty[j - 1] &amp;&amp; f[qy[j - 1][ty[j - 1]]][j - 1] &lt; f[i - 2][j - 1]; --ty[j - 1]) {
            dec(cnty[j - 1][f[qy[j - 1][ty[j - 1]]][j - 1]], g[qy[j - 1][ty[j - 1]]][j - 1]);
          }
          qy[j - 1][++ty[j - 1]] = i - 2;
          inc(cnty[j - 1][f[i - 2][j - 1]], g[i - 2][j - 1]);
        }
        for (; hy[j - 1] &lt;= ty[j - 1] &amp;&amp; qy[j - 1][hy[j - 1]] &lt; ly[i][j]; ++hy[j - 1]) {
          dec(cnty[j - 1][f[qy[j - 1][hy[j - 1]]][j - 1]], g[qy[j - 1][hy[j - 1]]][j - 1]);
        }
        if (hy[j - 1] &lt;= ty[j - 1]) {
          int mx = f[qy[j - 1][hy[j - 1]]][j - 1] + 1, cnt = cnty[j - 1][mx - 1];
          if (mx &gt; f[i][j]) {
            f[i][j] = mx, g[i][j] = cnt;
          } else if (mx == f[i][j]) {
            inc(g[i][j], cnt);
          }
        }
      }
    }
  }
}

void dickdreamer() {
  read(n, m, q);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      f[i][j] = g[i][j] = 1;
      lx[i][j] = ly[i][j] = 1e9;
    }
  }
  for (int i = 1; i &lt;= m; ++i)
    sx[i].mxx = 0, sx[i].build(1, 1, n);
  for (int i = 1; i &lt;= n; ++i)
    sy[i].mxx = 0, sy[i].build(1, 1, m);
  for (int cs = 1; cs &lt;= q; ++cs) {
    int _x1, _y1, _x2, _y2;
    read(_x1, _y1, _x2, _y2);
    if (_x1 &lt; _x2) sx[_y2].update(1, 1, n, _x1 + 1, _x2, _y1);
    if (_y1 &lt; _y2) sy[_x2].update(1, 1, m, _y1 + 1, _y2, _x1);
  }
  for (int i = m; i; --i) {
    sx[i].pushall();
    for (int j = 1; j &lt;= n; ++j) {
      lx[j][i] = sx[i].query(j);
      if (i != m) lx[j][i] = std::min(lx[j][i], lx[j][i + 1]);
    }
  }
  for (int i = n; i; --i) {
    sy[i].pushall();
    for (int j = 1; j &lt;= m; ++j) {
      ly[i][j] = sy[i].query(j);
      if (i != n) ly[i][j] = std::min(ly[i][j], ly[i + 1][j]);
    }
  }
  solve();
  int mx = 0, cnt = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (f[i][j] &gt; mx) {
        mx = f[i][j], cnt = g[i][j];
      } else if (f[i][j] == mx) {
        cnt = (cnt + g[i][j]) % kMod;
      }
    }
  }
  std::cout &lt;&lt; mx &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::cout.tie(0);
  int T = 1;
  read(T);
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17794580.html</id>
    <title type="text">[ARC166D] Interval Counts 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-10-28T12:33:00Z</published>
    <updated>2023-10-28T12:33:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17794580.html" />
    <content type="text">## Description

给定正整数 $n$ 和长度为 $n$ 的序列 $x_i,y_i$，保证 $x_i$ 单调递增。你要构造 $m$ 个区间 $[L_i,R_i]$（$m$ 由你指定），使每个 $x_i$ 恰好被 $y_i$ 个区间包含。

最大化 $\min_{i=1}^m \{R_i-L_i\}$，并求该值。无穷输出 $-1$。

$n\leq 2\times 10^5,1\leq x_i,y_i\leq 10^9$。

## Solution

考虑贪心。

假设当前已经满足了 $1\sim i-1$ 的限制，维护一个队列表示当前还没确定右端点的所有左端点。

如果 $y_i=y_{i-1}$，那么只要让原来右端点接在 $x_{i-1}$ 的区间接到 $x_i$ 即可。

如果 $y_i&gt;y_{i-1}$，这说明原来的区间就算全部接到 $x_i$ 上还不够，需要再加 $y_i-y_{i-1}$ 个左端点为 $x_{i-1}+1$ 的区间。

如果 $y_i&lt;y_{i-1}$，说明要删掉 $y_{i-1}-y_i$ 个区间，由于要让最小值最大，所以需要删掉左端点最小的区间。

于是只要维护一个左端点递增的区间即可，由于区间数很多，顺便记一个这个左端点的个数即可。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int x[kMaxN], y[kMaxN];
std::pair&lt;int, int&gt; q[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; x[i];
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; y[i];
  x[0] = -1e18;
  int h = 1, t = 0, ans = 1e18;
  for (int i = 1; i &lt;= n; ++i) {
    if (y[i] &gt; y[i - 1]) {
      q[++t] = {x[i - 1] + 1, y[i] - y[i - 1]};
    } else if (y[i] &lt; y[i - 1]) {
      int d = y[i - 1] - y[i];
      for (; d &amp;&amp; h &lt;= t;) {
        int w = std::min(q[h].second, d);
        d -= w, q[h].second -= w;
        ans = std::min(ans, x[i] - 1 - q[h].first);
        if (!q[h].second) ++h;
        else break;
      }
    }
  }
  std::cout &lt;&lt; (ans == 1e18 ? -1 : ans) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17823055.html</id>
    <title type="text">P9194 [USACO23OPEN] Triples of Cows P 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-11-09T14:29:00Z</published>
    <updated>2023-11-09T14:29:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17823055.html" />
    <content type="text">## Description

给定一棵初始有 $n$ 个点的树。

在第 $i$ 天，这棵树的第 $i$ 个点会被删除，所有与点 $i$ **直接相连**的点之间都会**两两**连上一条边。你需要在每次删点**发生前**，求出满足 $(a,b)$ 之间有边，$(b,c)$ 之间有边且 $a\not=c$的**有序**三元组 $(a,b,c)$ 对数。

$n\leq 2\times 10^5$。

## Solution

考虑把每个原图中的点看成白点，边看成黑点，原图中有连边的两个点就向他们对应的黑点连边。

那么每次删点操作就相当于把一个白点的所有相邻黑点合并，并且删除这个黑点。

所以所有 $(a,b,c)$ 可以看成 $(a,x,b,y,c)$，其中 $x$ 是 $a,b$ 连边对应的黑点，$y$ 是 $b,c$ 连边对应的黑点。

容易发现把 $n$ 作为根可以保证图始终是个树。

设 $s_x$ 表示 $x$ 的儿子数，$t_x$ 表示 $x$ 儿子的 $s$ 之和，$w_x$ 表示 $x$ 儿子的 $t$ 之和。然后考虑分类讨论。

首先如果 $x=y$，答案就是 $\sum_{x为黑点}{(s_x+1)s_x(s_x-1)}$。

如果 $x\neq y$ 但是 $x,y$ 都是 $b$ 的儿子，答案就是 $\sum_{b为白点}{\left(t_b^2-\sum_{x\in son(b)}{s_x^2}\right)}$。

最后就是 $x\neq y$ 且 $x,y$ 一个是 $b$ 的儿子，一个是 $b$ 的父亲。

答案就是 $2\sum_{x是黑点}{s_x w_x}$。

把所有的加起来就是：

$$\sum_{x是黑点}{s_x^3-s_x^2-s_x+2s_x w_x}+\sum_{y是白点}{t_y^2}$$

每次合并的时候用并查集维护即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 4e5 + 5;

int n;
int64_t ans;
int fa[kMaxN], s[kMaxN], t[kMaxN], w[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

struct DSU {
  int fa[kMaxN];

  void init(int n) { std::iota(fa + 1, fa + 1 + n, 1); }

  int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
} dsu;

void dfs(int u) {
  for (auto v : G[u]) {
    if (v == fa[u]) continue;
    fa[v] = u, ++s[u];
    dfs(v);
    t[u] += s[v], w[u] += t[v];
  }
}

int64_t getcnt(int u) {
  if (!u) return 0;
  else if (u &lt;= n) return (int64_t)t[u] * t[u];
  else return (int64_t)s[u] * s[u] * s[u] - (int64_t)s[u] * s[u] - s[u] + (int64_t)2 * s[u] * w[u];
}

void work(int u) {
  int ffa = dsu.find(fa[u]), fffa = dsu.find(fa[ffa]), ffffa = dsu.find(fa[fffa]);
  ans -= getcnt(u) + getcnt(ffa) + getcnt(fffa) + getcnt(ffffa);
  --s[ffa], --t[fffa], --w[ffffa];
  for (auto v : G[u]) {
    if (v == fa[u]) continue;
    int fv = dsu.find(v);
    dsu.fa[fv] = ffa;
    ans -= getcnt(fv);
    s[ffa] += s[fv], t[ffa] += t[fv], w[ffa] += w[fv];
    --t[ffa], w[ffa] -= s[fv];
    --w[fffa], w[fffa] += t[fv], t[fffa] += s[fv];
    w[ffffa] += s[fv];
  }
  ans += getcnt(ffa) + getcnt(fffa) + getcnt(ffffa);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(n + i), G[n + i].emplace_back(u);
    G[v].emplace_back(n + i), G[n + i].emplace_back(v);
  }
  dfs(n);
  dsu.init(2 * n - 1);
  for (int i = 1; i &lt;= 2 * n - 1; ++i)
    ans += getcnt(i);
  for (int i = 1; i &lt;= n; ++i) {
    std::cout &lt;&lt; ans &lt;&lt; '\n';
    work(i);
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17873474.html</id>
    <title type="text">P3214 [HNOI2011] 卡农 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-03T09:37:00Z</published>
    <updated>2023-12-03T09:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17873474.html" />
    <content type="text">## Description

给定 $n,m$，要从 $1,2,\dots,2^n-1$ 中选 $m$ 个**无序**的数，使得他们互不相同且异或和为 $0$，问有多少种选法。

对 $998244353$ 取模。

## Solution

考虑求出有序的方案数的个数再除以 $m!$。

设 $f_i$ 表示选出 $i$ 个数的方案。

那么如果随便选前 $i-1$ 个数，那么一定有唯一的一个数使得这个数和前 $i-1$ 个数异或和为 $0$，这里的方案数就是 $A_{2^n-1}^{i-1}$。

但是有些方案数是不合法的。

首先是前 $i-1$ 个数异或和为 $0$，有 $f_{i-1}$ 种。

然后就是第 $i$ 个数出现了重复。

那么设第 $i$ 个数为 $x$，那么把所有 $i$ 个数中的两个 $x$ 丢掉，剩下的 $i-2$ 个数异或和一定为 $0$，那么这一类的方案数就是 $f_{i-2}\cdot (i-1)\cdot \left(2^n-1-\left(i-2\right)\right)$。

所以 $f_{i}=A_{2^n-1}^{i-1}-f_{i-1}-f_{i-2}\cdot (i-1)\cdot \left(2^n-1-\left(i-2\right)\right)$。

时间复杂度：$O(n+m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5, kMod = 1e8 + 7;

namespace Modular {
template&lt;class T&gt;
T qpow(T bs, T idx, T kMod) {
  bs %= kMod;
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}
int inv(int x, int kMod) {
  x %= kMod;
  if (!x) { std::cerr &lt;&lt; "inv error\n"; return 0; }
  return qpow(x, kMod - 2, kMod);
}
template&lt;class T, const T kMod&gt;
T add(T x, T y) {
  if (x + y &gt;= kMod) return x + y - kMod;
  else return x + y;
}

template&lt;class T, const T kMod&gt;
T sub(T x, T y) {
  if (x - y &lt; 0) return x - y + kMod;
  else return x - y;
}

template&lt;class T, const T kMod&gt;
struct Mint {
  T x;

  Mint() { x = 0; }
  template&lt;class _T&gt; Mint(_T _x) { x = _x; }

  friend Mint operator +(Mint m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator -(Mint m1, Mint m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator *(Mint m1, Mint m2) { return Mint(1ll * m1.x * m2.x % kMod); }
  friend Mint operator /(Mint m1, Mint m2) { return Mint(1ll * m1.x * inv(m2.x, kMod) % kMod); }
  Mint operator +=(Mint m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2.x); }
  Mint operator -=(Mint m2) { return x = Modular::sub&lt;T, kMod&gt;(x, m2.x); }
  Mint operator *=(Mint m2) { return x = 1ll * x * m2.x % kMod; }
  Mint operator /=(Mint m2) { return x = 1ll * x * inv(m2.x, kMod) % kMod; }

  template&lt;class _T&gt; friend Mint operator +(Mint m1, _T m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator -(Mint m1, _T m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator *(Mint m1, _T m2) { return Mint(1ll * m1.x * m2 % kMod); }
  template&lt;class _T&gt; friend Mint operator /(Mint m1, _T m2) { return Mint(1ll * m1.x * inv(m2, kMod) % kMod); }
  template&lt;class _T&gt; Mint operator +=(_T m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator -=(_T m2) { return x = Modular::sub&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator *=(_T m2) { return x = 1ll * x * m2 % kMod; }
  template&lt;class _T&gt; Mint operator /=(_T m2) { return x = 1ll * x * inv(m2, kMod) % kMod; }
  template&lt;class _T&gt; friend Mint operator +(_T m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1 % kMod, m2.x)); }
  template&lt;class _T&gt; friend Mint operator -(_T m1, Mint m2) { return Mint(Modular::sub&lt;T, kMod&gt;(m1 % kMod, m2)); }
  template&lt;class _T&gt; friend Mint operator *(_T m1, Mint m2) { return Mint(1ll * m1 * m2.x % kMod); }
  template&lt;class _T&gt; friend Mint operator /(_T m1, Mint m2) { return Mint(1ll * m1 * inv(m2.x, kMod) % kMod); }
  friend Mint operator -(Mint &amp;m1) { return Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator --(Mint &amp;m1) { return m1 = Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator ++(Mint &amp;m1) { return m1 = Mint(m1.x == (kMod - 1) ? 0 : (m1.x + 1)); }
  friend bool operator ==(Mint m1, Mint m2) { return m1.x == m2.x; }

  friend std::istream &amp;operator &gt;&gt;(std::istream &amp;is, Mint &amp;m) {
    int x;
    is &gt;&gt; x;
    m = Mint(x);
    return is;
  }
  friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;os, Mint m) {
    os &lt;&lt; m.x;
    return os;
  }
};
} // namespace Modular

using mint = Modular::Mint&lt;int, kMod&gt;;

int n, m;
mint pw2, f[kMaxN];

mint Fac(int n) {
  mint ret = 1;
  for (int i = 1; i &lt;= n; ++i)
    ret *= i;
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  pw2 = 1;
  for (int i = 1; i &lt;= n; ++i)
    pw2 *= 2;
  f[0] = 1;
  mint A = pw2 - 1;
  for (int i = 2; i &lt;= m; ++i) {
    f[i] = A - f[i - 1] - f[i - 2] * (i - 1) * (pw2 - i + 1);
    A *= pw2 - i;
  }
  std::cout &lt;&lt; f[m] / Fac(m) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17900072.html</id>
    <title type="text">P4463 [集训队互测 2012] calc 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-13T14:20:00Z</published>
    <updated>2023-12-13T14:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17900072.html" />
    <content type="text">## Description

一个序列 $a_1,a_2,\dots,a_n$ 是合法的，当且仅当：

- $a_1,a_2,\dots,a_n$ 都是 $[1,k]$ 中的整数。
- $a_1,a_2,\dots,a_n$ 互不相等。

一个序列的值定义为它里面所有数的乘积，即 $a_1\times a_2\times\dots\times a_n$。

求所有不同合法序列的值的和对 $p$ 取模后的结果。两个序列不同当且仅当他们任意一位不同。

$k \le 10 ^ 9$，$n \le 500$，$p \le 10 ^ 9$，保证 $p$ 为素数，保证 $n + 1 &lt; k &lt; p$。

## Solution

先考虑一个暴力 dp。

设 $f_{i,j}$ 表示前 $i$ 个数，值域为 $[1,j]$ 且这些数单调递增的总和。

那么可以得到转移：$f_{i,j}=f_{i,j-1}+j\times f_{i-1,j-1}$。

时间复杂度：$O(nk)$。

---

考虑优化。

可以猜测 $f_{i,j}$ 是关于 $j$ 的某个多项式，且对于第一维相同的次数相同。

不妨设 $g_i$ 表示 $f_{i}$ 的系数。

那么把 $f_i$ 做差分后的多项式系数为原来的系数 $-1$，即 $f_{i,j}-f_{i,j-1}=j\times f_{i-1,j-1}$ 的系数为 $g_i-1$。

所以 $g_i-1=g_{i-1}+1$，也就是 $g_i=g_{i-1}+2$。

注意到 $g_0$ 一定是 $0$，所以 $g_i=2i$。

然后只要求出 $f_{n,1},f_{n,2},\dots,f_{n,2n+1}$，然后做一遍拉格朗日插值即可。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 505;

int k, n, mod;
int f[kMaxN][kMaxN * 2];

int qpow(int bs, int idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % mod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % mod;
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; k &gt;&gt; n &gt;&gt; mod;
  std::fill_n(f[0], std::min(2 * n + 1, k) + 1, 1);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= std::min(2 * n + 1, k); ++j)
      f[i][j] = (f[i][j - 1] + 1ll * j * f[i - 1][j - 1] % mod) % mod;
  }
  int ans = 0;
  for (int i = 1; i &lt;= 2 * n + 1; ++i) {
    int tmpu = f[n][i], tmpd = 1;
    for (int j = 1; j &lt;= 2 * n + 1; ++j)
      if (i != j)
        tmpu = 1ll * tmpu * ((k - j + mod) % mod) % mod, tmpd = 1ll * tmpd * ((i - j + mod) % mod) % mod;
    ans = (ans + 1ll * tmpu * qpow(tmpd) % mod) % mod;
  }
  for (int i = 1; i &lt;= n; ++i)
    ans = 1ll * ans * i % mod;
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17923806.html</id>
    <title type="text">P9669 [ICPC2022 Jinan R] DFS Order 2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-23T15:14:00Z</published>
    <updated>2023-12-23T15:14:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17923806.html" />
    <content type="text">## Description

P 哥有一棵树，根节点是 $1$，总共有 $n$ 个节点，从 $1$ 到 $n$ 编号。

他想从根节点开始进行深度优先搜索。他想知道对于每个节点 $v$，在深度优先搜索中，它出现在第 $j$ 个位置的方式有多少种。深度优先搜索的顺序是在搜索过程中访问节点的顺序。节点出现在第 $j\ (1 \leq j \le n)$ 个位置表示它在访问了 $j - 1$个其他节点之后才被访问。因为节点的子节点可以以任意顺序访问，所以有多种可能的深度优先搜索顺序。

P 哥想知道对于每个节点 $v$，有多少种不同的深度优先搜索顺序，使得 $v$ 出现在第 $j$ 个位置。对于每个 $v$ 和 $j\ (i \le v,j \le n)$ 计算答案。

答案可能很大，所以输出时要取模 $998244353$。

$1\leq n\leq 500$。

以下是深度优先搜索的伪代码，用于处理树。在调用 `main()` 函数后，`dfs_order` 将会包含深度优先搜索的顺序。

```
void dfs(u):
  dfs_order.push_back(u)
  for (auto v : son(u))
    dfs(v)

void main():
  dfs_order = {}
  dfs(1)
```

## Solution

考虑树形 DP。

设 $f_{i}$ 表示 $i$ 的子树任意排列的方案数，这个东西是很好求的，$g_{i,j}$ 表示走到了 $i$，并且 $i$ 当前在第 $j$ 个的方案数。

假设当前是从 $u\to v$，然后会发现这个 $g$ 的转移会受到 $u$ 子树以外的点的影响，这个是不好搞的。

容易发现只要把 $g_{i,j}$ 改成表示走到了 $i$，并且 $i$ 当前在第 $j$ 个的**概率**，那么这个时候就只要考虑 $u$ 子树里对 $v$ 的影响了。

设 $h_{i,j}$ 表示 $u$ 的子树里去掉 $v$，选 $i$ 个无序儿子使得他们的子树大小和为 $j$ 的方案数。容易发现 $h_{i,j}$ 可以先用考虑所有儿子的答案，然后利用 01 背包的可撤销性求得。

所以这里 $v$ 的编号比 $u$ 的编号大 $i+1$ 的概率就是 

$$\frac{\sum\limits_{j=0}^{cnt-1}{h_{j,i}\times j!\times (cnt-1-j)!}}{cnt!}$$

其中 $cnt$ 表示 $u$ 的儿子个数。

然后只要枚举 $u$ 的编号为 $k$ 的概率和 $v$ 比 $u$ 大 $i$ 的概率即可得到 $v$ 的编号为 $k+i$ 的概率。

最后只要把所有的概率乘 $f_1$ 就是答案。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

namespace Modular {
template&lt;class T&gt;
T qpow(T bs, T idx, T kMod) {
  bs %= kMod;
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}
int inv(int x, int kMod) {
  x %= kMod;
  if (!x) { std::cerr &lt;&lt; "inv error\n"; return 0; }
  return qpow(x, kMod - 2, kMod);
}
template&lt;class T, const T kMod&gt;
T add(T x, T y) {
  if (x + y &gt;= kMod) return x + y - kMod;
  else return x + y;
}

template&lt;class T, const T kMod&gt;
T minu(T x, T y) {
  if (x - y &lt; 0) return x - y + kMod;
  else return x - y;
}

template&lt;class T, const T kMod&gt;
struct Mint {
  T x;

  Mint() { x = 0; }
  template&lt;class _T&gt; Mint(_T _x) { x = _x; }

  friend Mint operator +(Mint m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator -(Mint m1, Mint m2) { return Mint(Modular::minu&lt;T, kMod&gt;(m1.x, m2.x)); }
  friend Mint operator *(Mint m1, Mint m2) { return Mint(1ll * m1.x * m2.x % kMod); }
  friend Mint operator /(Mint m1, Mint m2) { return Mint(1ll * m1.x * inv(m2.x, kMod) % kMod); }
  Mint operator +=(Mint m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2.x); }
  Mint operator -=(Mint m2) { return x = Modular::minu&lt;T, kMod&gt;(x, m2.x); }
  Mint operator *=(Mint m2) { return x = 1ll * x * m2.x % kMod; }
  Mint operator /=(Mint m2) { return x = 1ll * x * inv(m2.x, kMod) % kMod; }

  template&lt;class _T&gt; friend Mint operator +(Mint m1, _T m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator -(Mint m1, _T m2) { return Mint(Modular::minu&lt;T, kMod&gt;(m1.x, m2 % kMod)); }
  template&lt;class _T&gt; friend Mint operator *(Mint m1, _T m2) { return Mint(1ll * m1.x * m2 % kMod); }
  template&lt;class _T&gt; friend Mint operator /(Mint m1, _T m2) { return Mint(1ll * m1.x * inv(m2, kMod) % kMod); }
  template&lt;class _T&gt; Mint operator +=(_T m2) { return x = Modular::add&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator -=(_T m2) { return x = Modular::minu&lt;T, kMod&gt;(x, m2); }
  template&lt;class _T&gt; Mint operator *=(_T m2) { return x = 1ll * x * m2 % kMod; }
  template&lt;class _T&gt; Mint operator /=(_T m2) { return x = 1ll * x * inv(m2, kMod) % kMod; }
  template&lt;class _T&gt; friend Mint operator +(_T m1, Mint m2) { return Mint(Modular::add&lt;T, kMod&gt;(m1 % kMod, m2.x)); }
  template&lt;class _T&gt; friend Mint operator -(_T m1, Mint m2) { return Mint(Modular::minu&lt;T, kMod&gt;(m1 % kMod, m2)); }
  template&lt;class _T&gt; friend Mint operator *(_T m1, Mint m2) { return Mint(1ll * m1 * m2.x % kMod); }
  template&lt;class _T&gt; friend Mint operator /(_T m1, Mint m2) { return Mint(1ll * m1 * inv(m2.x, kMod) % kMod); }
  friend Mint operator -(Mint &amp;m1) { return Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator --(Mint &amp;m1) { return m1 = Mint(m1.x == 0 ? (kMod - 1) : (m1.x - 1)); }
  friend Mint operator ++(Mint &amp;m1) { return m1 = Mint(m1.x == (kMod - 1) ? 0 : (m1.x + 1)); }
  friend bool operator ==(Mint m1, Mint m2) { return m1.x == m2.x; }

  friend std::istream &amp;operator &gt;&gt;(std::istream &amp;is, Mint &amp;m) {
    int x;
    is &gt;&gt; x;
    m = Mint(x);
    return is;
  }
  friend std::ostream &amp;operator &lt;&lt;(std::ostream &amp;os, Mint m) {
    os &lt;&lt; m.x;
    return os;
  }
};
} // namespace Modular

using mint = Modular::Mint&lt;int, 998244353&gt;;

const int kMaxN = 505;

int n;
int sz[kMaxN];
std::vector&lt;int&gt; G[kMaxN];
mint f[kMaxN], g[kMaxN][kMaxN], fac[kMaxN], ifac[kMaxN]; // f[i] : i 的子树的方案数, g[i][j] : i 排在第 j 个的概率

mint C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return fac[m] * ifac[n] * ifac[m - n];
}

void dfs1(int u, int fa) {
  f[u] = sz[u] = 1;
  int ct = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    f[u] *= f[v] * (++ct);
  }
}

void dfs2(int u, int fa) {
  static mint ff[kMaxN][kMaxN], tmp[kMaxN];
  for (int i = 0; i &lt;= n; ++i)
    for (int j = 0; j &lt;= n; ++j)
      ff[i][j] = 0;
  ff[0][0] = 1;
  int now = 0, cnt = 0;
  mint mul = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    mul *= f[v];
    ++cnt;
    for (int i = cnt; i; --i)
      for (int j = sz[v]; j &lt;= n; ++j)
        ff[i][j] += ff[i - 1][j - sz[v]];
    now += sz[v];
  }
  for (auto v : G[u]) {
    if (v == fa) continue;
    for (int i = 0; i &lt;= n; ++i)
      tmp[i] = 0;
    for (int i = 1; i &lt;= cnt; ++i)
      for (int j = sz[v]; j &lt;= n; ++j)
        ff[i][j] -= ff[i - 1][j - sz[v]];
    for (int i = 0; i &lt;= cnt - 1; ++i) {
      for (int j = 0; j &lt;= n; ++j) {
        tmp[j] += ff[i][j] * fac[i] * fac[cnt - 1 - i] * mul;
      }
    }
    for (int i = cnt; i; --i)
      for (int j = sz[v]; j &lt;= n; ++j)
        ff[i][j] += ff[i - 1][j - sz[v]];
    mint val = 1 / f[u];
    for (int i = 0; i &lt;= n; ++i)
      for (int j = 0; j &lt;= n - 1 - i; ++j)
        g[v][i + j + 1] += g[u][i] * tmp[j] * val;
  }
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs2(v, u);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    fac[i] = fac[i - 1] * i;
    ifac[i] = 1 / fac[i];
  }
  dfs1(1, 0);
  g[1][1] = 1;
  dfs2(1, 0);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j)
      std::cout &lt;&lt; g[i][j] * f[1] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17926255.html</id>
    <title type="text">P6922 [ICPC2016 WF] Longest Rivers 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-25T07:48:00Z</published>
    <updated>2023-12-25T07:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17926255.html" />
    <content type="text">## Description

有 $n$ 条河和 $m+1$ 个交汇处构成一棵以 $0$ 号点（即大海） 为根的树。

每条河有各自的名称。对于一个交汇处，从它流出的干流的名称是流入这个交汇处的各个支流的名称之一。一条河流的长度是以它为名称的河流的长度之和。对于一个可能的命名方案，一条河流的排名等于长度大于它的河流数 $+1$ 。

对于每条河，求出它在所有命名方案中，最小的排名。

$n,m\leq 5\times 10^5$。

## Solution

先考虑对于每条河怎么 $O(n)$ 求答案。

容易发现当前河一定要一冲到底，设长度为 $L$，那么就要要求其余长度 $&gt;L$ 的河流数量最少。

然后从下往上考虑每个点，有下面 2 种情况：

1. 如果有儿子流过来是长的，那么当前点就流这个最长的。
2. 如果儿子流过来全是短的，那么流里面最短的。

这样递归处理即可做到 $O(n)$。

---

考虑怎样一次求出所有的答案。

这里有个转化就是只要求出所有河流中 $&gt;L$ 的河流的最小数量，而不用考虑当前河是否要连到根。

因为如果一个最小数量的方案当前河没有连到根，那么把当前河到根的路径上全都连到当前河一定不会更劣。

然后从小到大枚举 $L$，这时候有 3 种情况：

1. 有儿子流过来是长的。
2. 儿子流过来全是短的，但最短的流完当前点到父亲的边后变长。
3. 儿子流过来全是短的，但最短的流完当前点到父亲的边后还是短的。

容易发现答案就是 2 号点的数量$+1$，并且随着 $L$ 的增大，部分 2 号点会变为 3 号点，1 号点可能会变成 2 或 3 号点。

设 $f_i$ 表示将 $i$ 从 2 变到 3 的最小长度。

那么只要用一个 pair 的优先队列维护所有 2 号点，其中 $\{l,x\}$ 分别表示 $x$ 需要从 2 变到 3 的最小长度和当前点的编号。

每次从队列中取出 $l$ 最小的 $x$，然后不停跳父亲，如果这个祖先 $y$ 的所有儿子都变 3 并且 $f_y\leq L$ 说明 $y$ 也是 3 号点，就继续跳，否则退出。

最后如果跳出来一个 $y$，使得他的所有儿子全是 3 并且 $f_y&gt;L$ 就说明他变成了个 2 号点，加到队列里即可。

如果要输出一个任意 $L$ 的答案，就只要找到求出的所有答案中小于等于 $L$ 的最大长度的答案即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;
const int64_t kInf = 1e18;

int n, m;
int fa[kMaxN], w[kMaxN], cnt[kMaxN];
int64_t sum[kMaxN], f[kMaxN];
std::string name[kMaxN];
std::vector&lt;int&gt; G[kMaxN];
std::map&lt;int64_t, int&gt; mp;
std::priority_queue&lt;std::pair&lt;int64_t, int&gt;, std::vector&lt;std::pair&lt;int64_t, int&gt;&gt;, std::greater&lt;std::pair&lt;int64_t, int&gt;&gt;&gt; q;

void dfs(int u) {
  int64_t minn = kInf;
  for (auto v : G[u]) {
    sum[v] = sum[u] + w[v];
    dfs(v);
    minn = std::min(minn, f[v]);
    ++cnt[u];
  }
  if (minn == kInf) f[u] = w[u];
  else f[u] = minn + w[u];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = m + 1; i &lt;= m + n; ++i) {
    std::cin &gt;&gt; name[i] &gt;&gt; fa[i] &gt;&gt; w[i];
    G[fa[i]].emplace_back(i);
  }
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; fa[i] &gt;&gt; w[i];
    G[fa[i]].emplace_back(i);
  }
  dfs(0);
  for (int i = m + 1; i &lt;= m + n; ++i)
    q.emplace(f[i], i);
  for (; !q.empty();) {
    auto [L, u] = q.top();
    q.pop();
    --cnt[fa[u]];
    for (u = fa[u]; u &amp;&amp; !cnt[u]; u = fa[u]) {
      if (L &gt;= f[u]) {
        --cnt[fa[u]];
      } else {
        q.emplace(f[u], u);
        break;
      }
    }
    mp[L] = q.size() + 1;
  }
  mp[kInf] = 0;
  for (int i = m + 1; i &lt;= m + n; ++i)
    std::cout &lt;&lt; name[i] &lt;&lt; ' ' &lt;&lt; prev(mp.upper_bound(sum[i]))-&gt;second &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17932766.html</id>
    <title type="text">P8868 [NOIP2022] 比赛 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-28T07:28:00Z</published>
    <updated>2023-12-28T07:28:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17932766.html" />
    <content type="text">## Description

小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\{a _ i\}$ 和 $\{b _ i\}$ 还分别构成了从 $1$ 到 $n$ 的排列。

每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \leq l \leq r \leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \leq p \leq q \leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \times m _ b$。

NOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \leq p \leq q \leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。

[link](https://www.luogu.com.cn/problem/P8868)。

## Solution

考虑把询问离线下来然后对 $r$ 做扫描线。

设 $x_i=\max\limits_{j=i}^{r}{a_j},y_i=\max\limits_{j=i}^{r}{b_j}$。

那么区间 $[l_0,r_0]$ 的答案就是 $r$ 取 $[l_0,r_0]$ 时 $x_{l_0}\times y_{l_0}$ 的历史版本和 $S$。

首先可以用单调栈维护对于每个 $r$，他能控制 $x$ 的范围和控制 $y$ 的范围，所以当 $r$ 往右移一格，只会有三种操作：

1. 将区间的 $x$ 更改为 $a_r$。
2. 将区间的 $y$ 更改为 $a_r$。
3. 对于 $[1,r]$ 里的所有 $i$，让 $S_i$ 加 $x_i\times y_i$。

最后需要多次查询区间 $S$ 之和。

---

考虑用线段树维护，容易发现每次操作之后 $S$ 的增量一定可以表示为：$add_{x}\times X+add_y\times Y+add_{xy}\times XY+add_c$，其中 $add_x,add_y,add_{xy},add_c$ 都是常数。

所以可以维护懒标记 $tag=(set_x,set_y,add_x,add_y,add_{xy},add_c)$ 分别表示区间 $x$ 赋值标记，区间 $y$ 赋值标记和四个系数。

考虑怎样合并两个懒标记 $tag_1,tag_2$。

这里需要分类讨论 $tag_1$ 是否有 $x$ 赋值和 $y$ 赋值。

1. 如果 $x$ 和 $y$ 都有赋值，那么只用更新 $add_c$。

2. 如果 $x$ 有，$y$ 没有，那么可以用 $tag_2$ 的 $add_{xy}$ 和 $add_y$ 更新 $add_t$，$add_x$ 更新 $add_c$（$x$ 没有 $y$ 没有是同理的）。

3. 如果 $x$ 和 $y$ 都没有，那么只要将 $tag_2$ 的 $add_x$ 更新 $add_x$，$add_y$ 更新 $add_y$，$add_{xy}$ 更新 $add_xy$ 即可。

不要忘记 $add_c$ 要直接合并。

时间复杂度：$O((n+q)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using u64 = uint64_t;

const int kMaxN = 2.5e5 + 5;

struct Node {
  u64 sumx, sumy, sumxy, sum;

  Node() {}
  Node(u64 _sumx, u64 _sumy, u64 _sumxy, u64 _sum) : sumx(_sumx), sumy(_sumy), sumxy(_sumxy), sum(_sum) {}

  friend Node operator +(Node n1, Node n2) {
    return {n1.sumx + n2.sumx, n1.sumy + n2.sumy, n1.sumxy + n2.sumxy, n1.sum + n2.sum};
  }
} t[kMaxN * 4];

struct Tag {
  u64 setx, sety, addx, addy, addxy, addc; // x 的赋值，y 的赋值，x 对 sum 的系数，y 对 sum 的系数，xy 对 sum 的系数，常数对 sum 的系数

  Tag() {}
  Tag(u64 _setx, u64 _sety, u64 _addx, u64 _addy, u64 _addxy, u64 _addc) : setx(_setx), sety(_sety), addx(_addx), addy(_addy), addxy(_addxy), addc(_addc) {}

  friend Tag operator +(Tag t1, Tag t2) { // t1：前面的，t2：后面的
    Tag ret = t1;
    if (t2.setx) ret.setx = t2.setx;
    if (t2.sety) ret.sety = t2.sety;
    if (t1.setx) {
      ret.addc += t1.setx * t2.addx;
      if (t1.sety) ret.addc += t1.sety * t2.addy + t1.setx * t1.sety * t2.addxy;
      else ret.addy += t2.addy + t1.setx * t2.addxy;
    } else {
      ret.addx += t2.addx;
      if (t1.sety) ret.addx += t1.sety * t2.addxy, ret.addc += t1.sety * t2.addy;
      else ret.addy += t2.addy, ret.addxy += t2.addxy;
    }
    ret.addc += t2.addc;
    return ret;
  }
} tag[kMaxN * 4];

int n, q;
int a[kMaxN], b[kMaxN], la[kMaxN], lb[kMaxN], stka[kMaxN], stkb[kMaxN];
u64 ans[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxN];

Node merge(Node a, Tag t, int len) {
  Node ret = a;
  if (t.setx) ret.sumx = t.setx * len;
  if (t.sety) ret.sumy = t.sety * len;

  if (t.setx &amp;&amp; t.sety) ret.sumxy = t.setx * t.sety * len;
  else if (t.setx) ret.sumxy = t.setx * a.sumy;
  else if (t.sety) ret.sumxy = t.sety * a.sumx;
  
  ret.sum += a.sumx * t.addx + a.sumy * t.addy + a.sumxy * t.addxy + t.addc * len;
  return ret;
}

struct SGT {
  Node t[kMaxN * 4];
  Tag tag[kMaxN * 4];

  void pushup(int x) {
    t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1];
  }

  void addtag(int x, int l, int r, Tag tg) {
    t[x] = merge(t[x], tg, r - l + 1), tag[x] = tag[x] + tg;
  }

  void pushdown(int x, int l, int r) {
    if (!tag[x].setx &amp;&amp; !tag[x].sety &amp;&amp; !tag[x].addx &amp;&amp; !tag[x].addy &amp;&amp; !tag[x].addxy &amp;&amp; !tag[x].addc) return;
    int mid = (l + r) &gt;&gt; 1;
    addtag(x &lt;&lt; 1, l, mid, tag[x]), addtag(x &lt;&lt; 1 | 1, mid + 1, r, tag[x]);
    tag[x] = {0, 0, 0, 0, 0, 0};
  }

  void update(int x, int l, int r, int ql, int qr, Tag t) {
    if (l &gt; qr || r &lt; ql) {
      return;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return addtag(x, l, r, t);
    }
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, t), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t);
    pushup(x);
  }

  u64 query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) {
      return 0;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return t[x].sum;
    }
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return query(x &lt;&lt; 1, l, mid, ql, qr) + query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }
} sgt;

void dickdreamer() {
  int _case;
  std::cin &gt;&gt; _case &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; b[i];
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    vec[r].emplace_back(l, i);
  }
  int topa = 0, topb = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (; topa &amp;&amp; a[stka[topa]] &lt; a[i]; --topa) {}
    for (; topb &amp;&amp; b[stkb[topb]] &lt; b[i]; --topb) {}
    la[i] = stka[topa], lb[i] = stkb[topb];
    stka[++topa] = i, stkb[++topb] = i;
    sgt.update(1, 1, n, la[i] + 1, i, {a[i], 0, 0, 0, 0, 0});
    sgt.update(1, 1, n, lb[i] + 1, i, {0, b[i], 0, 0, 0, 0});
    sgt.update(1, 1, n, 1, i, {0, 0, 0, 0, 1, 0});
    for (auto p : vec[i])
      ans[p.second] = sgt.query(1, 1, n, p.first, i);
  }
  for (int i = 1; i &lt;= q; ++i)
    std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17935661.html</id>
    <title type="text">CF1917F Construct Tree 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2023-12-29T12:56:00Z</published>
    <updated>2023-12-29T12:56:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17935661.html" />
    <content type="text">## Description

给你一个数组 $l_1,l_2,\dots.l_n$ 和一个数字 $d$。问你是否能够构造一棵树满足以下条件：

- 这棵树有 $n+1$ 个点。
- 第 $i$ 条边的长度是  $l_i$。
- 树的直径是 $d$。

只需要判断是否有解即可。

$2\le n\le2000,1\le d\le 2000,1\le l_i\le d$。

## Solution

先把 $l$ 从大到小排序。

容易发现把直径拉出来后，其他不在直径上的边 $l_k$ 挂在直径的点上要满足 $l_k\leq \min\{L,d-L\}$，其中 $L$ 和 $d-L$ 分别是直径上挂的点左右的长度和。

所以肯定是把不在直径上的边以类似菊花图的形式尽可能挂在中间，使得所有 $l_k\leq \min\{L,d-L\}$。

如果 $l_n&gt;d$ 显然无解。

如果 $l_n&gt;\left\lfloor\dfrac{d}{2}\right\rfloor$，则它一定不能是挂着的边，也就是一定在直径上，这时候只要判断 $l_1,l_2\dots. l_{n-1}$ 都 $\leq d-l_n$ 并且能够选出某些数和为 $d-l_n$。

如果 $l_n\leq\left\lfloor\dfrac{d}{2}\right\rfloor$，并且 $l_n$ 在直径上，则其他点一定能全挂上去，所以只要判断能否有若干个和为 $d-l_n$ 即可。如果 $l_n$ 不在直径上，那么就需要保证 $\min\{L,d-L\}\geq l_n$，所以直接设 $f_{i,j}$ 表示左边和为 $i$，右边和为 $j$ 是否可行即可求出。

时间复杂度：$O(nd^2)$，过不了。

但是注意到 $f_{i,j}$ 的转移只有 $0/1$，所以可以 bitset 优化至 $O\left(\frac{nd^2}{\omega}\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e3 + 5;

int n, d;
int a[kMaxN];
std::bitset&lt;kMaxN&gt; f[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; d;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  std::sort(a + 1, a + 1 + n);
  if (a[n] &gt; d / 2) {
    if (a[n - 1] &gt; d - a[n]) return void(std::cout &lt;&lt; "No\n");
    f[0].reset();
    f[0][0] = 1;
    for (int i = 1; i &lt; n; ++i)
      f[0] |= (f[0] &lt;&lt; a[i]);
    std::cout &lt;&lt; (f[0][d - a[n]] ? "Yes\n" : "No\n");
  } else {
    for (int i = 0; i &lt;= d; ++i)
      f[i].reset();
    f[0][0] = 1;
    for (int i = 1; i &lt; n; ++i) {
      for (int j = d; ~j; --j) {
        f[j] |= (f[j] &lt;&lt; a[i]);
        if (j &gt;= a[i]) f[j] |= f[j - a[i]];
      }
    }
    bool ans = f[0][d - a[n]];
    for (int i = a[n]; i &lt;= d - a[n]; ++i)
      ans |= f[i][d - i];
    std::cout &lt;&lt; (ans ? "Yes\n" : "No\n");
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/17943272.html</id>
    <title type="text">P2726 [SHOI2005] 树的双中心 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-01-03T07:32:00Z</published>
    <updated>2024-01-03T07:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/17943272.html" />
    <content type="text">## Description

![](https://cdn.luogu.com.cn/upload/pic/15902.png)

$n\leq 5\times 10^4$，树的深度 $\leq 100$。

## Solution

对于每个 $x,y$，满足 $d(v,x)\leq d(v,y)$ 或者 $d(v,x)\geq d(v,y)$ 的点一定构成一个子树，所以可以枚举这个子树的根，然后对两边分别求重心可以得到答案。

但是直接暴力求是 $O(n^2)$ 的，过不了。

注意到深度很小，所以可以考虑 $O(h)$ 求一颗树的重心。

设 $sz_i$ 表示以 $i$ 为根的子树权值的和，假设已知节点 $u$ 到其他点的距离和 $now$，那么对于 $u$ 的儿子 $v$ 的答案就是 $now+sz_{root}-2\times sz_v$，所以每次只用跳到子树权值最大的儿子 $v$，如果答案不会变优就终止即可。

容易想到预处理每个点权值最大的儿子，但是这里求总树去掉当前树的连通块的答案时有修改，又注意到一个点最多只有一个儿子的权值会变，所以只要记录权值最大和次大的儿子即可。

时间复杂度：$O(nh)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e4 + 5;

int n;
int64_t ans = 1e18, sz[kMaxN], f[kMaxN];
int a[kMaxN], p[kMaxN], dep[kMaxN], wson1[kMaxN], wson2[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

void dfs1(int u, int fa) {
  sz[u] = a[u], p[u] = fa, dep[u] = dep[fa] + 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v], f[u] += f[v] + sz[v];
    if (sz[v] &gt;= sz[wson1[u]]) wson2[u] = wson1[u], wson1[u] = v;
    else if (sz[v] &gt;= sz[wson2[u]]) wson2[u] = v;
  }
}

int64_t dfs2(int u, int fa, int64_t now, int64_t sum, int pos) { // 找答案
  int v = wson1[u];
  if (v == pos || sz[wson2[u]] &gt; sz[v]) v = wson2[u];
  if (sz[v] * 2 &gt; sum) return std::min(now, dfs2(v, u, now + (sum - sz[v] * 2), sum, pos));
  else return now;
}

void dfs3(int u, int fa) {
  for (auto v : G[u]) {
    if (v == fa) continue;
    for (int j = u; j; j = p[j]) sz[j] -= sz[v];
    ans = std::min(ans, dfs2(v, u, f[v], sz[v], v) + dfs2(1, 0, f[1] - f[v] - (int64_t)(dep[v] - 1) * sz[v], sz[1], v));
    for (int j = u; j; j = p[j]) sz[j] += sz[v];
    dfs3(v, u);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  dfs1(1, 0), dfs3(1, 0);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18010441.html</id>
    <title type="text">P8330 [ZJOI2022] 众数 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-06T14:55:00Z</published>
    <updated>2024-02-06T14:55:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18010441.html" />
    <content type="text">## Description

给定一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，问选一段区间，它的价值是里面的众数个数 $+$ 外面的众数个数，求最大价值，以及所有满足这个最大价值的区间的外面的众数颜色。

$\sum n\leq 5\times 10^5,n\leq 2\times 10^5$。

## Solution

考虑根号分治。

定义一个大的颜色指出现次数 $&gt;\sqrt n$ 的颜色，小的颜色指出现次数 $\leq\sqrt n$ 的颜色。

首先考虑两个众数中至少一个是大颜色的贡献。

假设大颜色为 $x$，另一个为 $y$。

第一种情况是形如 $\texttt{xxxxyyyyyxxxx}$ 即 $x$ 在两边，$y$ 在中间的贡献。这时会发现一个区间 $[l,r]$ 的答案就是 $x$ 的出现次数 $+$  $[l,r]$ 中 $y$ 的出现次数 $-$ $[l,r]$ 中 $x$ 的出现次数，这个东西很容易搞成区间和的形式，搞个最大子段和即可做到单次 $O(n)$。

容易发现最优情况一定满足选定区间的左右端点都是 $y$，所以只要对于所有颜色为 $y$ 的位置计算答案即可做到单次 $O(cnt_y)$。

对于 $\texttt{yyyyxxxxxyyyy}$ 的情况是同理的，所以这一部分的总时间复杂度为 $O(\sqrt n)$。

---

然后考虑 小-小 的情况。

这里先枚举区间外的众数 $x$，容易发现最优情况的区间 $[l,r]$ 一定满足：$l=1$ 或 $a_{l-1}=x$，和 $r=n$ 或 $a_{r+1}=x$。

这时只要枚举这些 $[l,r]$ 再求出 $[l,r]$ 之间的众数即可得出答案。

但是这样要求 $O(n\sqrt n)$ 次区间众数，显然过不了。

观察到这里只需要考虑 $[l,r]$ 中出现次数 $\leq \sqrt n$ 的数的众数，所以 $[l,r]$ 的答案也 $\leq \sqrt n$。

于是可以依次枚举 $r$，维护 $s_l$ 表示 $[l,r]$ 的众数。然后对于所有 $r$ 前且颜色和 $r$ 相等的位置 $i$，需要对于所有 $j\leq i$ 的 $s_j$ 对 $[i,r]$ 中 $a_i$ 的个数取 $\max$。

注意到这里 $s$ 一定是单调不增的，所以只需从后往前扫，如果能更新就更新，否则就退出。

然后右端点为 $r+1$ 的答案即为 $\max{c_i+cnt_{[1,i-1],a_{r+1}}+cnt_{[r+1,n],a_{r+1}}}$，这个暴力枚举颜色与 $r+1$ 相同的 $i$ 即可。

容易发现一次更新至少会使 $s$ 的总和 $+1$，而最终 $s_i\leq \sqrt n$，所以时间复杂度就是 $O(n\sqrt n)$。

总的时间复杂度：$O(n\sqrt n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, m, b;
int a[kMaxN], unq[kMaxN], pos[kMaxN], res[kMaxN], sum[kMaxN];
std::vector&lt;int&gt; v[kMaxN];

void discrete() {
  b = sqrt(n);
  for (int i = 1; i &lt;= n; ++i)
    unq[i] = a[i];
  std::sort(unq + 1, unq + 1 + n);
  m = std::unique(unq + 1, unq + 1 + n) - (unq + 1);
  for (int i = 1; i &lt;= n; ++i)
    v[i].clear(), res[i] = 0;
  for (int i = 1; i &lt;= n; ++i) {
    a[i] = std::lower_bound(unq + 1, unq + 1 + m, a[i]) - unq;
    pos[i] = v[a[i]].size();
    v[a[i]].emplace_back(i);
  }
}

int big1(int x, int y) { // xxxxxyyyyyyyyyxxxxx
  static int pre1[kMaxN], pre2[kMaxN];
  int mi = 1e9, ret = 0;
  for (int i = 0; i &lt; (int)v[y].size(); ++i) {
    pre1[i] = sum[v[y][i]] + i + 1;
    pre2[i] = sum[v[y][i] - 1] + i;
    mi = std::min(mi, pre2[i]);
    ret = std::max(ret, pre1[i] - mi);
  }
  return ret + v[x].size();
}

int big2(int x, int y) { // yyyyyxxxxxxyyyyyy
  static int pre[kMaxN], suf[kMaxN], mx[kMaxN];
  for (int i = 0; i &lt; (int)v[y].size(); ++i) {
    pre[i] = sum[v[y][i]] + i + 1;
    suf[i] = sum[n] - sum[v[y][i] - 1] + v[y].size() - i;
    mx[i] = (i == 0 ? pre[i] : std::max(mx[i - 1], pre[i]));
  }
  int now = -1e9, ret = mx[(int)v[y].size() - 1];
  for (int i = (int)v[y].size() - 1; i; --i) {
    now = std::max(now, suf[i]);
    ret = std::max(ret, now + pre[i - 1]);
  }
  ret = std::max(ret, now);
  return ret + v[x].size();
}

void solve_big() {
  for (int x = 1; x &lt;= m; ++x) {
    if (v[x].size() &lt;= b) continue;
    for (int i = 1; i &lt;= n; ++i)
      sum[i] = sum[i - 1] - (a[i] == x);
    for (int y = 1; y &lt;= m; ++y) {
      res[x] = std::max(res[x], big1(x, y));
      res[y] = std::max(res[y], big2(x, y));
    }
  }
}

void solve_small() {
  static int c[kMaxN], cnt[kMaxN];
  // c[i] : [i, r] 的众数
  std::fill_n(c + 1, n, 0);
  std::fill_n(cnt + 1, n, 0);
  for (int i = 1; i &lt;= n; ++i) {
    if (v[a[i]].size() &gt; b) continue;
    res[a[i]] = std::max(res[a[i]], c[1] + (int)v[a[i]].size() - pos[i]);
    for (int j = pos[i] - 1; ~j; --j) {
      res[a[i]] = std::max(res[a[i]], c[v[a[i]][j] + 1] + (int)v[a[i]].size() - pos[i] + j + 1);
    }
    for (int j = pos[i]; ~j; --j) {
      for (int k = v[a[i]][j]; k &amp;&amp; c[k] &lt;= pos[i] - j + 1; --k)
        c[k] = pos[i] - j + 1;
    }
  }
  int mx = 0;
  for (int i = n; i; --i) {
    res[a[i]] = std::max(res[a[i]], mx + pos[i] + 1);
    mx = std::max(mx, ++cnt[a[i]]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; a[i];
  discrete(), solve_big(), solve_small();
  int mx = 0;
  for (int i = 1; i &lt;= m; ++i) mx = std::max(mx, res[i]);
  std::cout &lt;&lt; mx &lt;&lt; '\n';
  for (int i = 1; i &lt;= m; ++i)
    if (res[i] == mx)
      std::cout &lt;&lt; unq[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18011249.html</id>
    <title type="text">[AGC021E] Ball Eat Chameleons 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-07T12:25:00Z</published>
    <updated>2024-02-07T12:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18011249.html" />
    <content type="text">## Description

有 $n$ 只变色龙，一开始都是蓝色。现在你喂了 $k$ 次球，每次指定一只变色龙吃下你指定颜色的球。

一只变色龙从蓝色变成红色当且仅当它吃的红球比蓝球多；
一只变色龙从红色变成蓝色当且仅当它吃的蓝球比红球多。

求最后能使所有变色龙都变成红色的方案数。

两个方案不同当且仅当至少一次喂的球颜色不同（**而不是喂的变色龙不同**）。

**注意：存在一次喂的变色龙不同的两个方案可能是相同的方案。**

$1\leq n,k\leq 5\times 10^5$。

## Solution

考虑对于一只变色龙，怎样给他喂球才能变成红色。

设喂了 $a$ 个红球，$b$ 个蓝球。

1. $a&gt;b$：为红色。
2. $a&lt;b$：为蓝色。
3. $a=b$：为不同于最后喂的颜色的另一个颜色，即最后的颜色异或 $1$。

首先如果 $a-b\geq 2$，那么把多出来的 $a-b-1$ 个球给别人一定不劣，所以这里只需要满足 $a=b+1$ 或 $a=b$ 且最后一次选了蓝球。

不妨设一个方案总共放了 $R$ 个红球，$B$ 个蓝球，则要满足条件一定要满足 $R\geq B$。

容易发现 $a=b+1$ 的变色龙总共 $R-B$ 个，$a=b$ 的变色龙共 $n-(R-B)$ 个，不妨设 $cnt=n-(R-B)$。

所以判断一个方案是否合法等价于能否在其中找到 $cnt$ 个形如 `RB` 的匹配。

但是这个判定还不够简单。

注意到这些匹配一定是前 $cnt$ 个 `R` 和后 $cnt$ 个 `B` 按顺序进行匹配，那么对于倒数第 $i$ 个 `B`，它前面一定有至少 $cnt-i+1$ 个 `R`。

所以对于每个前缀，他的 `R` 的个数 $\geq$ `B` 的个数 $-(B-cnt)$。

那么把 `R` 看作 $+1$，`B` 看作 $-1$ 做一遍前缀和，只要满足每个前缀和 $\geq R-n$ 即可。

这就转化为了一个类似卡特兰数的东西，答案就是：

$$
\binom{R+B}{R}-\binom{R+B}{n+B-R-1}
$$

这里对于 $R=B$ 要特判，因为最后一步必须是 $B$，所以只要把 $B-1$ 再做上面那个式子即可。

时间复杂度：$O(k)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5, kMod = 998244353;

int n, k;
int inv[kMaxN], fac[kMaxN], ifac[kMaxN];

int add(int x, int y) { return (x + y) &gt;= kMod ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x &lt; y) ? (x - y + kMod) : (x - y); }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= k; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  if (k &lt; n) return void(std::cout &lt;&lt; "0\n");
  prework();
  int ans = 0;
  for (int i = (k + 1) / 2; i &lt;= k; ++i) {
    int j = k - i;
    if (i == j) -- j;
    ans = add(ans, sub(C(i + j, i), C(i + j, n + j - i - 1)));
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18011301.html</id>
    <title type="text">P8863 「KDOI-03」构造数组-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-07T13:09:00Z</published>
    <updated>2024-02-07T13:09:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18011301.html" />
    <content type="text">## Descriptoin

你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。

* 选出两个**不同的**下标 $1\leq i&lt;j\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。

两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。

**答案对 $\bm{998244353}$ 取模。**

$1\le n\le 5000$，$1\leq b_i\le30000$，$\sum b_i\le30000$。

## Solution

这题可以转化为给定 $t$ 个空位置，每个位置最多放 $2$ 个数，每次可以选择 $a_i$ 个没满位置放 $i$ 进去，问最后把这 $t$ 个位置都放满有多少种方案。

设 $f_{i,j}$ 表示前 $i$ 个数，放满了 $j$ 个位置，容易发现只放了一个的位置个数为 $cnt_1=\sum_{k=1}^{i}{a_k}-2j$，还没放的位置个数为 $t-cnt_1-j$。

那么只要枚举当前的 $i$ 放在 $k$ 个 $1$ 位置，$a_i-k$ 个 $0$ 位置，然后乘上组合数即可做到 $O\left(\left(\sum b_i\right)^2\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e3 + 5, kMaxS = 3e4 + 5, kMod = 998244353;

int n;
int a[kMaxN], sum[kMaxN], f[2][kMaxS], fac[kMaxS], ifac[kMaxS], inv[kMaxS];

inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }

inline int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= sum[n]; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    sum[i] = sum[i - 1] + a[i];
  }
  if (sum[n] &amp; 1) return void(std::cout &lt;&lt; "0\n");
  prework();
  int o = 0, t = sum[n] / 2;
  f[o][0] = 1;
  for (int i = 0; i &lt; n; ++i) {
    o ^= 1;
    for (int j = 0; j &lt;= t; ++j)
      f[o][j] = 0;
    for (int j = 0; j &lt;= t; ++j) {
      int cnt1 = sum[i] - 2 * j, cnt0 = t - cnt1 - j;
      if (cnt1 &lt; 0 || cnt0 &lt; 0) continue;
      for (int k = std::max(0, a[i + 1] - cnt0); k &lt;= std::min(cnt1, a[i + 1]); ++k) { // 放在 1 位置的个数
        inc(f[o][j + k], 1ll * f[o ^ 1][j] * C(cnt1, k) % kMod * C(cnt0, a[i + 1] - k) % kMod);
      }
    }
  }
  std::cout &lt;&lt; f[o][t] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18011598.html</id>
    <title type="text">[ABC327G] Many Good Tuple Problems 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-08T01:42:00Z</published>
    <updated>2024-02-08T01:42:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18011598.html" />
    <content type="text">## Description

对于一对长度均为 $M$ 且元素值在 $\left[1, N\right]$ 之间的序列 $(S, T)$，定义其为好的当且仅当：

- 存在一个长度为 $N$ 的 $01$ 序列 $X$，使得其满足如下条件：

    - 对于任意 $i \in \left[1, M\right]$，有 $X_{S_i} \neq X_{T_i}$。

给定 $N, M$，求在所有可能的 $N^{2M}$ 种长度均为 $M$ 且元素值在 $\left[1, N\right]$ 之间的序列对 $(A, B)$ 中，有多少对序列是好的。

对 $998244353$ 取模。

$1 \le N \le 30, 1 \le M \le 10^9$。

## Solution

首先对于两个序列他们合法的条件就是把所有 $S_i$ 和 $T_i$ 连边后是个二分图，于是原题就等价于要求有多少个 $n$ 个点 $m$ 条边的有标号二分图。

先考虑如何求出 $n$ 个点 $m$ 条边的**简单**有标号二分图数量。然后会发现不好把染色方式的影响去掉，所以先不考虑染色方式的影响去做。

设 $f_{n,m}$ 表示 $n$ 个点 $m$ 条边的简单二分图数（染色方式不同算不同的方式），那么可以得到：

$$f_{n,m}=\sum_{i=0}^{n}{\binom{n}{i}\binom{i(n-i)}{m}}$$

但是这个状态无法把连通块个数表示出来，而无法去除染色方式的影响，所以可以考虑求出 $n$ 个点 $m$ 条边的简单**连通**二分图数（染色方式不同算不同的方式），这样只要把方案数除以 $2$ 就能去掉连通图染色方式的影响，最后把再把连通图重组成普通简单二分图即可求出答案。

那么设 $g_{n,m}$ 表示 $n$ 个点 $m$ 条边的简单**连通**二分图数（染色方式不同算不同的方式），可以得到：

$$g_{n,m}=f_{n,m}-\sum_{i=1}^{n-1}\sum_{j=0}^{m}{\binom{n-1}{i-1}\times g_{i,j}\times h_{n-i,m-j}}$$

这个式子就是用总方案减去有至少两个连通块的方案数。

然后设 $h_{n,m}$ 表示 $n$ 个点 $m$ 条边的简单二分图数（染色方式不同算相同的方式），可以得到：

$$h_{n,m}=\frac{\sum_{i=1}^{n}\sum_{j=0}^{m}{\binom{n-1}{i-1}\times g_{i,j}\times h_{n-i,m-i}}}{2}$$

---

最后考虑怎么处理有重边的情况，先设有 $k$ 种边。

题目转化为有一个长度为 $m$ 的序列，序列每个数的取值范围为 $[1,k]$，问有多少个序列满足他们 $k$ 种数都出现过。容易发现直接容斥即可。

时间复杂度：$O(n^6+n^4\log m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 35, kMaxM = 505, kMod = 998244353, kInv2 = 499122177;

int n, m;
int C[kMaxM][kMaxM], pw[kMaxM], f[kMaxN][kMaxM], g[kMaxN][kMaxM], h[kMaxN][kMaxM];

int add(int x, int y) { return (x + y) &gt;= kMod ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x - y) &lt; 0 ? (x - y + kMod) : (x - y); }
void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }
void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? (x += kMod) : x; }

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}

void prework() {
  C[0][0] = 1;
  for (int i = 1; i &lt;= 500; ++i) {
    C[i][0] = 1;
    for (int j = 1; j &lt;= i; ++j)
      C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  prework();
  f[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= i * (i - 1) / 2; ++j) {
      for (int k = 0; k &lt;= i; ++k) {
        inc(f[i][j], 1ll * C[i][k] * C[k * (i - k)][j] % kMod);
      }
    }
  }
  g[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= i * i / 4; ++j) {
      g[i][j] = f[i][j];
      for (int k = 1; k &lt; i; ++k) {
        for (int s = 0; s &lt;= std::min(k * k / 4, j); ++s) {
          dec(g[i][j], 1ll * C[i - 1][k - 1] * g[k][s] % kMod * f[i - k][j - s] % kMod);
        }
      }
      // std::cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; g[i][j] &lt;&lt; '\n';
    }
  }
  h[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= i * i / 4; ++j) {
      for (int k = 1; k &lt;= i; ++k) {
        for (int s = 0; s &lt;= std::min(k * k / 4, j); ++s) {
          inc(h[i][j], 1ll * C[i - 1][k - 1] * g[k][s] % kMod * h[i - k][j - s] % kMod * kInv2 % kMod);
        }
      }
      // std::cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; h[i][j] &lt;&lt; '\n';
    }
  }
  int ans = 0;
  for (int i = 0; i &lt;= std::min(n * (n - 1) / 2, m); ++i) {
    int w = 0;
    for (int j = 0; j &lt;= i; ++j) {
      inc(w, 1ll * (((i - j) &amp; 1) ? (kMod - 1) : 1) * C[i][j] % kMod * qpow(j, m) % kMod);
    }
    inc(ans, 1ll * w * h[n][i] % kMod);
    // std::cerr &lt;&lt; w &lt;&lt; ' ' &lt;&lt; h[n][i] &lt;&lt; '\n';
  }
  std::cout &lt;&lt; 1ll * ans * qpow(2, m) % kMod &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18012212.html</id>
    <title type="text">CF516D Drazil and Morning Exercise 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-08T14:38:00Z</published>
    <updated>2024-02-08T14:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18012212.html" />
    <content type="text">## Description

- 给定一棵 $n$ 个点的树，边有边权。
- 定义 $f_x = \max_{i=1}^n \text{dist}(x,i)$。
- $q$ 次询问最大的满足 $\max_{x \in s} f_x - \min_{x \in s} f_x \le l$ 的连通块 $s$ 包含的点数。
- $n \le 10^5$，$q \le 50$。

## Solution

这里 $f_u$ 显然可以用换根 dp 求出。

但是直接做很难搞，考虑去思考 $f_u$ 的性质。

有一个结论是 $f_u$ 一定是 $u$ 到直径两端点距离中的一个，证明就考虑反证即可。

有了这个性质，如果把树的中心当作根，那么每个点的 $f$ 一定不小于它父亲的 $f$，所以直接枚举连通块的点，那么满足条件的连通块的根一定是条链，搞个树上差分就行了。

时间复杂度：$O(nq\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, q, l, rt;
int f[kMaxN], g[kMaxN], h[kMaxN][2], d[kMaxN], p[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];
std::vector&lt;int&gt; vec;

void dfs1(int u, int fa) {
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    int val = h[v][0] + w;
    if (val &gt;= h[u][0]) h[u][1] = h[u][0], h[u][0] = val;
    else if (val &gt;= h[u][1]) h[u][1] = val;
  }
}

void dfs2(int u, int fa) {
  f[u] = std::max(g[u], h[u][0]);
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    g[v] = std::max(g[u], h[u][h[v][0] + w == h[u][0]]) + w;
    dfs2(v, u);
  }
}

void dfs3(int u, int fa) {
  p[u] = fa;
  vec.emplace_back(u);
  int L = -1, R = vec.size(), res = vec.size() - 1;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (f[vec[mid]] &gt;= f[u] - l) R = res = mid;
    else L = mid;
  }
  --d[p[vec[res]]], ++d[u];
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    dfs3(v, u);
  }
  vec.pop_back();
}

void dfs4(int u, int fa) {
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    dfs4(v, u);
    d[u] += d[v];
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
  }
  dfs1(1, 0), dfs2(1, 0);
  rt = std::min_element(f + 1, f + 1 + n) - f;
  std::cin &gt;&gt; q;
  for (int cs = 1; cs &lt;= q; ++cs) {
    std::cin &gt;&gt; l;
    std::fill_n(d + 1, n, 0);
    dfs3(rt, 0), dfs4(rt, 0);
    std::cout &lt;&lt; *std::max_element(d + 1, d + 1 + n) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18012546.html</id>
    <title type="text">P9170 [省选联考 2023] 填数游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-09T09:57:00Z</published>
    <updated>2024-02-09T09:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18012546.html" />
    <content type="text">## Description

众所周知，Alice 和 Bob 是一对好朋友。今天，他们约好一起玩游戏。

一开始，他们各自有一张空白的纸条。接下来，他们会在纸条上依次写 $n$ 个 $[1,m]$ 范围内的正整数。等 Alice 写完，Bob **在看到 Alice 写的纸条之后开始写他的纸条**。

Alice 需要保证她写下的第 $i$ 个数在集合 $S_{i}$ 中，Bob 需要保证他写下的第 $i$ 个数在集合 $T_{i}$ 中。**题目保证** $1 \leq\left|S_{i}\right|,\left|T_{i}\right| \leq 2$ 。

Alice 喜欢相同，因此，她希望她写下的数与 Bob 写下的数对应位置相同的个数尽量多。Bob 喜欢不同，因此，他希望他写下的 $n$ 个数 $b_{1}, \ldots, b_{n}$ 互不相同。在此基础上，Bob 希望他写下的数与 Alice 写下的数对应位置相同的个数尽量少。

即设 Alice 写下的数为 $a_{1}, \ldots, a_{n}$，Bob 写下的数为 $b_{1}, \ldots, b_{n}$，记 $X$ 为满足 $1 \leq i \leq n, a_{i}=b_{i}$ 的下标 $i$ 的个数，则

- Alice 希望最大化 $X,$
- Bob 在**保证 $b_{1}, \ldots, b_{n}$ 互不相同的前提下**希望最小化 $X$。

你首先想知道 Bob 能否保证他写下的 $n$ 个数互不相同。如果 Bob 能够做到，你想知道**在双方均采取最优策略的前提下** $X$ 的值会是多少。

$n,m\leq 10^6,\sum n,\sum m\leq 1.5\times 10^6$。

## Solution

这题 Bob **在看到 Alice 写的纸条之后才开始写他的纸条**！！

先做特殊性质 A。这个就是让你判断 $b_1,\dots,b_n$ 能否互不相同。

考虑把所有 $T_{i,0}$ 和 $T_{i,1}$ 连边（如果 $|T|=1$，就连一条 $T_{i,0}$ 的自环），题目就转化为将一个图中的边定向，使得每个点的入度不超过 $1$。

容易发现对于每个连通块，如果边数大于点数就一定不合法，否则这个连通块是个树或者基环树，一定合法。

---

然后考虑怎么对一个基环树求答案。

容易发现基环树除掉环的边的方向是定好的，只有环上的边有两种可能。设环的大小为 $k$。

所以 Alice 就只要在这 $k$ 条边对应的 $k$ 个集合中每个集合选一个数，使得两种方向答案的 $\min$ 值最大。

首先对于 $|S_i\cap T_i|=0$ 的边，显然没有贡献。$|S_i\cap T_i|=1$ 的边，肯定选择那个交的数，这相当于已经确定了选的数。$|S_i\cap T_i|=2$ 的边，就只能对于两种方向的一种产生贡献。

设 $c_u$ 表示已经确定的数中第一种方向已有的贡献，$c_u$ 表示已经确定的数中第二种方向已有的贡献，$c$ 表示待确定的集合数量。

那么答案就是：

$$\max_{i=0}^{c}{\left\{\min\{c_u+i,c_v+c-i\}\right\}}$$

这个暴力求就行了。

这一部分的时间复杂度：$O(n)$。

---

然后考虑树的情况。

显然定向方式就是选定一个点作为根的外向树。

对于交为 $1$ 的边 $u\to v$，如果 $u$ 是交的数，那么根一定在 $v$ 的子树里，否则根一定在 $v$ 的子树外。

这一部分的贡献可以用 dfs 序上差分维护。

设 $f_i$ 表示以 $i$ 为根的答案。

然后题目转化为对于所有交为 $2$ 的边 $u\to v$，要选择把 $v$ 子树内或子树外的 $f$ 全加一，使得最后 $\min\{f_1,\dots,f_n\}$ 最大。

观察可知如果两个点他们要将 $f$ 加一的集合不交，则把这两个集合都换成原来的补集一定更优。

所以对于两个点 $u,v$，如果 $u$ 是 $v$ 的祖先，那么不能出现 $u$ 选子树外和 $v$ 选子树内的情况。如果 $u$ 不是 $v$ 祖先，那么不能出现 $u$ 和 $v$ 都选子树外。

于是根据这两个性质可以得到选子树的点一定构成一个到根的链，然后 dfs 一边用线段树维护答案即可。

这一部分的时间复杂度：$O(n\log n)$。

所以总的时间复杂度就是 $O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }
 
char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) { while (*x) putc(*x++); }
void write(const char *x) { while (*x) putc(*x++); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 1e6 + 5;

int n, m;
int cnt[kMaxN], fa[kMaxN], sz[kMaxN], cnted[kMaxN];
std::vector&lt;int&gt; s[kMaxN], t[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) {
    fa[fx] = fy, sz[fy] += sz[fx], cnted[fy] += cnted[fx];
  }
  ++cnted[fy];
}

void addedge(int u, int v, int id) {
  G[u].emplace_back(v, id), unionn(u, v);
  if (u != v) G[v].emplace_back(u, id);
}

namespace Cycle {
int res, p[kMaxN], pid[kMaxN], dep[kMaxN];
bool vis[kMaxN], onc[kMaxN];
std::vector&lt;int&gt; circ, circ_v;

void clear() {
  std::fill_n(vis + 1, m, 0);
  std::fill_n(onc + 1, m, 0);
  std::fill_n(p + 1, m, 0);
}

void dfs1(int u, int fa, int faid) {
  p[u] = fa, dep[u] = dep[fa] + 1, vis[u] = 1;
  for (auto [v, id] : G[u]) {
    if (id == faid) continue;
    if (!vis[v]) {
      pid[v] = id, dfs1(v, u, id);
    } else if (dep[u] &gt;= dep[v]) {
      for (int i = u; i != v; i = p[i]) {
        circ.emplace_back(pid[i]);
        circ_v.emplace_back(i);
        onc[i] = 1;
      }
      circ.emplace_back(id), onc[v] = 1, circ_v.emplace_back(v);
    }
  }
}

void dfs2(int u, int fa) {
  for (auto [v, id] : G[u]) {
    if (v == fa || onc[v]) continue;
    res += (v == s[id][0] || v == s[id].back());
    dfs2(v, u);
  }
}

int solve(int rt) {
  res = 0, circ.clear(), circ_v.clear(), dfs1(rt, 0, 0);
  for (auto x : circ_v) dfs2(x, 0);
  assert(circ.size() == circ_v.size());
  int cu = 0, cv = 0, c = 0;
  for (int i = 0; i &lt; circ.size(); ++i) {
    if (cnt[circ[i]] == 1) {
      if (circ_v[i] == s[circ[i]][0] || circ_v[i] == s[circ[i]].back()) ++cu;
      else ++cv;
    } else if (cnt[circ[i]] == 2) {
      ++c;
    }
  }
  if (circ.size() == 1) c *= 2;
  return res + (abs(cu - cv) &lt;= c ? (cu + cv + c) / 2 : std::min(cu, cv) + c);
}
} // namespace Cycle

namespace Tree {
struct SGT {
  int mi[kMaxN * 4], tag[kMaxN * 4];

  void pushup(int x) {
    mi[x] = std::min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]);
  }

  void addtag(int x, int v) {
    mi[x] += v, tag[x] += v;
  }

  void pushdown(int x) {
    if (!tag[x]) return;
    addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
    tag[x] = 0;
  }

  void build(int x, int l, int r) {
    mi[x] = tag[x] = 0;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) {
      return;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return addtag(x, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }
} sgt;

int res, dfnc;
int dfn[kMaxN], sz[kMaxN];

void dfs1(int u, int fa) {
  dfn[u] = ++dfnc, sz[u] = 1;
  for (auto [v, id] : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
  }
}

void dfs2(int u, int fa) {
  for (auto [v, id] : G[u]) {
    if (v == fa) continue;
    if (cnt[id] == 1) {
      if (v == s[id][0] || v == s[id].back()) {
        sgt.update(1, 1, dfnc, 1, dfn[v] - 1, 1), sgt.update(1, 1, dfnc, dfn[v] + sz[v], dfnc, 1);
      } else {
        sgt.update(1, 1, dfnc, dfn[v], dfn[v] + sz[v] - 1, 1);
      }
    } else if (cnt[id] == 2) {
      sgt.update(1, 1, dfnc, 1, dfn[v] - 1, 1), sgt.update(1, 1, dfnc, dfn[v] + sz[v], dfnc, 1);
    }
    dfs2(v, u);
  }
}

void dfs3(int u, int fa) {
  res = std::max(res, sgt.mi[1]);
  for (auto [v, id] : G[u]) {
    if (v == fa) continue;
    if (cnt[id] == 2) {
      sgt.update(1, 1, dfnc, 1, dfn[v] - 1, -1);
      sgt.update(1, 1, dfnc, dfn[v] + sz[v], dfnc, -1);
      sgt.update(1, 1, dfnc, dfn[v], dfn[v] + sz[v] - 1, 1);
    }
    dfs3(v, u);
    if (cnt[id] == 2) {
      sgt.update(1, 1, dfnc, 1, dfn[v] - 1, 1);
      sgt.update(1, 1, dfnc, dfn[v] + sz[v], dfnc, 1);
      sgt.update(1, 1, dfnc, dfn[v], dfn[v] + sz[v] - 1, -1);
    }
  }
}

int solve(int rt) {
  res = dfnc = 0;
  dfs1(rt, 0);
  sgt.build(1, 1, dfnc);
  dfs2(rt, 0), dfs3(rt, 0);
  return res;
}
} // namespace Tree

void dickdreamer() {
  read(n, m);
  for (int i = 1; i &lt;= m; ++i) {
    G[i].clear();
    fa[i] = i, sz[i] = 1, cnted[i] = 0;
  }
  Cycle::clear();
  for (int i = 1; i &lt;= n; ++i) {
    int c;
    read(c);
    s[i].clear();
    for (int j = 1; j &lt;= c; ++j) {
      int x;
      read(x);
      s[i].emplace_back(x);
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    int c;
    read(c);
    cnt[i] = 0, t[i].clear();
    for (int j = 1; j &lt;= c; ++j) {
      int x;
      read(x);
      t[i].emplace_back(x);
      for (auto y : s[i]) cnt[i] += (x == y);
    }
    if (c == 1) cnt[i] *= 2;
    if (c == 1) addedge(t[i][0], t[i][0], i);
    else addedge(t[i][0], t[i][1], i);
  }
  int ans = 0;
  for (int i = 1; i &lt;= m; ++i) {
    if (i == find(i)) {
      if (cnted[i] &gt; sz[i]) return void(write("-1\n"));
      else if (cnted[i] == sz[i]) ans += Cycle::solve(i);
      else ans += Tree::solve(i);
    }
  }
  write(ans, '\n');
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int T = 1;
  read(T);
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18013097.html</id>
    <title type="text">P4183 [USACO18JAN] Cow at Large P 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-10T15:13:00Z</published>
    <updated>2024-02-10T15:13:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18013097.html" />
    <content type="text">## Description

贝茜被农民们逼进了一个偏僻的农场。农场可视为一棵有 $N$   个结点的树，结点分别编号为 $1,2,\ldots, N$  。每个叶子结点都是出入口。开始时，每个出入口都可以放一个农民（也可以不放）。每个时刻，贝茜和农民都可以移动到相邻的一个结点。如果某一时刻农民与贝茜相遇了（在边上或点上均算），则贝茜将被抓住。抓捕过程中，农民们与贝茜均知道对方在哪个结点。

请问：对于结点 $i\,(1\le i\le N)$  ，如果开始时贝茜在该结点，最少有多少农民，她才会被抓住。

$2\leq N\leq 7\times 10^4$。

## Solution

先考虑固定起点怎么做。

首先每个叶子一定是每次往父亲跳，那么设 $len_i$ 表示 $i$ 到 $i$ 子树里叶子的最短距离。

那么如果 $len_i&gt;dis_i$，则无论 $i$ 的子树怎么放都无法在 $i$ 点拦截贝茜。否则只要在离 $i$ 最近的点放一个奶牛就能在 $i$ 点拦截且贝茜不可能走到 $i$ 子树里的其他点。

容易发现这些放的奶牛是不重的。

所以答案就是所有 $len_i\leq dis_i$ 且 $len_{fa_{i}}&gt;dis_{fa_i}$ 的 $i$ 的个数。

这样做是 $O(n^2)$ 的。

---

考虑优化。

继续固定起点。容易发现这个题目等价于问有多少个子树，子树的根 $i$ 满足 $len_i\leq dis_i$ 且 $len_{fa_{i}}&gt;dis_{fa_i}$。

设 $deg_i$ 表示 $i$ 的度数。

则对于一个大小为 $m$ 的子树 $S$，且子树的根不为原树的根，那么 $\sum_{u\in S}{deg_u}=2m-1$，转化一下就是：$\sum_{u\in S}{(2-deg_u)}=1$。

所以这个子树的价值可以换为子树里 $(2-deg_i)$ 的和。

又注意到如果子树的根 $r$ 满足 $len_r\leq dis_r$ 那么整个子树都满足这个条件。

所以整个树的答案就是：$\sum_{i=1}^{n}{[len_i\leq dis_i]\times (2-deg_i)}$。

然后把这个式子用点分治做即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 7e4 + 5;

int n, rt;
int ans[kMaxN], f[kMaxN], deg[kMaxN], sz[kMaxN], mx[kMaxN];
bool del[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
std::vector&lt;int&gt; G[kMaxN];

struct BIT {
  int c[kMaxN * 2];

  void upd(int x, int v) {
    x += n + 1;
    for (; x &lt;= 2 * n + 1; x += x &amp; -x) c[x] += v;
  }

  int qry(int x) {
    x += n + 1;
    int ret = 0;
    for (; x; x -= x &amp; -x) ret += c[x];
    return ret;
  }
  int qry(int l, int r) { return qry(r) - qry(l - 1); }
} bit;

void pre_dfs1(int u, int fa) {
  if (G[u].size() == 1) f[u] = 0;
  else f[u] = 1e9;
  deg[u] = G[u].size();
  for (auto v : G[u]) {
    if (v == fa) continue;
    pre_dfs1(v, u);
    f[u] = std::min(f[u], f[v] + 1);
  }
}

void pre_dfs2(int u, int fa) {
  for (auto v : G[u]) {
    if (v == fa) continue;
    f[v] = std::min(f[v], f[u] + 1);
    pre_dfs2(v, u);
  }
}

void getsz(int u, int fa) {
  sz[u] = 1, mx[u] = 0;
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    getsz(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
  }
}

void getrt(int u, int fa, int tot) {
  mx[u] = std::max(mx[u], tot - sz[u]);
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    getrt(v, u, tot);
  }
  if (mx[u] &lt; mx[rt]) rt = u;
}

void dfs2(int u, int fa, int dis) {
  ans[u] += bit.qry(-n, dis);
  vec.emplace_back(f[u] - dis, 2 - deg[u]);
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    dfs2(v, u, dis + 1);
  }
}

void dfs1(int u, int fa) {
  bit.upd(f[u], 2 - deg[u]);
  vec = {{f[u], 2 - deg[u]}};
  int lst = 1;
  for (int i = 0; i &lt; G[u].size(); ++i) {
    int v = G[u][i];
    if (v == fa || del[v]) continue;
    dfs2(v, u, 1);
    for (int i = lst; i &lt; vec.size(); ++i) bit.upd(vec[i].first, vec[i].second);
    lst = vec.size();
  }
  for (auto [x, v] : vec) bit.upd(x, -v);
  vec.clear(), lst = 0;
  for (int i = (int)G[u].size() - 1; ~i; --i) {
    int v = G[u][i];
    if (v == fa || del[v]) continue;
    dfs2(v, u, 1);
    for (int i = lst; i &lt; vec.size(); ++i) bit.upd(vec[i].first, vec[i].second);
    lst = vec.size();
  }
  ans[u] += bit.qry(-n, 0);
  for (auto [x, v] : vec) bit.upd(x, -v);
  vec.clear();

  del[u] = 1;
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    rt = 0, getsz(v, u), getrt(v, u, sz[v]), dfs1(rt, 0);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  pre_dfs1(1, 0), pre_dfs2(1, 0);
  mx[0] = 1e9, getsz(1, 0), getrt(1, 0, n), dfs1(rt, 0);
  for (int i = 1; i &lt;= n; ++i) {
    std::cout &lt;&lt; (deg[i] != 1 ? ans[i] : 1) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18015057.html</id>
    <title type="text">20240213 模拟赛 T3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-14T01:58:00Z</published>
    <updated>2024-02-14T01:58:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18015057.html" />
    <content type="text">## Description

在坐标平面上有 $n$ 个矩形，边平行于坐标轴。第 $i$ 个矩形覆盖了所有满足 $l_i\le x\le r_i$ 和 $d_i\le y\le u_i$ 的点 $(x,y)$。

为简单起见，对于每个 $i\neq j$，我们有 $l_i\neq l_j,r_i\neq r_j, l_i\neq r_j , d_i\neq d_j , u_i\neq u_j, d_i\neq u_j$。

计算满足 $1\le i&lt; j &lt; k \le n$ 且第 $i,j$ 和 $k$ 个矩形两两不相交（它们之间没有共同点）的三元组 $(i,j,k)$ 的数量。

$1\leq n\leq 2\times 10^5$。

## Solution

考虑容斥。

答案可以写成钦定 $0$ 个交 - 钦定 $1$ 个交 + 钦定 $2$ 个交 - 钦定 $3$ 个交。

容易发现如果把相交的两个矩形连一条边，那么 $1$ 和 $2$ 就只跟每个点的度数有关，而 $3$ 就是求三元环数。

先考虑如何求度数。

显然可以扫描线，对于一个点 $i$ 的度数，可以用 $l_j&lt;l_i$ 的相交数 + $l_j\leq r_i$ 的相交数 - $l_j\leq l_i$ 的相交数表示。

所以只要维护 $l$ 和 $r$ 的树状数组，用 $l_j\leq l_i$ 的个数 - $r_j\leq l_i$ 的个数就是答案。

---

然后是如何求三元环。

由于这里只需要求三元环的个数，所以可以在三元环中 $l$ 最大的点算贡献。

也考虑扫描线，设 $cnt_i$ 表示 $i$ 被 $[l_j,r_j]$ 覆盖的个数。

有一个假做法是对于每个 $i$，把 $\sum_{j=l_i}^{r_i}{\binom{cnt_j}{2}}$ 算成贡献，但是这样显然会算重，这个求的是 $y$ 轴点交的大小和。

观察到对于一个交，它的点数 - 边数一定是 $1$，所以答案等于点交大小和 - 边交大小和，这个同样维护即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int l[kMaxN], r[kMaxN], u[kMaxN], d[kMaxN], deg[kMaxN], op[kMaxN * 2], id[kMaxN * 2];

int64_t C(int m, int n) {
  if (n == 0) return 1;
  else if (n == 1) return m;
  else if (n == 2) return 1ll * m * (m - 1) / 2;
  else return 1ll * m * (m - 1) * (m - 2) / 6;
}

struct BIT {
  int c[kMaxN * 2];

  void upd(int x, int v) {
    for (; x &lt;= 2 * n; x += x &amp; -x) c[x] += v;
  }

  int qry(int x) {
    int ret = 0;
    for (; x; x -= x &amp; -x) ret += c[x];
    return ret;
  }
} bit1, bit2;

struct SGT {
  int64_t sum[kMaxN * 8][3], tag[kMaxN * 8];

  void pushup(int x) {
    for (int i = 0; i &lt;= 2; ++i)
      sum[x][i] = sum[x &lt;&lt; 1][i] + sum[x &lt;&lt; 1 | 1][i];
  }

  void addtag(int x, int64_t v) {
    tag[x] += v;
    for (int i = 2; ~i; --i) {
      for (int j = i - 1; ~j; --j)
        sum[x][i] += sum[x][j] * C(v, i - j);
    }
  }

  void pushdown(int x) {
    if (!tag[x]) return;
    addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
    tag[x] = 0;
  }

  void build(int x, int l, int r) {
    sum[x][0] = 1;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) {
      return;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return addtag(x, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int64_t query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) {
      return 0;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return sum[x][2];
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return query(x &lt;&lt; 1, l, mid, ql, qr) + query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }
} sgt1, sgt2;

void discrete(int *a, int *b) {
  static int unq[kMaxN * 2];
  int m = 0;
  for (int i = 1; i &lt;= n; ++i) {
    unq[++m] = a[i];
    unq[++m] = b[i];
  }
  std::sort(unq + 1, unq + 1 + m);
  m = std::unique(unq + 1, unq + 1 + m) - (unq + 1);
  for (int i = 1; i &lt;= n; ++i) {
    a[i] = std::lower_bound(unq + 1, unq + 1 + m, a[i]) - unq;
    b[i] = std::lower_bound(unq + 1, unq + 1 + m, b[i]) - unq;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; l[i] &gt;&gt; r[i] &gt;&gt; d[i] &gt;&gt; u[i];
  if (n &lt;= 2) return void(std::cout &lt;&lt; "0\n");
  discrete(l, r), discrete(d, u);
  for (int i = 1; i &lt;= n; ++i) {
    op[l[i]] = 1, op[r[i]] = -1;
    id[l[i]] = id[r[i]] = i;
  }
  for (int i = 1; i &lt;= 2 * n; ++i) {
    if (op[i] == 1) deg[id[i]] += bit1.qry(u[id[i]]) - bit2.qry(d[id[i]] - 1);
    bit1.upd(d[id[i]], op[i]), bit2.upd(u[id[i]], op[i]);
  }
  for (int i = 1; i &lt;= 2 * n; ++i) {
    if (op[i] == 1) bit1.upd(d[id[i]], op[i]), bit2.upd(u[id[i]], op[i]);
    deg[id[i]] += (-op[i]) * (bit1.qry(u[id[i]]) - bit2.qry(d[id[i]] - 1));
  }
  int64_t ans = 0;
  for (int i = 1; i &lt;= n; ++i) {
    ans -= 1ll * deg[i] * (n - 2);
  }
  ans = ans / 2 + C(n, 3);
  for (int i = 1; i &lt;= n; ++i) {
    ans += C(deg[i], 2);
  }
  sgt1.build(1, 1, 2 * n), sgt2.build(1, 1, 2 * n);
  for (int i = 1; i &lt;= 2 * n; ++i) {
    if (op[i] == 1) {
      ans -= sgt1.query(1, 1, 2 * n, d[id[i]], u[id[i]]) - sgt2.query(1, 1, 2 * n, d[id[i]], u[id[i]] - 1);
    }
    sgt1.update(1, 1, 2 * n, d[id[i]], u[id[i]], op[i]), sgt2.update(1, 1, 2 * n, d[id[i]], u[id[i]] - 1, op[i]);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("rectangle.in", "r", stdin);
  freopen("rectangle.out", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18015264.html</id>
    <title type="text">LOJ #2876. 「JOISC 2014 Day2」水壶 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-14T08:10:00Z</published>
    <updated>2024-02-14T08:10:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18015264.html" />
    <content type="text">## Description

JOI 君所居住的 IOI 市以一年四季都十分炎热著称。

IOI 市被分成 $H$ 行，每行包含 $W$ 块区域。每个区域都是建筑物、原野、墙壁之一。
IOI 市有 $P$ 个区域是建筑物，坐标分别为 $(A_1, B_1),$ $(A_2, B_2),$ $\ldots,$ $(A_P, B_P)$。
JOI 君只能进入建筑物与原野，而且每次只能走到相邻的区域中，且不能移动到市外。

JOI 君因为各种各样的事情，必须在各个建筑物之间往返。虽然建筑物中的冷气设备非常好，但原野上太阳非常毒辣，因此在原野上每走过一个区域都需要 1 升水。此外，原野上没有诸如自动售货机、饮水处之类的东西，因此 IOI 市的市民一般都携带水壶出行。大小为 $x$ 的水壶最多可以装 $x$ 升水，建筑物里有自来水可以将水壶装满。
由于携带大水壶是一件很困难的事情，因此 JOI 君决定携带尽量小的水壶移动。因此，为了随时能在建筑物之间移动，请你帮他写一个程序来计算最少需要多大的水壶。

现在给出 IOI 市的地图和 $Q$ 个询问，第 $i$ 个询问包含两个整数 $S_i,$ $T_i$，对于每个询问，请输出：要从建筑物 $S_i$ 移动到 $T_i$，至少需要多大的水壶？

数据范围：$H,W\leq2000$，$P,Q\leq2\times10^5$，$1\leq S_i,T_i\leq P$。

## Solution

首先对于任意两个建筑物连一条边权为他们的距离的边，那么对于每个询问，显然就是求最小瓶颈生成树两点间的最大权值。

考虑如何建出这个最小生成树。

可以先 bfs 求出距离每个原野最近的建筑物，那么对于每个建筑物，他管辖的原野一定是个连通块，考虑对于连通块有相邻边的两个建筑物连边，然后跑 kruskal 最小生成树。

感性理解一下，这样做显然能够连出一个生成树，并且对于每个点都保存了离他最近的几条边，所以这样做肯定能求出最小生成树。

时间复杂度：$O\left(HW+(P+Q)\log P\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxH = 2e3 + 5, kMaxP = 2e5 + 5, kMaxE = 4e6 + 5;
const int kDx[] = {0, 0, 1, -1}, kDy[] = {1, -1, 0, 0};

int h, w, p, q;
int a[kMaxP], b[kMaxP], fa[kMaxP][19], faw[kMaxP][19], dep[kMaxP], lg[kMaxP];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxP];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; ed;
std::string s[kMaxH];

struct DSU {
  std::vector&lt;int&gt; fa;

  void init(int _n) { fa.resize(_n + 1), std::iota(fa.begin(), fa.end(), 0); }
  
  DSU() {}
  DSU(int _n) { init(_n); }

  int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
  }

  void unionn(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy) fa[fx] = fy;
  }
} dsu;

void bfs() {
  static int dis[kMaxH][kMaxH], idx[kMaxH][kMaxH];
  for (int i = 1; i &lt;= h; ++i) {
    for (int j = 1; j &lt;= w; ++j) {
      dis[i][j] = idx[i][j] = -1;
    }
  }
  std::queue&lt;std::tuple&lt;int, int, int&gt;&gt; q;
  for (int i = 1; i &lt;= p; ++i) {
    dis[a[i]][b[i]] = 0, idx[a[i]][b[i]] = i;
    q.emplace(a[i], b[i], i);
  }
  for (; !q.empty();) {
    auto [x, y, id] = q.front();
    q.pop();
    for (int k = 0; k &lt; 4; ++k) {
      int tx = x + kDx[k], ty = y + kDy[k];
      if (tx &lt; 1 || tx &gt; h || ty &lt; 1 || ty &gt; w || s[tx][ty] == '#') continue;
      if (!~idx[tx][ty]) {
        dis[tx][ty] = dis[x][y] + 1, idx[tx][ty] = id;
        q.emplace(tx, ty, id);
      } else if (idx[tx][ty] != id) {
        ed.emplace_back(dis[x][y] + dis[tx][ty], id, idx[tx][ty]);
      }
    }
  }
}

void kruskal() {
  dsu.init(p);
  std::sort(ed.begin(), ed.end());
  for (auto [w, u, v] : ed) {
    if (dsu.find(u) != dsu.find(v)) {
      dsu.unionn(u, v), G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    }
  }
}

void dfs(int u, int fa) {
  ::fa[u][0] = fa, dep[u] = dep[fa] + 1;
  for (int i = 1; i &lt;= lg[p]; ++i) {
    ::fa[u][i] = ::fa[::fa[u][i - 1]][i - 1];
    faw[u][i] = std::max(faw[u][i - 1], faw[::fa[u][i - 1]][i - 1]);
  }
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    faw[v][0] = w;
    dfs(v, u);
  }
}

void lca_prework() {
  lg[0] = -1;
  for (int i = 1; i &lt;= p; ++i)
    lg[i] = lg[i &gt;&gt; 1] + 1;
  for (int i = 1; i &lt;= p; ++i) {
    if (!dep[i]) {
      dfs(i, 0);
    }
  }
}

int getans(int x, int y, int id = 0) {
  if (dep[x] &lt; dep[y]) std::swap(x, y);
  int ret = 0;
  for (int i = lg[p]; ~i; --i)
    if (dep[fa[x][i]] &gt;= dep[y])
      ret = std::max(ret, faw[x][i]), x = fa[x][i];
  if (x == y) return ret;
  for (int i = lg[p]; ~i; --i) {
    if (fa[x][i] != fa[y][i]) {
      ret = std::max({ret, faw[x][i], faw[y][i]});
      x = fa[x][i], y = fa[y][i];
    }
  }
  return std::max({ret, faw[x][0], faw[y][0]});
}

void dickdreamer() {
  std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; p &gt;&gt; q;
  for (int i = 1; i &lt;= h; ++i) {
    std::cin &gt;&gt; s[i];
    s[i] = " " + s[i];
  }
  for (int i = 1; i &lt;= p; ++i)
    std::cin &gt;&gt; a[i] &gt;&gt; b[i];
  bfs(), kruskal(), lca_prework();
  for (int i = 1; i &lt;= q; ++i) {
    int s, t;
    std::cin &gt;&gt; s &gt;&gt; t;
    std::cout &lt;&lt; (dsu.find(s) == dsu.find(t) ? getans(s, t, i) : -1) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18017501.html</id>
    <title type="text">20240216 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-16T13:37:00Z</published>
    <updated>2024-02-16T13:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18017501.html" />
    <content type="text">## Description

$\text{H}$ 国的国王想要画一幅画，该幅画由黑白两种颜色组成，长 $n$ 个像素，宽 $m$ 个像素。作为国师的你需要使用魔法将它绘制到一张白纸上。

国师有两种魔法，第一种魔法可以选择一个 $1\times x$ 或者 $x\times 1$ 的矩形，将其绘制成黑色或者白色，消耗 $Ax + B$ 的代价。第二种魔法可以选择一个 $1\times 1$ 的像素，将其绘制成黑色或者白色，消耗 $C$ 的代价。

但是由于 $\text{H}$ 国的颜料产业还处于发展阶段，颜料很容易发生混杂。具体来说，如果一个像素先被白色颜料绘制，再被黑色颜料绘制，那么它会变成一种奇怪的颜色。**但是反过来先用黑色再用白色不会发生这种情况**。

同时，如果一个像素被重复绘制 $3$ 次及以上，那么这个像素的颜料会扩散，也会变成一种奇怪的颜色。

除此之外，颜料的覆盖是允许的，并且该像素点的颜色由最后一次绘制的颜料决定。特别的，如果一个像素没有被任何颜料绘制，那么它会显示纸张的底色即白色。

作为国师的你希望通过最少的代价绘制出 $\text{H}$ 国国王想要的画。你想要知道代价最小是多少。

## Solution

容易发现同一行或者同一列两种相同颜色的矩形一定不相交，并且先涂 $1$ 操作黑色 $\to 1$ 操作白色 $\to 2$ 操作一定最优。

考虑最小割，转化为代数形式，形如 $\sum{a_i\overline{b_j}w_{i,j}}$，这样只要连一条 $i\to j$ 流量为 $w_{i,j}$ 的边，然后如果 $i$ 和源点在一起，$j$ 和汇点在一起即可造成贡献。

设 $a_{i,j}$ 表示 $(i,j)$ 被行染成了黑色，$b_{i,j}$ 表示 $(i,j)$ 被行染成了白色，$c_{i,j}$ 表示 $(i,j)$ 被列染成了黑色，$d_{i,j}$ 表示 $(i,j)$ 被列染成了白色。

先考虑操作 $1$ 的贡献。对于 $(i,j)$ 染黑的贡献显然是 $A\times a_{i,j}+B\times a_{i,j}\times \overline{a_{i,j+1}}+A\times c_{i,j}+B\times c_{i,j}\times \overline{c_{i+1,j}}$，染白同理。

然后是操作 $2$ 的贡献。

先是黑点：如果操作 $1$ 被染成了白色，那么显然不行，所以是 $\infty\times(b_{i,j}+d_{i,j})$。然后如果操作 $1$ 没被染成黑色就要有 $C$ 的贡献，所以是 $C\times(\overline{a_{i,j}}\times\overline{c_{i,j}})$。

再是白点：如果操作 $1$ 染了两次白色，显然不行，所以是 $\infty\times(a_{i,j}\times c_{i,j})$。然后如果操作 $1$ 没被染成白色就要有 $C$ 的贡献，所以是 $C\times(a_{i,j}\times\overline{d_{i,j}}+c_{i,j}\times\overline{b_{i,j}})$。

把总的贡献写出来后发现 $\overline{a_{i,j}}\times\overline{c_{i,j}}$ 是不合法的，所以把 $b_{i,j}$ 变为 $\overline{b_{i,j}}$，$c_{i,j}$ 变为 $\overline{c_{i,j}}$ 即可。

然后跑网络流即可。

时间复杂度：$O(n^3 m^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 45, kMaxS = 6405, kMaxM = kMaxS * 10, kInf = 1e12;

int n, m, A, B, C, s, t;

int getid(int k, int x, int y) {
  return (k - 1) * n * m + (x - 1) * m + y;
}

namespace Dinic {
struct Edge {
  int v, w, pre;
} e[kMaxM];

int tot = 1;
int tail[kMaxS], cur[kMaxS], dep[kMaxS];

void clear() {
  for (int i = 1; i &lt;= t; ++i) {
    tail[i] = cur[i] = dep[i] = 0;
  }
  for (int i = 1; i &lt;= tot; ++i) {
    e[i].v = e[i].w = e[i].pre = 0;
  }
  tot = 1;
}

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }

bool bfs() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= std::max(t, n); ++i) {
    dep[i] = 1e9, cur[i] = tail[i];
  }
  q.emplace(s), dep[s] = 1;
  for (; !q.empty();) {
    int u = q.front();
    q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v;
      if (!e[i].w || dep[v] != 1e9) continue;
      dep[v] = dep[u] + 1, q.emplace(v);
    }
  }
  return dep[t] != 1e9;
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = 1e9;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

int64_t maxflow() {
  int64_t ans = 0;
  for (; bfs(); ans += dfs(s, 1e18)) {}
  return ans;
}
} // namespace Dinic

void dickdreamer() {
  Dinic::clear();
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; A &gt;&gt; B &gt;&gt; C;
  s = getid(4, n, m) + 1, t = getid(4, n, m) + 2;
  for (int i = 1; i &lt;= n; ++i) {
    std::string str;
    std::cin &gt;&gt; str;
    str = " " + str;
    for (int j = 1; j &lt;= m; ++j) {
      for (int k = 1; k &lt;= 4; ++k) {
        Dinic::add(s, getid(k, i, j), kInf + A * (k == 2 || k == 3));
        Dinic::add(getid(k, i, j), t, kInf + A * (k == 1 || k == 4));
      }

      if (j &lt; m) {
        Dinic::add(getid(1, i, j), getid(1, i, j + 1), B);
        Dinic::add(getid(2, i, j + 1), getid(2, i, j), B);
      } else {
        Dinic::add(getid(1, i, j), t, B);
        Dinic::add(s, getid(2, i, j), B);
      }

      if (i &lt; n) {
        Dinic::add(getid(3, i + 1, j), getid(3, i, j), B);
        Dinic::add(getid(4, i, j), getid(4, i + 1, j), B);
      } else {
        Dinic::add(s, getid(3, i, j), B);
        Dinic::add(getid(4, i, j), t, B);
      }

      if (str[j] == '1') {
        Dinic::add(getid(3, i, j), getid(1, i, j), C);
        Dinic::add(s, getid(2, i, j), kInf);
        Dinic::add(getid(4, i, j), t, kInf);
      } else {
        Dinic::add(getid(1, i, j), getid(4, i, j), C);
        Dinic::add(getid(2, i, j), getid(3, i, j), C);
        Dinic::add(getid(1, i, j), getid(3, i, j), C);
      }
    }
  }
  std::cout &lt;&lt; Dinic::maxflow() - 4ll * n * m * kInf &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("magic.in", "r", stdin);
  freopen("magic.out", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18017832.html</id>
    <title type="text">[AGC040C] Neither AB nor BA 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-17T03:46:00Z</published>
    <updated>2024-02-17T03:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18017832.html" />
    <content type="text">## Description

给出一个大于0的偶数 $N$ 。

请找出长度为 $N$ ，由 `A`，`B`，`C` 这三个字母组成且可以由下列规则把其变为空串的字符串 $s$ 的数量。

- 不断选择 $s$ 中任意除 `AB` 和 `BA` 外的长度为 $2$ 的子串并删除。

比如 `ABBC` 是 $N=4$ 条件下的一个合法字符串，因为我们可以通过这样的方式将其变为空串：`ABBC` →（删除 `BB`）→`AC`→（删除`AC`）→`(空串)`

答案可能很大，所以请将结果对 $998244353$ 取模。

$N\leq 10^7$。

## Solution

注意到如果把奇数位染成黑色，偶数位染成白色，那么每次操作一定是删除一个黑格一个白格。

所以同色位置之间是没有影响的，那么把黑色位置的 `AB` 反转，题目就等价于每次删除任意除 `AA` 和 `BB` 外的长度为 $2$ 的子串。

先考虑没有 `C` 怎么做。

容易发现只要 `A` 的个数和 `B` 的个数相等，那么每次操作前必定会有相邻的 `AB`，随便选一个删掉，显然是合法的。而个数不相等则一定不合法。

然后考虑有 `C` 怎么做。

由于 `C` 可以和任意一个字符一起删掉，所以可以把每个 `C` 替换成 `A` 或 `B`，如果有一种方案合法就一定合法。

不妨设 `A` 有 $x$ 个，`B` 有 $y$ 个，`C` 有 $n-x-y$ 个。

则字符串合法等价于 $n-x-y\geq |x-y|$，算一下可以得出：$x,y\leq\frac{n}{2}$。

然后用总方案 - 不合法方案数即可。答案是：

$$3^n-2\times\sum_{i=\frac{n}{2}+1}^{n}{\binom{n}{i}\cdot 2^{n-i}}$$

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e7 + 5, kMod = 998244353;

int n;
int fac[kMaxN], ifac[kMaxN], inv[kMaxN], pw2[kMaxN] = {1, 2};

int C(int m, int n) {
  if (m &lt; n) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    pw2[i] = 2ll * pw2[i - 1] % kMod;
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  prework();
  int ans = 1;
  for (int i = 1; i &lt;= n; ++i) ans = 3ll * ans % kMod;
  for (int i = n / 2 + 1; i &lt;= n; ++i) {
    ans = (ans - 1ll * pw2[n - i + 1] * C(n, i) % kMod + kMod) % kMod;
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18018255.html</id>
    <title type="text">CF1365G Secure Password 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-17T11:38:00Z</published>
    <updated>2024-02-17T11:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18018255.html" />
    <content type="text">## Description

本题是**交互题**。

有一个固定的数组 $A$，同时通过数组 $A$ 构造出数组 $P$，具体来讲，$P_i$ 是 $A$ 中除 $A_i$ 外的所有元素的按位或。

你需要在最多 $13$ 次询问中得到最后的 $P$ 数组。

$2\leq n\leq 1000$。

## Solution

首先有一个 $2\log n$ 的是注意到对于任意两个不同的数 $i,j$，则必有至少一位满足 $i$ 和 $j$ 不同，所以只要维护 $val_{i,0/1}$ 表示第 $i$ 位为 $0/1$ 的数的或，那么每次只要把与 $i$ 不同的位的 $val$ 值或起来即可。

考虑怎么优化到 $\log n$。

容易发现要想优化掉那个 $2$，就必定要构造出一种方案，使得 $id_i$ 存在一位为 $1$，$id_j$ 存在一位为 $0$。

所以只要给每个 $i$ 分配 popcount 相同的 $id$ 即可满足条件。

经过计算，这些 $id$ 最小位数是 $13$，因为 $\binom{13}{6}&gt;1000$。

总询问次数：$13$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e3 + 5;

int n;
int id[kMaxN], val[13];

int ask(std::vector&lt;int&gt; vec) {
  if (!vec.size()) return 0;
  std::cout &lt;&lt; "? " &lt;&lt; vec.size() &lt;&lt; ' ';
  for (auto x : vec) std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; std::endl;
  int x;
  std::cin &gt;&gt; x;
  return x;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  int cnt = 0;
  for (int i = 0; i &lt; (1 &lt;&lt; 13); ++i) {
    if (__builtin_popcount(i) == 6) {
      id[++cnt] = i;
      if (cnt == n) break;
    }
  }
  for (int i = 0; i &lt; 13; ++i) {
    std::vector&lt;int&gt; vec;
    for (int j = 1; j &lt;= n; ++j)
      if (~id[j] &gt;&gt; i &amp; 1)
        vec.emplace_back(j);
    val[i] = ask(vec);
  }
  std::cout &lt;&lt; "! ";
  for (int i = 1; i &lt;= n; ++i) {
    int res = 0;
    for (int j = 0; j &lt; 13; ++j)
      if (id[i] &gt;&gt; j &amp; 1)
        res |= val[j];
    std::cout &lt;&lt; res &lt;&lt; ' ';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18019488.html</id>
    <title type="text">[ARC122E] Increasing LCMs 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-18T08:18:00Z</published>
    <updated>2024-02-18T08:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18019488.html" />
    <content type="text">## Description

给定长度为 $N$ 的正整数序列 $\{A_i\}$，满足 $A_i$ 单调升。

问是否能将 $\{A_i\}$ 重排为序列 $\{x_i\}$，满足：

令 $y_i = \operatorname{LCM}(x_1, \dots, x_i)$，$\forall 1\le i&lt;N, y_i&lt;y_{i+1}$（即 $y_i$ 单调升）。

$ 1\ \leq\ N\ \leq\ 100,2\ \leq\ A_1\ &lt;\ A_2\ \cdots\ &lt;\ A_N\ \leq\ 10^{18} $

## Solution

直接构造显然很难，但是注意到一件事情，就是如果一个序列 $B_1,\dots,B_N$ 合法，那么如果把 $B_i$ 放到最后能使得 $y_{N-1}&lt;y_{N}$，则整个序列依然合法。

所以每次从后往前确定数，找到能够满足 $y_{N-1}&lt;y_N$ 的 $A_i$ 放到最后面，只要每次都能找到就一定合法。

时间复杂度：$O(N^3\log V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 105;

int n;
int a[kMaxN], res[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = n; i; --i) {
    for (int j = i; j; --j) {
      std::swap(a[i], a[j]);
      int lcm = 1;
      bool fl = 1;
      for (int k = 1; k &lt; i; ++k) {
        int val = std::__gcd(a[k], a[i]);
        lcm = lcm / std::__gcd(lcm, val) * val;
        if (lcm % a[i] == 0) {
          fl = 0;
          break;
        }
      }
      if (fl) break;
      else if (j == 1) return void(std::cout &lt;&lt; "No\n");
      std::swap(a[i], a[j]);
    }
  }
  std::cout &lt;&lt; "Yes\n";
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; a[i] &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18022591.html</id>
    <title type="text">P5163 WD与地图 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-20T02:49:00Z</published>
    <updated>2024-02-20T02:49:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18022591.html" />
    <content type="text">## Description

CX 让 WD 研究的地图可以看做是 $n$ 个点，$m$ 条边的有向图，由于政府正在尝试优化人民生活，他们会废弃一些无用的道路来把省下的钱用于经济建设。

城市都有各自的发达程度 $s_i$。为了方便管理，政府将整个地图划分为一些地区，两个点 $u,v$ 在一个地区当且仅当 $u,v$ 可以互相到达。政府希望知道一些时刻某个地区的前 $k$ 发达城市的发达程度总和，以此推断建设的情况。

也就是说，共有三个操作：

`1 a b` 表示政府废弃了从 $a$ 连向 $b$ 的边，保证这条边存在。

`2 a b` 表示政府把钱用于建设城市 $a$，使其发达程度增加 $b$。

`3 a b` 表示政府希望知道 $a$ 城市所在地区发达程度前 $b$ 大城市的发达程度之和。如果地区中的城市不足 $b$ 个输出该地区所有城市的发达程度总和。

$n\leq 10^5,m\leq 2\times 10^5,q\leq 2\times 10^5$

## Solution

考虑时空倒流，如果无向图就直接并查集+线段树合并即可。但是这里是 scc，所以无法确定能否合并，并且如果现在一条边的两端点在不同 scc 不代表以后也不在。

注意到一条边如果在某一时刻在 scc 内部，那么以后它一直会在 scc 内部。

如果直接二分，每次把出现时间在 $[1,mid]$ 的边加进去跑 tarjan，但这样做是 $O(m^2\log m)$，显然过不了。

考虑整体二分，当前时间区间为 $[l,r]$，假设已经用并查集维护好了 $[1,l-1]$ 的 scc 信息，那么对于 $[l,mid]$ 的边就只要在之前的 scc 之间连边跑 tarjan。

对于出现时间在 $[l,mid]$ 的边如果两端点在同一 scc 了，就放 $[l,mid]$，否则放 $[mid+1,r]$。而出现时间 $&gt;mid$ 的边显然只能放 $[mid+1,r]$。

至于保证并查集维护好了 $[1,l-1]$ 的 scc 信息，可以每次加完 $[l,mid]$ 的边后先递归右区间，然后用可撤销并查集回到 $l-1$ 的时刻后再递归左区间即可。

时间复杂度：$O(m\log^2 m+(m+q)\log m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5, kMaxM = 3e5 + 5;

struct Node {
  int op, a, b;
} qq[kMaxM];

int n, m, q, tot, mm;
int s[kMaxN], t[kMaxM], unq[kMaxM];
std::pair&lt;int, int&gt; ed[kMaxM];

int getid(int x) { return std::lower_bound(unq + 1, unq + 1 + mm, x) - unq; }

void discrete() {
  std::sort(unq + 1, unq + 1 + mm);
  mm = std::unique(unq + 1, unq + 1 + mm) - (unq + 1);
}

namespace GETT {
int dfn[kMaxN], low[kMaxN];
bool ins[kMaxN];
std::stack&lt;std::tuple&lt;int, int, int&gt;&gt; stk;
std::vector&lt;int&gt; vec, G[kMaxN];
std::map&lt;std::pair&lt;int, int&gt;, int&gt; mp;

struct DSU {
  int fa[kMaxN], rnk[kMaxN];

  void init(int n) {
    std::fill_n(rnk + 1, n, 1);
    std::iota(fa + 1, fa + 1 + n, 1);
  }

  int find(int x) {
    for (; x != fa[x]; x = fa[x]) {}
    return x;
  }

  void unionn(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return;
    if (rnk[fx] &gt; rnk[fy]) std::swap(fx, fy);
    fa[fx] = fy;
    int det = (rnk[fx] == rnk[fy]);
    rnk[fy] += det;
    stk.emplace(fx, fy, det);
  }
} dsu;

void back(int t) {
  for (; stk.size() &gt; t; stk.pop()) {
    auto [x, y, det] = stk.top();
    dsu.rnk[y] -= det, dsu.fa[x] = x;
  }
}

void dfs(int u) {
  static int cnt = 0;
  static std::stack&lt;int&gt; stk;
  dfn[u] = low[u] = ++cnt, stk.emplace(u), ins[u] = 1;
  for (auto v : G[u]) {
    if (!dfn[v]) {
      dfs(v), low[u] = std::min(low[u], low[v]);
    } else if (ins[v]) {
      low[u] = std::min(low[u], dfn[v]);
    }
  }
  if (low[u] == dfn[u]) {
    for (; !stk.empty();) {
      int t = stk.top();
      stk.pop();
      ins[t] = 0, dsu.unionn(t, u);
      if (t == u) break;
    }
  }
}

void solve(int l, int r, std::vector&lt;int&gt; &amp;vec) {
  if (l == r) {
    std::vector&lt;int&gt; idx;
    for (auto i : vec) {
      int x = dsu.find(ed[i].first), y = dsu.find(ed[i].second);
      G[x].emplace_back(y), idx.emplace_back(x), idx.emplace_back(y);
    }
    int lst = stk.size();
    for (auto x : idx) {
      if (!dfn[x]) dfs(x);
    }
    for (auto i : vec) {
      if (dsu.find(ed[i].first) == dsu.find(ed[i].second)) {
        t[i] = l;
      }
    }
    back(lst);
    for (auto x : idx) G[x].clear(), dfn[x] = low[x] = ins[x] = 0;
    return;
  }
  int mid = (l + r) &gt;&gt; 1, lst = stk.size();
  std::vector&lt;int&gt; idx, ls, rs;
  for (auto i : vec) {
    if (i &lt;= mid) {
      int x = dsu.find(ed[i].first), y = dsu.find(ed[i].second);
      G[x].emplace_back(y), idx.emplace_back(x), idx.emplace_back(y);
    }
  }
  for (auto x : idx) {
    if (!dfn[x]) dfs(x);
  }
  for (auto i : vec) {
    if (i &lt;= mid) {
      if (dsu.find(ed[i].first) == dsu.find(ed[i].second)) {
        ls.emplace_back(i);
      } else {
        rs.emplace_back(i);
      }
    } else if (dsu.find(ed[i].first) != dsu.find(ed[i].second)) {
      rs.emplace_back(i);
    }
  }
  for (auto x : idx) G[x].clear(), dfn[x] = low[x] = ins[x] = 0;
  solve(mid + 1, r, rs);
  back(lst);
  solve(l, mid, ls);
}

void solve() {
  for (auto [p, o] : mp) {
    if (o) ed[++tot] = p;
  }
  std::reverse(ed + 1, ed + 1 + tot);
  std::fill_n(t + 1, tot, tot + 1);
  for (int i = 1; i &lt;= tot; ++i) vec.emplace_back(i); 
  dsu.init(n);
  solve(1, tot, vec);
}
} // namespace GETT

namespace GETANS {
int sgt_tot, id[kMaxM], fa[kMaxN], rt[kMaxN], ls[kMaxN * 32], rs[kMaxN * 32], sum[kMaxN * 32], cnt[kMaxN * 32];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec;

void pushup(int x) {
  sum[x] = sum[ls[x]] + sum[rs[x]];
  cnt[x] = cnt[ls[x]] + cnt[rs[x]];
}

void update(int &amp;x, int l, int r, int ql, int v) {
  if (!x) x = ++sgt_tot;
  sum[x] += v * unq[ql], cnt[x] += v;
  if (l == r) return;
  int mid = (l + r) &gt;&gt; 1;
  if (ql &lt;= mid) update(ls[x], l, mid, ql, v);
  else update(rs[x], mid + 1, r, ql, v);
}

int merge(int x, int y, int l, int r) {
  if (!x || !y) return x + y;
  if (l == r) {
    sum[x] += sum[y], cnt[x] += cnt[y];
    return x;
  }
  int mid = (l + r) &gt;&gt; 1;
  ls[x] = merge(ls[x], ls[y], l, mid), rs[x] = merge(rs[x], rs[y], mid + 1, r);
  pushup(x);
  return x;
}

int query(int x, int l, int r, int k) {
  if (!x) return 0;
  else if (k &gt;= cnt[x]) return sum[x];
  else if (l == r) return k * unq[l];
  int mid = (l + r) &gt;&gt; 1;
  if (k &lt;= cnt[rs[x]]) return query(rs[x], mid + 1, r, k);
  else return sum[rs[x]] + query(ls[x], l, mid, k - cnt[rs[x]]);
}

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) fa[fx] = fy, rt[fy] = merge(rt[fy], rt[fx], 1, mm);
}

void solve() {
  int now = tot;
  for (int i = 1; i &lt;= tot; ++i) {
    vec.emplace_back(t[i], ed[i].first, ed[i].second);
  }
  std::sort(vec.begin(), vec.end());
  for (int i = 1; i &lt;= q; ++i) {
    id[i] = now;
    if (qq[i].op == 1) --now;
  }
  for (int i = 1; i &lt;= n; ++i) {
    fa[i] = i, update(rt[i], 1, mm, getid(s[i]), 1);
  }
  int pos = -1;
  std::vector&lt;int&gt; ans;
  for (int i = q; i; --i) {
    for (; pos + 1 &lt; vec.size() &amp;&amp; std::get&lt;0&gt;(vec[pos + 1]) &lt;= id[i];) {
      auto [t, u, v] = vec[++pos];
      unionn(u, v);
    }
    if (qq[i].op == 2) {
      int fi = find(qq[i].a);
      update(rt[fi], 1, mm, getid(s[qq[i].a]), -1);
      s[qq[i].a] -= qq[i].b;
      update(rt[fi], 1, mm, getid(s[qq[i].a]), 1);
    } else if (qq[i].op == 3) {
      int fi = find(qq[i].a);
      ans.emplace_back(query(rt[fi], 1, mm, qq[i].b));
    }
  }
  std::reverse(ans.begin(), ans.end());
  for (auto x : ans) std::cout &lt;&lt; x &lt;&lt; '\n';
}
} // namespace GETANS

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    unq[++mm] = s[i];
  }
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    GETT::mp[{u, v}] = 1;
  }
  for (int i = 1; i &lt;= q; ++i) {
    std::cin &gt;&gt; qq[i].op &gt;&gt; qq[i].a &gt;&gt; qq[i].b;
    if (qq[i].op == 1) {
      ed[++tot] = {qq[i].a, qq[i].b}, GETT::mp[{qq[i].a, qq[i].b}] = 0;
    } else if (qq[i].op == 2) {
      s[qq[i].a] += qq[i].b;
      unq[++mm] = s[qq[i].a];
    }
  }
  discrete(), GETT::solve(), GETANS::solve();
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18027215.html</id>
    <title type="text">[ABC259Ex] Yet Another Path Counting 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-22T06:12:00Z</published>
    <updated>2024-02-22T06:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18027215.html" />
    <content type="text">## Description

有 $N$ 行 $N$ 列的网格图，只能向下或向右走，合法路径的开端和结尾的格子上数字一样

找到合法路径条数，对 $998244353$ 取模

$1\leq N\leq 400,1\leq a_{i,j}\leq N^2$。

## Solution

有一个 $O(n^4)$ 的做法是每次枚举起点和终点然后用组合数计算答案，但是由于同一颜色的点可能很多所以这个做法过不了。

注意到出现次数 $\leq n$ 的颜色显然这样做是可以的，而出现次数 $&gt;n$ 的颜色最多 $n$ 个，所以对于这些出现次数很多的颜色在网格图上进行 dp 即可。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 405, kMaxS = kMaxN * kMaxN, kMod = 998244353;

int n;
int col[kMaxN][kMaxN], fac[kMaxS], ifac[kMaxS], inv[kMaxS];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxS];

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= 2 * n; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

int solve1(int x) {
  int ret = 0;
  for (auto p1 : vec[x]) {
    ret = (ret + 1) % kMod;
    for (auto p2 : vec[x]) {
      if (p1.first &lt;= p2.first &amp;&amp; p1.second &lt;= p2.second &amp;&amp; p1 != p2) {
        ret = (ret + C(p2.first - p1.first + p2.second - p1.second, p2.first - p1.first)) % kMod;
      }
    }
  }
  return ret;
}

int solve2(int x) {
  static int f[kMaxN][kMaxN] = {0};
  int ret = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      f[i][j] = ((col[i][j] == x) + f[i - 1][j] + f[i][j - 1]) % kMod;
      if (col[i][j] == x) ret = (ret + f[i][j]) % kMod;
    }
  }
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      std::cin &gt;&gt; col[i][j];
      vec[col[i][j]].emplace_back(i, j);
    }
  }
  prework();
  int ans = 0;
  for (int i = 1; i &lt;= n * n; ++i) {
    if (vec[i].size() &lt;= n) ans = (ans + solve1(i)) % kMod;
    else ans = (ans + solve2(i)) % kMod;
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18030310.html</id>
    <title type="text">P10138 [USACO24JAN] Cowmpetency G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-23T12:20:00Z</published>
    <updated>2024-02-23T12:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18030310.html" />
    <content type="text">## Description

Farmer John 正在为他的奶牛们雇用一位新的牛群领队。为此，他面试了 $N$（$2\le N\le 10^9$）头奶牛来担任该职位。在每次面试后，他会为候选牛分配一个 $1$ 到 $C$（$1\le C\le 10^4$）范围内的整数「牲任力」分数 $c_i$，与她们的领导能力相关。

由于 Farmer John 面试了如此多的奶牛，他已经忘记了所有奶牛的牲任力分数。然而，他确实记得 $Q$（$1\le Q\le \min(N−1,100)$）对数字 $(a_i,h_i)$，其中奶牛 $h_i$ 是第一头比奶牛 $1$ 到 $a_i$ 拥有**严格**更高牲任力分数的奶牛（所以 $1\le a_i&lt;h_i\le N$）。

Farmer John 现在告诉你这 $Q$ 个数对 $(a_i,h_i)$。请帮助他数一下有多少个牲任力分数序列与此信息一致！输入保证存在至少一个这样的序列。由于这个数字可能非常大，输出该值模 $10^9+7$ 的余数。

## Solution

先考虑 $N\leq 2000$ 的情况。

容易发现那个限制等价于 $\max_{j=a_i+1}^{h_i-1}{c_j}\leq \max_{j=1}^{a_i}{c_j}&lt;c_{h_i}$，那么此时每个位置就出现了三种状态：一定是前缀最大值、一定不是前缀最大值和无法确定。不妨设一定不是前缀最大值标号为 $0$，无法确定为 $1$，一定是则为 $2$。

对这个进行 dp 可做到 $O(NC)$。

考虑到连续的 $0/1$ 段是 $O(Q)$ 级别的，所以把连续的 $0/1$ 段缩掉然后 dp 即可。转移方程如下：

$$
f_{i,j}=\begin{cases}
op_i=0:f_{i-1,j}\cdot j^{len_i}\\
op_i=1:f_{i-1,j}\cdot j^{len_i}+\sum_{k=1}^{j-1}{f_{i-1,k}\cdot \left[j^{len_i}-(j-1)^{len_i}\right]}\\
op_i=2:\sum_{k=1}^{j-1}{f_{i-1}{k}}
\end{cases}
$$

时间复杂度：$O(QC\log N)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxQ = 305, kMaxC = 1e4 + 5, kMod = 1e9 + 7;

int n, q, c;
int f[2][kMaxC];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec, seg;

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int qpow(int bs, int idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = 1ll * bs * bs % kMod)
    if (idx &amp; 1)
      ret = 1ll * ret * bs % kMod;
  return ret;
}

void prework() {
  std::sort(vec.begin(), vec.end());
  std::vector&lt;std::pair&lt;int, int&gt;&gt; tmp;
  for (int i = 0; i &lt; vec.size(); ++i) {
    if (!i || vec[i].first != vec[i - 1].first)
      tmp.emplace_back(vec[i].second, vec[i].first);
  }
  for (int i = 0; i &lt; tmp.size(); ++i) {
    if (!i &amp;&amp; tmp[i].first &gt; 1)
      seg.emplace_back(tmp[i].first - 1, 1);
    else if (i &amp;&amp; tmp[i].first &gt; tmp[i - 1].second + 1)
      seg.emplace_back(tmp[i].first - tmp[i - 1].second - 1, 1);
    if (tmp[i].first != tmp[i].second)
      seg.emplace_back(tmp[i].second - tmp[i].first, 0);
    seg.emplace_back(1, 2);
    if (i + 1 == tmp.size() &amp;&amp; tmp[i].second &lt; n) seg.emplace_back(n - tmp[i].second, 1);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; c;
  for (int i = 1; i &lt;= q; ++i) {
    int a, h;
    std::cin &gt;&gt; a &gt;&gt; h;
    vec.emplace_back(h, a + 1);
  }
  prework();
  int o = 0;
  f[o][0] = 1;
  for (auto [len, op] : seg) {
    o ^= 1;
    std::fill_n(f[o], c + 1, 0);
    int sum = 0;
    if (op == 2) assert(len == 1);
    for (int i = 1; i &lt;= c; ++i) {
      inc(sum, f[o ^ 1][i - 1]);
      if (op == 0) f[o][i] = 1ll * f[o ^ 1][i] * qpow(i, len) % kMod;
      else if (op == 1) f[o][i] = add(1ll * f[o ^ 1][i] * qpow(i, len) % kMod, 1ll * sum * sub(qpow(i, len), qpow(i - 1, len)) % kMod);
      else f[o][i] = sum;
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= c; ++i) inc(ans, f[o][i]);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18030443.html</id>
    <title type="text">P10139 [USACO24JAN] Nap Sort G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-23T14:00:00Z</published>
    <updated>2024-02-23T14:00:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18030443.html" />
    <content type="text">## Description

Bessie 正在尝试使用她自己的排序算法对一个整数数组进行排序。她有一堆共 $N$（$1\le N\le 2\cdot 10^5$）个整数 $a_1,a_2,\ldots,a_N$（$1\le a_i\le 10^{11}$），她将会按排序顺序将这些数放入一个单独的数组中。她反复查找这堆数中的最小数，将其删除，同时将其添加到数组的末尾。Bessie 在 $p$ 个数的堆中找到最小数需要花费 $p$ 秒。

Farmer John 命令了农场中其他一些奶牛帮助 Bessie 完成任务，她们很懒，然而 Bessie 利用了这一点。她将整数分成两堆：Bessie 堆和助手堆。对于 Bessie 堆中的每个整数，她会正常执行她的算法。对于助手堆中的每个整数，她将其分配给不同的助手奶牛。Farmer John 有一个很大的农场，所以 Bessie 可以找来任意多的助手奶牛。如果助手收到整数 $a_i$，Bessie 会指示该牛小睡 $a_i$ 秒，并在她们醒来时立即将该整数添加到数组末尾。如果 Bessie 和一个助手同时向数组添加整数，Bessie 的整数将优先被添加，因为她是领导者。如果多个助手被分配了相同的整数，她们会同时将多个该整数添加到数组中。

请帮助 Bessie 划分她的数，使得最终得到的数组是排序的，并使得排序该数组所需的时间最少。

## Solution

先把 $a$ 数组排序，不妨设 Bessie 分配到了 $k$ 头牛，那么答案一定是 $a_{n}$ 或 $\frac{k\times(k+1)}{2}$。容易发现答案为 $a_n$ 的情况一定能满足，考虑求后面那个的最小值。

先考虑对于一个 $k$ 如何求其是否可行，钦定最后一个一定是 Bessie。那么从后往前扫显然剩下的 Bessie 数一定越多越好，但是如果 $a_i$ 大于后面的最小 sum，则 $a_i$ 一定要选 Bessie，否则维持现状一定更优。但是如果 $a_i=sum$ 根据题意同一时间 Bessie 选的牛回放前面，则这个时候 $a_i$ 会被放到后面的牛的后面，显然不合法。所以 $a_i$ 选 Bessie 的条件为 $a_i\geq sum$。如果最后选了的数量 $&gt;k$ 就一定可行，否则不可行。

容易发现这个对于 $k$ 具有单调性，所以二分即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN];

bool check(int k) {
  int now = 1, sum = k * (k + 1) / 2;
  for (int i = n - 1; i; --i) {
    if (a[i] &gt;= sum) sum -= (now++);
    if (now &gt; k) return 0;
  }
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  std::sort(a + 1, a + 1 + n);
  int L = 0, R = n, res = n;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (check(mid)) R = res = mid;
    else L = mid;
  }
  std::cout &lt;&lt; std::min(res * (res + 1) / 2, a[n]) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18032074.html</id>
    <title type="text">[ARC155D] Avoid Coprime Game 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-25T01:51:00Z</published>
    <updated>2024-02-25T01:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18032074.html" />
    <content type="text">## Description

非负整数 $x,y$ 的最大公约数记为 $\gcd(x,y)$，规定 $\gcd(x,0)=\gcd(0,x)=x$。

黑板上写了 $N$ 个整数 $A_1,A_2,...,A_N$，这 $N$ 个数的最大公约数是 $1$。Takahashi 和 Aoki 在玩游戏，有一个变量 $G$ 初值为 $0$，他们轮流进行以下操作：

&gt; 从黑板上选择一个数 $a$，必须满足 $\gcd(a,G)\ne 1$，从黑板上擦掉这个数，并将 $G$ 的值改为 $\gcd(a,G)$。

Takahashi 先手，谁无法操作就输了，两人都采取最优策略。

请你对于 $i=1,2,..,N$ 分别判断，假如第一步 Takahashi 选择的数是 $A_i$，最后谁会获胜。

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ A_i\ \leq\ 2\ \times\ 10^5 $

## Code

考虑对于必胜必败态进行 dp，不妨设当前 gcd 为 $G$，注意到删数很难用状态表示，但是发现删掉的数一定是当前 $G$ 的倍数，而其他 $G$ 的倍数与 $G$ 的 gcd 还是 $G$，并且不是 $G$ 的倍数的数一定没被删。

所以只要记录 $G$ 和当前轮数即可刻画这个状态，显然过不了。

---

先考虑每次 $G$ 一定会变小的情况，设 $f_i$ 表示 $G=i$ 是否必胜/必败，$cnt_i$ 表示 $i$ 的倍数的个数。

那么枚举一个 $j$ 使得 $\exists x,gcd(i,x)=j$，如果 $f_j$ 为必败，则 $f_i$ 必胜。如果所有 $j$ 全必胜，则 $f_i$ 必败。

但是这题 $G$ 不一定会变小，考虑什么情况下 $G$ 不会变小。

注意到如果存在一个 $f_j(j&lt;i)$ 满足其是必败态，则当前操作一定最优。所以 $G$ 不变小当且仅当所有转移到的 $f_j$ 都必胜，则两人一定不停操作直到必须变小，即操作到 $cnt_i$ 轮的人会必胜。

所以只要记录一维状态表示当前操作了奇数/偶数轮，$f_{i,0/1}$ 表示当前 $G=i$，在这之前操作了偶数/奇数轮。

然后同样进行 dp，如果后继状态全必胜，则 $f_{i,1-(cnt_i\bmod 2)}$ 必胜。

时间复杂度：$O(V\log^2 V+N)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN], cnt[kMaxN], tmp[kMaxN];
bool f[kMaxN][2];
std::vector&lt;int&gt; d[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    ++cnt[a[i]];
  }
  for (int i = 2; i &lt;= 2e5; ++i) {
    d[i].emplace_back(i);
    for (int j = 2 * i; j &lt;= 2e5; j += i)
      cnt[i] += cnt[j], d[j].emplace_back(i);
  }
  for (int i = 2; i &lt;= 2e5; ++i) {
    bool fl = 0;
    for (auto j : d[i]) tmp[j] = cnt[j];
    for (int j = (int)d[i].size() - 1; ~j; --j) {
      int x = d[i][j];
      if (x != i &amp;&amp; tmp[x]) {
        if (!f[x][0]) f[i][1] = 1, fl = 1;
        if (!f[x][1]) f[i][0] = 1, fl = 1;
      }
      for (auto k : d[x]) tmp[k] -= tmp[x];
    }
    if (!fl) f[i][~cnt[i] &amp; 1] = 1;
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::cout &lt;&lt; (f[a[i]][1] ? "Aoki\n" : "Takahashi\n");
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18032168.html</id>
    <title type="text">CF1930E 2..3...4.... Wonderful! Wonderful! 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-25T03:09:00Z</published>
    <updated>2024-02-25T03:09:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18032168.html" />
    <content type="text">## Description

Stack has an array $ a $ of length $ n $ such that $ a_i = i $ for all $ i $ ( $ 1 \leq i \leq n $ ). He will select a positive integer $ k $ ( $ 1 \leq k \leq \lfloor \frac{n-1}{2} \rfloor $ ) and do the following operation on $ a $ any number (possibly $ 0 $ ) of times.

- Select a subsequence $ ^\dagger $ $ s $ of length $ 2 \cdot k + 1 $ from $ a $ . Now, he will delete the first $ k $ elements of $ s $ from $ a $ . To keep things perfectly balanced (as all things should be), he will also delete the last $ k $ elements of $ s $ from $ a $ .

Stack wonders how many arrays $ a $ can he end up with for each $ k $ ( $ 1 \leq k \leq \lfloor \frac{n-1}{2} \rfloor $ ). As Stack is weak at counting problems, he needs your help.

Since the number of arrays might be too large, please print it modulo $ 998\,244\,353 $ .

 $ ^\dagger $ A sequence $ x $ is a subsequence of a sequence $ y $ if $ x $ can be obtained from $ y $ by deleting several (possibly, zero or all) elements. For example, $ [1, 3] $ , $ [1, 2, 3] $ and $ [2, 3] $ are subsequences of $ [1, 2, 3] $ . On the other hand, $ [3, 1] $ and $ [2, 1, 3] $ are not subsequences of $ [1, 2, 3] $ .

 $3\leq n\leq 10^6$ .

## Solution

不妨设 $x$ 为总共删的数的个数，$p_i$ 表示 $i$ 是否被删，考虑什么样的序列是合法的。

1. $x=2k$，则充要条件为存在 $i$ 使得 $p_i=0$ 且 $i$ 之前和之后都有恰好 $k$ 个 $1$。

2. $x&gt;2k$，则如果不存在一个  $i$ 使得 $p_i=0$ 且 $i$ 之前和之后都有至少 $k$ 个 $1$，那么最后一步一定不合法。如果一定存在，那么可以先把左右两边的 $1$ 的个数删成 $[k,3k)$ 然后就必然合法。

所以一个序列合法的条件为存在一个  $i$ 使得 $p_i=0$ 且 $i$ 之前和之后都有至少 $k$ 个 $1$。

考虑用总数减去不合法的方案数，先把 $2x$ 个 $1$ 插进去，然后每个 $0$ 只能插入左右各 $k$ 个空，总方案数即为：

$$\binom{n}{x}-\binom{n-x+2k-1}{2k-1}$$

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5, kMod = 998244353;

int n;
int fac[kMaxN], ifac[kMaxN], inv[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= 1e6; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

int solve(int n, int k) {
  int ret = 1;
  for (int i = 2 * k; i &lt;= n; i += 2 * k) {
    inc(ret, sub(C(n, i), C(n - i + 2 * k - 1, 2 * k - 1)));
  }
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= (n - 1) / 2; ++i)
    std::cout &lt;&lt; solve(n, i) &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  prework();
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18038627.html</id>
    <title type="text">[AGC018C] Coins 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-27T14:52:00Z</published>
    <updated>2024-02-27T14:52:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18038627.html" />
    <content type="text">## Description

有 $x+y+z$ 个人，第 $i$ 个人有 $A_i$ 个金币，$B_i$ 个银币，$C_i$ 个铜币。

要选出 $x$ 个人获得其金币，选出 $y$ 个人获得其银币，选出 $z$ 个人获得其铜币。在不重复选某个人的情况下，最大化获得的币的总数。 

$x+y+z\le 10 ^ 5$。

## Solution

先默认每个人都选 $C$，让每个 $A_i,B_i$ 都减 $C_i$，相当于就是要选出 $x$ 个人选 $A$，$y$ 个人选 $B$，最大化总和。

注意到如果 $i$ 选 $A$，$j$ 选 $B$ 且 $A_i+B_j&lt;A_j+B_i$ 则把 $i,j$ 互换会更优，这个条件等价于 $A_i-B_i&lt;A_j-B_j$。

所以如果把所有人按照 $A_i-B_i$ 排序，选 $B$ 的一定是选了的人里最靠前的 $y$ 个，而选 $A$ 的一定是最靠后的 $x$ 个，搞个优先队列即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, x, y, z, ans;
int a[kMaxN], b[kMaxN], c[kMaxN], pre[kMaxN], suf[kMaxN];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec;

void getpre() {
  std::multiset&lt;int&gt; st;
  int sum = 0;
  for (int i = 1; i &lt;= n; ++i) {
    int val = std::get&lt;2&gt;(vec[i]);
    if (st.size() &lt; y) sum += val, st.emplace(val);
    else if (*st.begin() &lt; val) sum += val - *st.begin(), st.erase(st.begin()), st.emplace(val);
    if (i &gt;= y) pre[i] = sum;
  }
}

void getsuf() {
  std::multiset&lt;int&gt; st;
  int sum = 0;
  for (int i = n; i; --i) {
    int val = std::get&lt;1&gt;(vec[i]);
    if (st.size() &lt; x) sum += val, st.emplace(val);
    else if (*st.begin() &lt; val) sum += val - *st.begin(), st.erase(st.begin()), st.emplace(val);
    if (i &lt;= n - x + 1) suf[i] = sum;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
  n = x + y + z;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
    ans += c[i], a[i] -= c[i], b[i] -= c[i];
    vec.emplace_back(a[i] - b[i], a[i], b[i]);
  }
  vec.emplace_back(-2e9, 0, 0);
  std::sort(vec.begin(), vec.end());
  getpre(), getsuf();
  int tmp = -1e18;
  for (int i = y; i &lt;= n - x; ++i)
    tmp = std::max(tmp, pre[i] + suf[i + 1]);
  std::cout &lt;&lt; ans + tmp &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18041128.html</id>
    <title type="text">CF1209G2 Into Blocks (hard version) 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-28T09:16:00Z</published>
    <updated>2024-02-28T09:16:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18041128.html" />
    <content type="text">## Description

给你 $n$ , $q$，$n$ 表示序列长度，$q$ 表示操作次数。

我们需要达成这么一个目标状态：
如果存在 $x$ 这个元素，那么必须满足所有 $x$ 元素都必须在序列中连续。

然后你可以进行这么一种操作，将所有的 $x$ 元素的变为任意你指定的 $y$ 元素，并且花费 $cnt[x]$ 的花费，$cnt[x]$ 代表 $x$ 元素的个数。

现在有 $q$ 次询问，每次询问单点修改一个位置的值，求修改完之后最小花费使得序列满足目标状态。

注意：更新不是独立的，之前的更新会保留。

$1\leq n\leq 2\times 10^5,0\leq q\leq 2\times 10^5$

## Solution

先考虑对于一个序列怎么求答案。

显然是把整个序列先划分成若干个最短的区间使得区间内部里出现过的颜色的所有位置都在这个区间里，答案就是 $n$ 减每个区间颜色出现次数的最大值。

考虑怎么去刻画这个区间。

先不考虑长度是 $1$ 的区间，不妨设 $l_i$ 表示颜色 $i$ 第一次出现的位置，$r_i$ 表示颜色 $i$ 最后一次出现的位置，$b_i$ 表示位置 $i$ 被多少个区间 $[l_j,r_j)$ 覆盖，$w_i$ 表示 $a_i$ 这个颜色的出现次数。

那么每个合法的区间 $[l,r]$ 一定满足 $b_l,b_{l+1},\dots,b_{r-1}$ 都不为 $0$，所以每个 $[l,r]$ 都可以用 $b$ 数组的最长非零区间表示，由于必定会有一个颜色在 $[l,r]$ 中出现至少 $2$ 次，所以 $[l,r]$ 对答案的贡献就是 $\max\{w_l,w_{l+1},\dots,w_{r-1}\}$。

现在考虑用线段树维护这个东西。

设 $minb_i$ 表示 $i$ 这个区间 $b$ 的最小值，$maxw_i$ 表示区间内 $w$ 的最大值，$sum_i$ 表示区间内的贡献之和。

容易发现 $b_n=0$，所以 $minb_1=0$，那么总贡献就是 $sum_1$。

但是线段树需要支持合并，所以只要再维护区间前缀还没确定的贡献和后缀还没确定的贡献（这个贡献不能包含左端点）。

修改相当于就是删除或加入 $[l_c,r_c)$，并且每次只要修改每个颜色第一次出现的位置的 $w$，因为求区间 max 时一定会在第一次出现的位置贡献到。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5;

int n, q;
int a[kMaxN];
std::set&lt;int&gt; st[kMaxN];

struct SGT {
  int mi[kMaxN * 4], lmx[kMaxN * 4], rmx[kMaxN * 4], mx[kMaxN * 4], sum[kMaxN * 4], tag[kMaxN * 4];

  void pushup(int x) {
    mi[x] = std::min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]);
    mx[x] = std::max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
    if (mi[x &lt;&lt; 1] &lt; mi[x &lt;&lt; 1 | 1]) {
      lmx[x] = lmx[x &lt;&lt; 1], rmx[x] = std::max(rmx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
      sum[x] = sum[x &lt;&lt; 1];
    } else if (mi[x &lt;&lt; 1] &gt; mi[x &lt;&lt; 1 | 1]) {
      rmx[x] = rmx[x &lt;&lt; 1 | 1], lmx[x] = std::max(lmx[x &lt;&lt; 1 | 1], mx[x &lt;&lt; 1]);
      sum[x] = sum[x &lt;&lt; 1 | 1];
    } else {
      lmx[x] = lmx[x &lt;&lt; 1], rmx[x] = rmx[x &lt;&lt; 1 | 1];
      sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1] + std::max(rmx[x &lt;&lt; 1], lmx[x &lt;&lt; 1 | 1]);
    }
  }

  void addtag(int x, int v) {
    tag[x] += v, mi[x] += v;
  }

  void pushdown(int x) {
    if (!tag[x]) return;
    addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
    tag[x] = 0;
  }

  void update1(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) {
      return;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return addtag(x, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update1(x &lt;&lt; 1, l, mid, ql, qr, v), update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  void update2(int x, int l, int r, int ql, int v) {
    if (l == r) return void(mx[x] = lmx[x] = v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update2(x &lt;&lt; 1, l, mid, ql, v);
    else update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }
} sgt;

void upd(int x, int v) {
  int val = a[x];
  if (!st[val].empty()) {
    sgt.update1(1, 1, n, *st[val].begin(), *prev(st[val].end()) - 1, -1);
    sgt.update2(1, 1, n, *st[val].begin(), 0);
  }
  if (v == 1) st[val].emplace(x);
  else st[val].erase(x);
  if (!st[val].empty()) {
    sgt.update1(1, 1, n, *st[val].begin(), *prev(st[val].end()) - 1, 1);
    sgt.update2(1, 1, n, *st[val].begin(), st[val].size());
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    st[a[i]].emplace(i);
  }
  for (int i = 1; i &lt;= 2e5; ++i) {
    if (!st[i].size()) continue;
    sgt.update1(1, 1, n, *st[i].begin(), *prev(st[i].end()) - 1, 1);
    sgt.update2(1, 1, n, *st[i].begin(), st[i].size());
  }
  std::cout &lt;&lt; n - sgt.lmx[1] - sgt.rmx[1] - sgt.sum[1] &lt;&lt; '\n';
  for (int i = 1; i &lt;= q; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    upd(x, -1), a[x] = y, upd(x, 1);
    std::cout &lt;&lt; n - sgt.lmx[1] - sgt.rmx[1] - sgt.sum[1] &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18041771.html</id>
    <title type="text">CF1408H Rainbow Triples 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-28T12:56:00Z</published>
    <updated>2024-02-28T12:56:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18041771.html" />
    <content type="text">## Description

给定长度为 $n$ 的序列 $p$

找出尽可能多的三元组 $(a_i,b_i,c_i)$ 满足：

- $1\le a_i&lt;b_i&lt;c_i\le n$
- $p_{a_i}=p_{c_i}=0$，$p_{b_i}\ne 0$
- $p_{b_i}$ 互不相同。
- 所有的 $a_i,b_i,c_i$ 互不相同。

输出最多可以选出多少个三元组，多组数据。

$\sum n\le 5\cdot 10^5$

## Solution

设总共有 $c$ 个 $0$，容易发现答案的上界是 $\left\lfloor\frac{c}{2}\right\rfloor$，并且对于每个三元组，$a_i$ 一定在前 $\left\lfloor\frac{c}{2}\right\rfloor$ 个，$c_i$ 一定在最后 $\left\lfloor\frac{c}{2}\right\rfloor$ 个。

因为如果不满足那么调整成这个情况一定更优。

然后考虑一个 $b_i$，如果在前 $\left\lfloor\frac{c}{2}\right\rfloor$ 个 $0$ 的区间里，那么如果它能够与 $\left\lfloor\frac{c}{2}\right\rfloor$ 匹配那么一定能和右边的 $0$ 匹配，如果在右边则一定能与左边的 $0$ 匹配。

所以只要把 $mid$ 左边和右边的分开考虑然后把答案相加与 $\left\lfloor\frac{c}{2}\right\rfloor$ 取 min。

容易发现对于一个颜色，只有 $&lt;mid$ 的最大位置和 $&gt;mid$ 的最小位置有意义，所以把这个颜色与 $&lt;mid$ 的位置之前的 $0$ 和 $&gt;mid$ 的位置之后的 $0$ 连边跑网络流即可，显然过不了。

注意到一个颜色匹配的一定是一个前缀+一个后缀，所以把 $mid$ 之前的 $0$ 移到最后面，那么每个颜色匹配的就是一个区间 $[l,r]$，于是只要先按 $r$ 排序然后贪心即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;
 
// #define int int64_t
 
const int kMaxN = 5e5 + 5;
 
int n;
int a[kMaxN];
std::vector&lt;int&gt; vec[kMaxN];
 
void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 0; i &lt;= n; ++i) vec[i].clear();
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    vec[a[i]].emplace_back(i);
  }
  // if (vec[0].size() &amp; 1) vec[0].erase(vec[0].begin() + vec[0].size() / 2);
  if (!vec[0].size()) return void(std::cout &lt;&lt; "0\n");
  int cnt = vec[0].size(), L, R;
  if (vec[0].size() &amp; 1) L = R = vec[0][(vec[0].size() - 1) / 2];
  else L = vec[0][vec[0].size() / 2 - 1], R = vec[0][vec[0].size() / 2];
  std::vector&lt;std::pair&lt;int, int&gt;&gt; rg;
  for (int i = 1; i &lt;= n; ++i) {
    if (!vec[i].size()) continue;
    int id1 = -1, id2 = n + 1;
    for (auto x : vec[i]) {
      if (x &lt; R) id1 = x;
      if (x &gt; L &amp;&amp; id2 == n + 1) id2 = x;
    }
    id1 = std::lower_bound(vec[0].begin(), vec[0].end(), id1) - vec[0].begin() - 1;
    id2 = std::lower_bound(vec[0].begin(), vec[0].end(), id2) - vec[0].begin();
    rg.emplace_back(id2, cnt + id1);
  }
  auto cmp = [](const std::pair&lt;int, int&gt; &amp;p1, const std::pair&lt;int, int&gt; &amp;p2) {
    return std::make_pair(p1.second, p1.first) &lt; std::make_pair(p2.second, p2.first);
  };
  std::sort(rg.begin(), rg.end(), cmp);
  std::set&lt;int&gt; st;
  for (int i = 0; i &lt; 2 * cnt; ++i) st.emplace(i);
  int ans = 0;
  for (auto p : rg) {
    auto it = st.lower_bound(p.first);
    if (it != st.end() &amp;&amp; *it &lt;= p.second) ++ans, st.erase(it);
  }
  std::cout &lt;&lt; std::min(ans, cnt / 2) &lt;&lt; '\n';
}
 
int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18042946.html</id>
    <title type="text">[AGC018F] Two Trees 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-02-29T02:51:00Z</published>
    <updated>2024-02-29T02:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18042946.html" />
    <content type="text">## Description

给定两棵都是 $n$ 个节点的有根树 $A,B$，节点均从 $1..n$ 标号。

我们需要给每个标号定一个权值，使在两棵树上均满足任意节点子树权值和为 $1$ 或 $-1$。

输出任意一种解，需要判断无解。

$1\leq n\leq 10^5$。

## Solution

注意到每个点权值的奇偶性是确定的，所以如果两棵树对应点的奇偶性不同则一定无解，否则可以证明有解。

考虑如何构造方案。

先新建一个根，连接原来两棵树的根，然后对于 $i$，如果 $i$ 在两棵树里的度数均为奇数，则连一条 $i$ 左树点到右树点的边，这时每个点的度数就都为偶数了，所以可以跑一遍欧拉回路。

如果 $i$ 原来度数为偶数，权值为 $0$。否则如果 $(L_i,R_i)$ 这条边是从 $L_i\to R_i$，权值为 $1$，$R_i\to L_i$ 则为 $-1$。

下面证明这个构造是正确的。

考虑对于欧拉回路上的每个环计算贡献，对于点 $i$，一个环有三种情况：

1. 先走儿子，然后再从儿子或横叉边回来。
2. 先走儿子，再从父亲回来。
3. 先走父亲，再从儿子或横叉边回来。

对于 1 情况，$i$ 的子树会贡献一个 $1$ 一个 $-1$ 就抵消了。

对于 $2$ 和 $3$ 情况，$i$ 的子树都会有 $1$ 或 $-1$ 的贡献，但是注意到 $i$ 到父亲的边只有一条，所以 $2$ 和 $3$ 总共有且仅会出现一次，所以 $i$ 的子树最后权值和还是 $1$ 或 $-1$。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, rt1, rt2, cnt;
int fa1[kMaxN], fa2[kMaxN], deg1[kMaxN], deg2[kMaxN], cur[kMaxN], res[kMaxN];
bool vis[kMaxN * 2];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs(int u) {
  for (int i = cur[u]; i &lt; G[u].size(); i = cur[u]) {
    cur[u] = i + 1;
    auto [v, id] = G[u][i];
    if (vis[id]) continue;
    vis[id] = 1;
    dfs(v);
    if (v &amp;&amp; u == v + n) res[v] = 1;
    else if (u &amp;&amp; v == u + n) res[u] = -1;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; fa1[i];
    if (~fa1[i]) {
      deg1[fa1[i]] ^= 1, deg1[i] ^= 1;
      G[fa1[i]].emplace_back(i, ++cnt), G[i].emplace_back(fa1[i], cnt);
    } else {
      rt1 = i;
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; fa2[i];
    if (~fa2[i]) {
      deg2[fa2[i]] ^= 1, deg2[i] ^= 1;
      G[fa2[i] + n].emplace_back(i + n, ++cnt), G[i + n].emplace_back(fa2[i] + n, cnt);
    } else {
      rt2 = i;
    }
  }
  deg1[rt1] ^= 1, deg2[rt2] ^= 1;
  for (int i = 1; i &lt;= n; ++i) {
    if (deg1[i] != deg2[i])
      return void(std::cout &lt;&lt; "IMPOSSIBLE\n");
  }
  G[0].emplace_back(rt1, ++cnt), G[rt1].emplace_back(0, cnt);
  G[0].emplace_back(rt2 + n, ++cnt), G[rt2 + n].emplace_back(0, cnt);
  for (int i = 1; i &lt;= n; ++i) {
    if (deg1[i]) {
      G[i].emplace_back(i + n, ++cnt), G[i + n].emplace_back(i, cnt);
    }
  }
  dfs(0);
  std::cout &lt;&lt; "POSSIBLE\n";
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; res[i] &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18064835.html</id>
    <title type="text">HNOI2024 游记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-03-10T13:16:00Z</published>
    <updated>2024-03-10T13:16:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18064835.html" />
    <content type="text">### Day 0

机房打摆，早上扫雷但是离 xkr 的记录差的有点远，很自闭。

一天就写了 fft 和 ntt。

晚上有点失眠。

---

### Day 1

带了东鹏特饮和巧克力就去考试了。

T1 发现直接枚举 $m\bmod n$ 的值然后解方程就行，25 分钟过了大样例，然后对着代码瞪了 10 分钟发现没什么错误就丢掉了。

T2 想了一下发现可以二分，想着先写暴力再想正解，于是很快写完 $2^n$ 暴力，但是 A 性质的 $O(nk^2)$ 写了半天发现假了，很自闭，以为要 112 遗憾离场。

去了趟厕所回来发现好像写个分治就可以了，然后就写 B 性质，写完调到 12 点才过大样例，发现 $n=2$ 要跑 2s，**当时认为评测机比本机要快就没管了**。

看了眼 T3，没有思路，于是 24 分跑路。

期望得分：$100+40+24$。

下午看了眼云斗发现 B 性质 $n=2$ 的 T 了，但是 $n$ 很大的还 WA 了一个。

最后云斗就只有：$100+28+24$，很自闭。

晚上看了下自己从小学到现在写的所有博客和翻提交记录找到了自己第一次改码风的时间！

结果失眠了，大概 12 点多才睡着。

### Day 2

候考的时候 syc 说我 Day 1 这分有队线，虽然知道 Day 1 区分度不大+我 noip 很低，但还是又有了一点信心。

T1 看了 20 分钟想到了去 dp 求出第一个数，就开写了，写到 10 点发现自己的做法小样例会挂，当时认为做法假了就先写了个 $2^n$ 暴力保底然后看 T2。

看了会 T2 发现 T1 还可以挽救，但是还是没怎么想清楚，改了好久才写完 $O(2^{2n})$ 暴力，然后花了 20min 改成了 $O(2^{n}n^2)$ 的做法，大样例只要 0.01s，11 点上拍了。

然后又去想 T2，很快认定自己一定不会做，于是去写了个指数暴力 + B 性质 + $m=0$，结果写到了 12:30 才写完。$k=0$ 没想到状压 dp 以为很难写就没管了。

看了眼 T3，题意都没看懂就回去检查 T2。

期望得分：$100+25+0$，没挂。

晚上看云斗发现自己估分是 hn rk 18，但是由于 noip 有点低显然进不了队，就再次自闭，遗憾退役。

### Day 3~5

教练说按照云斗的估分我会卡在队线边上不知道能不能进。

### Day 6

出分了，实际得分 $100+24+24+100+25+0=273$，d1t2 B 性质挂没了。

标准分跟队线只差 2.4 分，如果我 d1t2 或者 d2t2 多过任何一个点就进队了。。。

### 后记

这次的失利主要还是因为 noip 不够重视+暴力写的不多还挂了，而且 d1t2 还是因为少讨论了 $n=1$ 导致挂的 8 分。

有点离谱，但是不管怎样还是有 D，重庆再见。

祝贺 wxl 进队/bx</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18078828.html</id>
    <title type="text">P10218 [省选联考 2024] 魔法手杖 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-03-17T09:37:00Z</published>
    <updated>2024-03-17T09:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18078828.html" />
    <content type="text">## Description

给定 $a_1,a_2,\dots,a_n$ 以及 $b_1,b_2,\dots,b_n$，满足 $a_i \in [0,2^k-1]$ 以及 $b_i\geq 0$，你需要给出 $S \subseteq \{1,2,\dots,n\}$ 以及 $x \in [0,2^k-1]$ 满足以下条件：

- $\sum \limits_{i\in S} b_i\leq m$；
- 满足以上条件的前提下，最大化 $val(S,x)=\min(\min \limits_{i \in S}(a_i+x),\min \limits_{i \in U \backslash S}(a_i \oplus x))$ 的值。

你只需要给出最大的 $val(S,x)$ 的值即可。

---

设 $\sum n$ 表示单组测试点各组数据 $n$ 的和。对于所有测试数据，
- $T \geq 1$；
- $1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$；
- $0 \leq m \leq 10^9$；
- $0 \leq k \leq 120$；
- $\forall 1 \leq i \leq n, 0 \leq a_i&lt;2^k$；
- $\forall 1 \leq i \leq n, 0 \leq b_i \leq 10^9$。

## Solution

考虑建出 $a$ 数组的 trie 树然后按照从高位到低位确定答案。

设当前走到第 $k$ 位，trie 树节点权值为 $val$，目前确定了 $x$ 和 $ans$ 的这些位，$nowm$ 表示剩下的权值，$minv$ 表示目前已经确定放到 $S$ 中的数 $a$ 的最小值。容易发现 $x\oplus val=ans$。

首先需要判断 $ans$ 的第 $k$ 位能否为 $1$。

不妨设 $x$ 这位为 $0$，对于 $1$ 的情况同理。那么要让 $ans$ 这位为 $1$，就必须要把 $val$ 子树内这位为 $0$ 的数加到 $S$ 中去，因为单靠异或是不能满足要求的。

那么如果 $\min\{minv,minb_{ch_{val,0}}\}+2^k-1\geq ans+2^k$，就能满足 $+$ 的部分大于等于 $ans+2^k$，因为这里让后面 $x$ 的位尽可能大一定是最优的。于是往这个儿子递归求答案即可。

---

然后是对于 $ans$ 的第 $k$ 位不能为 $1$ 的情况。

还是设 $x$ 这位为 $0$。那么 $val$ 子树内为 $1$ 的显然异或出来 $\geq ans+2^k$，就不用管了，直接走到 $ch_{val,0}$ 递归求解即可。

如果当前的 $val$ 只有一个儿子需要特判。

容易发现对于 trie 树上的每个点只会遍历一次，所以时间复杂度是 $O(nk)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }
 
char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

using i128 = __int128_t;

const int kMaxN = 1e5 + 5, kMaxK = 124, kMaxT = kMaxN * kMaxK;

int sid, n, m, k, tot;
int b[kMaxN], trie[kMaxT][2];
int64_t sumb[kMaxT];
i128 ans, a[kMaxN], mina[kMaxT];

void ins(i128 a, int b) {
  int cur = 0;
  for (int i = k - 1; ~i; --i) {
    int c = (a &gt;&gt; i &amp; 1);
    if (!trie[cur][c]) trie[cur][c] = ++tot, mina[tot] = a;
    cur = trie[cur][c];
    mina[cur] = std::min(mina[cur], a), sumb[cur] += b;
  }
}

void solve(int cur, i128 nowval, i128 x, i128 nowans, i128 minv, int m, int k) {
  assert((x ^ nowans) == nowval);
  assert(m &gt;= 0);
  if (!~k) {
    ans = std::max(ans, nowans);
    return;
  }
  assert(trie[cur][0] || trie[cur][1]);
  i128 pw = (i128)1 &lt;&lt; k;
  if (!trie[cur][0]) {
    // x 这位为 0
    bool fl = 0;
    if (minv + x + pw - 1 &gt;= nowans + pw) {
      fl = 1;
      solve(trie[cur][1], nowval + pw, x, nowans + pw, minv, m, k - 1);
    }
    // x 这位为 1
    if (std::min(minv, mina[trie[cur][1]]) + x + pw + pw - 1 &gt;= nowans + pw &amp;&amp; m &gt;= sumb[trie[cur][1]]) {
      fl = 1;
      ans = std::max(ans, std::min(std::min(minv, mina[trie[cur][1]]) + x + pw + pw - 1, nowans + pw + pw - 1));
    }

    if (!fl) {
      ans = std::max(ans, std::min(nowans + pw - 1, minv + x + pw - 1));
      solve(trie[cur][1], nowval + pw, x + pw, nowans, minv, m, k - 1);
    }
  } else if (!trie[cur][1]) {
    bool fl = 0;
    // x 这位为 1
    if (minv + x + pw + pw - 1 &gt;= nowans + pw) {
      fl = 1;
      solve(trie[cur][0], nowval, x + pw, nowans + pw, minv, m, k - 1);
    }
    // x 这位为 0
    if (std::min(minv, mina[trie[cur][0]]) + x + pw - 1 &gt;= nowans + pw &amp;&amp; m &gt;= sumb[trie[cur][0]]) {
      fl = 1;
      ans = std::max(ans, std::min(std::min(minv, mina[trie[cur][1]]) + x + pw - 1, nowans + pw + pw - 1));
    }
    if (!fl) {
      ans = std::max(ans, std::min(nowans + pw - 1, minv + x + pw + pw - 1));
      solve(trie[cur][0], nowval, x, nowans, minv, m, k - 1);
    }
  } else {
    // ans 这位为 1
    assert(trie[cur][0] &amp;&amp; trie[cur][1]);
    bool fl = 0;
    if (std::min(minv, mina[trie[cur][0]]) + x + pw - 1 &gt;= nowans + pw &amp;&amp; m &gt;= sumb[trie[cur][0]]) {
      fl = 1;
      solve(trie[cur][1], nowval + pw, x, nowans + pw, std::min(minv, mina[trie[cur][0]]), m - sumb[trie[cur][0]], k - 1);
    }
    if (std::min(minv, mina[trie[cur][1]]) + x + pw + pw - 1 &gt;= nowans + pw &amp;&amp; m &gt;= sumb[trie[cur][1]]) {
      fl = 1;
      solve(trie[cur][0], nowval, x + pw, nowans + pw, std::min(minv, mina[trie[cur][1]]), m - sumb[trie[cur][1]], k - 1);
    }
    if (!fl) {
      solve(trie[cur][0], nowval, x, nowans, minv, m, k - 1);
      solve(trie[cur][1], nowval + pw, x + pw, nowans, minv, m, k - 1);
    }
  }
}

void dickdreamer() {
  read(n, m, k);
  for (int i = 0; i &lt;= tot; ++i) {
    trie[i][0] = trie[i][1] = sumb[i] = mina[i] = 0;
  }
  tot = 0;
  for (int i = 1; i &lt;= n; ++i) read(a[i]);
  int64_t tsb = 0;
  for (int i = 1; i &lt;= n; ++i) {
    read(b[i]);
    ins(a[i], b[i]);
    tsb += b[i];
  }
  ans = 0, solve(0, 0, 0, 0, ((i128)1 &lt;&lt; k) - 1, m, k - 1);
  if (tsb &lt;= m) {
    ans = std::max(ans, *std::min_element(a + 1, a + 1 + n) + ((i128)1 &lt;&lt; k) - 1);
  }
  write(ans, '\n');
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int T = 1;
  read(sid, T);
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18083757.html</id>
    <title type="text">prufer 序列-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-03-19T11:51:00Z</published>
    <updated>2024-03-19T11:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18083757.html" />
    <content type="text">定义：prufer序列是树和序列的双向映射，prufer 序列描述了节点的度数以及父节点的信息。

使用场景：将构造树的问题转化为构造序列，将统计树的问题转化为统计序列，将树的 dp 转化为序列的 dp。

如何得到 prufer 序列：

1. 统计树上所有结点的 degree.
2. 找到度数为 1 的最小的点把他的父亲加到 prufer 序列并删掉他。
3. 重复 2 直到只剩两个点。

性质：

1. 剩余两个点中一定有 n。
2. 节点编号在 prufer 序列中的出现次数为 degree-1

prufer 序列的常用结论：

1. 对于 n 个点的完全图，他的生成树的个数为 $n^{n-2}$
2. 对于 n 个点的无根树，他的方案数为 $n^{n-2}$，有根树的方案数是 $n^{n-1}$
3. 对于 n 个点的无根树，每个点的度数确定，他的方案数为 $(n-2)!/(deg_1!deg_2!...deg_n!)$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18109168.html</id>
    <title type="text">Public Easy Round #2 E. 2048-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-01T10:57:00Z</published>
    <updated>2024-04-01T10:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18109168.html" />
    <content type="text">## Description

pb 大师喜欢玩 2048。

pb 大师在一个 $1\times n$ 的网格上玩 2048，初始 $n$ 个格子都是空的。

游戏会进行若干轮，每轮将发生如下事件：

1. 如果没有空位，游戏结束。否则随机一个 $1$ 到 $m$ 的数，随机到 $i$ 的概率是 $p_i$，再等概率随机一个空位，在空位中填入 $2^i−1$。

2. 将所有数顺序不变移到最左侧。例如 `_ _ x _ y z` 会变成 `x y z _ _ _`。

3. 如果没有相邻相同的数，这一轮结束。否则从左往右最后一对相同的数变成他们的和以及一个空位，并且他的得分会加上产生的和，例如 `x y y z _ _` 会变成 `x 2y _ z _ _`，并且 pb 大师会得到 $2y$ 分，接下来回到第二步。

pb 大师想要知道：他的期望总得分是多少。

## Solution

显然每次 1 操作之前所有已填的数构成一个前缀，所以那个选位置的操作是没意义的，于是每次相当于就是在栈的末尾添加一个数。

考虑 dp。

设 $f_{i,j}$ 表示栈的大小为 $i$，第一步填了 $j$ 的期望得分。

这时会发现后面总共有三种可能：

1. 后面比他小并且填到末尾。
2. 后面能消成 $j$ 然后与第一个 $j$ 合并。
3. 后面的第一个数比 $j$ 大。

所以需要记 $g_{i,j}$ 表示栈的大小为 $i$，最终开头为 $j$ 的期望得分，$h_{i,j}$ 表示栈的大小为 $i$，由空栈填成只有一个 $j$ 的概率，$s_{i,j}$ 表示栈的大小为 $i$，由空栈填成只有一个 $j$ 的期望得分。

那么可以得到转移方程：

$$
\begin{aligned}
h_{i,j}&amp;=p_j+h_{i,j-1}\cdot h_{i-1,j-1}\\
s_{i,j}&amp;=h_{i,j-1}s_{i-1,j-1}+h_{i-1,j-1}s_{i,j-1}+h_{i,j-1}h_{i-1,j-1}2^j\\
g_{i,j}&amp;=s_{i,j}+h_{i,j}\left(\sum_{k=0}^{j-1}g_{i-1,k}+\sum_{k=j+1}^{m}{p_kf_{i-1,k}}\right)-s_{i,j}h_{i-1,j}\\
f_{i,j}&amp;=\sum_{k=0}^{j-1}{g_{i-1,k}}+\sum_{k=j+1}^{m}{p_kf_{i-1,k}}+h_{i-1,j}\left(2^{j+1}+f_{i,j+1}\right)+s_{i-1,j}
\end{aligned}
$$

注意栈里的数可能达到 $n+m$。

时间复杂度：$O\left(n(n+m)\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e3 + 5, kMod = 998244353;

int n, m;
int p[kMaxN * 2], pw[kMaxN * 2], f[kMaxN][kMaxN * 2], g[kMaxN][kMaxN * 2],
    h[kMaxN][kMaxN * 2], s[kMaxN][kMaxN * 2];
int pre[kMaxN * 2], suf[kMaxN * 2];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1) ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  int sum = 0;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; p[i];
    inc(sum, p[i]);
  }
  sum = qpow(sum);
  for (int i = 1; i &lt;= m; ++i) p[i] = 1ll * p[i] * sum % kMod;
  pw[0] = 1;
  for (int i = 1; i &lt;= n + m + 1; ++i) pw[i] = add(pw[i - 1], pw[i - 1]);
  // get h, s
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n + m; ++j) {
      h[i][j] = add(p[j], 1ll * h[i][j - 1] * h[i - 1][j - 1] % kMod);
      s[i][j] =
          add(1ll * h[i][j - 1] * s[i - 1][j - 1] % kMod,
              add(1ll * h[i - 1][j - 1] * s[i][j - 1] % kMod,
                  1ll * h[i][j - 1] * h[i - 1][j - 1] % kMod * pw[j - 1] % kMod));
    }
  }
  // get f, g
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= n + m; ++j) {
      if (j) pre[j] = pre[j - 1];
      else pre[j] = 0;
      inc(pre[j], g[i - 1][j]);
    }
    for (int j = n + m; ~j; --j) {
      suf[j] = add(suf[j + 1], 1ll * p[j] * f[i - 1][j] % kMod);
      f[i][j] = add((j ? pre[j - 1] : (int)0), suf[j + 1]);
      g[i][j] = 1ll * h[i][j] * f[i][j] % kMod;
      inc(f[i][j], add(1ll * h[i - 1][j] * add(pw[j], f[i][j + 1]) % kMod, s[i - 1][j]));
      inc(g[i][j], 1ll * s[i][j] * sub(1, h[i - 1][j]) % kMod);
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= m; ++i)
    inc(ans, 1ll * f[n][i] * p[i] % kMod);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18112914.html</id>
    <title type="text">P9731 [CEOI2023] Balance 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-03T08:07:00Z</published>
    <updated>2024-04-03T08:07:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18112914.html" />
    <content type="text">## Description

由于黑客对评测机的攻击，组委会决定重测所有提交记录。

有 $N$ 台评测机，$T$ 个题目（编号为 $1, 2, \cdots, T$）。组委会已经确定，每台评测机要评测哪些提交（数目相同，都是 $S$ 个提交，保证 $S$ 是 $2$ 的整数次幂）。在接下来的 $S$ 分钟内，每分钟每台评测机会评测一个提交。

每个提交都会提交至某个题目。由于存数据的机器太脆弱了，所以要求，对于所有题目和任意两个时刻，在这两个时刻，这个题的被评测的提交的数量之差不超过 $1$。

请构造一组方案，使得满足上面的条件。

保证存在正整数 $k$ 使得 $S = 2 ^ k$，$1 \le N, S, T \le 10 ^ 5$，$NS \le 5 \times 10 ^ 5$。

## Solution

考虑 $S=2$ 的时候怎么做。

这里相当于要选择某些评测机并交换他们的两个题目，使得每个题目在第一列和第二列出现次数相差不超过 $1$。

那么如果把每个评测机的两个题目连一条无向边，题目等价于给每个无向边定向，使得每个点入度和出度相差不超过 $1$，这就是个欧拉回路的经典题了，只要建一个超级源点并与所有奇度点连边，然后对于每个连通块跑欧拉回路，每条边在欧拉回路里的方向就是最终的方向。

---

然后是 $S&gt;2$ 的做法。

考虑把 $S$ 平分为两段，先让每个点在这两段里出现的次数相差不超过 $1$，然后分治处理，则最后的答案一定满足条件。

建图就考虑对于每行，$a_{i,j}$ 与 $a_{j+\frac{S}{2}}$ 连边，跑上面那个算法，虽然方案不一定是刚好 swap $a_{i,j}$ 与 $a_{j+\frac{S}{2}}$，但是这样一定能构造出来。

时间复杂度：$O\left((NS+T)\log^2 S\right)$，可以用 unordered_map 优化掉一个 $\log$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5, kMaxS = 5e5 + 5;

struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;
    return x ^ (x &gt;&gt; 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        std::chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

  size_t operator()(std::pair&lt;uint64_t, uint64_t&gt; x) const {
    static const uint64_t FIXED_RANDOM =
        std::chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x.first + FIXED_RANDOM) ^
           (splitmix64(x.second + FIXED_RANDOM) &gt;&gt; 1);
  }
};

int n, m, t;
int cur[kMaxN];
bool vis[kMaxS], vs[kMaxN];
std::vector&lt;int&gt; a[kMaxN], vec;
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs(int u) {
  vs[u] = 1;
  for (int i = cur[u]; i &lt; (int)G[u].size(); i = cur[u]) {
    cur[u] = i + 1;
    int v = G[u][i].first, id = G[u][i].second;
    if (vis[id]) continue;
    vis[id] = 1, dfs(v);
  }
  vec.emplace_back(u);
}

void solve(int l, int r) {
  if (l == r) return;
  for (int i = 0; i &lt;= t; ++i)
    G[i].clear(), cur[i] = vs[i] = 0;
  int mid = (l + r) &gt;&gt; 1, len = r - l + 1, id = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = l; j &lt;= mid; ++j) {
      vis[++id] = 0;
      G[a[i][j]].emplace_back(a[i][j + len / 2], id);
      G[a[i][j + len / 2]].emplace_back(a[i][j], id);
    }
  }
  int rt = 1;
  for (int i = 1; i &lt;= t; ++i) {
    if (G[i].size() &amp; 1) {
      rt = 0, vis[++id] = 0;
      G[rt].emplace_back(i, id), G[i].emplace_back(rt, id);
    }
  }
  cur[rt] = 0;
  std::unordered_map&lt;std::pair&lt;int, int&gt;, int, my_hash&gt; mp;
  for (int i = rt; i &lt;= t; ++i) {
    if (!vs[i]) {
      vec.clear();
      dfs(i);
      for (int j = 0; j + 1 &lt; (int)vec.size(); ++j)
        ++mp[{vec[j], vec[j + 1]}];
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = l; j &lt;= mid; ++j) {
      if (!mp[{a[i][j], a[i][j + len / 2]}]) {
        std::swap(a[i][j], a[i][j + len / 2]);
      }
      --mp[{a[i][j], a[i][j + len / 2]}];
    }
  }
  solve(l, mid), solve(mid + 1, r);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;
  for (int i = 1; i &lt;= n; ++i) {
    a[i].resize(m);
    for (auto &amp;x : a[i]) std::cin &gt;&gt; x;
  }
  solve(0, m - 1);
  for (int i = 1; i &lt;= n; ++i) {
    for (auto x : a[i]) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18114553.html</id>
    <title type="text">UOJ #514. 【UR #19】通用测评号-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-04T12:17:00Z</published>
    <updated>2024-04-04T12:17:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18114553.html" />
    <content type="text">## Description

有 $n$ 个管道，每个管道的最大大小为 $a$，每次等概率随机选一个没满的管道里放一个石子，当所有管道的大小都 $\geq b$ 时停止，问装满的管道的期望个数，与 $998244353$ 取模。

$1 \le n \le 250,1 \le b &lt; a \le 250$。

## Solution

先考虑一个引理：有 $n$ 个集合，有一些集合不能加数，那么对于所有能加数的集合，它是下一个被加数的集合的概率刚好等于所有集合都能加数，且它是原本所有能加数的集合中第一个加数的概率。这个很好证。

所以原题就可以转化为每次随便加石子，最终所有的管道的大小都 $\geq b$ 时大小 $\geq a$ 的期望个数。

不妨先求 $1$ 号管道被装满的概率，最终答案就是这个概率$\times n$。

由于操作序列是无法确定长度的，所以不好求概率。考虑利用引理，定义一个管道不能再加石子当且仅当它是 $1$ 号且 $\geq a$ 或者不是 $1$ 号且 $\geq b$。

这样的话操作序列长就是 $(n-1)\times b+a$ 了，然后只要用 $1$ 减去最后一步是 $1$ 号管道的概率。

不妨设 $t_i$ 表示 $i$ 最后一次操作的时间（$1\leq t_1&lt;t_2&lt;\dots&lt;t_{n-1}&lt;(n-1)\times b+a$），则最后一步是 $1$ 的概率即为：

$$
\frac{\prod_{i=1}^{n-1}{\binom{t_i-1-(i-1)b}{b-1}}}{\prod_{i=1}^{n-1}{(n-i+1)^{t_{i}-t_{i-1}}}}
$$

上面那个是总的方案数，下面是选择每个位置要乘的概率。

然后对这个进行 dp 即可，设 $f_{i,j}$ 表示当前在时间 $i$，有 $j$ 个非 $1$ 管道被填满的概率，则 $f_{i+1,j}\leftarrow \frac{f_{i,j}}{n-j},f_{i+1,j+1}\leftarrow \frac{f_{i,j}\times \binom{i-j\cdot b}{b-1}}{n-j}$。

最终答案就是 $n\times \left(1-(n-1)!\times f_{(n-1)b+a-1,n-1}\right)$。

时间复杂度：$O(n^2b+na)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 255, kMaxS = 9e4 + 5, kMod = 998244353;

int n, a, b;
int fac[kMaxS], ifac[kMaxS], inv[kMaxS], f[kMaxS][kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= n * a; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
  prework();
  int m = (n - 1) * b + a;
  f[0][0] = 1;
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt;= std::min(n - 1, i / b); ++j) {
      int p = 1ll * f[i][j] * inv[n - j] % kMod;
      inc(f[i + 1][j], p), inc(f[i + 1][j + 1], 1ll * p * C(i - j * b, b - 1) % kMod);
    }
  }
  std::cout &lt;&lt; 1ll * n * sub(1, 1ll * f[m - 1][n - 1] * fac[n - 1] % kMod) % kMod &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18115792.html</id>
    <title type="text">P9058 [Ynoi2004] rpmtdq 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-05T07:46:00Z</published>
    <updated>2024-04-05T07:46:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18115792.html" />
    <content type="text">## Description

给定一棵有边权的无根树，需要回答一些询问。

定义 $\texttt{dist(i,j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离。

对于每一组询问，会给出 $l,r$，你需要输出 $\min(\texttt{dist(i,j)})$ 其中 $l\leq i &lt; j \leq r$。$n\leq2\times 10^5$，$q\leq 10^6$，$1\le z\le 10^9$。

## Solution

注意到一个点对 $[l,r]$ 能作为询问的答案，当且仅当 $\min(\texttt{dist(i,j)})=\texttt{dist(i,j)}(l\leq i&lt;j\leq r)$，考虑求出所有这样的 $[l,r]$，然后二维数点即可。

先点分治，假设分治中心为 $x$，$i$ 到 $x$ 的距离为 $a_i$。

那么 $\texttt{dist(i,j)}=a_i+a_j$，则如果 $i&lt;k&lt;j$ 且 $\texttt{dist(i,k)}\geq \texttt{dist(i,j)},\texttt{dist(k,j)}\geq \texttt{dist(i,j)}$，$[i,j]$ 就可以加到重要区间内。

化简一下就是 $\max\left\{a_i,a_j\right\}\leq \min_{k=i+1}^{j-1}{a_k}$，容易发现如果按照 $a$ 从小到大加点，那么加入 $j$ 时，$i$ 一定是 $j$ 的前驱或后继，用 set 维护即可。

时间复杂度：$O(n\log^2n+q\log n)$。

但是这样做常数太大了，过不了，因此点分治部分可以先按照编号大小排序，然后正反扫两边，维护单调栈即可。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxQ = 1e6 + 5;

int n, q, rt;
int mx[kMaxN], sz[kMaxN], stk[kMaxN];
int64_t dis[kMaxN], ans[kMaxQ];
bool del[kMaxN];
std::vector&lt;int&gt; vec;
std::vector&lt;std::pair&lt;int, int64_t&gt;&gt; qq[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN], qr[kMaxN];

struct BIT {
  int64_t c[kMaxN];

  BIT() { memset(c, 0x3f, sizeof(c)); }

  void upd(int x, int64_t v) {
    for (; x; x -= x &amp; -x) c[x] = std::min(c[x], v);
  }

  int64_t qry(int x) {
    int64_t ret = 1e18;
    for (; x &lt;= n; x += x &amp; -x) ret = std::min(ret, c[x]);
    return ret;
  }
} bit;

void getsz(int u, int fa) {
  mx[u] = 0, sz[u] = 1;
  for (auto [v, w] : G[u]) {
    if (v == fa || del[v]) continue;
    getsz(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
  }
}

void getrt(int u, int fa, int tot) {
  mx[u] = std::max(mx[u], tot - sz[u]);
  if (mx[u] &lt; mx[rt]) rt = u;
  for (auto [v, w] : G[u]) {
    if (v == fa || del[v]) continue;
    getrt(v, u, tot);
  }
}

void dfs2(int u, int fa) {
  vec.emplace_back(u);
  for (auto [v, w] : G[u]) {
    if (v == fa || del[v]) continue;
    dis[v] = dis[u] + w;
    dfs2(v, u);
  }
}

void dfs1(int u) {
  dis[u] = 0, dfs2(u, 0);
  std::sort(vec.begin(), vec.end());
  int top = 0;
  for (auto x : vec) {
    for (; top &amp;&amp; dis[stk[top]] &gt; dis[x]; --top) {}
    if (top) qq[x].emplace_back(stk[top], dis[x] + dis[stk[top]]);
    stk[++top] = x;
  }
  top = 0;
  std::reverse(vec.begin(), vec.end());
  for (auto x : vec) {
    for (; top &amp;&amp; dis[stk[top]] &gt; dis[x]; --top) {}
    if (top) qq[stk[top]].emplace_back(x, dis[x] + dis[stk[top]]);
    stk[++top] = x;
  }
  vec.clear(), vec.shrink_to_fit();
  del[u] = 1;

  for (auto [v, w] : G[u]) {
    if (del[v]) continue;
    rt = 0, getsz(v, 0), getrt(v, 0, sz[v]), dfs1(rt);
  }
}

void solve() {
  for (int r = 1; r &lt;= n; ++r) {
    for (auto [l, w] : qq[r]) bit.upd(l, w);
    for (auto [l, id] : qr[r]) ans[id] = bit.qry(l);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
  }
  mx[0] = 1e9, getsz(1, 0), getrt(1, 0, n), dfs1(rt);
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    ans[i] = 1e18;
    if (l != r) qr[r].emplace_back(l, i);
    else ans[i] = -1;
  }
  solve();
  for (int i = 1; i &lt;= q; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18117733.html</id>
    <title type="text">CF1149D Abandoning Roads 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-06T10:43:00Z</published>
    <updated>2024-04-06T10:43:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18117733.html" />
    <content type="text">## Description

一张 $n$ 个点 $m$ 条边的无向图，只有 $a,b$ 两种边权（$a&lt;b$），对于每个 $i$，求图中所有的最小生成树中，从 $1$ 到 $i$ 距离的最小值。

$2\leq n\leq 70,n-1\leq m\leq 200,1\leq a&lt;b\leq 10^7$。

## Solution

先考虑一个最小生成树是什么样的形态，显然保留边权为 $a$ 的边后形成的连通块和原图保留 $a$ 边的连通块完全相同，并且树中连接连通块之间的边都是 $b$ 边。

所以树上两点的简单路径一定是先走 $a$ 再走 $b$ 再走 $a$，以此类推，并且如果出了一个连通块就不会再回来，容易发现在原图中如果存在一条这样的 $1$ 到 $i$ 的路径，那么在新树中一定也存在。

这样就可以 dp 了，设 $f_{s,i}$ 表示已经出了 $s$ 这个集合的所有连通块，并且当前在 $j$ 的最短路。跑 dijkstra 即可。

时间复杂度：$O(2^nn)$。

考虑优化。

注意到对于一个大小不超过 $3$ 的连通块，如果出了它再走回来一定没有直接走连通块内的边优，所以这些连通块不用记到状态里，则状态数总共就只有 $2^{\frac{n}{4}}$ 个了。

时间复杂度：$O(2^{\frac{n}{4}}n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 75, kMaxS = (1 &lt;&lt; 18);

int n, m, a, b, cnt, tot;
int g[kMaxN][kMaxN], id[kMaxN], f[kMaxN][kMaxS];
bool vis[kMaxN];
std::vector&lt;int&gt; vec;

void dfs(int u) {
  vec.emplace_back(u), vis[u] = 1;
  for (int i = 1; i &lt;= n; ++i)
    if (g[u][i] == a &amp;&amp; !vis[i])
      dfs(i);
}

void dijkstra() {
  static bool vis[kMaxN][kMaxS] = {0};
  memset(f, 0x3f, sizeof(f));
  std::priority_queue&lt;std::tuple&lt;int, int, int&gt;&gt; q;
  f[1][0] = 0, q.emplace(0, 1, 0);
  for (; !q.empty();) {
    auto [d, i, s] = q.top(); q.pop();
    if (vis[i][s]) continue;
    vis[i][s] = 1;
    for (int j = 1; j &lt;= n; ++j) {
      if (!g[i][j]) continue;
      int t = s;
      if (id[j] &lt; cnt) {
        if (s &gt;&gt; id[j] &amp; 1) continue;
        if (id[j] == id[i]) {
          if (g[i][j] == a &amp;&amp; f[j][t] &gt; f[i][s] + g[i][j]) {
            f[j][t] = f[i][s] + g[i][j], q.emplace(-f[j][t], j, t);
          }
        } else {
          if (id[i] &lt; cnt) t |= (1 &lt;&lt; id[i]);
          if (f[j][t] &gt; f[i][s] + g[i][j]) {
            f[j][t] = f[i][s] + g[i][j], q.emplace(-f[j][t], j, t);
          }
        }
      } else {
        if (id[j] == id[i]) {
          if (g[i][j] == a &amp;&amp; f[j][t] &gt; f[i][s] + g[i][j]) {
            f[j][t] = f[i][s] + g[i][j], q.emplace(-f[j][t], j, t);
          }
        } else {
          if (id[i] &lt; cnt) t |= (1 &lt;&lt; id[i]);
          if (f[j][t] &gt; f[i][s] + g[i][j]) {
            f[j][t] = f[i][s] + g[i][j], q.emplace(-f[j][t], j, t);
          }
        }
      }
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    g[u][v] = g[v][u] = w;
  }
  for (int i = 1; i &lt;= n; ++i) {
    if (vis[i]) continue;
    dfs(i);
    if (vec.size() &gt;= 4) {
      for (auto x : vec) id[x] = tot;
      ++cnt, ++tot;
    }
    vec.clear();
  }
  std::fill_n(vis + 1, n, 0);
  for (int i = 1; i &lt;= n; ++i) {
    if (vis[i]) continue;
    dfs(i);
    if (vec.size() &lt;= 3) {
      for (auto x : vec) id[x] = tot;
      ++tot;
    }
    vec.clear();
  }
  dijkstra();
  for (int i = 1; i &lt;= n; ++i)
    std::cout &lt;&lt; *std::min_element(f[i], f[i] + (1 &lt;&lt; cnt)) &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18117911.html</id>
    <title type="text">UOJ #710. 【北大集训2021】魔塔 OL-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-06T12:42:00Z</published>
    <updated>2024-04-06T12:42:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18117911.html" />
    <content type="text">## Description

# [北大集训 2021] 魔塔 OL

## 题目背景

CTT2021 D1T2

## 题目描述

比特游戏公司最近发布了一款新游戏《魔塔 Online》，玩家可以操控勇士在游戏世界中与怪物进行搏斗。在游戏发布之初，魔塔里没有任何怪物，接下来将依次发生 $q$ 个事件，每个事件是以下三种之一：

* `+ x y z a b`：表示游戏发布了新版本，在游戏中新增了一只怪物。如果这是第一只新增的怪物，那么它的编号为 $1$；否则它的编号为最后一只新增的怪物的编号 $+1$。这只怪物位于魔塔的第 $x$ 层，它的等级为 $y$ 级，它的难度为 $z$。如果玩家选择击杀这只怪物，那么需要消耗 $a$ 点血量，在击杀成功后，玩家将得到一支可以恢复 $b$ 点血量的药剂并立即使用。
* `- k`：表示游戏发布了新版本，编号为 $k$ 的怪物由于平衡性问题下架，它将不会出现在魔塔中。请注意：下架的怪物**仍然保留它们的编号**，未来新增的怪物**不会复用**被下架怪物的编号。
* `? g l d`：表示一个询问。某玩家希望击杀魔塔前 $g$ 层中**所有**等级**不超过** $l$ 且难度**不超过** $d$ 的怪物。玩家可以按照**任意顺序**去击杀这些怪物，登上新的一层**不需要杀光**当前层的所有怪物，且作战过程中不会受到别的怪物的干扰。你的任务是帮助该玩家计算出征前勇士的血量**最少**是多少。如果某个时刻勇士的血量是**负数**，那么游戏结束，你一定要防止这种情况的发生。

请写一个程序，依次回答每个询问。注意：每个询问只是玩家的一个思考，**不会真正击杀**任何一只怪物。

输入数据保证 $1\leq q\leq 150\,000$，怪物总数不超过 $50\,000$，询问数量不超过 $50\,000$。

对于新增怪物操作，保证 $1\leq x,y,z\leq 10\,000$，且 $0\leq a,b\leq 10^9$。

对于下架怪物操作，保证操作合法，且每只怪物不会被重复下架。

对于询问，保证 $1\leq g,l,d\leq 10\,000$。

## Solution

考虑怎么单次 $O(n)$ 做这个事情。

容易发现打完怪物后能回血的一定要放前面，且回血的怪物内部一定是按照 $a$ 从小到大排序，不回血的怪物按照 $b$ 从大到小排序，答案就是前缀最小值的相反数。

显然这个东西加上动态三维偏序用 polylog 算法一定过不了，于是考虑优化 $O(n^2)$。

先把所有的怪物拿出来排好序，设有 $n$ 个，询问次数为 $m$，则可以用一个 bitset 维护每一维前缀的怪物编号，把三维的前缀与起来就可以得到三维偏序的怪物。

但是这样显然过不了，因为每次更新要改变每维的一个后缀。

考虑分块，设每个块的大小为 $B$，每次对于一个 $B$ 去做上面那个暴力，计算这个块对答案的贡献。

则单次复杂度为 $O\left(2^B(n+m+V)\right)$，总复杂度为 $O\left(\frac{n}{B}\cdot 2^B(n+m+V)\right)$，当 $B=\log n$ 时取到最小值 $O\left(\frac{n(n+m+V)}{\log n}\right)$。

因此时间复杂度：$O\left(\frac{n(n+m+V)}{\log n}\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e4 + 5, kMaxV = 1e4 + 5, kMaxQ = 1.5e5 + 5;

struct Node {
  int x, y, z, a, b, l, r;
} a[kMaxN];

int n, m, q, b;
int x[kMaxN], y[kMaxN], z[kMaxN], t[kMaxN];
int64_t sum[kMaxN], ans[kMaxN];

bool cmp(Node a, Node b) {
  bool fl1 = (a.a &gt; a.b), fl2 = (b.a &gt; b.b);
  if (fl1 != fl2) return fl1 &lt; fl2;
  else if (fl1 == 0) return a.a &lt; b.a;
  else return a.b &gt; b.b;
}

void solve(int l, int r) {
  static int s[kMaxV][3];
  static int64_t sm[kMaxN], mi[kMaxN];
  memset(s, 0, sizeof(s));
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
  for (int i = l; i &lt;= r; ++i) {
    vec.emplace_back(a[i].l, (1 &lt;&lt; (i - l)));
    vec.emplace_back(a[i].r, (1 &lt;&lt; (i - l)));
    s[a[i].x][0] |= (1 &lt;&lt; (i - l));
    s[a[i].y][1] |= (1 &lt;&lt; (i - l));
    s[a[i].z][2] |= (1 &lt;&lt; (i - l));
  }
  for (int s = 1; s &lt; (1 &lt;&lt; (r - l + 1)); ++s) {
    int i = 31 - __builtin_clz(s) + l, t = s ^ (1 &lt;&lt; (i - l));
    mi[s] = std::min(mi[t], sm[t] - a[i].a);
    sm[s] = sm[t] - a[i].a + a[i].b;
  }
  for (int i = 1; i &lt; kMaxV; ++i) {
    s[i][0] |= s[i - 1][0];
    s[i][1] |= s[i - 1][1];
    s[i][2] |= s[i - 1][2];
  }
  std::sort(vec.begin(), vec.end());
  int p = 0, now = 0;
  for (int i = 1; i &lt;= m; ++i) {
    for (; p &lt; vec.size() &amp;&amp; vec[p].first &lt;= t[i]; ++p)
      now ^= vec[p].second;
    int msk = now &amp; s[x[i]][0] &amp; s[y[i]][1] &amp; s[z[i]][2];
    ans[i] = std::min(ans[i], sum[i] + mi[msk]);
    sum[i] += sm[msk];
  }
}

void dickdreamer() {
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    std::string op;
    std::cin &gt;&gt; op;
    if (op[0] == '+') {
      ++n;
      std::cin &gt;&gt; a[n].x &gt;&gt; a[n].y &gt;&gt; a[n].z &gt;&gt; a[n].a &gt;&gt; a[n].b;
      a[n].l = i, a[n].r = q + 1;
    } else if (op[0] == '-') {
      int k;
      std::cin &gt;&gt; k;
      a[k].r = i;
    } else {
      ++m;
      std::cin &gt;&gt; x[m] &gt;&gt; y[m] &gt;&gt; z[m];
      t[m] = i;
    }
  }
  std::sort(a + 1, a + 1 + n, cmp);
  b = std::max(1, std::__lg(n));
  for (int i = 1; i &lt;= n; i += b) solve(i, std::min(i + b - 1, n));    
  for (int i = 1; i &lt;= m; ++i) std::cout &lt;&lt; -ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18122405.html</id>
    <title type="text">CF1361E James and the Chase 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-08T11:45:00Z</published>
    <updated>2024-04-08T11:45:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18122405.html" />
    <content type="text">## Description

给定一个有 $n$ 个点 $m$ 条边的**有向强连通图**。称一个点是**好的**当且仅当它到其他点都有且只有一条**简单路径**。如果好的点至少有 $20\%$ 则输出所有好的点，否则输出 `-1`。

**单个测试点内有多组数据。**
$1\leq T\leq 2\times 10^3,1\leq n\leq 10^5,1\leq m\leq 2\times 10^5,\sum n\leq 10^5,\sum m\leq 2\times 10^5$。

## Solution

考虑如何判断一个点是否是好的。

先以一个点 $x$ 为根建出 dfs 树，如果建不出来显然不合法，并且如果一条非树边不是返祖边，就说明存在横叉边，显然不合法。

容易发现满足上面的两个条件就一定合法，但是这样做单次是 $O(n)$ 的，过不了。

先不妨假设 $x$ 是好点，那么对于一个点 $y$，如果他是好点，就说明其子树里有且仅有 $1$ 条返祖边其祖先为 $y$ 的祖先，设其为 $z\to w$。

然后有一个性质：如果 $y$ 是好点当且仅当 $w$ 是好点。

证明：

如果 $y$ 是好点，由于 $w\to y$ 只有一条路径，所以 $w\to y$ 的子树的路径都有且仅有一条，并且 $y$ 要出 $w$ 的子树就必须经过 $w$，由于 $y\to w$ 子树外的点的路径都是唯一的，所以 $w\to w$ 子树外的点的路径也是唯一的，所以 $w$ 是好点。

如果 $w$ 是好点，由于 $w$ 到所有点路径唯一且 $y$ 出 $w$ 子树必须经过 $w$，所以 $y$ 也是好点。

所以先找到一个为好点的 $x$，然后做树上差分对于每个 $y$ 求出 $w$ 用并查集合并即可。

然后对于每个好点就一定和 $x$ 在同一并查集，否则无论如何也到不了 $x$。

至于找 $x$，就每次随机一个点做 $100$ 次，失败的概率是 $\left(\frac{4}{5}\right)^{100}$，非常小。

时间复杂度：$O\left(100(n+m)\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, m, fl = 1;
int cnt[kMaxN], sum[kMaxN], fa[kMaxN];
bool ins[kMaxN], vis[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

void unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) fa[fx] = fy;
}

void dfs1(int u) {
  vis[u] = ins[u] = 1;
  for (auto v : G[u]) {
    if (!vis[v]) {
      dfs1(v);
    } else {
      if (!ins[v]) fl = 0;
      else ++cnt[u], --cnt[v], sum[u] += v, sum[v] -= v;
    }
  }
  ins[u] = 0;
}

void dfs2(int u) {
  ins[u] = 1;
  for (auto v : G[u]) {
    if (!ins[v]) {
      dfs2(v);
      cnt[u] += cnt[v], sum[u] += sum[v];
    } else {
    }
  }
  ins[u] = 0;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v);
  }
  std::vector&lt;int&gt; vec;
  for (int i = 1; i &lt;= n; ++i) vec.emplace_back(i);
  std::shuffle(vec.begin(), vec.end(), std::mt19937(std::chrono::steady_clock::now().time_since_epoch().count()));
  for (int i = 0; i &lt; std::min(100, (int)vec.size()); ++i) {
    int x = vec[i];
    for (int i = 1; i &lt;= n; ++i) {
      fa[i] = i;
      cnt[i] = sum[i] = ins[i] = vis[i] = 0;
    }
    fl = 1, dfs1(x);
    if (!fl) continue;
    std::fill_n(ins + 1, n, 0);
    dfs2(x);
    for (int i = 1; i &lt;= n; ++i) {
      if (cnt[i] == 1) {
        unionn(i, sum[i]);
      }
    }
    std::vector&lt;int&gt; idx;
    for (int i = 1; i &lt;= n; ++i)
      if (find(i) == find(x))
        idx.emplace_back(i);
    if (idx.size() &gt;= (n + 4) / 5) {
      for (auto u : idx) std::cout &lt;&lt; u &lt;&lt; ' ';
      std::cout &lt;&lt; '\n';
    } else {
      std::cout &lt;&lt; "-1\n";
    }
    return;
  }
  std::cout &lt;&lt; "-1\n";
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18153615.html</id>
    <title type="text">min-max 容斥-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-23T12:00:00Z</published>
    <updated>2024-04-23T12:00:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18153615.html" />
    <content type="text">min-max 容斥也称之为最值反演。

$$Max(S)=\sum_{T\subseteq S,T\neq \varnothing}{(-1)^{|T|-1}\cdot Min(T)}$$

定义 $kMax(S)$ 等于 $S$ 的第 $k$ 大值，那么：

$$kMax(S)=\sum_{T\subseteq S,|T|\geq k}{(-1)^{|T|-k}Min(T)\cdot C_{|T|-1}^{k-1}}$$

$$E\left(Max(S)\right)=\sum_{T\subseteq S}{(-1)^{|T|-1}{E\left(Min(T)\right)}}$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18160895.html</id>
    <title type="text">P4707 重返现世 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-04-26T13:30:00Z</published>
    <updated>2024-04-26T13:30:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18160895.html" />
    <content type="text">## Description

为了打开返回现世的大门，Yopilla 需要制作开启大门的钥匙。Yopilla 所在的迷失大陆有 $n$ 种原料，只需要集齐任意 $k$ 种，就可以开始制作。

Yopilla 来到了迷失大陆的核心地域。每个单位时间，这片地域就会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是  $\frac{p_i}{m}$。如果 Yopilla 没有这种原料，那么就可以进行收集。

Yopilla 急于知道，他收集到任意 $k$ 种原料的期望时间，答案对 $998244353$ 取模。

$1 \le n \le 1000$，$1 \le k \le n, \lvert n - k \rvert \le 10$，$0 \le p_i \le m, \sum p = m, 1 \le m \le 10000$。

## Solution

先让 $k\leftarrow n-k+1$，那么原题相当于求 $E\left(\text{kMax}(T)\right)$，这玩意可以用 min-max 容斥转化为：

$$
\sum_{|S|\geq k}{(-1)^{|S|-k}E\left(\text{Min}(S)\right)\binom{|S|-1}{k-1}}
$$

容易发现对于一个集合 $S$，它的第一次出现的期望就是 $\dfrac{m}{\sum_{i\in S}{p_i}}$，然后对这个进行 dp 即可。

设 $f_{i,j,k}$ 表示考虑到了编号 $1\sim i$，选了 $j$ 个数，目前和为 $k$ 的方案数，直接进行 dp 是 $O(n^2m)$ 的，过不了。

考虑优化。

注意到 $\sum{p_i}$ 这个东西在分母，所以一定是无法优化掉的，于是可以考虑把个数那一维去掉。

设 $g_{i,j}$ 表示目前考虑了 $1\sim i$，和为 $j$ 的所有方案的 $\sum{\frac{(-1)^{|S|-k}\binom{|S|-1}{k}}{\sum_{p_i}}}$。

那么如果 $i$ 不选，则 $g_{i,j}\leftarrow g_{i-1,j}$。

如果 $i$ 选，会发现哪个组合数不好搞，但是注意到 $\binom{|S|-1}{k-1}=\binom{|S|-2}{k-1}+\binom{|S|-2}{k-2}$，且前面的 $-1$ 是好处理的，所以那个组合数也可以 dp 求出。

但是这里 $k$ 会变化且很小，所以可以记一维 $k$，即 $g_{i,j,k}=g_{i-1,j,k}+g_{i-1,j-p_i,k-1}-g_{i-1,j-p_i,k}$。

边界是 $g_{0,0,0}=1$。

时间复杂度：$O\left(nm(n-k)\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e3 + 5, kMaxM = 1e4 + 5, kMaxK = 15, kMod = 998244353;

int n, k, m;
int p[kMaxN], f[2][kMaxM][kMaxK];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;
  k = n - k + 1;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; p[i];
  int o = 0;
  f[o][0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    if (!p[i]) continue;
    o ^= 1;
    for (int j = 0; j &lt;= m; ++j)
      for (int s = 0; s &lt;= k; ++s)
        f[o][j][s] = f[o ^ 1][j][s];
    for (int j = p[i]; j &lt;= m; ++j) {
      for (int s = 1; s &lt;= k; ++s) {
        inc(f[o][j][s], sub(f[o ^ 1][j - p[i]][s - 1], f[o ^ 1][j - p[i]][s]));
      }
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= m; ++i) {
    inc(ans, 1ll * f[o][i][k] * m % kMod * qpow(i) % kMod);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18172585.html</id>
    <title type="text">牛客 215E 黄魔法师 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-05-04T11:17:00Z</published>
    <updated>2024-05-04T11:17:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18172585.html" />
    <content type="text">## Description

给出 $n, k$，求一个长度为 $n$ 的数组 $a$, 满足有恰好 $k$ 对数对 $(i, j) (1 \leq i &lt; j \leq n)$ 满足 $a_i + a_j$ 为完全平方数。如果不存在，输出 $-1$。

[link](https://ac.nowcoder.com/acm/contest/215/E)

## Solution

显然如果 $k&gt;\binom{n}{2}$ 就一定无解。

构造时会发现肯定要尽量弄成相同的然后进行微调，那么设 $m$ 为最大的数满足 $\binom{m}{2}\leq k$，$r=k-\binom{m}{2}$。

这个时候直接选 $m$ 个 $2$ 会发现多出来的 $r$ 很难微调，因为这个时候要是调整加数的话最小就是增加 $m$ 了。

这时可以把 $m$ 个数拆成 $r$ 个 $A$ 和 $m-r$ 个 $B$，然后找 $1$ 个 $C$ 使得 $A+B,2A,2B,A+C$ 均为完全平方数并且其他的都不是完全平方数，剩下多的 $n-m-1$ 个 $D$ 只要随便找一个数使得加出来不是完全平方数即可。

经枚举 $A=2,B=98,C=7,D=1$ 可以满足条件。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, k, m, r;

bool check(int x) {
  int y = sqrtl(x);
  for (; y * y &gt; x; --y) {}
  for (; (y + 1) * (y + 1) &lt;= x; ++y) {}
  return x == y * y;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  if (k &gt; n * (n - 1) / 2) return void(std::cout &lt;&lt; "-1\n");
  for (m = 1; m * (m + 1) / 2 &lt;= k; ++m) {}
  if (n == m) {
    for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; "2 ";
    return;
  }
  r = k - m * (m - 1) / 2;
  for (int i = 1; i &lt;= r; ++i) std::cout &lt;&lt; "2 ";
  for (int i = 1; i &lt;= m - r; ++i) std::cout &lt;&lt; "98 ";
  std::cout &lt;&lt; "7 ";
  for (int i = 1; i &lt;= n - m - 1; ++i) std::cout &lt;&lt; "1 ";
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18180777.html</id>
    <title type="text">省队集训2024 Day6 T1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-05-08T12:10:00Z</published>
    <updated>2024-05-08T12:10:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18180777.html" />
    <content type="text">## Description

给定 $m$ 个 $\{1,2,\dots,n\}$ 的子集，要求选出两个不交的编号集合，使得两组编号所对应的集合并相等。

$n+1\leq m\leq 500$。

## Solution

考虑强化原题。

不妨把每个集合看成一个 $n$ 为向量 $X_i$，设大小为 $i$ 的序列 $s$ 和 $t$，如果 $i$ 被第一个集合选了则 $s_i$ 为正数，被第二个选了则 $t_i$ 为正数。

题目等价于找到 $s,t$，使得 $\sum_{i=1}^{m}{X_i s_i}=\sum_{i=1}^{m}{X_i t_i}$，等价于 $\sum_{i=1}^{m}{X_i (s_i-t_i)}=0$。

这里用高斯消元解出 $s$ 和 $t$ 即可，注意如果一个 $a_i$ 的解为无数个则把他设为 $1$ 来保证方案不全为 $0$。

时间复杂度：$O(m^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using f64 = long double;

const int kMaxN = 505;
const f64 kEps = 1e-6;

int n, m;
int sz[kMaxN];
f64 a[kMaxN][kMaxN], res[kMaxN];

void solve() {
  static int vis[kMaxN] = {0};
  int now = 0;
  std::fill_n(vis + 1, m, 0);
  std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(5);
  for (int i = 1; i &lt;= m; ++i) {
    ++now;
    if (abs(a[now][i]) &lt; kEps) {
      for (int j = now + 1; j &lt;= n; ++j) {
        if (abs(a[j][i]) &gt;= kEps) {
          std::swap(a[now], a[j]); break;
        }
      }
      if (abs(a[now][i]) &lt; kEps) {
        --now; continue;
      }
    }
    vis[i] = now;
    for (int j = 1; j &lt;= n; ++j) {
      if (j == now || abs(a[j][i]) &lt; kEps) continue;
      f64 d = a[j][i] / a[now][i];
      for (int k = i; k &lt;= m + 1; ++k)
        a[j][k] -= a[now][k] * d;
    }
    if (now == n) break;
  }
  for (int i = m; i; --i) {
    if (!vis[i]) {
      res[i] = 1; break;
    }
  }
  for (int i = m; i; --i) {
    if (vis[i]) {
      int p = vis[i];
      res[i] = a[p][m + 1];
      for (int j = 1; j &lt;= m; ++j)
        if (i != j) res[i] -= res[j] * a[p][j];
      res[i] /= a[p][i];
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; sz[i];
  for (int i = 1; i &lt;= m; ++i) {
    for (int j = 1; j &lt;= sz[i]; ++j) {
      int x;
      std::cin &gt;&gt; x;
      a[x][i] = 1;
    }
  }
  solve();
  std::vector&lt;int&gt; vec1, vec2;
  for (int i = 1; i &lt;= m; ++i) {
    if (res[i] &gt; kEps) vec1.emplace_back(i);
    if (res[i] &lt; -kEps) vec2.emplace_back(i);
  }
  std::cout &lt;&lt; vec1.size() &lt;&lt; ' ' &lt;&lt; vec2.size() &lt;&lt; '\n';
  for (auto x : vec1) std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
  for (auto x : vec2) std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}

int32_t main() {
  freopen("moon.in", "r", stdin);
  freopen("moon.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18204776.html</id>
    <title type="text">best 定理-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-05-21T11:22:00Z</published>
    <updated>2024-05-21T11:22:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18204776.html" />
    <content type="text">对于有向欧拉图G，其不同欧拉回路的总数cnt(G)为：

$$
cnt(G)=T\cdot\prod_{i\in V}{(deg_i-1)!}
$$

其中T表示对于任意节点x的G的内向树的的生成树个数。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18218674.html</id>
    <title type="text">lgv 引理-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-05-28T11:14:00Z</published>
    <updated>2024-05-28T11:14:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18218674.html" />
    <content type="text">lgv 引理：在一张有向无环图中，有边权，给定起点点集A，终点点集B，且A、B中点数一致。

定义P表示dag中一条路径

定义w(P)表示路径P上的边权乘积。

定义e(a,b)表示a到b的所有路径的边权乘积之和，即$e(a,b)=\sum_{P_i\in a\to b}{\omega(P_i)}$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18231542.html</id>
    <title type="text">支配树-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-06-04T11:12:00Z</published>
    <updated>2024-06-04T11:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18231542.html" />
    <content type="text">在有向图 G 中，存在源点 s，若从 s 出发的到达点 y 的路径都经过点 x，称 x 支配 y。

注意：若源点 s 有多个，则可以虚拟一个起点。

性质 1：源点 s 支配所有的点，点 x 一定支配 x 本身。

性质 2：支配的传递性，若 x 支配 y，y 支配 z，则 x 支配 z。

性质 3：若 x 支配 y，y 支配 x，则 x=y。

性质 4：若 x 支配 z，y 支配 z，则 x 和 y 之间一定存在支配关系。

定义 dom[i] 表示支配点i的点集，idom[i] 表示支配点i的点集中离i最近且不等于i的点。

性质 5：除了源点s，所有点i都有唯一的idom[i]

将i只想idom[i]即可得到一棵树，称之为原有向图的支配树。

性质 6：支配树的根节点为原图的源点s，形态唯一。

性质 7：支配树上点i的所有祖先节点，就是点集dom[i]

应用场景：无向图的必经点的分析工具是圆方树，有向图的必经点的分析工具是支配树。

DAG图的支配树：
对于DAG的拓扑序，显然拓扑序大的节点不可达拓扑序最小的节点，进而拓扑序大的点不能支配拓扑序小的点</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18262674.html</id>
    <title type="text">P1971 [NOI2011] 兔兔与蛋蛋游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-06-22T12:07:00Z</published>
    <updated>2024-06-22T12:07:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18262674.html" />
    <content type="text">## Description

这些天，兔兔和蛋蛋喜欢上了一种新的棋类游戏。

这个游戏是在一个 $n$ 行 $m$ 列的棋盘上进行的。游戏开始之前，棋盘上有一个格子是空的，其它的格子中都放置了一枚棋子，棋子或者是黑色，或者是白色。

每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：

* 兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。
* 蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。

第一个不能按照规则操作的人输掉游戏。为了描述方便，下面将操作“将第 $x$ 行第 $y$ 列中的棋子移进空格中”记为 $M(x,y)$。

例如下面是三个游戏的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6wfmhuf2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/j7vox6n7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/er1t5wpb.png)

最近兔兔总是输掉游戏，而且蛋蛋格外嚣张，于是兔兔想请她的好朋友——你——来帮助她。她带来了一局输给蛋蛋的游戏的实录，请你指出这一局游戏中所有她“犯错误”的地方。

注意：

* 两个格子相邻当且仅当它们有一条公共边。
* 兔兔的操作是“犯错误”的，当且仅当，在这次操作前兔兔有必胜策略，而这次操作后蛋蛋有必胜策略。

$1\leq n,m\leq 40$。

## Solution

考虑什么样的情况是必胜状态。

先有一个性质，就是一个位置最多被空格经过一次。

因为如果经过 $(x,y)$ 两次，则这两次之间的操作次数一定为偶数，那么如果最开始空格走到一个原本为黑色的格，那么 $(x,y)$ 就变成了黑色，而经过偶数次后再要回到 $(x,y)$ 必须要求 $(x,y)$ 为白色，矛盾。

所以一个位置最多被经过一次。

那么按照初始状态染色，黑格或者空格染黑，白格染白，则每次一定是走到相邻的且未经过的颜色不同的格子。

按照这个颜色进行黑白染色就变成一个二分图的问题，即：有一个起点 $s$，每次走到有连边的未经过的点，走不了的输，问谁有必胜策略。

有个结论是先手必胜等价于起点是最大匹配的**必经点**。

证明就是如果起点是必经点，设走到 $x$，$x$ 的下一步一定是个必经点，否则 $x$ 连下一步的点一定构成一个新的最大匹配。所以先手每步都会走到必经点，所以其必定能走到它的匹配点。而后手到最后总会先走不动，所以先手必胜。

如果起点是非必经点，则下一步一定走到必经点，否则也能构造出一个更大的匹配。然后就变成了起点是必经点的问题，所以这里先手必败。

---

所以题目就变成了每次删点，然后判断一个点是否为最大匹配必经点。考虑倒着做，每次加点然后在残量网络上跑网络流，如果有更新则为必经点。

然后这题就做完了。

时间复杂度：$O(knm\sqrt{nm})$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e3 + 5, kMaxM = 1e5 + 5;
const int kD[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int n, m, k;
int col[45][45], x[kMaxN], y[kMaxN], cnt[kMaxN];
bool del[kMaxN];

int getid(int x, int y) { return (x - 1) * m + y; }

namespace Dinic {
struct Node {
  int v, w, pre;

  Node(int _v = 0, int _w = 0, int _pre = 0) : v(_v), w(_w), pre(_pre) {}
} e[kMaxM];

int n, s, t, tot = 1, tail[kMaxN], cur[kMaxN], dep[kMaxN];
bool vis[kMaxN];

void addedge(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { addedge(u, v, w), addedge(v, u, 0); }
void init(int _n, int _s, int _t) {
  n = _n, s = _s, t = _t, tot = 1, std::fill_n(tail, n + 1, 0);
}

bool bfs() {
  for (int i = 1; i &lt;= n; ++i)
    cur[i] = tail[i], vis[i] = 0, dep[i] = 1e9;
  std::queue&lt;int&gt; q;
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v, w = e[i].w;
      if (w &amp;&amp; !vis[v]) {
        dep[v] = dep[u] + 1, vis[v] = 1, q.emplace(v);
      }
    }
  }
  return vis[t];
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = 1e9;
      e[i].w -= fl, e[i ^ 1].w += fl;
      lim -= fl, flow += fl;
      if (!lim) break;
    }
  }
  return flow;
}

int maxflow() {
  int ans = 0;
  for (; bfs(); ans += dfs(s, 1e9)) {}
  return ans;
}
}  // namespace Dinic

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  int s = n * m + 1, t = n * m + 2;
  Dinic::init(n * m + 2, s, t);
  // 0 : 白，1 : 黑
  for (int i = 1; i &lt;= n; ++i) {
    std::string str;
    std::cin &gt;&gt; str;
    str = " " + str;
    for (int j = 1; j &lt;= m; ++j) {
      if (str[j] == '.') x[0] = i, y[0] = j, del[getid(i, j)] = 1;
      if (str[j] == 'O') col[i][j] = 0;
      else col[i][j] = 1;
      if (!col[i][j]) Dinic::add(s, getid(i, j), 1);
      else Dinic::add(getid(i, j), t, 1);
    }
  }
  std::cin &gt;&gt; k;
  for (int i = 1; i &lt;= 2 * k; ++i) {
    std::cin &gt;&gt; x[i] &gt;&gt; y[i];
    del[getid(x[i], y[i])] = 1;
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (col[i][j] || del[getid(i, j)]) continue;
      for (auto [di, dj] : kD) {
        int ti = i + di, tj = j + dj;
        if (col[ti][tj] &amp;&amp; !del[getid(ti, tj)])
          Dinic::add(getid(i, j), getid(ti, tj), 1);
      }
    }
  }
  cnt[2 * k + 1] = Dinic::maxflow();
  for (int i = 2 * k; ~i; --i) {
    int u = getid(x[i], y[i]);
    del[u] = 0;
    for (auto [di, dj] : kD) {
      int tx = x[i] + di, ty = y[i] + dj, v = getid(tx, ty);
      if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue;
      if (col[tx][ty] != col[x[i]][y[i]] &amp;&amp; !del[v]) {
        if (!col[x[i]][y[i]]) Dinic::add(u, v, 1);
        else Dinic::add(v, u, 1);
      }
    }
    cnt[i] = Dinic::maxflow();
  }
  std::vector&lt;int&gt; vec;
  for (int i = 1; i &lt;= k; ++i) {
    if (cnt[2 * i - 2] &amp;&amp; cnt[2 * i - 1])
      vec.emplace_back(i);
  }
  std::cout &lt;&lt; vec.size() &lt;&lt; '\n';
  for (auto x : vec) std::cout &lt;&lt; x &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18264342.html</id>
    <title type="text">P3974 [TJOI2015] 组合数学 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-06-24T01:15:00Z</published>
    <updated>2024-06-24T01:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18264342.html" />
    <content type="text">## Description

给一个网格图，其中某些格子有一些财宝。每次从左上角出发，只能往右或下走，每一次经过一个格子至多只能捡走一块财宝，至少要走几次才可能把财宝全捡完？

$1\leq n \leq 1000$，$1\leq m \leq 1000$，每个格子中的财宝不超过 $10^6$ 块。

## Solution

考虑把每个点 $(i,j)$ 拆成 $a_{i,j}$ 个点，然后题目相当于要求出这个网格图的最小链覆盖。

由于两个点互相不可达一定是一个在左下，一个在右上，或者在同一位置。所以根据 Dilworth 定理，题目就是求一个从右上到左下的坐标单调的路径使得 $a$ 之和最大。

直接 dp 即可。

时间复杂度：$O(nm)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e3 + 5;

int n, m;
int a[kMaxN][kMaxN], f[kMaxN][kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      std::cin &gt;&gt; a[i][j];
  for (int i = 0; i &lt;= n + 1; ++i)
    for (int j = 0; j &lt;= m + 1; ++j)
      f[i][j] = 0;
  f[0][m + 1] = 0;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = m; j; --j)
      f[i][j] = std::max({f[i - 1][j + 1] + a[i][j], f[i - 1][j], f[i][j + 1]});
  std::cout &lt;&lt; f[n][1] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18272111.html</id>
    <title type="text">20240627 模拟赛 T2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-06-27T12:04:00Z</published>
    <updated>2024-06-27T12:04:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18272111.html" />
    <content type="text">## Description

给定一个包含 $n$ 个排列的序列 $x_1,x_2,\cdots,x_n$，排列 $x_i$ 是由 $1\sim m $ 的整数组成的。

你需要找到一个 $1\sim n$ 的排列 $p_1,p_2,\cdots,p_n$。令 $y_i=x_{p_i}$，则 $y_1,y_2,\cdots,y_n$ 满足如下性质：

对于任意 $1\le i&lt;j&lt;k\le n$ 和 $1\le a,b\le m$，如果 $a$ 在排列 $y_i$ 和 $y_k$ 的位置都在 $b$ 之前，那么 $a$ 在 $y_j$ 也在 $b$ 之前出现。（直观上，任意 $a,b$ 在排列中的相对顺序至多改变一次。）

$1 \leq T \leq 5,1 \leq n\times m \leq 10^6$。

## Solution

不妨设 $c(i,j)$ 表示 $x_i$ 与 $x_j$ 有多少对数顺序变化。

那么对于一个合法的排列，对于 $\forall 1\leq i\leq n$，必然满足 $c(p_1,p_i)\geq c(p_2,p_i)\geq\dots \geq c(p_i,p_i)\leq c(p_{i+1},p_i)\leq\dots\leq c(p_n,p_i)$。

所以任意选一个排列然后找到与其 $c$ 值最大的排列 $x_k$，则 $x_k$ 一定是可能的答案的开头。

找到开头后，容易发现只要对所有的 $c(x,i)$ 进行排序即可得到一组可能的答案，但是没法确定是否合法，需要进一步验证。

注意到对于 $1\leq a,b\leq m$ 和 $1\leq i&lt;j&lt;k\leq n$，如果排列合法，则 $\text{diff}_{a,b}(p_i,p_j)+\text{diff}_{a,b}(p_j,p_k)=\text{diff}_{a,b}(p_i,p_k)$，即 $c(p_i,p_j)+c(p_j,p_k)=c(p_i,p_k)$，所有的不合法排列一定存在 $i,j,k$ 不满足这个条件。

容易发现只要对于所有的 $i$，判断是否满足 $c(p_1,p_{i-1})+c(p_{i-1},p_i)=c(p_1,p_i)$ 即可。

时间复杂度：$O(nm\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }
 
char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) { while (*x) putc(*x++); }
void write(const char *x) { while (*x) putc(*x++); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

int n, m;
int id[kMaxN];
int64_t val[kMaxN];
std::vector&lt;std::vector&lt;int&gt;&gt; a;

struct BIT {
  int c[kMaxN];

  void upd(int x, int v) {
    for (; x; x -= x &amp; -x) c[x] += v;
  }
  int qry(int x) {
    int ret = 0;
    for (; x &lt;= m; x += x &amp; -x) ret += c[x];
    return ret;
  }
} bit;

int64_t calc(std::vector&lt;int&gt; &amp;a, std::vector&lt;int&gt; &amp;b) {
  static int c[kMaxN];
  for (int i = 1; i &lt;= m; ++i) c[a[i]] = i;
  int64_t cnt = 0;
  for (int i = 1; i &lt;= m; ++i) {
    cnt += bit.qry(c[b[i]]);
    bit.upd(c[b[i]], 1);
  }
  for (int i = 1; i &lt;= m; ++i) bit.upd(c[b[i]], -1);
  return cnt;
}

void dickdreamer() {
  read(n, m);
  a.resize(n + 1);
  for (int i = 1; i &lt;= n; ++i) {
    a[i].resize(m + 1);
    for (int j = 1; j &lt;= m; ++j) read(a[i][j]);
  }
  int64_t mx = 0; int p = 1;
  for (int i = 2; i &lt;= n; ++i) {
    int64_t val = calc(a[1], a[i]);
    if (val &gt; mx) mx = val, p = i;
  }
  for (int i = 1; i &lt;= n; ++i)
    id[i] = i, val[i] = calc(a[p], a[i]);
  std::sort(id + 1, id + 1 + n, [&amp;] (int i, int j) { return val[i] &lt; val[j]; });
  for (int i = 2; i &lt;= n; ++i) {
    if (val[id[i - 1]] + calc(a[id[i - 1]], a[id[i]]) != val[id[i]])
      return write("-1\n");
  }
  for (int i = 1; i &lt;= n; ++i) write(id[i], ' ');
  write('\n');
}

int32_t main() {
  freopen("perm.in", "r", stdin);
  freopen("perm.out", "w", stdout);
  int T = 1;
  read(T);
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18274309.html</id>
    <title type="text">20240628 模拟赛 T1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-06-28T12:39:00Z</published>
    <updated>2024-06-28T12:39:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18274309.html" />
    <content type="text">## Description

小 $\omega$ 在玩一个游戏，他把它称作「换换」。

初始有一个长为 $n$ 的正整数序列 $a_1,a_2,\dots,a_n$和两个参数 $l,r$。小 $\omega$ 的操作是可以选定 $i,j\in [1,n]\cap\mathbb{N}$，并交换 $a_i,a_j$。

当序列满足 $\exists k\in[1,n]\cap\mathbb{N},\sum_{i=1}^k a_i\in[l,r]$ 时游戏结束，小 $\omega$ 获胜。

由于小 $\omega$ 不想玩游戏被发现，因此小 $\omega$ 需要你帮他求出最小操作次数。

$1\le n,l,r,a_i\le 5\times 10^3,\sum n\le 10^4,l\le r$。

## Solution

容易发现题目相当于是求一个 $k$ 中，使得选出总共 $k$ 个数，和在 $[L,R]$ 中，且 $[k+1,n]$ 的个数最少。

设 $dp1_{i,j}$ 表示从 $a_1\sim a_i$ 中选一些数和为 $j$ 的**最大个数**，$dp2_{i,j}$ 表示从 $a_1\sim a_i$ 中选一些数和为 $[L-j,R-j]$ 的**最小个数**。

做法是对于每个 $i,j$，如果 $dp1_{i,j}+dp2_{i,j}\geq i$ 就让 $dp2_{i,j}$ 更新答案。下面证明这为什么是对的。

首先如果 $dp1_{i,j}+dp2_{i,j}\geq i$，则当前缀为 $[1,dp1_{i,j}+dp2_{i,j}]$ 时答案一定 $\leq dp2_{i,j}$。

然后对于每个最优解，不妨设是从 $[1,i]$ 中选 $k$ 个，$[i+1,n]$ 选 $k-i$ 个。

如果 $dp1_{i,j}+dp2_{i,j}&lt;i$，容易发现 $k=dp1_{i,j}$，则这时的 $dp1,dp2$ 构成的方案在 $[1,dp1+dp2]$ 时答案一定 $\leq dp2_{i,j}+i-(dp1_{i,j}+dp2_{i,j})=k-i$。于是这时求 $[1,i]$ 的答案就转化到了 $[1,dp1+dp2]$ 的答案，容易发现这个转化一定不会永远进行下去，所以每个最优解一定能被统计到。

于是对于 $dp1$ 进行 dp，$dp2$ 进行 dp+单调队列优化即可。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e3 + 5;

int n, L, R;
int a[kMaxN], f[kMaxN][kMaxN], g[kMaxN][kMaxN], q[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 0; i &lt;= n + 1; ++i)
    for (int j = 0; j &lt;= R + 1; ++j)
      f[i][j] = -1e9, g[i][j] = 1e9;
  f[0][0] = 0, g[n + 1][0] = 0;
  int ans = 1e9;
  for (int i = n; i; --i) {
    for (int j = 0; j &lt;= R; ++j) {
      g[i][j] = std::min(g[i][j], g[i + 1][j]);
      if (j &lt;= R - a[i]) g[i][j + a[i]] = std::min(g[i][j + a[i]], g[i + 1][j] + 1);
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= R; ++j) {
      f[i][j] = std::max(f[i][j], f[i - 1][j]);
      if (j &lt;= R - a[i]) f[i][j + a[i]] = std::max(f[i][j + a[i]], f[i - 1][j] + 1);
    }
    int h = 1, t = 0;
    for (int j = R; ~j; --j) {
      for (; h &lt;= t &amp;&amp; g[i + 1][R - j] &lt;= g[i + 1][q[t]]; --t) {}
      q[++t] = R - j;
      if (j &lt;= L - 1) {
        for (; h &lt;= t &amp;&amp; q[h] &lt;= L - j - 1; ++h) {}
      }
      if (f[i][j] &gt;= 0 &amp;&amp; f[i][j] + g[i + 1][q[h]] &gt;= i) ans = std::min(ans, g[i + 1][q[h]]);
    }
  }
  std::cout &lt;&lt; (ans == 1e9 ? -1 : ans) &lt;&lt; '\n';
}

int32_t main() {
  freopen("swap.in", "r", stdin);
  freopen("swap.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18284635.html</id>
    <title type="text">CF505E Mr. Kitayuta vs. Bamboos 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-04T12:40:00Z</published>
    <updated>2024-07-04T12:40:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18284635.html" />
    <content type="text">## Description
- 给定 $n$ 个数 $h_{1 \dots n}$。
- 你需要进行 $m$ 轮操作，每轮操作为 $k$ 次修改，每次修改可以选择一个数 $h_i$ 修改为 $\max(h_i - p, 0)$。
- 每轮操作后每个 $h_i$ 将会被修改为 $h_i + a_i$。
- 你需要最小化最终 $h_{1 \dots n}$ 中的最大值。
- $n \le 10^5$，$m \le 5 \times 10^3$，$k \le 10$。

## Solution

注意到要最小化最大值，显然是二分。假设当前二分的答案为 $x$，那么就要判断能否满足最后的高度都不超过 $x$。

但是题目里有一个 $h_i\leftarrow \max(h_i-p,0)$ 的操作，这个取 max 是难以处理的，考虑倒过来做。

不妨设 $b_i$ 表示 $i$ 当前的高度，初始值为 $x$。

那么对于每轮操作，相当于是先让所有的 $b_i$ 减去 $a_i$，如果 $b_i&lt;0$ 则不合法，然后选择 $k$ 个 $b_i$ 加上 $p$（这里的 $i$ 可以重复）。

然后如果最后所有 $b_i\geq h_i$ 则满足条件，否则不满足。这是因为显然最后的 $b_i$ 为在这个操作下满足最后 $h_i\leq x$ 的最大初始值，如果比这个还大显然不合法。

容易发现这个东西可以用优先队列维护，队列维护不新加 $p$ 的情况下没法满足最后的 $b_i\geq h_i$ 的所有 $i$，按照 $\left\lfloor\frac{b_i}{a_i}\right\rfloor$ 排序，每次选择最小的加 $p$，如果能满足最后 $b_i\geq h_i$ 了就不再放进队列，否则继续放进去。

时间复杂度：$O\left((n+mk)\log n\log V\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, m, k, p;
int h[kMaxN], a[kMaxN], now[kMaxN];

bool check(int x) {
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    now[i] = x;
    if (x - a[i] * m &lt; h[i]) q.emplace(-(now[i] / a[i]), i);
  }
  for (int c = 1; c &lt;= m; ++c) {
    for (int j = 1; j &lt;= k &amp;&amp; !q.empty(); ++j) {
      auto [d, i] = q.top(); q.pop();
      if (now[i] - c * a[i] &lt; 0) return 0;
      now[i] += p;
      if (now[i] - a[i] * m &lt; h[i]) q.emplace(-(now[i] / a[i]), i);
    }
  }
  return q.empty();
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; h[i] &gt;&gt; a[i];
  int L = -1, R = 1e18, res = 1e18;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (check(mid)) R = res = mid;
    else L = mid;
  }
  std::cout &lt;&lt; res &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18293367.html</id>
    <title type="text">P3993 [BJOI2017] 同构 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-10T02:38:00Z</published>
    <updated>2024-07-10T02:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18293367.html" />
    <content type="text">## Description

你有 $n$ 个点，你可以在这 $n$ 个点之间连无向边，两个点之间至多只能连一条边，也不允许连自环，问至多能连多少条边。

但这个问题的答案显然是 $\frac{n(n-1)}{2}$ 条。所以有一个额外的限制，要求这个图不存在非平凡的自同构。

一个图 $G$ 有非平凡的自同构定义为存在一个 $1$ 到 $n$ 的置换 $p(1)$ 到 $p(n)$ 满足对于所有点 $u,v$，$(u, v)$ 之间有边当且仅当 $(p(u), p(v))$ 之间有边，并且这个置换非平凡也就是存在一个点 $u$ 使得 $p(u) \ne u$。

比如对于一个 $5$ 个点的图 $(1,2),(2,3),(3,4),(4,5),(5,1),(1,3)$，那么 $p(1)=3$，$p(2)=2$，$p(3)=1$，$p(4)=5$，$p(5)=4$ 为这个图的一个非平凡的自同构。

你要回答一个 $n$ 个点的无向简单的不存在非平凡自同构的图最多有多少条边，如果答案不存在，即不存在 $n$ 个点满足条件的图，请输出 `-1`，否则输出答案对 $10^9+7$ 取模的结果。

对于 $100\%$ 的数据，$1 \le n \le 10^{100}$，$1 \le T \le 10^4$。

## Solution

观察样例可以得到 $n\leq 6$ 的答案，这里只考虑 $n\geq 7$ 的情况。

容易发现对于一个图 $G$ 合法，则 $G$ 的补图 $G'$ 也合法，所以只需要求出最少有多少条边即可。

手玩之后会发现对于每个合法方案，每个连通块一定不存在非平凡自同构且连通块两两不同构。

首先对于 $n\geq 7$ 一定有解，构造如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ffaftdn.png)

容易发现对于每个 $n$，最小的情况一定是个森林，证明就考虑如果只有 $\leq 1$ 个树，则把方案改成一个 $n$ 个点的树一定不劣。然后这时就有 $\geq 2$ 个树了，则让点数最多的树和其它非树连通块的点删掉原先的边并连成一颗新树，这样一定合法且不劣。

所以只需要让树的个数最多即可。

容易发现肯定是先取点数小的树再取点数大的，剩下的点合并到最大的树一定合法。

考虑什么样的树是合法的。先固定根，对于每个点 $x$ 的所有子树，一定是不同构的，如果对于所有的根都满足这个条件就一定合法。

有一个结论是：在判断树同构的时候，我们可以以重心为根做一遍树哈希（如果有两个就都做一遍），然后比较哈希值判断两棵树是否同构。

于是可以用重心来计算方案数可以避免算重。

设 $f_n$ 表示 $n$ 个点的无根树的个数，$g_{n,m}$ 表示由大小 $\leq n$ 的树组成大小为 $m$ 的森林的方案数，$h_n$ 表示 $n$ 个点的有根树个数。

则：

$$
\begin{aligned}
h_n&amp;=g_{n-1,n-1}\\
g_{n,m}&amp;=\sum_{i=0}^{\left\lfloor\frac{m}{n}\right\rfloor}\binom{h_n}{i}g_{n-1,m-in}\\
f_n&amp;=g_{\left\lfloor\frac{n-1}{2}\right\rfloor,n-1}+\left[2|n\right]\binom{h_{\frac{n}{2}}}{2}
\end{aligned}
$$

经计算，当 $n=266$ 时 $\sum{if_i}$ 已经 $\geq 10^{100}$ 了。

时间复杂度：$O(玄学)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

namespace BIGINT {
using ull = unsigned long long;
using bigint = __int128;
using bigbig = __int128;
struct bign {
  static const int block = 16;
  static const ull base = 10000000000000000;
  std::vector&lt;ull&gt; a;
  bign() : a(std::vector&lt;ull&gt;()) {}
  bign(ull x) {
    for (; x; x /= base) a.push_back(x % base);
  }
  bign(std::string s) {
    std::reverse(s.begin(), s.end());
    for (int i = 0; i &lt; (int)s.length(); i += block) {
      int r = std::min((int)s.length(), i + block);
      ull x = 0;
      for (int j = r - 1; j &gt;= i; j--) x = x * 10 + s[j] - 48;
      a.push_back(x);
    }
  }
  bign operator=(ull x) { return *this = bign(x); }
  bign operator=(std::string s) { return *this = bign(s); }
  void resize(int len) { a.assign(len, 0); }
  ull operator[](const int &amp;x) const { return a[x]; }
  ull &amp;operator[](const int &amp;x) { return a[x]; }
  friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, bign &amp;x) {
    std::string s;
    in &gt;&gt; s, x = s;
    return in;
  }
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const bign &amp;x) {
    if (x.a.empty())
      out &lt;&lt; "0";
    else {
      ull ed = x.a.back();
      printf("%llu", ed);
      for (int i = x.a.size() - 2; ~i; i--) printf("%0*llu", block, x[i]);
    }
    return out;
  }
  bool operator&lt;(const bign &amp;x) const {
    if (a.size() != x.a.size()) return a.size() &lt; x.a.size();
    for (int i = a.size() - 1; ~i; i--)
      if (a[i] ^ x[i]) return a[i] &lt; x[i];
    return 0;
  }
  bool operator==(const bign &amp;x) const {
    if (a.size() != x.a.size()) return 0;
    for (int i = 0; i &lt; (int)a.size(); i++)
      if (a[i] ^ x[i]) return 0;
    return 1;
  }
  bool operator!=(const bign &amp;x) const { return !(*this == x); }
  bool operator&gt;(const bign &amp;x) const { return x &lt; *this; }
  bool operator&lt;=(const bign &amp;x) const {
    if (a.size() != x.a.size()) return a.size() &lt; x.a.size();
    for (int i = a.size() - 1; ~i; i--)
      if (a[i] ^ x[i]) return a[i] &lt; x[i];
    return 1;
  }
  bool operator&gt;=(const bign &amp;x) const { return x &lt;= *this; }
  bign operator+=(const bign &amp;x) {
    ull r = 0;
    for (int i = 0; i &lt; (int)x.a.size() || r; i++) {
      if (i &lt; (int)x.a.size()) r += x[i];
      if (i &gt;= (int)a.size()) a.push_back(0);
      if ((a[i] += r) &gt;= base)
        r = 1, a[i] -= base;
      else
        r = 0;
    }
    return *this;
  }
  bign operator+(const bign &amp;x) const {
    bign t = *this;
    return t += x;
  }
  bign operator-=(const bign &amp;x) {
    ull r = 0;
    for (int i = 0; i &lt; (int)x.a.size() || r; i++) {
      if (i &lt; (int)x.a.size()) r += x[i];
      if (a[i] &gt;= r)
        a[i] -= r, r = 0;
      else
        a[i] += base - r, r = 1;
    }
    for (; !a.empty() &amp;&amp; !a.back();) a.pop_back();
    return *this;
  }
  bign operator-(const bign &amp;x) const {
    bign t = *this;
    return t -= x;
  }
  bign operator-=(const ull &amp;_x) {
    ull r = 0;
    ull x = _x;
    for (int i = 0; x || r; i++) {
      r += x % base, x /= base;
      if (a[i] &gt;= r)
        a[i] -= r, r = 0;
      else
        a[i] += base - r, r = 1;
    }
    for (; !a.empty() &amp;&amp; !a.back();) a.pop_back();
    return *this;
  }
  bign operator-(const ull &amp;x) const {
    bign t = *this;
    return t -= x;
  }
  friend void reduce(bign &amp;a) {
    for (; !a.a.empty() &amp;&amp; !a.a.back(); a.a.pop_back());
  }
  friend void split(const bign &amp;a, bign &amp;x, bign &amp;y, int mid) {
    int len = std::min(mid, (int)a.a.size());
    y.resize(len);
    for (int i = 0; i &lt; len; i++) y[i] = a[i];
    len = std::max&lt;int&gt;(0, (int)a.a.size() - mid);
    x.resize(len);
    for (int i = 0; i &lt; len; i++) x[i] = a[mid + i];
    reduce(x), reduce(y);
  }
  friend bign mul(const bign &amp;a, int x) {
    if (a.a.empty()) return bign();
    bign b;
    b.resize(a.a.size() + x);
    for (int i = a.a.size() - 1; ~i; i--) b[i + x] = a[i];
    return b;
  }
  bign operator*(const bign &amp;x) const {
    if (a.size() &lt;= 20 &amp;&amp; x.a.size() &lt;= 20) {
      int len = a.size() + x.a.size() + 1;
      std::vector&lt;bigbig&gt; t(a.size() + x.a.size() + 1);
      for (int i = 0; i &lt; (int)a.size(); i++)
        for (int j = 0; j &lt; (int)x.a.size(); j++) {
          int k = i + j;
          t[k] += (bigbig)a[i] * x[j], t[k + 1] += t[k] / base, t[k] %= base;
        }
      bign ans;
      ans.resize(len);
      for (int i = 0; i &lt; (int)t.size(); i++) {
        if (i + 1 &lt; (int)t.size()) t[i + 1] += t[i] / base;
        ans[i] = t[i] % base;
      }
      reduce(ans);
      return ans;
    }
    int mid = (std::max(a.size(), x.a.size()) + 1) / 2;
    bign A, B, C, D;
    split(*this, A, B, mid);
    split(x, C, D, mid);
    bign ac = A * C, bd = B * D, t = (A + B) * (C + D) - ac - bd;
    return mul(ac, mid * 2) + mul(t, mid) + bd;
  }
  bign operator*=(const bign &amp;x) { return *this = *this * x; }
  bign operator*=(const int &amp;x) {
    bigint r = 0;
    for (int i = 0; i &lt; (int)a.size() || r; i++) {
      if (i &gt;= (int)a.size()) a.push_back(0);
      r += x * (bigint)a[i], a[i] = r % base, r /= base;
    }
    return *this;
  }
  bign operator*(const int &amp;x) const {
    bign t = *this;
    return t *= x;
  }
  bign operator*=(const ull &amp;x) {
    bigint r = 0;
    for (int i = 0; i &lt; (int)a.size() || r; i++) {
      if (i &gt;= (int)a.size()) a.push_back(0);
      r += x * (bigint)a[i], a[i] = r % base, r /= base;
    }
    return *this;
  }
  bign operator*(const ull &amp;x) const {
    bign t = *this;
    return t *= x;
  }
  bign operator/=(const ull &amp;x) {
    bigint r = 0;
    for (int i = a.size() - 1; ~i; i--) {
      r = r * base + a[i];
      a[i] = r / x, r %= x;
    }
    for (; !a.empty() &amp;&amp; !a.back();) a.pop_back();
    return *this;
  }
  bign operator/(const ull &amp;x) const {
    bign t = *this;
    return t /= x;
  }
  friend bign qpow(const bign &amp;_x, const ull &amp;_y) {
    bign x(_x), ans(1);
    for (ull y = _y; y; y &gt;&gt;= 1, x *= x)
      if (y &amp; 1) ans *= x;
    return ans;
  }
  ull trans() const {
    ull x = 0;
    for (int i = a.size() - 1; ~i; i--) x = x * base + a[i];
    return x;
  }
  ull operator%(const ull &amp;x) const {
    ull res = 0;
    for (int i = a.size() - 1; ~i; i--) {
      res = ((bigbig)res * base + a[i]) % x;
    }
    return res;
  }
};
}  // namespace BIGINT

using BIGINT::bign;

using i128 = __int128_t;

const int kMaxN = 270, kMod = 1e9 + 7;

bign f[kMaxN], g[kMaxN][kMaxN], h[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1) ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

bign C(bign n, int m) {
  static bool vis[kMaxN];
  if (n &lt; m) return 0;
  bign ret = 1;
  memset(vis, 0, sizeof(vis));
  for (bign i = n; i &gt; n - m; i = i - 1) {
    ret *= i;
    for (int j = 1; j &lt;= m; ++j)
      if (!vis[j] &amp;&amp; ret % j == 0) ret /= j, vis[j] = 1;
  }
  return ret;
}

void prework() {
  g[0][0] = 1;
  for (int i = 1; i &lt;= 266; ++i) {
    h[i] = g[i - 1][i - 1];
    if (i &amp; 1)
      f[i] = g[(i - 1) / 2][i - 1];
    else
      f[i] = g[i / 2 - 1][i - 1] + C(h[i / 2], 2);
    for (int j = 0; j &lt;= 266; ++j) {
      for (int k = 0; k &lt;= j / i; ++k)
        g[i][j] += C(h[i], k) * g[i - 1][j - i * k];
    }
  }
}

int solve(bign n) {
  if (n == 1)
    return 0;
  else if (n &lt;= 5)
    return -1;
  else if (n == 6)
    return 9;
  int _n = n % kMod, ans = (1ll * _n * (_n - 1) / 2 % kMod - _n + kMod) % kMod;
  for (int i = 1; i &lt;= 266; ++i) {
    if (n &gt; (bign)i * f[i]) {
      n -= (bign)i * f[i], inc(ans, f[i] % kMod);
    } else {
      inc(ans, (n / i) % kMod);
      break;
    }
  }
  return ans;
}

void dickdreamer() {
  bign n;
  std::cin &gt;&gt; n;
  std::cout &lt;&lt; solve(n) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int T = 1;
  std::cin &gt;&gt; T;
  prework();
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18294972.html</id>
    <title type="text">[ARC080F] Prime Flip 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-10T12:53:00Z</published>
    <updated>2024-07-10T12:53:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18294972.html" />
    <content type="text">## Description

有无限枚硬币，其中有 $n$ 枚硬币 $x_{1\ldots n}$。初始时正面朝上，其余均为背面朝上，每次可以选择一段区间 $[l,r]$，将区间内所有硬币翻转，其中 $r-l+1$ 为一个奇质数。

问最少多少次能将所有硬币全部翻为背面朝上。

$1\leq n\leq 100, 1\leq x_1\leq x_2\leq\ldots\leq x_n\leq 10^7$。

## Solution

考虑差分，每次操作显然是选择两个数 $i,j$，使得 $|i-j|\in \text{prime}$ 然后把 $a_i$ 和 $a_j$ 异或 $1$，最后要使得所有的 $a_i$ 变为 $0$。

容易发现两两消去是最优的，证明见[这里](https://www.luogu.com.cn/article/t73a800r)。

考虑对于 $i,j(i&lt;j)$ 求出最少需要多少次操作才能把它们消掉。

1. $j-i\in \text{prime}$，显然能一次消掉。

2. $2|j-i$。

那么对于 $j-i=2$，就操作 $(i,i+5),(i+2,i+5)$ 即可。对于 $j-i=4$，则操作 $(i,i+7),(i+4,i+7)$，对于 $j-i\geq 6$，由哥德巴赫猜想在 $n\leq 10^7$ 时的正确性知一定能通过 $2$ 次构造出。

3. $2∤j-i,j-i\notin\text{prime}$

如果 $j-i=1$，操作 $(i,i+7),(i+1,i+4),(i+4,i+7)$。如果 $j-i\geq 5$，就转化为 $3+偶数$ 的情况，可以 $3$ 次构造出。

由于匹配的总数量一定，所以一定是先匹配一次消掉的，再两次，最后三次。

对于一次的跑最大匹配，后面的分奇偶考虑即可。

时间复杂度：$O(n^2\sqrt{V}+n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e3 + 5, kMaxV = 1e7 + 5;

int n, m, _m, ans;
int a[kMaxV], b[kMaxN], match[kMaxN];
bool vis[kMaxN], exi[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

bool isprime(int n) {
  if (n &lt;= 2) return 0;
  for (int i = 2; i * i &lt;= n; ++i)
    if (n % i == 0)
      return 0;
  return 1;
}

bool dfs(int u) {
  for (auto v : G[u]) {
    if (vis[v]) continue;
    vis[v] = 1;
    if (!match[v] || dfs(match[v])) {
      match[v] = u; return 1;
    }
  }
  return 0;
}

void solve1() {
  for (int i = 1; i &lt;= m; ++i) {
    if (b[i] &amp; 1) {
      for (int j = 1; j &lt;= m; ++j)
        if ((~b[j] &amp; 1) &amp;&amp; isprime(abs(b[i] - b[j])))
          G[i].emplace_back(j);
    }
  }
  for (int i = 1; i &lt;= m; ++i) {
    if (b[i] &amp; 1) {
      std::fill_n(vis + 1, m, 0);
      dfs(i);
    }
  }
  for (int i = 1; i &lt;= m; ++i) {
    if (match[i]) {
      exi[i] = exi[match[i]] = 1;
      ++ans, _m -= 2;
    }
  }
}

void solve2() {
  int cnt[2] = {0};
  for (int i = 1; i &lt;= m; ++i) {
    if (!exi[i]) ++cnt[b[i] &amp; 1];
  }
  ans += 2 * (cnt[0] / 2 + cnt[1] / 2), _m -= 2 * (cnt[0] / 2 + cnt[1] / 2);
}

void solve3() {
  if (_m) ans += 3;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    int x;
    std::cin &gt;&gt; x;
    a[x] = 1;
  }
  for (int i = 1; i &lt;= 1e7 + 1; ++i)
    if (a[i] ^ a[i - 1])
      b[++m] = i;
  _m = m;
  solve1(), solve2(), solve3();
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18298007.html</id>
    <title type="text">CF1519F Chests and Keys 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-12T03:56:00Z</published>
    <updated>2024-07-12T03:56:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18298007.html" />
    <content type="text">## Description

给定 $n,m$ 表示存在 $n$ 个宝箱和 $m$ 把钥匙，第 $i$ 把钥匙需要 $b_i$ 元，第 $i$ 个宝箱内部有 $a_i$ 元。

现在进行一场游戏，Bob 是本场游戏的玩家，而 Alice 则是场景布置者，Alice 可以给每个宝箱上一些锁（第 $j$ 种锁需要第 $j$ 种钥匙打开）

如果 Bob 可以购买一些钥匙，然后打开一些宝箱，使得 Bob 的收益大于 $0$，那么 Bob 就赢得了游戏，反之 Alice 获得了胜利。

现在 Alice 打算布置宝箱上的锁，第 $i$ 个宝箱上放置第 $j$ 种锁的花费为 $c_{i,j}$，请帮助 Alice 找到一种布置锁的方案，使得花费最小，且 Alice 将取得胜利。

特别的，一个箱子上可以放置若干把锁，Bob 需打开所有锁才能获得内部的钱。

$n,m\le 6,a_i,b_i\le 4,c_{i,j}\le 10^7$。

## Solution

考虑怎么什么样的方案是合法的。

不妨设 $T_i$ 表示第 $i$ 个宝箱选的所有钥匙，容易发现合法的充要条件是对于所有 $S\subseteq\{1,2,\ldots,n\}$，都满足：

$$
\sum_{i\in S}{a_i}\leq\sum_{j\in (\cup_{k\in S}{T_k})}b_j
$$

经过观察会发现这个东西很像[霍尔定理](https://zhuanlan.zhihu.com/p/460373184)的形式，考虑转化成二分图匹配。

原题的式子等价于对于每个箱子 $i$，拆 $a_i$ 个左部点。对于钥匙 $j$，拆 $b_j$ 个有部点，然后如果箱子 $i$ 里有钥匙 $j$ 则让所有 $i$ 对应的点与所有钥匙 $j$ 对应的点连边，然后如果对于左部点能找到完美匹配则合法。

经过转化容易发现可以 dp，设 $f_{i,s}$ 表示考虑了前 $i$ 个箱子，目前右边每个钥匙拆的点没匹配数量的状态为 $s$（$s$ 为五进制表示），每次搜出 $a_i$ 对应的点连哪些右部点，暴力转移即可。

时间复杂度：$O(n\cdot 5^{2n})$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxS = 2e4 + 5, kPw5[] = {1, 5, 25, 125, 625, 3125};

int n, m;
int a[10], b[10], c[10][10], f[10][kMaxS];

int getbit(int s, int k) { return s / kPw5[k] % 5; }

void dfs(int x, int cur, int val, int s, int cnt) {
  if (cur == m) {
    if (!cnt) f[x][s] = std::min(f[x][s], val);
    return;
  }
  int t = getbit(s, cur);
  for (int i = 0; i &lt;= std::min(t, cnt); ++i) {
    dfs(x, cur + 1, val + (bool)i * c[x][cur], s - i * kPw5[cur], cnt - i);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  int st = 0;
  for (int i = 0; i &lt; m; ++i) {
    std::cin &gt;&gt; b[i];
    st += kPw5[i] * b[i];
  }
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 0; j &lt; m; ++j)
      std::cin &gt;&gt; c[i][j];
  memset(f, 0x3f, sizeof(f));
  f[0][st] = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= st; ++j) {
      dfs(i, 0, f[i - 1][j], j, a[i]);
    }
  }
  int ans = *std::min_element(f[n], f[n] + st + 1);
  std::cout &lt;&lt; (ans &gt;= 1e9 ? -1 : ans) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18316011.html</id>
    <title type="text">CF506E Mr. Kitayuta's Gift 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-22T07:26:00Z</published>
    <updated>2024-07-22T07:26:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18316011.html" />
    <content type="text">## Description

给定一个长度为 $n$ 的小写字符串 $s$ 和一个正整数 $m$。

要求在 $s$ 中插入恰好 $m$ 个小写字符使其回文的方案数，两个方案不同当且仅当它们得到的串不同，与插入顺序和位置无关。

$n \le 200,m \le 10^9$，答案对 $10^4 + 7$ 取模。

## Solution

先考虑 $n+m$ 为偶数的情况。

设 $f_{i,l,r}$ 表示最终的字符串的前 $i$ 与后 $i$ 位与 $s$ 尽量匹配，最终剩下 $s_{l,\dots,r}$ 没有匹配的方案数，$g_i$ 表示前 $i$ 位与后 $i$ 位已经能与 $s$ 完全匹配的方案数。

容易发现答案是 $g_{(n+m)/2}$。考虑转移。

如果 $s_l=s_r$ 且 $r-l\leq 1$，则 $g_{i+1}\leftarrow f_{i,l,r},f_{i+1,l,r}\leftarrow 25\cdot f_{i,l,r}$。

如果 $s_l=s_r$ 且 $r-l&gt;1$，则 $f_{i+1,l+1,r-1}\leftarrow f_{i,l,r},f_{i+1,l,r}\leftarrow 25\cdot f_{i,l,r}$。

如果 $s_l\neq s_r$，则 $f_{i+1,l+1,r}\leftarrow f_{i,l,r},f_{i+1,l,r-1}\leftarrow f_{i,l,r},f_{i+1,l,r}\leftarrow 24\cdot f_{i,l,r}$。

并且 $g_{i+1}\leftarrow 26\cdot g_i$。

可以发现这个东西的转移图是个自动机。一个点 $s_{l,r}$ 如果满足 $s_l=s_r$ 则有 $25$ 个自环，否则有 $24$ 个自环，起点为 $s_{l,r}$，终点有 $26$ 个自环。不妨设 $24$ 个自环的为红点，$25$ 个的为绿点，可以发现图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/22hpf3i0.png)

于是题目转化为在求在这个图上有多少个长度为 $n+m$ 的从起点到终点的路径，可以用矩阵乘法做到 $O\left(n^6\log (n+m)\right)$，显然过不了。

---

考虑优化。

注意到对于图中的一个从起点到终点的不包含自环的链，$2cnt_{25}+cnt_{24}=n或n+1$，所以 $cnt_{25}=\left\lceil\frac{n-cnt_{24}}{2}\right\rceil$，那么图中只有 $O(n)$ 种不同的链，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qmzmkk43.png)

所以可以对于每种链，求出这种链的出现次数再乘上这个链的方案数即可。

可以做到 $O\left(n^4\log (n+m)\right)$。

---

但是还是过不了。

注意到上面那个做法有很多浪费，因为这 $n$ 条链有很多结构是类似的，可以把他们压到一张图上：

![](https://cdn.luogu.com.cn/upload/image_hosting/hgh3r64v.png)

那么先跑一遍矩乘就可以 $O(1)$ 求出任意两点间的方案数，于是做到 $O\left(n^3\log (n+m)\right)$ 了。

还有 $n+m$ 为奇数的情况。

这里先求出长度为 $n+m+1$ 的答案，可以发现多算的部分就是最后一步从形如 $s_{l,l+1}$ 的绿点走到终点的方案数，所以可以跑出 $n+m-1$ 的矩阵，再枚举这样的 $s_{l,l+1}$ 和对应的起点减去答案即可。

时间复杂度：$O\left(n^3\log (n+m)\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 205, kMaxM = 405, kMod = 1e4 + 7;

int n, m, len;
int f[kMaxN][kMaxN][kMaxN];
std::string s;

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

struct Matrix {
  int n, m, a[kMaxM][kMaxM];

  void set(int _n, int _m) { n = _n, m = _m; }
  friend Matrix operator*(const Matrix &amp;m1, const Matrix &amp;m2) {
    static Matrix ret;
    assert(m1.m == m2.n);
    ret.set(m1.n, m2.m);
    for (int i = 1; i &lt;= m1.n; ++i) {
      for (int j = i; j &lt;= m2.m; ++j) {
        ret.a[i][j] = 0;
        for (int k = i; k &lt;= j; ++k)
          inc(ret.a[i][j], 1ll * m1.a[i][k] * m2.a[k][j] % kMod);
      }
    }
    return ret;
  }
} M, S, O;

void prework() {
  len = n + m;
  for (int i = 0; i &lt;= n + 1; ++i)
    for (int j = 0; j &lt; i; ++j) f[i][j][0] = 1;
  for (int len = 1; len &lt;= n; ++len) {
    for (int i = 1; i &lt;= n - len + 1; ++i) {
      int j = i + len - 1;
      for (int k = 0; k &lt;= n; ++k) {
        if (s[i] == s[j])
          inc(f[i][j][k], f[i + 1][j - 1][k]);
        else
          inc(f[i][j][k + 1], add(f[i][j - 1][k], f[i + 1][j][k]));
      }
    }
  }
}

int calc(int l, int r, int k) {
  static int f[kMaxN][kMaxN][kMaxN] = {0};
  static bool vis[kMaxN][kMaxN][kMaxN] = {0};
  if (l &gt;= r || k &lt; 0) return 0;
  else if (l + 1 == r &amp;&amp; s[l] == s[r]) return !k;
  else if (vis[l][r][k]) return f[l][r][k];
  vis[l][r][k] = 1;
  if (s[l] == s[r]) f[l][r][k] = calc(l + 1, r - 1, k);
  else f[l][r][k] = add(calc(l, r - 1, k - 1), calc(l + 1, r, k - 1));
  return f[l][r][k];
}

Matrix qpow(Matrix bs, int idx) {
  Matrix ret = bs;
  --idx;
  for (; idx; idx &gt;&gt;= 1, bs = bs * bs)
    if (idx &amp; 1) ret = ret * bs;
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; s &gt;&gt; m;
  n = s.size(), s = " " + s;
  prework();
  for (int i = 0; i &lt;= n; ++i) std::cerr &lt;&lt; f[1][n][i] &lt;&lt; ' ';
  int cnt24 = n - 1, cnt25 = (n + 1) / 2, sz = cnt24 + 2 * cnt25;
  M.set(sz, sz), S.set(1, sz);
  for (int i = 1; i &lt;= cnt24; ++i) M.a[i][i] = 24;
  for (int i = cnt24 + 1; i &lt;= cnt24 + cnt25; ++i) M.a[i][i] = 25;
  for (int i = cnt24 + cnt25 + 1; i &lt;= sz; ++i) M.a[i][i] = 26;
  for (int i = 1; i &lt; cnt24 + cnt25; ++i) M.a[i][i + 1] = 1;
  for (int i = cnt24 + 1; i &lt;= cnt24 + cnt25; ++i) M.a[i][i + cnt25] = 1;
  auto tmp = qpow(M, len / 2);
  int ans = 0;
  if (len &amp; 1) {
    for (int i = 0; i &lt;= cnt24; ++i) {
      dec(ans, 1ll * calc(1, n, i) * tmp.a[cnt24 - i + 1][cnt24 + (n - i) / 2] % kMod);
    }
    tmp = tmp * M;
  }
  for (int i = 0; i &lt;= cnt24; ++i) {
    inc(ans, 1ll * f[1][n][i] * tmp.a[cnt24 - i + 1][cnt24 + cnt25 + (n - i + 1) / 2] % kMod);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18317203.html</id>
    <title type="text">CF512D Fox And Travelling 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-22T15:01:00Z</published>
    <updated>2024-07-22T15:01:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18317203.html" />
    <content type="text">## Description

- 给定一张 $n$ 个点 $m$ 条边的无向图。
- 一个点只有当与它直接相连的点中最多只有一个点未被选择过时才可被选择。
- 询问对于每个 $k \in [0,n]$，有序选择 $k$ 个点的方案数。
- $n \le 100$，$m \le \frac{n(n-1)}2$，答案对 $10^9+9$ 取模。

## Solution

容易发现一个环上的任意一个点一定不能被选，因为只要不动这些点那么它们一定不会变，也就永远没选。并且如果两个环之间存在一条路径，则这个路径上的也不能选。

用拓扑排序去掉这些不能选的点后原图就变为一个森林，并且有两类点：周围有不能删的和周围没有不能删的。

容易发现一棵树里最多有一个周围不能删的，如果有则这个点一定是最后一个选，就把这个点作为根，跑 dp。

设 $f_{i,j}$ 表示以 $i$ 为根的子树里选 $j$ 个点的方案数，容易 $O(n^2)$ 转移。

由于 $i$ 要选的话一定是最后一个，所以 $f_{i,sz_i}=f_{i,sz_i-1}$。

---

考虑树没有根的情况。

先让每个点作为根求一遍答案加起来，但是会有算重，容易发现对于一个大小为 $i$ 的方案，会在不在这 $i$ 个点里的点作为根时被算到，所以会算 $sz-i$ 次，除去这个就行了。特别的对于 $i=sz$ 则显然不会算重，就不用除。

然后类似 dp 过程合并答案即可。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 105, kMod = 1e9 + 9;

int n, m, rt;
int f[kMaxN][kMaxN], g[kMaxN], tmp[kMaxN], ans[kMaxN], sz[kMaxN], C[kMaxN][kMaxN];
bool vis[kMaxN], del[kMaxN], exi[kMaxN];
std::vector&lt;int&gt; G[kMaxN], vec;

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1) ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework() {
  C[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    C[i][0] = 1;
    for (int j = 1; j &lt;= i; ++j) C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);
  }
}

void _dfs(int u, int fa, int rt) {
  vis[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    if (!vis[v])
      _dfs(v, u, rt);
    else
      del[rt] |= (v == rt);
  }
}

void check(int x) {
  std::fill_n(vis + 1, n, 0);
  _dfs(x, 0, x);
  exi[x] = del[x];
}

void dfs1(int u, int fa) {
  vec.emplace_back(u);
  exi[u] = 1;
  bool fl = 0;
  for (auto v : G[u]) {
    fl |= del[v];
    if (v == fa || exi[v]) continue;
    dfs1(v, u);
  }
  if (fl) {
    if (~rt &amp;&amp; !rt)
      rt = u;
    else if (~rt)
      rt = -1;
  }
}

void dfs2(int u, int fa) {
  sz[u] = 0, f[u][0] = 1;
  for (auto v : G[u]) {
    if (v == fa || del[v]) continue;
    dfs2(v, u);
    std::fill_n(g, n + 1, 0);
    for (int i = 0; i &lt;= sz[u]; ++i)
      for (int j = 0; j &lt;= sz[v]; ++j)
        inc(g[i + j], 1ll * f[u][i] * f[v][j] % kMod * C[i + j][i] % kMod);
    sz[u] += sz[v];
    for (int i = 0; i &lt;= sz[u]; ++i) f[u][i] = g[i];
  }
  ++sz[u];
  f[u][sz[u]] = f[u][sz[u] - 1];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  prework();
  for (int i = 1; i &lt;= n; ++i) check(i);
  ans[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    if (!exi[i]) {
      vec.clear();
      rt = 0, dfs1(i, 0);
      if (!~rt) continue;
      if (rt) {
        dfs2(rt, 0);
        std::fill_n(g, n + 1, 0);
        for (int j = 0; j &lt;= n; ++j) {
          for (int k = 0; k &lt;= n - j; ++k)
            inc(g[j + k], 1ll * f[rt][j] * ans[k] % kMod * C[j + k][j] % kMod);
        }
        for (int j = 0; j &lt;= n; ++j) ans[j] = g[j];
      } else {
        std::fill_n(tmp, n + 1, 0);
        for (auto x : vec) {
          dfs2(x, 0);
          for (int j = 0; j &lt;= n; ++j)
            inc(tmp[j], f[x][j]);
        }
        std::fill_n(g, n + 1, 0);
        for (int j = 0; j &lt;= (int)vec.size(); ++j) {
          tmp[j] = 1ll * tmp[j] * (j == vec.size() ? 1 : qpow((int)vec.size() - j)) % kMod;
          for (int k = 0; k &lt;= n - j; ++k)
            inc(g[j + k], 1ll * tmp[j] * ans[k] % kMod * C[j + k][j] % kMod);
        }
        for (int j = 0; j &lt;= n; ++j) ans[j] = g[j];
      }
    }
  }
  for (int i = 0; i &lt;= n; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18317874.html</id>
    <title type="text">CF516E Drazil and His Happy Friends 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-23T03:29:00Z</published>
    <updated>2024-07-23T03:29:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18317874.html" />
    <content type="text">## Description

有 $n$ 个男生 $m$ 个女生，编号分别为 $0 \sim n - 1$ 和 $0 \sim m - 1$。

有 $b$ 个男生和 $g$ 个女生是快乐的，其他人是不快乐的。

在第 $i$ 天，编号为 $i \bmod n$ 的男生和编号为 $i \bmod m$ 的女生会一起玩。

如果他们俩中有一个人是快乐的，则另一个人也会变快乐。

求至少要多少天所有人都会变快乐，或者判断不可能所有人都变快乐。

$n,m \leq 10^9$，$b,g \leq 10^5$。

## Solution

不妨设 $d=\gcd(n,m)$，那么$\bmod d$ 不相等的数一定不会相互感染，所以如果对于 $0\leq r&lt;d$ 不存在初始时就快乐的人 $x$，使得 $x\bmod d=r$，就必然无解，否则一定有解。

所以如果 $d&gt;b+g$ 则必然无解，因为至少存在一个余数没有任何数。这样 $d$ 就不大了，考虑对于每个余数求解。

假设余数为 $r$，那么把每个数 $x$ 变为 $(x-r)/d$，$n$ 变为 $n/d$，$m$ 变为 $m/d$，此时求出的答案 $\times d+r$ 就是这个余数的答案，并且此时 $n,m$ 互质，细节变少。

先考虑女生什么时候会全部快乐。

由于女生变快乐必须有男生的参与，所以考虑怎么把男生的参与去掉。

注意到一个女生 $i$ 在第 $k$ 轮变成快乐或者把对应的男生变快乐，那么 $k+n$ 轮女生 $(i+n)\bmod m$ 一定会快乐。所以可以说是女生 $i$ 用了 $n$ 的时间把女生 $(i+n)\bmod m$ 变快乐，这样就把男生的影响消除了，就只用考虑女生内部的影响。

不妨设 $f_i$ 表示女生 $i$ 第一次变快乐的时间，容易预处理出通过最开始就快乐的男生转移过来或者自己最开始就快乐的女生所用的时间。

那么转移就是 $f_{(i+n)\bmod m}\leftarrow f_i+n$，这是个最短路的形式。

所以可以源点向最开始就快乐的女生 $i$ 连长度为 $i$ 的边。对于最开始就快乐的男生 $j$，就让源点向女生 $j\bmod m$ 连长度为 $j$ 的边。然后 $i$ 向 $(i+n)\bmod m$ 连长度为 $n$ 的边。

跑最短路后不用考虑最开始就快乐的女生，否则答案会大。

但是这里点数很多，不好跑最短路。注意到 $n,m$ 互质，那么 $i\to (i+n)\bmod m$ 这类边把女生连成了一个大环，所以只需要把关键点找出来就可以快速求答案。

时间复杂度：$O\left(\left(b+g\right)\log\left(b+g\right)\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5, kInf = 1e18;

int n, m, x, y, B, G;
std::vector&lt;int&gt; b[kMaxN], g[kMaxN];

int exgcd(int a, int b, int &amp;x, int &amp;y) {
  if (!b) { x = 1, y = 0; return a; }
  int d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}

int solve(int n, int m, int x, std::vector&lt;int&gt; &amp;b, std::vector&lt;int&gt; &amp;g) {
  if (g.size() == m) return -1;
  std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec;
  for (auto i : b) vec.emplace_back(i * x % m, 0, i);
  for (auto i : g) vec.emplace_back(i * x % m, 1, i);
  std::sort(vec.begin(), vec.end());
  vec.emplace_back(std::get&lt;0&gt;(vec.front()) + m, std::get&lt;1&gt;(vec.front()), std::get&lt;2&gt;(vec.front()));
  int ret = 0, dis = kInf;
  for (int i = 1; i &lt; (int)vec.size(); ++i)
    dis = std::min(dis + n * (std::get&lt;0&gt;(vec[i]) - std::get&lt;0&gt;(vec[i - 1])), std::get&lt;2&gt;(vec[i]));
  for (int i = 0; i + 1 &lt; (int)vec.size(); ++i) {
    if (i) dis = std::min(dis + n * (std::get&lt;0&gt;(vec[i]) - std::get&lt;0&gt;(vec[i - 1])), std::get&lt;2&gt;(vec[i]));
    if (std::get&lt;0&gt;(vec[i]) == std::get&lt;0&gt;(vec[i + 1])) continue;
    if (std::get&lt;0&gt;(vec[i + 1]) - std::get&lt;0&gt;(vec[i]) &gt; 1) ret = std::max(ret, dis + n * (std::get&lt;0&gt;(vec[i + 1]) - std::get&lt;0&gt;(vec[i]) - 1));
    else if (!std::get&lt;1&gt;(vec[i])) ret = std::max(ret, dis);
  }
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; B;
  int d = exgcd(n, m, x, y);
  if (d &gt; 2e5) return void(std::cout &lt;&lt; "-1\n");
  for (int i = 1; i &lt;= B; ++i) {
    int x;
    std::cin &gt;&gt; x;
    b[x % d].emplace_back(x / d);
  }
  std::cin &gt;&gt; G;
  for (int i = 1; i &lt;= G; ++i) {
    int x;
    std::cin &gt;&gt; x;
    g[x % d].emplace_back(x / d);
  }
  x = (x % m + m) % m, y = (y % n + n) % n;
  int ans = 0;
  for (int i = 0; i &lt; d; ++i) {
    if (b[i].empty() &amp;&amp; g[i].empty()) return void(std::cout &lt;&lt; "-1\n");
    ans = std::max(ans, solve(n / d, m / d, x, b[i], g[i]) * d + i);
    ans = std::max(ans, solve(m / d, n / d, y, g[i], b[i]) * d + i);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18318768.html</id>
    <title type="text">CF521D Shop 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-23T08:24:00Z</published>
    <updated>2024-07-23T08:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18318768.html" />
    <content type="text">## Description

- 有 $k$ 个正整数 $a_{1\dots k}$。
- 有 $n$ 个操作，每个操作给定正整数 $t, i, b$，有三种可能：
  - 如果 $t = 1$，这个操作是将 $a_i$ 赋值为 $b$；
  - 如果 $t = 2$，这个操作是将 $a_i$ 加上 $b$；
  - 如果 $t = 3$，这个操作是将 $a_i$ 乘以 $b$。
- 你可以从 $n$ 个操作中选择最多 $m$ 个操作，并按照一定顺序执行。
- 你的目标是最大化 $\prod_{i=1}^k a_i$ 的值。
- $k,n \le 10^5$。

## Solution

容易发现每个数一定是先赋值再加再乘，所以赋值可以转化为加，这样就剩下了加和乘。

由于要最大化乘积，所以考虑把加转化为乘。

不妨先让每个数把所有操作都做了，现在需要去掉一些操作使得剩下的乘积最大且选择不超过 $m$ 个操作。

显然每个数一定是去掉加或乘的最小的哪个。去掉一个乘法 $b$ 会让乘积乘以 $1/b$。$a_i$ 去掉加法 $b$，会让乘积乘以 $(a_i-b)/a_i$，注意到每次去掉加法最小的那个后，再去掉一个加法对乘积的贡献一定会变大，所以每次贪心地去掉对乘积贡献最小的那个就行了。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, m, k;
int a[kMaxN], op[kMaxN], pos[kMaxN], val[kMaxN], p0[kMaxN], p1[kMaxN];
std::pair&lt;int, int&gt; mx[kMaxN];
bool vis[kMaxN];
std::vector&lt;int&gt; sum[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxN][2];

struct frac {
  int x, y;

  frac(int _x = 0, int _y = 1) : x(_x), y(_y) {}
  friend bool operator &lt;(frac a, frac b) {
    return (__int128_t)a.x * b.y &lt; (__int128_t)a.y * b.x;
  }
};

int getsum(int x, int k) {
  if (!~k) return a[x];
  else return a[x] + sum[x][k];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; op[i] &gt;&gt; pos[i] &gt;&gt; val[i];
    if (op[i] == 1) mx[pos[i]] = std::max(mx[pos[i]], {val[i], i});
    else if (op[i] == 2) vec[pos[i]][0].emplace_back(val[i], i);
    else vec[pos[i]][1].emplace_back(val[i], i);
  }
  std::priority_queue&lt;std::tuple&lt;frac, int, int, int&gt;&gt; qq;
  int cnt = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (mx[i].first &gt; a[i]) vec[i][0].emplace_back(mx[i].first - a[i], mx[i].second);
    std::sort(vec[i][0].begin(), vec[i][0].end(), std::greater&lt;std::pair&lt;int, int&gt;&gt;());
    std::sort(vec[i][1].begin(), vec[i][1].end(), std::greater&lt;std::pair&lt;int, int&gt;&gt;());
    sum[i].resize(vec[i][0].size());
    for (int j = 0; j &lt; (int)vec[i][0].size(); ++j) {
      sum[i][j] = (!j ? 0 : sum[i][j - 1]) + vec[i][0][j].first;
    }
    for (auto [x, id] : vec[i][0]) vis[id] = 1;
    for (auto [x, id] : vec[i][1]) vis[id] = 1;
    p0[i] = (int)vec[i][0].size() - 1;
    p1[i] = (int)vec[i][1].size() - 1;
    if (~p0[i]) qq.emplace(frac(getsum(i, p0[i] - 1), getsum(i, p0[i])), i, 0, vec[i][0][p0[i]].second);
    if (~p1[i]) qq.emplace(frac(1, vec[i][1][p1[i]].first), i, 1, vec[i][1][p1[i]].second);
    cnt += vec[i][0].size() + vec[i][1].size();
  }
  for (; cnt &gt; k; --cnt) {
    auto [f, i, o, id] = qq.top(); qq.pop();
    vis[id] = 0;
    if (!o) {
      --p0[i];
      if (~p0[i]) qq.emplace(frac(getsum(i, p0[i] - 1), getsum(i, p0[i])), i, 0, vec[i][0][p0[i]].second);
    } else {
      --p1[i];
      if (~p1[i]) qq.emplace(frac(1, vec[i][1][p1[i]].first), i, 1, vec[i][1][p1[i]].second);
    }
  }
  std::vector&lt;int&gt; vec[3];
  for (int i = 1; i &lt;= m; ++i) {
    if (vis[i])
      vec[op[i] - 1].emplace_back(i);
  }
  std::cout &lt;&lt; cnt &lt;&lt; '\n';
  for (auto x : vec[0]) std::cout &lt;&lt; x &lt;&lt; ' ';
  for (auto x : vec[1]) std::cout &lt;&lt; x &lt;&lt; ' ';
  for (auto x : vec[2]) std::cout &lt;&lt; x &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18318787.html</id>
    <title type="text">CF521E Cycling City 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-23T08:33:00Z</published>
    <updated>2024-07-23T08:33:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18318787.html" />
    <content type="text">## Description

- 给定一张 $n$ 个点 $m$ 条边的无向简单图。
- 问图中能否找到两个点，满足这两个点之间有至少三条完全不相交的简单路径。
- $n,m \le 2 \times 10^5$，图不保证连通。

## Solution

容易发现有解地充要条件是存在两个环有边交，考虑在 dfs 树上做这件事。

注意到非树边一定不会成为边交，所以边交一定为树边。

那么对于每个边维护一个数组，表示覆盖这个边地环，然后每次找到一个非树边 $(u,v)$ 并把 $u\to v$ 路径上的边添加上 $(u,v)$，如果跳的过程找到了交就输出答案。

考虑如何输出方案，假设是 $(u_1,v_1)$ 和 $(u_2,v_2)$ 这两个非树边对应路径的交，不妨设 $dep_{u_1}&lt;dep_{v_1},dep_{u_2}&lt;dep_{v_2},dep_{v_2}&lt;dep_{v_1}$，则可构造出这样三条路径：

1. $LCA(u_1,u_2)\to v_2$
2. $LCA(u_1,u_2)\to u_1\to v_1\to v_2$
3. $LCA(u_1,u_2)\to u_2\to v_2$

由于每个边不会被覆盖超过 $2$ 次，所以求边交和 LCA 都暴力跳即可。

时间复杂度：$O(n+m)$。

## Code

```cpp

```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18319669.html</id>
    <title type="text">P10280 [USACO24OPEN] Cowreography G 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-23T13:20:00Z</published>
    <updated>2024-07-23T13:20:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18319669.html" />
    <content type="text">## Description

奶牛们组了一支舞蹈队，Farmer John 是她们的编舞！舞蹈队最新而最精彩的舞蹈有 $N$ 头奶牛（$2\le N\le 10^6$）排成一行。舞蹈中的每次动作都涉及两头奶牛，至多相距 $K$ 个位置（$1\le K &lt; N$），优雅地跳起并降落在对方的位置上。

队伍中有两种奶牛——更赛牛（Guernsey）和荷斯坦牛（Holstein）。因此，Farmer John 将这一舞蹈记录为一系列**长为 $N$ 的 `01` 字符串**，其中 `0` 代表更赛牛，`1` 代表荷斯坦牛，整个字符串表示奶牛在这一行中是如何排列的。

不幸的是，Farmer Nhoj（对手团队的编舞）蓄意破坏了这一舞蹈，并清除了除第一个和最后一个 `01` 字符串之外的所有内容！由于一场大型比赛即将开始，Farmer John 必须抓紧每一秒重建这一舞蹈。

给定这两个 `01` 字符串，帮助 Farmer John 求出舞蹈中的最小动作数量！

## Solution

考虑交换一对 $i,j(a_i\neq a_j)$ 所用的代价，结论是 $\left\lceil\frac{|i-j|}{k}\right\rceil$。

证明就考虑数学归纳法，不妨设 $i&lt;j$ 且长度小于 $j-i$ 的已经满足结论，容易发现对于 $j-i\leq k$ 的 $(i,j)$ 一定满足条件。

对于 $i&lt;s&lt;j$，如果 $a_i=a_s$ 则先交换 $(j,s)$ 再交换 $(i,s)$，否则先交换 $(i,s)$ 在交换 $(j,s)$，对应的代价为 $\left\lceil\frac{s-i}{k}\right\rceil+\left\lceil\frac{j-s}{k}\right\rceil$，容易发现当 $s$ 取 $i+k$ 时可以取到最小值，即为 $\left\lceil\frac{|i-j|}{k}\right\rceil$。

有了这个结论就可发现这里的交换一定是两两匹配，即在一张二分图上匹配。

如果没有取上整就从前往后扫，如果 $a_i\neq b_i$ 就找到任意一个还没匹配的 $j$ 使得 $a_i\neq a_j$ 匹配，容易发现这个一定是最小值。

如果有了取上整，感性理解可以发现这里需要让 $(i-j)\bmod k$ 的和尽可能小，所以只要把上面选任意一个匹配变为选使得 $(i-j)\bmod k$ 最小的 $j$ 匹配即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

int n, k;
std::string a, b;

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; a &gt;&gt; b;
  a = " " + a, b = " " + b;
  std::set&lt;std::pair&lt;int, int&gt;&gt; st[2];
  int64_t ans = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (a[i] == b[i]) continue;
    int oa = a[i] - '0', ob = b[i] - '0';
    if (!st[ob].empty()) {
      auto it = st[ob].lower_bound({i % k, 0});
      if (it == st[ob].end()) it = st[ob].begin();
      ans += (i - it-&gt;second + k - 1) / k;
      st[ob].erase(it);
    } else {
      st[oa].emplace(i % k, i);
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18320173.html</id>
    <title type="text">CF527E Data Center Drama 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-24T01:51:00Z</published>
    <updated>2024-07-24T01:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18320173.html" />
    <content type="text">## Description

- 给定一张 $n$ 个点 $m$ 条边的连通无向图。
- 你需要加尽可能少的边，然后给所有边定向，使得每一个点的出入度都是偶数。
- 边可以是自环，也可以有重边。
- $n \le 10^5$，$m \le 2 \times 10^5$。

## Solution

看到定向考虑欧拉回路。

注意到题目里每个点出入度都是偶数说明定向前每个点的度数均为偶数，正好符合欧拉回路的条件。

那么先把度数为奇数的点拿出来，相邻两个连边就让每个点度数为偶数了。

但是这里还需满足每个点出入度都是偶数，所以总边数也应为偶数，如果为奇数就随便找个点连自环即可。

定向就考虑在欧拉回路上交错定向，类似：$v_1\rightarrow v_2\leftarrow v_3\rightarrow v_4\leftarrow v_5\ldots$。

容易发现这样的定向方案合法且添加的边数最少。

时间复杂度：$O(n+m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, m;
int cur[kMaxN];
bool vis[kMaxN * 2];
std::vector&lt;int&gt; path;
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs(int u) {
  for (int i = cur[u]; i &lt; (int)G[u].size(); i = cur[u]) {
    cur[u] = i + 1;
    auto [v, id] = G[u][i];
    if (vis[id]) continue;
    vis[id] = 1;
    dfs(v);
  }
  if (path.size()) {
    if (path.size() &amp; 1) std::cout &lt;&lt; path.back() &lt;&lt; ' ' &lt;&lt; u &lt;&lt; '\n';
    else std::cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; path.back() &lt;&lt; '\n';
  }
  path.emplace_back(u);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v, i), G[v].emplace_back(u, i);
  }
  std::vector&lt;int&gt; v;
  for (int i = 1; i &lt;= n; ++i)
    if (G[i].size() &amp; 1)
      v.emplace_back(i);
  for (int i = 0; i + 1 &lt; v.size(); i += 2)
    ++m, G[v[i]].emplace_back(v[i + 1], m), G[v[i + 1]].emplace_back(v[i], m);
  if (m &amp; 1) G[1].emplace_back(1, ++m), G[1].emplace_back(1, m);
  std::cout &lt;&lt; m &lt;&lt; '\n';
  dfs(1);
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18320497.html</id>
    <title type="text">CF547D Mike and Fish 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-24T03:30:00Z</published>
    <updated>2024-07-24T03:30:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18320497.html" />
    <content type="text">## Description

- 给定 $n$ 个整点。
- 你要给每个点染成红色或蓝色。
- 要求同一水平线或垂直线上两种颜色的数量最多相差 $1$。
- $n,x_i, y_i \le 2 \times 10^5$。

## Solution

考虑给每条水平线和垂直线建一个点，对于每个整点就把它对应的两条线连一条边。

题目就转化为了给每条边定向，使得每个点入度和出度不超过 $1$。这是个经典的问题，由于度数为奇数的点只有偶数个，所以新建一个点和这个奇度数的点连边，然后跑欧拉回路定向即可。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 6e5 + 5;

int n;
int x[kMaxN], y[kMaxN], ans[kMaxN], cur[kMaxN];
bool vis[kMaxN], vx[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs(int u) {
  vx[u] = 1;
  for (int i = cur[u]; i &lt; (int)G[u].size(); i = cur[u]) {
    auto [v, id] = G[u][i];
    cur[u] = i + 1;
    if (vis[id]) continue;
    vis[id] = 1;
    dfs(v);
    if (u &gt;= 1 &amp;&amp; u &lt;= 2e5 &amp;&amp; v &gt; 2e5) ans[id] = 0;
    else if (v &gt;= 1 &amp;&amp; v &lt;= 2e5 &amp;&amp; u &gt; 2e5) ans[id] = 1;
    else assert(!u || !v);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; x[i] &gt;&gt; y[i];
    G[x[i]].emplace_back(y[i] + (int)2e5, i), G[y[i] + (int)2e5].emplace_back(x[i], i);
  }
  int tmp = n;
  for (int i = 1; i &lt;= 4e5; ++i)
    if (G[i].size() &amp; 1)
      G[0].emplace_back(i, ++tmp), G[i].emplace_back(0, tmp);
  for (int i = 0; i &lt;= 4e5; ++i) dfs(i);
  for (int i = 1; i &lt;= n; ++i)
    std::cout &lt;&lt; (ans[i] ? 'r' : 'b');
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18322963.html</id>
    <title type="text">CF559E Gerald and Path 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-25T06:24:00Z</published>
    <updated>2024-07-25T06:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18322963.html" />
    <content type="text">## Description

- 有 $n$ 条线段。
- 每条线段给定其中一端的位置及长度。
- 求所有线段覆盖的最大长度。
- $n \le 100$。

## Solution

考虑 dp。

先按照一端的位置进行排序，设 $f_{i,j,0/1}$ 表示前 $i$ 个线段，右端点最靠右的线段是 $j$ 向左/右覆盖，所有线段的最大长度。

直接枚举 $i+1$ 转移可能会出现 $i+1$ 完全覆盖了 $j$ 而无法算贡献，但是思考一下会发现如果 $i+1$ 完全覆盖 $j$ 则把 $j$ 删掉也毫无影响，所以只用钦定 $j$ 没有被完全覆盖，然后枚举下一个对答案有影响的线段。

设 $d_0$ 为 $k$ 倒的方向，转移即为：$f_{k,k,d_0}\leftarrow f_{i,j,d}+\min\{pos_k+d_0 len_k-(pos_j+d\cdot len_j), len_k\}$。

但是可能会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/6op82xst.png)

红的是枚举的下一个线段 $k$，但是可能 $k$ 向左并且存在一个 $x$ 使得 $i&lt;x&lt;k$ 且 $pos_x+len_x&gt;pos_k$，此时 $x$ 也会有贡献，贡献显然为 $pos_x+len_x-pos_k$。

容易发现 $x$ 对答案的贡献只与其右端点有关，并且这些线段一定是向右倒，所以枚举下一个没有完全覆盖的线段 $k$ 时还需要维护位于 $(i,k)$ 这个区间里往右倒的线段的右端点最大值。

转移即为 $f_{k,x,1}\leftarrow f_{i,j,d}+\min\{pos_k+d_0 len_k-(pos_j+d\cdot len_j), len_k\}+(pos_x+len_x-(pos_k+d_0 len_k))$。

具体见代码。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 105;

int n;
int f[kMaxN][kMaxN][2];
std::pair&lt;int, int&gt; a[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
  std::sort(a + 1, a + 1 + n);
  a[0].first = -1e9;
  for (int i = 0; i &lt;= n; ++i) {
    f[i][i][0] = std::max(f[i][i][0], a[i].second);
    f[i][i][1] = std::max(f[i][i][1], a[i].second);
    if (i == n) continue;
    for (int j = 0; j &lt;= i; ++j) {
      for (int d = 0; d &lt; 2; ++d) {
        int r = a[j].first + d * a[j].second;
        f[i + 1][j][d] = std::max(f[i + 1][j][d], f[i][j][d]);
        std::tuple&lt;int, int, int&gt; t = {-1e9, 0, 0};
        for (int tj = i + 1; tj &lt;= n; ++tj) {
          for (int td = 0; td &lt; 2; ++td) {
            int tr = a[tj].first + td * a[tj].second;
            t = std::max(t, {tr, tj, td});
            auto [_r, _j, _d] = t;
            f[tj][_j][_d] = std::max(f[tj][_j][_d], f[i][j][d] + std::min(tr - r, a[tj].second) + _r - tr);
          }
        }
      }
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= i; ++j)
      ans = std::max({ans, f[i][j][0], f[i][j][1]});
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18323613.html</id>
    <title type="text">CF568C New Language 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-25T08:50:00Z</published>
    <updated>2024-07-25T08:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18323613.html" />
    <content type="text">## Description

- 将 $\texttt{a} \sim \texttt{a} + l - 1$ 这 $l$ 个字符分成 $\texttt{V,C}$ 两个集合。
- 你需要构造一个**长度为 $n$** 且**满足 $m$ 个限制**且**不小于另一个长度为 $n$ 的字符串 $s$** 的**最小**字符串。
- 每一个限制为**若字符串的第 $p_1$ 个位置上的字符 $\in t_1$，则第 $p_2$ 个位置上的字符 $\in t_2$**。
- $l \le 26$，$n \le 200$，$m \le 4n(n-1)$。

## Solution

要满足答案不小于 $s$ 就直接枚举第一个与 $s$ 不同的位填的字符，然后就是判断能否让一个后缀随便填，使得其满足限制，如果能满足就直接输出最小字符串。

注意到限制类似于 2-SAT，所以先建图。

然后从前往后枚举每一位，如果这一位已经确定就填确定的，否则要选尽量小的填，所以用 tarjan 求 2-SAT 方案显然做不了，但是用 dfs 求 2-SAT 就可以贪心地判断小的是否可行，如果可行就填小的，否则判断大的是否可行，如果还不可行就不存在方案。

具体实现见代码。

时间复杂度：$O(n^2m)$，但是显然跑不满。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 405;

int l, n, m;
int mi[26][2], op[26], vis[kMaxN];
std::vector&lt;int&gt; G[kMaxN];
std::string s, ans;

bool dfs(int u) {
  if (vis[(u &lt;= n) ? (u + n) : (u - n)]) return 0;
  else if (vis[u]) return 1;
  vis[u] = 1;
  for (auto v : G[u])
    if (!vis[v] &amp;&amp; !dfs(v))
      return vis[u] = 0;
  return 1;
}

bool check(int k) { // 前 k 位确定，后面的随便填是否可行
  std::fill_n(vis + 1, 2 * n, 0);
  ans = s;
  for (int i = 1; i &lt;= k; ++i)
    if (!dfs(i + op[s[i] - 'a'] * n))
      return 0;
  for (int i = k + 1; i &lt;= n; ++i) {
    int x = mi[0][0], y = mi[0][1];
    if (!~x) {
      if (!dfs(i + op[y] * n)) return 0;
      ans[i] = char('a' + y);
    } else if (!~y) {
      if (!dfs(i + op[x] * n)) return 0;
      ans[i] = char('a' + x);
    } else if (x &lt; y) {
      if (!dfs(i + op[x] * n)) {
        if (!dfs(i + op[y] * n)) return 0;
        else ans[i] = char('a' + y);
      } else {
        ans[i] = char('a' + x);
      }
    } else {
      if (!dfs(i + op[y] * n)) {
        if (!dfs(i + op[x] * n)) return 0;
        else ans[i] = char('a' + x);
      } else {
        ans[i] = char('a' + y);
      }
    }
  }
  return 1;
}

void print(std::string s) {
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; s[i];
  std::cout &lt;&lt; '\n';
}

void dickdreamer() {
  std::string str;
  std::cin &gt;&gt; str &gt;&gt; n &gt;&gt; m;
  l = str.size();
  for (int i = 0; i &lt; l; ++i) op[i] = (str[i] == 'C');
  memset(mi, -1, sizeof(mi));
  for (int i = 0; i &lt; l; ++i) {
    for (int j = l - 1; j &gt;= i; --j) mi[i][op[j]] = j;
  }
  for (int i = 1; i &lt;= m; ++i) {
    int x, y;
    std::string sx, sy;
    std::cin &gt;&gt; x &gt;&gt; sx &gt;&gt; y &gt;&gt; sy;
    int ox = (sx[0] == 'C'), oy = (sy[0] == 'C');
    G[x + ox * n].emplace_back(y + oy * n);
    G[y + (oy ^ 1) * n].emplace_back(x + (ox ^ 1) * n);
  }
  std::cin &gt;&gt; s; s = " " + s;
  if (check(n)) return print(s);
  for (int i = n; i; --i) {
    int now = s[i] - 'a', x = mi[now + 1][0], y = mi[now + 1][1];
    if (!~x &amp;&amp; !~y) {
      continue;
    } else if (!~x) {
      s[i] = char(y + 'a');
      if (!check(i)) continue;
      else return print(ans);
    } else if (!~y) {
      s[i] = char(x + 'a');
      if (!check(i)) continue;
      else return print(ans);
    } else {
      if (x &lt; y) {
        s[i] = char(x + 'a');
        if (!check(i)) {
          s[i] = char(y + 'a');
          if (!check(i)) continue;
          else return print(ans);
        } else {
          return print(ans);
        }
      } else {
        s[i] = char(y + 'a');
        if (!check(i)) {
          s[i] = char(x + 'a');
          if (!check(i)) continue;
          else return print(ans);
        } else {
          return print(ans);
        }
      }
    }
    s[i] = char(now + 'a');
  }
  std::cout &lt;&lt; "-1\n";
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18325820.html</id>
    <title type="text">CF576D Flights for Regular Customers 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-26T09:18:00Z</published>
    <updated>2024-07-26T09:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18325820.html" />
    <content type="text">## Description

- 给定一张 $n$ 个点 $m$ 条边的有向图。
- 一开始你在 $1$ 号节点，你要走到 $n$ 号节点去。
- 只有当你已经走过了至少 $d_i$ 条边时，你才能走第 $i$ 条边。
- 问最少要走多少条边，或判断无法到达。
- $n,m \le 150$，$d_i \le 10^9$。

## Solution

注意到如果直接跑最短路可能走着走着突然有些边可以走了，这样就不太好做。

考虑枚举当前解锁了哪些边，即枚举 $w$，把所有边权 $\leq w$ 的边加入图中，并选择从 $1$ 走 $w$ 步能到达的点跑多源 bfs 就可以求出只用边权 $\leq w$ 的边能到达 $n$ 的最短距离。

容易发现 $w$ 只有 $O(m)$ 种，所以可以从小到大枚举边权，每次加入一条边。要找到从 $1$ 走 $w$ 步能到达的点就直接用矩阵乘法维护即可。不过这里直接矩乘会是 $O(n^3m\log V)$ 的，显然过不了。

由于矩乘只需维护 0/1 信息，所以 bitset 优化即可。

时间复杂度：$O\left(\frac{n^3m\log V}{\omega}\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 155;

int n, m;
int g[kMaxN][kMaxN], dis[kMaxN];
bool vis[kMaxN];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; ed;
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

struct Matrix {
  int n, m;
  std::bitset&lt;kMaxN&gt; a[kMaxN];

  void set(int _n, int _m) { n = _n, m = _m; }
  friend Matrix operator *(const Matrix &amp;m1, const Matrix &amp;m2) {
    static Matrix ret;
    assert(m1.m == m2.n);
    ret.set(m1.n, m2.m);
    for (int i = 1; i &lt;= m1.n; ++i)
      ret.a[i].reset();
    for (int i = 1; i &lt;= m1.n; ++i) {
      for (int k = 1; k &lt;= m1.m; ++k) {
        if (m1.a[i][k]) ret.a[i] |= m2.a[k]; 
      }
    }
    return ret;
  }
} S, M, O;

void dijkstra() {
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    dis[i] = 1e18, vis[i] = 0;
    if (S.a[1][i]) q.emplace(dis[i] = 0, i);
  }
  for (; !q.empty();) {
    auto [d, u] = q.top(); q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w] : G[u]) {
      if (M.a[u][v] &amp;&amp; dis[v] &gt; dis[u] + 1) {
        dis[v] = dis[u] + 1, q.emplace(-dis[v], v);
      }
    }
  }
}

Matrix qpow(Matrix bs, int idx) {
  Matrix ret = O;
  for (; idx; idx &gt;&gt;= 1, bs = bs * bs)
    if (idx &amp; 1)
      ret = ret * bs;
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  memset(g, 0x3f, sizeof(g));
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    ed.emplace_back(w, u, v);
    G[u].emplace_back(v, w);
    g[u][v] = w;
  }
  std::sort(ed.begin(), ed.end());
  int lst = 0, ans = 1e18;
  S.set(1, n), M.set(n, n), O.set(n, n);
  for (int i = 1; i &lt;= n; ++i) O.a[i][i] = 1;
  S.a[1][1] = 1;
  for (int i = 0; i &lt; m; ++i) {
    auto [w, u, v] = ed[i];
    if (ans &lt; w) break;
    if (w != lst) S = S * qpow(M, w - lst);
    M.a[u][v] = 1, lst = w;
    dijkstra();
    ans = std::min(ans, w + dis[n]);
  }
  if (ans &gt;= 1e15) std::cout &lt;&lt; "Impossible\n";
  else std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18326070.html</id>
    <title type="text">CF578E Walking! 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-26T11:15:00Z</published>
    <updated>2024-07-26T11:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18326070.html" />
    <content type="text">## Description

- 给定一个长度为 $n$ 的只包含 `L,R` 的字符串 $s$。
- 构造一个 $n$ 排列 $p$ 满足 $s[p_i] \ne s[p_{i+1}](1 \le i &lt; n)$。
- 最小化 $p$ 中 $p_i &gt; p_{i+1}(1 \le i &lt; n)$ 的数量。
- $n \le 10^5$，数据保证有解。

## Solution

考虑把 $p$ 中的每个极长连续上升子序列拿出来，显然这些子序列为 $1,2,\ldots,n$ 的一个划分，使得每个子序列一定是 LR 交错出现。

所以第一问的答案为把 $1,2,\ldots,n$ 划分成最少的子序列数$-1$，使得每个子序列是 LR 交错出现。

有一个显然的贪心策略是从前往后扫，不妨设 $s_i$ 为 L，如果 $s_i$ 能找到末尾与其不同的子序列就把它加到那个子序列末尾，如果找不到就创建一个新的子序列。

证明就考虑如果能找到但是不加，就说明当前答案会 $+1$，如果加了顶多是后面的一个 R 找不到 L 与其配对，也只会 $+1$，并且在这之前答案一直更优。

然后需要构造方案，用 $cnt_{ij}$ 表示开头为 $i$，末尾为 $j$ 的子序列数量。

容易发现当 $cnt_{LR},cnt_{RL}\neq 0,cnt_{LL}=cnt_{RR}=0$ 时是无法直接构造方案的，这时可以任意取一对 LR 和 RL 的序列，把末尾更靠后的那个序列的末尾放到另一个序列的末尾，这样就有了 LL 和 RR。

注意到 $|cnt_{LL}-cnt_{RR}|\leq 1$，不妨设 $cnt_{LL}\geq cnt_{RR}$，可以构造：LR、LR、...、LR、LL、RL、RL、...、RL、RR、LL、RR、LL、...

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, tot;
std::string str;
std::vector&lt;int&gt; vec[2], vv[kMaxN], id[2][2];

void fix() {
  int x = id[0][1].back(), y = id[1][0].back();
  id[0][1].pop_back(), id[1][0].pop_back();
  if (vv[x].back() &lt; vv[y].back()) std::swap(x, y);
  vv[y].emplace_back(vv[x].back()), vv[x].pop_back();
  id[str[vv[x].front()] == 'R'][str[vv[x].back()] == 'R'].emplace_back(x);
  id[str[vv[y].front()] == 'R'][str[vv[y].back()] == 'R'].emplace_back(y);
}

void print(int x) {
  for (auto i : vv[x]) std::cout &lt;&lt; i &lt;&lt; ' ';
}

void dickdreamer() {
  std::cin &gt;&gt; str;
  n = str.size(); str = " " + str;
  for (int i = 1; i &lt;= n; ++i) {
    int c = (str[i] == 'R');
    if (!vec[c ^ 1].size()) {
      vec[c].emplace_back(++tot);
      vv[tot] = {i};
    } else {
      int t = vec[c ^ 1].back(); vec[c ^ 1].pop_back();
      vv[t].emplace_back(i), vec[c].emplace_back(t);
    }
  }
  std::cout &lt;&lt; tot - 1 &lt;&lt; '\n';
  for (int i = 1; i &lt;= tot; ++i)
    id[str[vv[i].front()] == 'R'][str[vv[i].back()] == 'R'].emplace_back(i);
  if (id[0][1].size() &amp;&amp; id[1][0].size() &amp;&amp; !id[0][0].size() &amp;&amp; !id[1][1].size()) fix();
  int o = 0;
  if (id[0][0].size() &lt; id[1][1].size()) o = 1;
  for (auto x : id[o][o ^ 1]) print(x);
  if (id[o][o].size()) print(id[o][o].front());
  for (auto x : id[o ^ 1][o]) print(x);
  for (int i = 0; i &lt; (int)id[o ^ 1][o ^ 1].size(); ++i) {
    print(id[o ^ 1][o ^ 1][i]);
    if (i + 1 &lt; (int)id[o][o].size()) print(id[o][o][i + 1]);
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18326341.html</id>
    <title type="text">CF585F Digits of Number Pi 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-26T13:52:00Z</published>
    <updated>2024-07-26T13:52:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18326341.html" />
    <content type="text">## Description

给定长度为 $n$ 的数字串 $s$ 和长度为 $d$ 的不含前导零的数字串 $x,y(x \le y)$。

求**存在长度至少为 $\left\lfloor\frac{d}{2}\right\rfloor$ 的子串是 $s$ 的子串**的数字串 $t \in [x,y]$ 的数量。

$n \le 10^3$，$d \le 50$，答案对 $10^9+7$ 取模。

## Solution

先把 $s$ 所有长度为 $\left\lfloor\frac{d}{2}\right\rfloor$ 的子串拿出来，那么相当于要求这些子串必须在 $t$ 里出现，考虑用总数减去没出现的数量。

考虑用 $[0,y]$ 的答案减去 $[0,x-1]$ 的答案，这样就只有上界了。

注意到这里是很多个字符串匹配一个串，考虑把 $s$ 的这些子串加到 AC 自动机里，那么这些子串没在 $t$ 里出现当且仅当从前往后扫 $t$ 的每一个字符，每次让 $cur\leftarrow trie_{cur,t_i}$，如果这里的 $cur$ 每次都不在 $s$ 子串对应的节点上就说明子串没在 $t$ 里出现。

这样就可以 dp 了。设 $f_{i,j,0/1}$ 表示 $1\sim i-1$ 走到 $j$，$i\sim n$ 每次不走子串对应节点，后面有没有卡上界的限制的方案数。

转移就每次枚举 $t_i$ 即可。

时间复杂度：$O\left(|\Sigma|^2nd^2\right)$，$|\Sigma|$ 为字符集大小。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e3 + 5, kMaxD = 55, kMaxT = kMaxN * kMaxD * 5, kMod = 1e9 + 7;

int n, d, tot;
int a[kMaxN], trie[kMaxT][10], fail[kMaxT], f[kMaxD][kMaxT][2];
bool tag[kMaxT], vis[kMaxD][kMaxT][2];
std::string s, L, R;

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

std::string sub(std::string s) {
  for (int i = d; i; --i) {
    if (s[i] != '0') {
      --s[i];
      for (int j = i + 1; j &lt;= d; ++j) s[j] = '9';
      break;
    }
  }
  return s;
}

void ins(std::string s) {
  int cur = 0;
  for (auto c : s) {
    int k = c - '0';
    if (!trie[cur][k]) trie[cur][k] = ++tot;
    cur = trie[cur][k];
  }
  tag[cur] = 1;
}

void build() {
  std::queue&lt;int&gt; q;
  for (int i = 0; i &lt; 10; ++i) {
    if (trie[0][i]) {
      q.emplace(trie[0][i]);
    }
  }
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = 0; i &lt; 10; ++i) {
      if (trie[u][i]) {
        fail[trie[u][i]] = trie[fail[u]][i];
        q.emplace(trie[u][i]);
      } else {
        trie[u][i] = trie[fail[u]][i];
      }
    }
  }
}

int dfs(int x, int k, bool op) {
  if (x &gt; d || tag[k]) return !tag[k];
  else if (vis[x][k][op]) return f[x][k][op];
  int ret = 0;
  for (int i = 0; i &lt;= (op ? a[x] : 9); ++i) {
    inc(ret, dfs(x + 1, trie[k][i], op &amp;&amp; (i == a[x])));
  }
  vis[x][k][op] = 1;
  return f[x][k][op] = ret;
}

int solve(std::string t) {
  for (int i = 1; i &lt;= d; ++i) a[i] = t[i] - '0';
  int ans = 0;
  for (int i = 1; i &lt;= d; ++i) ans = (10ll * ans + a[i]) % kMod;
  memset(f, 0, sizeof(f)), memset(vis, 0, sizeof(vis));
  return sub(ans, dfs(1, 0, 1));
}

void dickdreamer() {
  std::cin &gt;&gt; s &gt;&gt; L &gt;&gt; R;
  n = s.size(), d = L.size();
  s = " " + s, L = " " + L, R = " " + R;
  for (int i = 1; i &lt;= n - (d / 2) + 1; ++i)
    ins(s.substr(i, d / 2));
  build();
  std::cout &lt;&lt; sub(solve(R), solve(sub(L))) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18327098.html</id>
    <title type="text">CF605E Intergalaxy Trips 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-27T08:15:00Z</published>
    <updated>2024-07-27T08:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18327098.html" />
    <content type="text">## Description

- $n$ 个点的有向完全图。
- $i \to j$ 的边每天出现的概率均为 $p_{i,j}$，若 $i = j$，有 $p_{i,j} = 1$。
- 每天可以选择一条存在的出边走过去或停留在原地不动。
- 求最优策略下从 $1$ 到 $n$ 的期望天数。
- $n \le 10^3$。

## Solution

设 $f_i$ 表示 $i$ 到 $n$ 的期望天数。

假设 $f$ 已经求出，那么 $i$ 每次走到的下一步 $j$ 一定是满足 $i\to j$ 这条边出现且 $f_j$ 最小的点。

容易发现如果 $f_j&gt;f_i$ 则 $i$ 下一步无论如何不会走到 $j$。

所以可以得出转移方程：

$$
f_i=\sum_{f_j&lt;f_i}p_{i,j}f_j\prod_{f_k&lt;f_j}(1-p_{i,k})+f_i\prod_{f_j&lt;f_i}(1-p_{i,j})+1
$$

移项可得：

$$
f_i=\frac{\sum_{f_j&lt;f_i}p_{i,j}f_j\prod_{f_k&lt;f_j}{(1-p_{i,k})}}{1-\prod_{f_j&lt;f_i}(1-p_{i,j})}
$$

考虑已经确定了前 $k$ 小的 $f$ 值，如何求出第 $k+1$ 小的编号。

注意到只考虑前 $k$ 小的贡献，对于一个没确定的 $i$，再计算一个 $f_j&lt;f_i$ 对 $i$ 贡献后 $f_i$ 一定不会变大，所以如果当前 $f_i&lt;f_j$，则 $i$ 一定不会在 $j$ 后面，否则 $f_i$ 计算 $f_j$ 的贡献后只会更小，与 $i$ 在 $j$ 后矛盾。

所以第 $k+1$ 小的编号就是只考虑前 $k$ 小的贡献的没确定的位置里 $f$ 值最小的编号。

时间复杂度：$O(n^2)$。

## Code


```cpp

```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18327599.html</id>
    <title type="text">CF613E Puzzle Lover 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-27T14:09:00Z</published>
    <updated>2024-07-27T14:09:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18327599.html" />
    <content type="text">## Description

给定一个 $2 \times n$ 的矩阵，每个位置上有一个小写字母。

有一个长度为 $k$ 的小写字符串 $w$，询问矩阵中有多少条有向路径满足以下条件：
  - 路径上的字母连起来恰好为 $w$。
  - 不多次经过同一个位置。
  - 只能向上下左右四个方向走。

$n,k \le 2 \times 10^3$，答案对 $10^9+7$ 取模。

## Solution

注意到矩阵的宽只有 $2$，所以最终的行走路线一定是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/fkecjfml.png)

即两边为一个 U 形，中间为一个不走回头路的路径和两边的 U 形拼接起来。

不妨先考虑起点在终点左边或者起点和终点在同一列并且起点先往左走的情况，另一种情况就把 w 反转再做一遍即可。

显然可以 dp，设 $f_{i,j,s}$ 表示目前走到 $(i,j)$，且匹配到了 $w$ 的第 $s$ 位的方案数，这个方案是考虑了左边的 U + 不回头路径或者只有不回头路径的方案。

那么如果 $(i,j)$ 右边能找到一个长度为 $k-s$ 的 U 就可以让 $f_{i,j,s}$ 更新答案。

实现时要注意如果起点和终点在同一列时答案会算重，需要把这一部分减掉。

时间复杂度：$O(nk)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using u64 = uint64_t;

const int kMaxN = 2e3 + 5, kMod = 1e9 + 7;

int n, m;
int f[kMaxN][2][kMaxN];
bool g[kMaxN][2][kMaxN];
u64 pw[kMaxN], hss[2][kMaxN], hst[kMaxN], rhst[kMaxN];
std::string s[2], t;

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

u64 gethash(u64 *hs, int l, int r) { return hs[r] - hs[l - 1] * pw[r - l + 1]; }
u64 gethash_rev(int l, int r) { return gethash(rhst, m - r + 1, m - l + 1); }

void prework() {
  memset(hss, 0, sizeof(hss));
  memset(hst, 0, sizeof(hst));
  memset(rhst, 0, sizeof(rhst));
  memset(pw, 0, sizeof(pw));
  pw[0] = 1;
  for (int i = 1; i &lt;= 2e3; ++i) pw[i] = 13331ull * pw[i - 1];
  for (int o = 0; o &lt; 2; ++o) {
    for (int i = 1; i &lt;= n; ++i) hss[o][i] = 13331ull * hss[o][i - 1] + s[o][i];
  }
  for (int i = 1; i &lt;= m; ++i) {
    hst[i] = 13331ull * hst[i - 1] + t[i];
    rhst[i] = 13331ull * rhst[i - 1] + t[m - i + 1];
  }
}

int solve(int o) {
  prework();
  memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g));
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt; 2; ++j) {
      for (int k = 1; k &lt;= std::min(m / 2, n - i + 1); ++k) {
        g[i][j][2 * k] =
            (gethash(hss[j], i, i + k - 1) ==
                 gethash(hst, m - 2 * k + 1, m - k) &amp;&amp;
             gethash(hss[j ^ 1], i, i + k - 1) == gethash_rev(m - k + 1, m));
      }
    }
  }
  int ret = 0, cnt = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt; 2; ++j) {
      for (int k = 1; k &lt;= std::min(m / 2, i); ++k) {
        inc(f[i][j][2 * k],
            gethash(hss[j ^ 1], i - k + 1, i) == gethash_rev(1, k) &amp;&amp;
                gethash(hss[j], i - k + 1, i) == gethash(hst, k + 1, 2 * k));
      }
      if (o) dec(ret, f[i][j][m] + g[i][j][m]);
      for (int k = 1; k &lt;= m; ++k) {
        if (s[j][i] != t[k]) continue;
        int sum = f[i][j][k];
        if (k == 1) {
          inc(f[i][j][k], 1);
        } else {
          inc(f[i][j][k], f[i - 1][j][k - 1]);
          inc(sum, f[i - 1][j][k - 1]);
          if (s[j ^ 1][i] == t[k - 1] &amp;&amp; k &gt; 2) {
            inc(f[i][j][k], f[i - 1][j ^ 1][k - 2]);
          }
        }
        if (k == m) inc(ret, sum);
        else if (g[i + 1][j][m - k]) inc(ret, f[i][j][k]);
      }
      inc(ret, g[i][j][m]);
    }
  }
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; s[0] &gt;&gt; s[1] &gt;&gt; t;
  n = s[0].size(), m = t.size();
  s[0] = " " + s[0], s[1] = " " + s[1], t = " " + t;
  if (m == 1) {
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i) ans += (s[0][i] == t[1]) + (s[1][i] == t[1]);
    return void(std::cout &lt;&lt; ans &lt;&lt; '\n');
  } else if (m == 2) {
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
      ans += (s[0][i] == t[1] &amp;&amp; s[1][i] == t[2]) +
             (s[1][i] == t[1] &amp;&amp; s[0][i] == t[2]);
      if (i &lt; n) {
        ans += (s[0][i] == t[1] &amp;&amp; s[0][i + 1] == t[2]);
        ans += (s[0][i + 1] == t[1] &amp;&amp; s[0][i] == t[2]);
        ans += (s[1][i] == t[1] &amp;&amp; s[1][i + 1] == t[2]);
        ans += (s[1][i + 1] == t[1] &amp;&amp; s[1][i] == t[2]);
      }
    }
    return void(std::cout &lt;&lt; ans &lt;&lt; '\n');
  }
  int ans = solve(0);
  std::reverse(t.begin() + 1, t.begin() + 1 + m);
  inc(ans, solve(1));
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18328571.html</id>
    <title type="text">CF626G Raffles 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-28T09:37:00Z</published>
    <updated>2024-07-28T09:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18328571.html" />
    <content type="text">## Description

- 有 $n$ 个奖池，第 $i$ 个奖池的奖金是 $p_i$，已经有 $l_i$ 张彩票押在上面。
- 现在你有 $t$ 张彩票，你需要将你的彩票分配到这些奖池中，并且保证你在每个奖池中押的彩票数**不能超过该奖池原有的彩票数**。
- 若你在第 $i$ 个奖池中押了 $t_i$ 张彩票，则你中奖的概率为 $\frac{t_i}{t_i + l_i}$，若你中奖，你可以获得这个奖池的全部奖金 $p_i$。
- 一共有 $q$ 次事件，每次事件会使某个 $l_i$ 加 $1$ 或减 $1$。
- 你需要在每个事件后求出在最佳方案下你获得的奖金总数的最大期望值。
- $n,t,q \le 2 \times 10^5$，$p_i,l_i \le 10^3$，答案精度误差 $\le 10^{-6}$。

## Solution

首先单次 $O(t\log n)$ 是很容易的，就先假设所有 $t_i=0$，每次取出让 $t_i\to t_i+1$ 的增量的最大值，由于对于每个 $i$，$t_i$ 越大增量越小，所以每次贪心取最大值是对的。

考虑怎么支持修改。

不妨设修改了 $x$，让 $l_x\leftarrow l_x+1$。

有一个结论是每次选出当前已经选择的 $\Delta$ 里的最小值和没选的 $\Delta$ 的最大值，如果这个最小值小于最大值就贪心地替换，替换的次数不超过 $1$ 次。

证明就考虑设 $\Delta E(k)=\dfrac{p_xl_x}{(l_x+k)(l_x+k+1)},\Delta E'(k)=\dfrac{p_x(l_x+1)}{(l_x+k+1)(l_x+k+2)}$。

注意到 $\Delta E'(k)=\dfrac{p_x(l_x+1)}{(l_x+k+1)(l_x+k+2)}&gt;\Delta E(k+1)=\dfrac{p_xl_x}{(l_x+k+1)(l_x+k+2)}$，所以 $x$ 只有可能是选了的最小的增量被替换，所以最多只有一次。

对于 $l_x\leftarrow l_x-1$ 的情况同理可证结论仍成立。

时间复杂度：$O((n+q+t)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using f64 = long double;

const int kMaxN = 2e5 + 5;

int n, m, q;
f64 ans;
int l[kMaxN], p[kMaxN], t[kMaxN];
std::multiset&lt;std::pair&lt;f64, int&gt;&gt; st[2];

f64 getdet(int x, int v) {
  return (f64)p[x] * l[x] / (l[x] + t[x]) / (l[x] + t[x] + v);
}

void add(int x) {
  --m;
  st[1].erase({getdet(x, 1), x});
  if (t[x]) st[0].erase({getdet(x, -1), x});
  ans += getdet(x, 1), ++t[x];
  st[0].emplace(getdet(x, -1), x);
  if (t[x] &lt; l[x]) st[1].emplace(getdet(x, 1), x);
}

void del(int x) {
  ++m;
  if (t[x] &lt; l[x]) st[1].erase({getdet(x, 1), x});
  st[0].erase({getdet(x, -1), x});
  ans -= getdet(x, -1), --t[x];
  if (t[x]) st[0].emplace(getdet(x, -1), x);
  st[1].emplace(getdet(x, 1), x);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; p[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; l[i];
  for (int i = 1; i &lt;= n; ++i) st[1].emplace(getdet(i, 1), i);
  for (; m &amp;&amp; !st[1].empty();) add(st[1].rbegin()-&gt;second);
  for (int i = 1; i &lt;= q; ++i) {
    int op, x;
    std::cin &gt;&gt; op &gt;&gt; x;
    if (op == 1) {
      if (t[x]) st[0].erase({getdet(x, -1), x});
      if (t[x] &lt; l[x]) st[1].erase({getdet(x, 1), x});
      ans -= (f64)p[x] * t[x] / (t[x] + l[x]);
      ++l[x];
    } else {
      if (t[x] == l[x]) del(x);
      if (t[x]) st[0].erase({getdet(x, -1), x});
      if (t[x] &lt; l[x]) st[1].erase({getdet(x, 1), x});
      ans -= (f64)p[x] * t[x] / (t[x] + l[x]);
      --l[x];
    }
    ans += (f64)p[x] * t[x] / (t[x] + l[x]);
    if (t[x]) st[0].emplace(getdet(x, -1), x);
    if (t[x] &lt; l[x]) st[1].emplace(getdet(x, 1), x);
    for (; m &amp;&amp; !st[1].empty();) add(st[1].rbegin()-&gt;second);
    if (!st[0].empty() &amp;&amp; !st[1].empty()) {
      auto [det1, j1] = *st[0].begin();
      auto [det2, j2] = *st[1].rbegin();
      if (det1 &lt; det2) del(j1), add(j2);
    }
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; ans &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18329159.html</id>
    <title type="text">CF526G Spiders Evil Plan 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-28T15:32:00Z</published>
    <updated>2024-07-28T15:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18329159.html" />
    <content type="text">## Description

给定一棵 $n$ 个节点的无根树，每条边有边权。

有 $q$ 次询问，每次询问给出 $x,y$，你需要选择 $y$ 条树上的路径，使这些路径形成一个包含 $x$ 的连通块，且连通块中包含的边权和最大。

$n, q \le 10^5$，强制在线。

## Solution

考虑只有一组询问怎么快速求答案。

容易发现树上路径的两端点一定是叶子，并且如果给定了这些叶子那么一定存在一组方案使得这些路径覆盖了这些叶子构成的虚树。

对于询问 $x,y$，考虑把 $x$ 提到根，需要找到一些叶子使得这些叶子的虚树包含 $x$ 并且虚树权值和最大。

如果只要求权值和最大就只需要找到权值最大的 $2y$ 条长链即可，这就是贪心选，但是此时选择的虚树可能不包含 $x$ 而导致这种以 $x$ 为根贪心取长链算出来的答案会算上一些虚树没有的边。

由于这是暴力就不考虑怎么调整了。

注意到选择叶子的最优解一定满足至少选了树的直径的两端点之一，所以考虑让直径的两端点作为根跑上面那个贪心做法，这样就不用换根了。

具体的，假设直径的一端点为 $p$，询问为 $(x,y)$，就以 $p$ 为根选择最长的 $2y-1$ 条长链加入答案。可能出现选的方案虚树不包含 $x$ 的情况，这时需要调整。容易发现只有两种调整方案：

1. 找到 $x$ 祖先里第一个被选的点然后把这个点到叶子的路径替换为这个点走到 $x$ 那边的路径。
2. 让 $x$ 所在的长链替换原来第 $2y-1$ 长的长链。

至于为什么是这两种就考虑 $x$ 的长链替换哪个原长链即可。

时间复杂度：$O\left((n+q)\log n\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, q, s, t, cntl;
int dis[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs(int u, int fa) {
  if (!fa) dis[u] = 0;
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    dis[v] = dis[u] + w;
    dfs(v, u);
  }
}

struct Tree {
  int rt, cnt, tot;
  int lg[kMaxN], len[kMaxN], dis[kMaxN], mxd[kMaxN], lson[kMaxN], p[kMaxN][18];
  int rnk[kMaxN], id[kMaxN], sum[kMaxN], minrnk[kMaxN], top[kMaxN];
  
  void dfs1(int u, int fa) {
    mxd[u] = u, p[u][0] = fa;
    for (int i = 1; i &lt;= lg[n]; ++i)
      p[u][i] = p[p[u][i - 1]][i - 1];
    for (auto [v, w] : G[u]) {
      if (v == fa) continue;
      dis[v] = dis[u] + w;
      dfs1(v, u);
      if (len[v] + w &gt; len[u])
        len[u] = len[v] + w, mxd[u] = mxd[v], lson[u] = v;
    }
  }

  void dfs2(int u, int fa) {
    minrnk[u] = rnk[u];
    for (auto [v, w] : G[u]) {
      if (v == fa) continue;
      dfs2(v, u);
      minrnk[u] = std::min(minrnk[u], minrnk[v]);
    }
  }

  void init(int s) {
    rt = s, lg[0] = -1;
    for (int i = 1; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; 1] + 1;
    dfs1(rt, 0);
    for (int i = 1; i &lt;= n; ++i) {
      if (i == rt || i != lson[p[i][0]]) {
        for (int j = i; j; j = lson[j]) top[j] = i;
      }
    }
    std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
    for (int i = 1; i &lt;= n; ++i) {
      rnk[i] = 1e9;
      if (i == rt || i != lson[p[i][0]]) {
        vec.emplace_back(dis[mxd[i]] - dis[p[i][0]], mxd[i]);
      }
    }
    std::sort(vec.begin(), vec.end(), std::greater&lt;std::pair&lt;int, int&gt;&gt;());
    tot = vec.size();
    for (int i = 0; i &lt; (int)vec.size(); ++i) {
      rnk[vec[i].second] = i + 1;
      id[i + 1] = vec[i].second, sum[i + 1] = sum[i] + vec[i].first;
    }
    dfs2(rt, 0);
  }

  int ask1(int x, int y) {
    int now = x;
    for (int i = lg[n]; ~i; --i)
      if (p[now][i] &amp;&amp; minrnk[p[now][i]] &gt; y)
        now = p[now][i];
    if (minrnk[now] &gt; y) now = p[now][0];
    return sum[y] - len[now] + dis[mxd[x]] - dis[now];
  }

  int ask2(int x, int y) {
    int now = x;
    for (int i = lg[n]; ~i; --i)
      if (p[now][i] &amp;&amp; minrnk[p[now][i]] &gt;= y)
        now = p[now][i];
    if (minrnk[now] &gt;= y) now = p[now][0];
    return sum[y - 1] + dis[mxd[x]] - dis[now];
  }

  int solve(int x, int y) {
    y = 2 * y - 1;
    if (y &gt;= tot) return sum[tot];
    else if (minrnk[x] &lt;= y) return sum[y];
    return std::max(ask1(x, y), ask2(x, y));
  }
} tr[2];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  int sumw = 0;
  for (int i = 1; i &lt; n; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    sumw += w;
  }
  for (int i = 1; i &lt;= n; ++i) cntl += (G[i].size() == 1);
  dfs(1, 0);
  s = std::max_element(dis + 1, dis + 1 + n) - dis;
  dfs(s, 0);
  t = std::max_element(dis + 1, dis + 1 + n) - dis;
  tr[0].init(s), tr[1].init(t);
  for (int i = 1, lstans = 0; i &lt;= q; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    x = (x + lstans - 1) % n + 1, y = (y + lstans - 1) % n + 1;
    if (2 * y &gt;= cntl)std::cout &lt;&lt; (lstans = sumw) &lt;&lt; '\n';
    else std::cout &lt;&lt; (lstans = std::max(tr[0].solve(x, y), tr[1].solve(x, y))) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18330881.html</id>
    <title type="text">CF538G Berserk Robot 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-29T11:29:00Z</published>
    <updated>2024-07-29T11:29:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18330881.html" />
    <content type="text">## Description

有一个机器人，第 $0$ 秒时在 $(0,0)$ 位置。

机器人会循环执行一个长度为 $l$ 的指令序列，每秒执行一个指令。

指令有 `ULDR` 四种，分别代表向上/左/下/右移动一格。

你不知道这个指令序列具体是什么，但是你知道 $n$ 条信息，第 $i$ 条信息为「第 $t_i$ 秒时机器人在 $(x_i,y_i)$」，保证 $t$ 递增。

你需要构造一个满足这些信息的指令序列，或判断不存在。

$n \le 2 \times 10^5$，$l \le 2 \times 10^6$，$t_i,|x_i|,|y_i| \le 10^{18}$。

## Solution

注意到这里每次移动 $x,y$ 会互相影响，而不是独立的，考虑把原图转 $45^{\circ}$ 即点 $(x,y)$ 变为 $(x+y,x-y)$，这样操作就变为 $(1,1),(1,-1),(-1,1),(-1,-1)$。

这样已经可以做了，但 $1,-1$ 这类操作不够优美，考虑让 $(x,y)$ 变为 $\left(\frac{y+x+t}{2},\frac{y-x+t}{2}\right)$，操作就只有 $(1,1),(1,0),(0,1),(0,0)$，这样题目就简化很多了。

先考虑 $x$ 的情况，对于 $y$ 同理。

不妨设 $s_i$ 表示前 $i$ 个指令对 $x$ 的贡献值，对于一组信息 $(t_i,x_i)$，$r_i=t_i\bmod l,k_i=\left\lfloor\frac{t_i}{l}\right\rfloor$，一定满足 $x_i=s_{r_i}+k_is_l$，所以$s_{r_i}=x_i-k_is_l$。

考虑按照 $r_i$ 排序，容易发现按照 $r$ 把 $[1,l]$ 分成若干块，对于块内的操作可以随便排序，所以 $0\leq (x_{i+1}-k_{i+1}s_l)-(x_{i}-k_is_l)\leq r_{i+1}-r_{i}$，这里为了让 $[1,r_1]$ 和 $[r_n+1,l]$ 这两个块也考虑到，可以加入 $k=0,r=0,x=0$ 和 $k=-1,r=l,x=0$ 这两组信息。

通过解不等式就可以得到 $s_l$ 的范围，然后随便取一个 $s_l$ 的可能取值对于每个块分别考虑就可以构造出答案了。

时间复杂度：$O(n\log n+l)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5, kMaxL = 2e6 + 5;

int n, l;
bool ans[kMaxL][2];
std::tuple&lt;int, int, int, int&gt; a[kMaxN];

char getch(bool o1, bool o2) {
  if (!o1 &amp;&amp; !o2) return 'D';
  else if (!o1 &amp;&amp; o2) return 'L';
  else if (o1 &amp;&amp; !o2) return 'R';
  else return 'U';
}

int cei(int x, int k) {
  if (k &lt; 0) x = -x, k = -k;
  if (x &gt;= 0) return (x + k - 1) / k;
  else return -((-x) / k);
  // return ceil((long double)x / k);
}

int flr(int x, int k) {
  if (k &lt; 0) x = -x, k = -k;
  if (x &gt;= 0) return x / k;
  else return -((-x + k - 1) / k);
  // return floor((long double)x / k);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; l;
  for (int i = 1; i &lt;= n; ++i) {
    int t, x, y;
    std::cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;
    if ((x + y - t) &amp; 1) return void(std::cout &lt;&lt; "NO\n");
    a[i] = {t % l, t / l, (y + x + t) / 2, (y - x + t) / 2};
  }
  a[++n] = {0, 0, 0, 0}, a[++n] = {l, -1, 0, 0};
  std::sort(a + 1, a + 1 + n);
  int L = 0, R = l;
  for (int i = 1; i &lt; n; ++i) {
    int k = std::get&lt;1&gt;(a[i]) - std::get&lt;1&gt;(a[i + 1]);
    int nl = std::get&lt;2&gt;(a[i]) - std::get&lt;2&gt;(a[i + 1]);
    int nr = nl + std::get&lt;0&gt;(a[i + 1]) - std::get&lt;0&gt;(a[i]);
    assert(nl &lt;= nr);
    if (!k &amp;&amp; (nl &gt; 0 || nr &lt; 0)) return void(std::cout &lt;&lt; "NO\n");
    if (k &gt; 0)
      L = std::max(L, cei(nl, k)), R = std::min(R, flr(nr, k));
    else if (k &lt; 0)
      L = std::max(L, cei(nr, k)), R = std::min(R, flr(nl, k));
  }
  if (L &gt; R) return void(std::cout &lt;&lt; "NO\n");
  for (int i = 1; i &lt; n; ++i) {
    int det = (std::get&lt;2&gt;(a[i + 1]) - L * std::get&lt;1&gt;(a[i + 1])) -
              (std::get&lt;2&gt;(a[i]) - L * std::get&lt;1&gt;(a[i]));
    assert(det &gt;= 0);
    int nl = std::get&lt;0&gt;(a[i]) + 1, nr = std::get&lt;0&gt;(a[i]) + det;
    for (int j = nl; j &lt;= nr; ++j) ans[j][0] = 1;
  }
  L = 0, R = l;
  for (int i = 1; i &lt; n; ++i) {
    int k = std::get&lt;1&gt;(a[i]) - std::get&lt;1&gt;(a[i + 1]);
    int nl = std::get&lt;3&gt;(a[i]) - std::get&lt;3&gt;(a[i + 1]);
    int nr = nl + std::get&lt;0&gt;(a[i + 1]) - std::get&lt;0&gt;(a[i]);
    assert(nl &lt;= nr);
    if (!k &amp;&amp; (nl &gt; 0 || nr &lt; 0)) return void(std::cout &lt;&lt; "NO\n");
    if (k &gt; 0)
      L = std::max(L, cei(nl, k)), R = std::min(R, flr(nr, k));
    else if (k &lt; 0)
      L = std::max(L, cei(nr, k)), R = std::min(R, flr(nl, k));
  }
  if (L &gt; R) return void(std::cout &lt;&lt; "NO\n");
  for (int i = 1; i &lt; n; ++i) {
    int det = (std::get&lt;3&gt;(a[i + 1]) - L * std::get&lt;1&gt;(a[i + 1])) -
              (std::get&lt;3&gt;(a[i]) - L * std::get&lt;1&gt;(a[i]));
    assert(det &gt;= 0);
    int nl = std::get&lt;0&gt;(a[i]) + 1, nr = std::get&lt;0&gt;(a[i]) + det;
    for (int j = nl; j &lt;= nr; ++j) ans[j][1] = 1;
  }

  for (int i = 1; i &lt;= l; ++i) std::cout &lt;&lt; getch(ans[i][0], ans[i][1]);
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18333247.html</id>
    <title type="text">CF538H Summer Dichotomy 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-07-30T11:55:00Z</published>
    <updated>2024-07-30T11:55:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18333247.html" />
    <content type="text">## Description

有 $T$ 名学生，你要从中选出至少 $t$ 人，并将选出的人分成两组，可以有某一组是空的。

有 $n$ 名老师，每名老师要被分配到两个小组之一，对于第 $i$ 名老师，要求所在的小组中的学生人数 $\in [l_i, r_i]$。

此外，有 $m$ 对老师不能在同一个小组中。

你需要判断能否满足所有要求，如果可以，请给出一种方案。

$t \le T \le 10^9$，$n,m \le 10^5$。

## Solution

先不考虑人数为 $[t,T]$ 的限制，只考虑怎么取出 $n_1$ 和 $n_2$ 使答案尽可能合法。

注意到如果 $\max\{l_i\}\leq\min\{r_i\}$ 那么 $n_1$ 和 $n_2$ 取这个区间里的任意一个数均可行。

否则不妨让 $n_1=\min\{r_i\},n_2=\max\{l_i\}$，则一定有 $n_1&lt;n_2$，此时如果让 $n_1$ 增大则必然会使 $r$ 最大的那个区间两个组都选不上，而让 $n_1$ 减少则一定会让 $n_1$ 这边能放的区间变为原来的子集，一定不优。对于 $n_2$ 同理，所以此时的 $n_1,n_2$ 一定是最优解。

现在考虑上 $[t,T]$ 的限制，如果 $n_1+n_2\in [t,T]$ 则不需要调整。如果 $n_1+n_2&gt;T$，注意到 $n_2$ 不能减少，所以让 $n_1$ 减少，$n_2$ 不变最优。如果 $n_1+n_2&lt;t$ 则让 $n_1$ 不变，$n_2$ 增大最优。

确定了 $n_1,n_2$ 后只需要对于每个区间判断其能放到哪个组，如果只能放一个组则已经确定，否则不管它。

然后对于不能放在一个组的两个区间连一条边，跑二分图染色即可。

时间复杂度：$O(n+m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int L, R, n, m;
int l[kMaxN], r[kMaxN], col[kMaxN];
bool vis[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

bool dfs(int u) {
  vis[u] = 1;
  for (auto v : G[u]) {
    if (!col[v]) {
      col[v] = 3 - col[u];
      dfs(v);
    } else if (col[v] == col[u]) {
      return 0;
    }
  }
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; L &gt;&gt; R &gt;&gt; n &gt;&gt; m;
  int n1 = 1e9, n2 = 0;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; l[i] &gt;&gt; r[i];
    n1 = std::min(n1, r[i]), n2 = std::max(n2, l[i]);
  }
  if (n1 + n2 &gt; R) n1 = R - n2;
  if (n1 + n2 &lt; L) n2 = L - n1;
  if (n1 &lt; 0 || n2 &lt; 0) return void(std::cout &lt;&lt; "IMPOSSIBLE\n");
  for (int i = 1; i &lt;= n; ++i) {
    int o1 = (l[i] &lt;= n1 &amp;&amp; n1 &lt;= r[i]), o2 = (l[i] &lt;= n2 &amp;&amp; n2 &lt;= r[i]);
    if (!o1 &amp;&amp; !o2) return void(std::cout &lt;&lt; "IMPOSSIBLE\n");
    if (o1 &amp;&amp; !o2) col[i] = 1;
    else if (!o1 &amp;&amp; o2) col[i] = 2;
  }
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  for (int i = 1; i &lt;= n; ++i) {
    if (!vis[i] &amp;&amp; col[i] &amp;&amp; !dfs(i))
      return void(std::cout &lt;&lt; "IMPOSSIBLE\n");
  }
  for (int i = 1; i &lt;= n; ++i) {
    if (!vis[i] &amp;&amp; !col[i]) {
      col[i] = 1;
      if (!dfs(i)) return void(std::cout &lt;&lt; "IMPOSSIBLE\n");
    }
  }
  std::cout &lt;&lt; "POSSIBLE\n" &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; col[i];
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18337340.html</id>
    <title type="text">20240801 模拟赛 T1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-01T11:56:00Z</published>
    <updated>2024-08-01T11:56:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18337340.html" />
    <content type="text">## Description

Hitori的手上有一个字符串，同时有 $n$ 个长度为 $m$ 的字符串 $T_1,T_2,...,T_n$，以及一个长度为 $k$ 的正实数数列 $\{p_i\}$，保证这个数列的和为 $1$ 。每一个字符串都保证只由前 $k$ 个小写字符构成。Hitori有个爱捣蛋的朋友Kita酱，Kita酱会对字符串做如下的操作：

$\quad$1、如果存在一个 $j(1\leq j\leq n)$ 满足 $T_j$ 是 $S$ 的子串，则停止。

$\quad$2、在字符串的尾部以 $p_i(1\leq i \leq k)$ 的概率添加第 $i$ 个小写字母，然后回到步骤一检测。

这里定义一个函数 $f(S;T,p)$ 表示：字符串 $S$ 经过无限次操作停下来的期望长度。

Kita酱表示对于一个给定的 $S$，计算 $f(S;T,p)$ 太无聊了。

然而，Hitori表示对于一个给定的 $R$，计算 $R$ 的每一个前缀 $R[1...i](1\leq i \leq |R|)$ 的函数值 $f(R[1..i];T,p)$ 也很无聊，Hitori表示我甚至可以加入修改操作以及动态查询操作，具体的操作形式如下：

$\quad$· 修改操作：给定 $l$ 和 $c$，将字符串 $R$ 末尾的 $l$ 个字符换成 $c$。

$\quad$· 查询操作：给定 $l$，查询$f(R[1..i];T,p)$ 的值。

这里保证 $f(S;T,p)$ 可以被表示成一个正实数 $\frac{P}{Q}(gcd(P,Q)=1)$，同时保证对于任意的字符串 $S$ 在给定的 $T$ 和序列 $\{p_i\}$ 下，有 $Q\not\equiv 0 \enspace(mod(10^9+7))$，所以只需要计算出 $PQ^{-1}mod\enspace(10^9+7)$ 即可。

$n\leq 100,n\times m\leq 10^4,|R|\leq 10^4,Q\leq 10^5$。

[link](http://xsy.gdgzez.com.cn/JudgeOnline/problem.php?cid=2001&amp;pid=0)

## Solution

注意到这里停止的条件为存在一个 $T_j$ 为 $S$ 的子串，这显然可以转到 AC 自动机上，等价于 $S$ 对应的节点为叶子节点。

那么就可以设计 dp 了。

设 $f_i$ 表示 AC 自动机上 $i$ 号点走到停止的期望步数，可以得到转移：

$$
f_i=\sum_{j=0}^{k-1}{p_jf_{trie_{i,j}}}+1
$$

对于解方程、修改和查询均暴力可以做到 $O((nm)^3+Q|R|)$。

---

先考虑修改和查询的优化。

不妨设 $pos_i$ 表示 $R[1\ldots i]$ 对应节点，注意到两次修改 $(l_1,c_1)$ 和 $(l_2,c_2)$，如果 $(l_2,c_2)$ 后出现并且 $l_1\leq l_2$，则 $(l_1,c_1)$ 就没用了。所以可以维护一个 $l$ 递减单调栈表示可能造成贡献的修改，每次添加一个 $(l,c)$ 就把栈里所有长度 $\leq l$ 的修改去掉，顺便维护 $g_i$ 表示栈里第 $i$ 个修改的 $pos_{l_i}$ 的值，这部分可以通过倍增维护。

对于查询节点就找到栈里覆盖当前位置的修改，通过 $g$ 值+倍增即可快速求出。

这部分时间复杂度：$O(Q|R|k\log|R|)$。

---

再考虑解方程的优化。

注意到上面那个暴力解方程有很多是浪费的，同时 $n$ 很小，考虑转化为 $n\times n$ 的方程。

可以先把 trie 树做树链剖分，然后用所有链的链顶去表示其它所有点的答案。

这里自顶向下转移，不妨设 $i$ 在同一个链里的儿子为 $trie_{i,s}$，那么可以用 $f_i$ 表示 $f_{trie_{i,s}}$：

$$
f_{trie_{i,s}}=\frac{f_i-1-\sum_{j\neq s}{p_jf_{trie_{i,j}}}}{p_s}
$$

容易发现如果 $trie_{i,j}$ 为返祖边则 $f_{trie_{i,j}}$ 一定已经计算出来了，否则 $trie_{i,j}$ 一定是一个链的链顶，也已经计算出，所以 $f_{trie_{i,s}}$ 能够成功表示。

然后通过对 $n$ 个叶子的表示就可以解出 $n$ 个链顶的答案，然后通过这 $n$ 个链顶即可求出所有节点的答案。

这部分时间复杂度：$O(n^2mk+n^3)$。

总的时间复杂度：$O(n^2mk+n^3+Q|R|k\log|R|)$。

## Code

```cpp

```#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 105, kMaxT = 1e4 + 5, kMod = 1e9 + 7;

int n, m, k, q, t, trie_tot;
int p[30], trie[kMaxT][26], fail[kMaxT], dep[kMaxT];
int a[kMaxN][kMaxN], f[kMaxT], g[kMaxN], nxt[kMaxT][26][15], pp[kMaxT], pos[kMaxT];
int top[kMaxT], bel[kMaxT], son[kMaxT], val[kMaxT][kMaxN];
bool vis[kMaxT];
std::string str, s[kMaxN];
std::vector&lt;int&gt; T[kMaxT];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void ins(std::string s) {
  int cur = 0;
  for (auto c : s) {
    int k = c - 'a';
    if (!trie[cur][k]) dep[trie[cur][k] = ++trie_tot] = dep[cur] + 1;
    cur = trie[cur][k];
  }
  vis[cur] = 1;
}

void dfs(int u) {
  for (auto v : T[u]) {
    vis[v] |= vis[u];
    dfs(v);
  }
}

void build() {
  std::queue&lt;int&gt; q;
  for (int i = 0; i &lt; k; ++i) {
    if (trie[0][i]) q.emplace(trie[0][i]);
  }
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = 0; i &lt; k; ++i) {
      if (trie[u][i]) {
        fail[trie[u][i]] = trie[fail[u]][i];
        q.emplace(trie[u][i]);
      } else {
        trie[u][i] = trie[fail[u]][i];
      }
    }
  }
  for (int i = 1; i &lt;= trie_tot; ++i) T[fail[i]].emplace_back(i);
  dfs(0);
}

int getnxt(int x, int c, int s) {
  for (int i = 0; i &lt;= 14; ++i)
    if (s &gt;&gt; i &amp; 1)
      x = nxt[x][c][i];
  return x;
}

void _dfs(int u) {
  static int cnt = 0;
  if (!bel[u]) bel[u] = ++cnt, top[cnt] = u;
  bool fl = 0;
  for (int i = 0; i &lt; k; ++i) {
    int v = trie[u][i];
    if (dep[v] &lt;= dep[u]) continue;
    if (!fl) bel[v] = bel[u], son[u] = i, fl = 1;
    _dfs(v);
  }
}

void getmat() {
  std::queue&lt;int&gt; q;
  q.emplace(0);
  for (int i = 1; i &lt;= n; ++i) val[top[i]][i] = 1;
  int now = 0;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = 0; i &lt; k; ++i) {
      int v = trie[u][i];
      if (dep[v] &lt;= dep[u]) continue;
      assert(dep[v] == dep[u] + 1);
      q.emplace(v);
    }
    if (dep[u] == m) {
      ++now;
      for (int i = 1; i &lt;= n; ++i) a[now][i] = val[u][i];
      a[now][n + 1] = sub(0, val[u][0]);
      continue;
    }
    int s = son[u], v = trie[u][s], iv = qpow(p[s]);
    for (int i = 0; i &lt;= n; ++i) val[v][i] = val[u][i];
    dec(val[v][0], 1);
    for (int i = 0; i &lt; k; ++i) {
      if (i == s) continue;
      for (int j = 0; j &lt;= n; ++j) dec(val[v][j], 1ll * val[trie[u][i]][j] * p[i] % kMod);
    }
    for (int i = 0; i &lt;= n; ++i) val[v][i] = 1ll * val[v][i] * iv % kMod;
  }
}

void prework() {
  for (int i = 0; i &lt;= trie_tot; ++i) {
    for (int j = 0; j &lt; k; ++j) nxt[i][j][0] = trie[i][j];
  }
  for (int j = 0; j &lt; k; ++j) {
    for (int s = 1; s &lt;= 14; ++s)
      for (int i = 0; i &lt;= trie_tot; ++i) {
        nxt[i][j][s] = nxt[nxt[i][j][s - 1]][j][s - 1];
      }
  }
  _dfs(0), getmat();
  for (int i = 1; i &lt;= n; ++i) {
    if (!a[i][i]) {
      for (int j = i + 1; j &lt;= n; ++i) {
        if (a[j][i]) {
          std::swap(a[i], a[j]);
          break;
        }
      }
    }
    assert(a[i][i]);
    for (int j = i + 1; j &lt;= n; ++j) {
      int v = 1ll * a[j][i] * qpow(a[i][i]) % kMod;
      for (int k = i; k &lt;= n + 1; ++k)
        dec(a[j][k], 1ll * a[i][k] * v % kMod);
    }
  }
  for (int i = n; i; --i) {
    assert(a[i][i]);
    for (int j = i + 1; j &lt;= n; ++j)
      dec(a[i][n + 1], 1ll * g[j] * a[i][j] % kMod);
    g[i] = 1ll * a[i][n + 1] * qpow(a[i][i]) % kMod;
  }
  for (int i = 0; i &lt;= trie_tot; ++i) {
    f[i] = val[i][0];
    for (int j = 1; j &lt;= n; ++j)
      inc(f[i], 1ll * val[i][j] * g[j] % kMod);
  }
}

void upd(int x, int c) {
  for (; !vec.empty() &amp;&amp; vec.back().first &lt;= x; vec.pop_back()) {}
  if (!vec.empty()) {
    pos[vec.size()] = trie[getnxt(pos[vec.size() - 1], vec.back().second, vec.back().first - x - 1)][c];
  } else {
    pos[vec.size()] = trie[pp[t - x]][c];
  }
  vec.emplace_back(x, c);
}

int getpos(int x) {
  if (vec.empty()) return pp[x];
  int L = -1, R = vec.size(), res = -1;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (x &gt;= t - vec[mid].first + 1) L = res = mid;
    else R = mid;
  }
  if (res == -1) return pp[x];
  int lst = vec[res].first, c = vec[res].second;
  return getnxt(pos[res], c, x - (t - lst + 1));
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  int sump = 0;
  for (int i = 0; i &lt; k; ++i) {
    std::cin &gt;&gt; p[i];
    inc(sump, p[i]);
  }
  sump = qpow(sump);
  for (int i = 0; i &lt; k; ++i) p[i] = 1ll * p[i] * sump % kMod;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    ins(s[i]);
  }
  std::sort(s + 1, s + 1 + n);
  n = std::unique(s + 1, s + 1 + n) - (s + 1);
  build();
  std::cin &gt;&gt; str &gt;&gt; q;
  prework();
  int cur = 0;
  t = str.size(), str = " " + str;
  for (int i = 1; i &lt;= t; ++i) {
    cur = trie[cur][str[i] - 'a'];
    std::cout &lt;&lt; add(f[cur], i) &lt;&lt; '\n';
    pp[i] = cur;
  }
  for (int cs = 1; cs &lt;= q; ++cs) {
    int op, l;
    std::string c;
    std::cin &gt;&gt; op &gt;&gt; l;
    if (op == 1) {
      std::cin &gt;&gt; c;
      upd(l, c[0] - 'a');
    } else {
      int cur = 0;
      cur = getpos(l);
      std::cout &lt;&lt; add(f[cur], l) &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18337581.html</id>
    <title type="text">CF553E Kyoya and Train 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-01T13:17:00Z</published>
    <updated>2024-08-01T13:17:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18337581.html" />
    <content type="text">## Description

给定一张 $n$ 个点 $m$ 条边的无重边无自环的有向图，你要从 $1$ 号点到 $n$ 号点去。

如果你在 $t$ 时刻之后到达 $n$ 号点，你要交 $x$ 元的罚款。

每条边从 $a_i$ 到 $b_i$，走过它需要花费 $c_i$ 元，多次走过同一条边需要多次花费。

走过每条边所需的时间是随机的，对于 $k \in [1,t]$，$\frac{p_{i,k}}{10^5}$ 表示走过第 $i$ 条边需要时间 $k$ 的概率。因此如果多次走过同一条边，所需的时间也可能不同。

你希望花费尽可能少的钱（花费与罚款之和）到达 $n$ 号点，因此每到达一个点，你可能会更改原有的计划。

求在最优决策下，你期望花费的钱数。

$n \le 50$，$m \le 100$，$t \le 2 \times 10^4$，$x,c_i \le 10^6$，$\sum_{k=1}^t p_{i,k} = 10^5$，答案精度误差 $\le 10^{-6}$。

## Solution

考虑 dp。

设 $f_{i,j}$ 表示在 $j$ 时刻走到 $i$ 的期望花费，那么转移如下：

$$
f_{i,j}=
\begin{cases}
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &amp;(i=n, j\leq t)\\
x\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &amp;(i=n, j&gt; t)\\
x+\text{dist}(i,n)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &amp;(i\neq n, j\geq t)\\
\min_{a_k=i}{\left\{\sum_{len=1}^{t}{p_{k,len}f_{b_k,j+len}+c_k}\right\}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &amp;(i\neq n, j&lt;t)
\end{cases}
$$

直接暴力做是 $O(mt^2)$ 的，过不了。

注意到最后一个转移是差卷积的形式，可以用分治 fft 进行优化。具体的，设 $g_{i,k}=\sum_{len=1}^{t}{p_{k,len}f_{b_k,j+len}}$，那么分治到 $[k,k]$ 时就让 $f_{i,k}\leftarrow g_{i,k}+c_k$。

转移就考虑假设当前区间为 $[l,r]$，先递归处理 $[mid+1,r]$，然后处理时间 $[mid+1,r]$ 对 $[l,mid]$ 的 $g$ 值的贡献，最后递归 $[l,mid]$。

注意对于 $[t,2t-1]$ 这个区间由于不能内部进行转移所以不需要递归。

时间复杂度：$O(mt\log^2 t)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using f64 = double;

const int kMaxN = 105, kMaxM = 105, kMaxT = 4e4 + 5;

struct Complex {
  f64 a, b;

  Complex(f64 _a = 0, f64 _b = 0) : a(_a), b(_b) {}
  friend Complex operator +(const Complex &amp;c1, const Complex &amp;c2) { return {c1.a + c2.a, c1.b + c2.b}; }
  friend Complex operator -(const Complex &amp;c1, const Complex &amp;c2) { return {c1.a - c2.a, c1.b - c2.b}; }
  friend Complex operator *(const Complex &amp;c1, const Complex &amp;c2) { return {c1.a * c2.a - c1.b * c2.b, c1.a * c2.b + c2.a * c1.b}; }
};

using cp = Complex;

int n, m, t, x;
int u[kMaxM], v[kMaxM], w[kMaxM];
f64 dis[kMaxN][kMaxN], p[kMaxM][kMaxT * 2], f[kMaxN][kMaxT * 2], g[kMaxM][kMaxT * 2];

namespace FFT {
int n, m, c, len, rev[kMaxT * 50];
cp a[kMaxT * 50], b[kMaxT * 50], omg[kMaxT * 50], inv[kMaxT * 50];

int getlen(int n) {
  int ret = 1;
  for (c = 0; ret &lt;= n + 1; ret &lt;&lt;= 1, ++c) {}
  return ret;
}

void prework() {
  const double kPi = acos(-1.0);
  len = getlen(n + m + 5);
  cp og = {cos(2 * kPi / len), sin(2 * kPi / len)}, ig = {cos(2 * kPi / len), -sin(2 * kPi / len)};
  omg[0] = inv[0] = {1, 0};
  for (int i = 1; i &lt; len; ++i) {
    omg[i] = omg[i - 1] * og;
    inv[i] = inv[i - 1] * ig;
    for (int j = 0; j &lt; c; ++j)
      if (i &gt;&gt; j &amp; 1)
        rev[i] |= (1 &lt;&lt; (c - j - 1));
  }
}

void fft(cp *a, int n, cp *omg) {
  for (int i = 0; i &lt; n; ++i)
    if (i &lt; rev[i])
      std::swap(a[i], a[rev[i]]);
  for (int l = 2; l &lt;= n; l &lt;&lt;= 1) {
    int m = l / 2;
    for (int i = 0; i &lt; n; i += l) {
      for (int j = 0; j &lt; m; ++j) {
        auto tmp = a[i + j + m] * omg[n / l * j];
        a[i + j + m] = a[i + j] - tmp;
        a[i + j] = a[i + j] + tmp;
      }
    }
  }
}

void clear() {
  for (int i = 0; i &lt; len; ++i)
    a[i] = b[i] = omg[i] = inv[i] = {0, 0}, rev[i] = 0;
  n = m = c = len = 0;
}

void set(int _n, int _m) {
  n = _n, m = _m;
}

void mul() {
  prework();
  fft(a, len, omg), fft(b, len, omg);
  for (int i = 0; i &lt; len; ++i) a[i] = a[i] * b[i];
  fft(a, len, inv);
  for (int i = 0; i &lt; len; ++i) a[i].a /= len;
}
} // namespace FFT

void solve(int l, int r) {
  if (l == r) {
    for (int i = 1; i &lt; n; ++i) f[i][l] = 1e18;
    for (int i = 1; i &lt;= m; ++i)
      if (u[i] != n) f[u[i]][l] = std::min(f[u[i]][l], g[i][l] + w[i]);
    return;
  }
  int mid = (l + r) &gt;&gt; 1;
  if (r - l + 1 != 2 * t) solve(mid + 1, r);
  for (int i = 1; i &lt;= m; ++i) {
    if (u[i] == n) continue;
    FFT::set(r - l, r - mid);
    for (int j = 1; j &lt;= r - l; ++j) FFT::a[j] = {p[i][j], 0};
    for (int j = 1; j &lt;= r - mid; ++j) FFT::b[j] = {f[v[i]][r - j + 1], 0};
    FFT::mul();
    for (int j = r - mid + 1; j &lt;= r - l + 1; ++j) {
      g[i][r - j + 1] += FFT::a[j].a;
    }
    FFT::clear();
  }
  solve(l, mid);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; x;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= n; ++j)
      dis[i][j] = (i != j) * 1e18;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];
    dis[u[i]][v[i]] = w[i];
    for (int j = 1; j &lt;= t; ++j) {
      int x;
      std::cin &gt;&gt; x;
      p[i][j] = x / 1e5;
    }
  }
  for (int k = 1; k &lt;= n; ++k)
    for (int i = 1; i &lt;= n; ++i)
      for (int j = 1; j &lt;= n; ++j)
        dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);
  for (int i = 0; i &lt; 2 * t; ++i) f[n][i] = x * (i &gt; t);
  for (int i = 1; i &lt; n; ++i)
    for (int j = t; j &lt; 2 * t; ++j)
      f[i][j] = x + dis[i][n];
  solve(0, 2 * t - 1);
  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; f[1][0] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18338785.html</id>
    <title type="text">CF566C Logistical Questions 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-02T07:00:00Z</published>
    <updated>2024-08-02T07:00:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18338785.html" />
    <content type="text">## Description

一棵 $n$ 个节点的树，点有点权，边有边权。

两点间的距离定义为两点间边权和的 $\frac 32$ 次方。

求这棵树的带权重心。

$n \le 2 \times 10^5$。

## Solution

不妨设 $d(i,j)=dist(i,j)^{1.5}$，考虑找到一个最小的在树上的端点或边上的一个位置，使得这个位置到所有节点的距离之和最小。

注意到 $\left(x^{1.5}\right)'=1.5\sqrt{x}$，所以 $y=x^{1.5}$ 是一个下凸函数。如果存在一个位置使得距离和最小，那么从这个位置往外走，距离和一定会变大。

考虑怎么求出这个位置。

注意到求权值和只能暴力，所以可以先随便找一个点 $u$，暴力求出答案，然后判断走哪个儿子会让答案变小。

暴力走儿子肯定会超时，考虑每次只向儿子 $v$ 走一个极小距离 $k$，显然答案的减少量是 $\Delta(v)=k\sum_{i\in subtree(v)}{\frac{3}{2}\sqrt{dist(i,u)}}$，增加量即为其余儿子的  $\Delta$ 之和，这部分暴力求，然后找到 $\Delta$ 值最大的 $v$ 走即可。

但是这样做可能会被链的情况卡成 $O(n^2)$。由于这里只需要锁定位置，所以每次可以选点分治的分治重心作根判断往哪边走，走后 $size$ 的大小一定不超过原来的 $\frac 12$，这样就只要做 $\log n$ 次了。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using f64 = long double;

const int kMaxN = 2e5 + 5;

int n, rt, ansid;
int val[kMaxN], sz[kMaxN], mx[kMaxN];
f64 ansdis;
bool del[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

f64 pw(f64 x) { return x * sqrtl(x); }

void getsz(int u, int fa) {
  sz[u] = 1, mx[u] = 0;
  for (auto [v, w] : G[u]) {
    if (v == fa || del[v]) continue;
    getsz(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
  }
}

void getrt(int u, int fa, int tot) {
  mx[u] = std::max(mx[u], tot - sz[u]);
  if (mx[u] &lt; mx[rt]) rt = u;
  for (auto [v, w] : G[u]) {
    if (v == fa || del[v]) continue;
    getrt(v, u, tot);
  }
}

f64 dfs1(int u, int fa, int dis) {
  f64 ret = (f64)val[u] * pw(dis);
  for (auto [v, w] : G[u]) {
    if (v != fa) ret += dfs1(v, u, dis + w);
  }
  return ret;
}

f64 dfs2(int u, int fa, int dis) {
  f64 ret = (f64)val[u] * sqrtl((f64)dis);
  for (auto [v, w] : G[u]) {
    if (v != fa) ret += dfs2(v, u, dis + w);
  }
  return ret;
}

void solve(int u) {
  if (del[u]) return;
  mx[0] = 1e9, getsz(u, 0), getrt(u, 0, sz[u]);
  u = rt, del[u] = 1;
  f64 now = dfs1(u, 0, 0);
  if (!ansid || now &lt; ansdis) ansid = u, ansdis = now;

  int idx = u;
  f64 mx = 0, sum = 0;
  for (auto [v, w] : G[u]) {
    f64 t = dfs2(v, u, w);
    sum += t;
    if (t &gt; mx) mx = t, idx = v;
  }
  if (mx &gt; sum - mx) solve(idx);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; val[i];
  for (int i = 1; i &lt; n; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
  }
  solve(1);
  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; ansid &lt;&lt; ' ' &lt;&lt; ansdis &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18342002.html</id>
    <title type="text">CF566E Restoring Map 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-04T09:22:00Z</published>
    <updated>2024-08-04T09:22:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18342002.html" />
    <content type="text">## Description

有一棵 $n$ 个点的树，你不知道这棵树的边是怎么连的。

你得到了 $n$ 条关于每个点信息，每条信息记录了距离某一个点 $\le 2$ 的所有点。

但你不知道每条信息具体是哪个点的。

你需要构造一棵满足这些信息的树。

$n \le 10^3$。

## Solution

首先可以发现如果存在一条路径 $x-u-v-y$，那么 $x,y$ 的信息求个交一定是 $\left\{u,v\right\}$，可以证明所有的非叶子节点之间的连边一定可以通过这种方式构造出来。

然后就只要考虑叶子节点选哪个非叶子节点做父亲了。

---

注意到非叶子节点很少的时候会比较特殊，考虑单独处理，下面先考虑非叶子节点个数 $\geq 3$ 的情况。


不妨设 $T_x$ 表示距离 $x$ 不超过 $1$ 的非叶子节点构成的集合，由于非叶子节点个数 $\geq 3$，所以 $T_x$ 互不相同。

考虑对于一个叶子 $x$，设其父亲为 $y$，则距离 $x$ 不超过 $2$ 的点构成的集合一定是 $x$ 所在的集合中最小的那个，这个容易求出来。

这时候会发现如果把 $s_x$ 中所有的叶子节点去掉后，$s_x$ 就等于 $T_y$。由于 $T_y$ 互不相同，所以暴力枚举 $y$ 即可。

---

然后考虑特殊情况。

如果没有非叶子节点，说明 $n=2$，直接输出。如果只有 $1$ 个，说明原图是个菊花图，直接输出。

如果有 $2$ 个，那么一定只有两种不同的大小不为 $n$ 的集合，对于这两种集合一种连左边的非叶子即可，另一种连另一个非叶子节点即可。

注意到直接做是 $O(n^3)$，可以用 bitset 优化上面的求交和判相等，就可以除掉一个 $\omega$ 了。

时间复杂度：$O\left(\frac{n^3}{\omega}\right)$

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e3 + 5;

int n;
bool isleaf[kMaxN];
std::bitset&lt;kMaxN&gt; a[kMaxN], b[kMaxN], g[kMaxN], tmp;
std::vector&lt;int&gt; vec[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; ed;

void dickdreamer() {
  std::cin &gt;&gt; n;
  bool fl = 1;
  for (int i = 1; i &lt;= n; ++i) {
    int k, x;
    std::cin &gt;&gt; k;
    fl &amp;= (k == n);
    for (int j = 1; j &lt;= k; ++j) {
      std::cin &gt;&gt; x;
      a[i][x] = 1, vec[x].emplace_back(i);
    }
  }
  if (fl == 1) {
    for (int i = 2; i &lt;= n; ++i) std::cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\n';
    return;
  }
  std::fill_n(isleaf + 1, n, 1);
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = i + 1; j &lt;= n; ++j) {
      tmp = (a[i] &amp; a[j]);
      if (tmp.count() != 2) continue;
      int u = tmp._Find_first(), v = tmp._Find_next(u);
      g[u][v] = g[v][u] = 1, isleaf[u] = isleaf[v] = 0;
      ed.emplace_back(u, v);
    }
  }
  int cnt = 0;
  for (int i = 1; i &lt;= n; ++i) cnt += (!isleaf[i]);
  if (cnt == 2) {
    auto [u1, v1] = ed[0];
    int id1 = 0, id2 = 0;
    for (int i = 1; i &lt;= n; ++i) {
      if (a[i].count() == n) continue;
      if (!id1) {
        id1 = i;
        for (int j = 1; j &lt;= n; ++j)
          if (isleaf[j] &amp;&amp; a[i][j]) ed.emplace_back(j, u1);
      } else if (a[i] != a[id1]) {
        id2 = i;
        for (int j = 1; j &lt;= n; ++j)
          if (isleaf[j] &amp;&amp; a[i][j]) ed.emplace_back(j, v1);
      }
      if (id1 &amp;&amp; id2) break;
    }
  } else {
    std::vector&lt;int&gt; notleaf;
    for (int i = 1; i &lt;= n; ++i) {
      if (!isleaf[i]) {
        notleaf.emplace_back(i);
        g[i][i] = 1;
      }
    }
    for (int i = 1; i &lt;= n; ++i)
      for (int j = 1; j &lt;= n; ++j) b[i][j] = (a[i][j] &amp; (!isleaf[j]));
    for (int i = 1; i &lt;= n; ++i) {
      if (!isleaf[i]) continue;
      int id = 0;
      for (auto j : vec[i])
        if (!id || a[j].count() &lt; a[id].count()) id = j;
      for (auto j : notleaf)
        if (b[id] == g[j]) ed.emplace_back(i, j);
    }
  }
  std::sort(ed.begin(), ed.end()),
      ed.erase(std::unique(ed.begin(), ed.end()), ed.end());
  for (auto [u, v] : ed) std::cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18344424.html</id>
    <title type="text">CF568E Longest Increasing Subsequence 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-06T00:59:00Z</published>
    <updated>2024-08-06T00:59:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18344424.html" />
    <content type="text">## Description

给定一个长度为 $n$ 的有 $k$ 个空缺的序列。

你有 $m$ 个数可以用于填补空缺。

要求最大化最长上升子序列的长度。

$n, m \le 10^5$，$k \le 10^3$。

## Solution

容易发现只需要先构造出 LIS 上的位置的值，对于其余未填位置随便填，所以构造 LIS 时就不需要考虑出现重复的问题。

考虑先求出最长上升子序列长度。

有一个显然的做法是维护一个数据结构，对于已经填了的位置就正常转移，对于没填的位置暴力枚举填的数然后转移，可以做到 $O\left((n+m)k\right)$，但是常数会比较大。

有另一个求 LIS 的方法是维护 $f_i$ 表示当前长度为 $i$ 的上升子序列的最小末尾值，$g_i$ 表示这个末尾的位置。每次加入一个 $x$，就二分求出 $f_j&lt;x$ 的最大的 $j$，说明以 $x$ 结尾的 LIS 长度为 $j+1$。又由于 $f_{j+1}\geq x$，就用 $x$ 更新 $f_{j+1}$ 。对于没填的位置可以维护一个指针，从大往小枚举填的数同时更新指针即可。这样做常数就很小了。

然后考虑构造方案。

先在求 LIS 的过程中求出 $len_i$ 表示以 $i$ 结尾的 LIS 长度，$pre_i$ 表示以 $i$ 结尾的 LIS 中 $i$ 的前驱的位置。这时会发现对于 $a_i=-1$ 的位置这两个东西是维护不了的，构造方案时需要特殊处理。

为了方便构造方案，先在数组末尾加入 $+\infty$。然后找到 LIS 的末尾位置 $n+1$，每次往前跳，可以在跳的过程中更新 $-1$ 的位置的 $len$ 值。设当前在 $i$，如果 $a_i$ 初始不为 $-1$，有两种情况：

1. $a_{pre_i}$ 为 $-1$，就让 $a_{pre_i}$ 填 $&lt;a_i$ 的最大可填值。
2. $a_{pre_i}$ 不为 $-1$，就不用管。

然后就是 $a_i$ 初始为 $-1$（由于是从后往前构造的，所以 $a_i$ 此时已经填了数了），如果前面存在一个位置 $j$，使得 $a_j\neq -1,a_j&lt;a_i,len_j=len_i-1$，那么 $i$ 的前驱就为 $j$。否则一定是一个 $-1$ 的位置，这里贪心选取最靠近 $i$ 的那个 $-1$，同时填上 $&lt;a_i$ 的最大可填值。填完往前跳即可。

时间复杂度：$O\left((n+m)k\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, m;
int a[kMaxN], b[kMaxN], pre[kMaxN], len[kMaxN], f[kMaxN], g[kMaxN];
bool vis[kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  std::cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; b[i];
  std::sort(b + 1, b + 1 + m);
  a[n + 1] = 1e9 + 1;
  memset(f, 0x3f, sizeof(f)), memset(pre, -1, sizeof(pre));
  f[0] = g[0] = 0;
  for (int i = 1; i &lt;= n + 1; ++i) {
    if (~a[i]) {
      int j = std::lower_bound(f, f + 2 + n, a[i]) - f - 1;
      len[i] = j + 1, pre[i] = g[j], f[j + 1] = a[i], g[j + 1] = i;
    } else {
      for (int j = m, k = n + 1; j; --j) {
        for (; ~k &amp;&amp; f[k] &gt;= b[j]; --k) {}
        f[k + 1] = b[j], g[k + 1] = i;
      }
    }
  }
  for (int i = n + 1; len[i] &gt; 1;) {
    if (!~pre[i]) {
      for (int j = i - 1; j; --j) {
        if (~a[j] &amp;&amp; len[j] == len[i] - 1 &amp;&amp; a[j] &lt; a[i]) {
          pre[i] = j; break;
        }
      }
      if (!~pre[i]) {
        for (int j = i - 1; j; --j) {
          if (!~a[j]) {
            pre[i] = j; break;
          }
        }
      }
    }
    if (!~a[pre[i]]) {
      int j = std::lower_bound(b + 1, b + 1 + m, a[i]) - b - 1;
      a[pre[i]] = b[j], vis[j] = 1, len[pre[i]] = len[i] - 1;
    }
    i = pre[i];
  }
  for (int i = 1, j = 1; i &lt;= n; ++i) {
    if (!~a[i]) {
      for (; vis[j]; ++j) {}
      a[i] = b[j], vis[j] = 1;
    }
  }
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; a[i] &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18345272.html</id>
    <title type="text">CF571E Geometric Progressions 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-06T07:37:00Z</published>
    <updated>2024-08-06T07:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18345272.html" />
    <content type="text">##  Description

- 给定 $n$ 以及 $n$ 个正整数对 $a_i, b_i$。
- 第 $i$ 对 $a_i, b_i$ 确定了一个序列 $\{a_i, a_i b_i, a_i b_i^2, a_i b_i^3, \ldots \}$。
- 询问最小的在 $n$ 个序列中都有出现的数，或者判断不存在。
- $n \le 100$，$a_i, b_i \le {10}^9$，答案对 ${10}^9 + 7$ 取模。

## Solution

设答案为 $k$，注意到答案很大，考虑分解质因数，设 $cnt_p(x)$ 表示 $x$ 的质因数分解有多少个 $p$，每次合并两个集合。

合并时有 $3$ 种情况：空集、只有一个数的集合、有无穷个数的集合。

考虑如何合并。设最终的数可以表示为 $a_ib_i^{k_i}$，那么一定满足 $cnt_p(a_i)+k_icnt_p(b_i)=cnt_p(a_j)+k_jcnt_p(b_j)$。对于所有 $p$，如果 $cnt_p(b_i)$ 和 $cnt_p(b_j)$ 都为 $0$，就只用判断 $cnt_p(a_i)$ 是否等于 $cnt_p(a_j)$。

如果 $cnt_p(b_i)$ 和 $cnt_p(b_j)$ 只有一个 $0$，那么就可以唯一确定 $k$ 了，求出来然后判断即可。

如果都不是 $0$，那么一定为关于 $k_i$ 和 $k_j$ 的不定方程，如果有 $\geq 2$ 种不同的方程就能唯一确定 $k$。否则就可以通过 exgcd 把 $(a_i,b_i)$ 和 $(a_j,b_j)$ 合并，设 $x$ 为 $k_i$ 的最小正整数解，结果就为 $\left(a_ib_i^x,\prod p^{\text{lcm}{\left\{cnt_p(b_i),cnt_p(b_j)\right\}}}\right)$。

这里由于 $cnt_p(b_i)\leq 30$，所以所有 $cnt$ 的 lcm 不会爆 `long long`，对于乘法用 `int128` 即可。

时间复杂度：还不会算。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using i128 = __int128_t;
using pii = std::pair&lt;int, int&gt;;

const int kMaxN = 105, kMod = 1e9 + 7;

int n;
int a[kMaxN], b[kMaxN];
std::vector&lt;int&gt; pri, va[kMaxN], vb[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

bool isprime(int x) {
  for (int i = 2; i * i &lt;= x; ++i)
    if (x % i == 0)
      return 0;
  return 1;
}

i128 exgcd(i128 a, i128 b, i128 &amp;x, i128 &amp;y) {
  if (!b) { x = 1, y = 0; return a; }
  i128 d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}

pii merge(std::pair&lt;i128, i128&gt; a, std::pair&lt;i128, i128&gt; b) {
  if (!~a.second || !~b.second) return {0, -1};
  if (a == b) return a;
  if (!~a.first) return b;
  if (!~b.first) return a;
  if (a.second &gt; b.second) std::swap(a, b);
  if (!a.second &amp;&amp; !b.second) {
    if (a.first == b.first) return {0, -1};
    else return a;
  } else if (!a.second) {
    if (a.first &gt;= b.first &amp;&amp; (a.first - b.first) % b.second == 0) return a;
    else return {0, -1};
  }
  i128 x, y;
  // a.second * x + a.first = b.second * y + b.first
  // a.second * x - b.second * y = b.first - a.first
  i128 d = exgcd(a.second, b.second, x, y);
  if ((a.first - b.first) % d != 0) return {0, -1};
  y = -y;
  // a.second * x - b.second * y = d
  x *= (b.first - a.first) / d, y *= (b.first - a.first) / d;
  // a.second * x - b.second * y = b.first - a.first
  a.second /= d, b.second /= d;
  int tmp = (b.first - a.first) / d;
  // a.second * x - b.second * y = tmp
  assert(a.second * x - b.second * y == tmp);
  assert((a.second * x * d + a.first - b.first) % (b.second * d) == 0);
  x = (x % b.second + b.second) % b.second;
  if (a.second * x - tmp &lt; 0) {
    int to = (tmp + a.second - 1) / a.second;
    assert(x &lt; to);
    int det = (to - x + b.second - 1) / b.second;
    x += det * b.second;
  }
  int val = a.second * x * d + a.first, lcm = a.second * b.second * d;
  // std::cerr &lt;&lt; "heige " &lt;&lt; a.first &lt;&lt; ' ' &lt;&lt; a.second * d &lt;&lt; ' ' &lt;&lt; b.first &lt;&lt; ' ' &lt;&lt; b.second * d &lt;&lt; ' ' &lt;&lt; val &lt;&lt; ' ' &lt;&lt; lcm &lt;&lt; '\n';
  assert((val - b.first) % (b.second * d) == 0);
  return {val, lcm};
}

std::vector&lt;int&gt; getp(int x) {
  std::vector&lt;int&gt; vec;
  for (int i = 2; i * i &lt;= x; ++i) {
    if (x % i == 0) {
      vec.emplace_back(i);
      for (; x % i == 0; x /= i) {}
    }
  }
  if (x &gt; 1) vec.emplace_back(x);
  return vec;
}

int getcnt(int a, int p) {
  int cnt = 0;
  for (; a % p == 0; a /= p) ++cnt;
  return cnt;
}

int getval(std::vector&lt;int&gt; v) {
  int ret = 1;
  for (int i = 0; i &lt; (int)v.size(); ++i)
    ret = 1ll * ret * qpow(pri[i], v[i]) % kMod;
  return ret;
}

bool check(std::vector&lt;int&gt; v) {
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt; (int)pri.size(); ++j) {
      if (v[j] &lt; va[i][j]) return 0;
      if (!vb[i][j] &amp;&amp; v[j] != va[i][j] || vb[i][j] &amp;&amp; (v[j] - va[i][j]) % vb[i][j] != 0) return 0;
    }
  }
  return 1;
}

bool equal(std::tuple&lt;int, int, int&gt; a, std::tuple&lt;int, int, int&gt; b) {
  return ((i128)std::get&lt;0&gt;(a) * std::get&lt;1&gt;(b) == (i128)std::get&lt;1&gt;(a) * std::get&lt;0&gt;(b))
      &amp;&amp; ((i128)std::get&lt;1&gt;(a) * std::get&lt;2&gt;(b) == (i128)std::get&lt;2&gt;(a) * std::get&lt;1&gt;(b));
}

std::pair&lt;int, int&gt; calc(std::tuple&lt;i128, i128, i128&gt; a, std::tuple&lt;i128, i128, i128&gt; b) {
  auto [a1, a2, a3] = a;
  auto [b1, b2, b3] = b;
  i128 kk = a2 * b1 - a1 * b2, vv = a3 * b1 - b3 * a1;
  if (!kk) return {-1, -1};
  if (kk &amp;&amp; (vv / kk) * kk != vv) return {-1, -1};
  i128 y = vv / kk;
  if (y &lt; 0) return {-1, -1};
  kk = a1, vv = a3 - a2 * y;
  if (!kk) kk = b1, vv = b3 - b2 * y;
  if (!kk &amp;&amp; vv || kk &amp;&amp; (vv / kk) * kk != vv) return {-1, -1};
  i128 x = vv / kk;
  assert(a1 * x + a2 * y == a3 &amp;&amp; b1 * x + b2 * y == b3);
  if (x &lt; 0 || y &lt; 0) return {-1, -1};
  else return {x, y};
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i] &gt;&gt; b[i];
    auto tmp1 = getp(a[i]), tmp2 = getp(b[i]);
    for (auto x : tmp1) pri.emplace_back(x);
    for (auto x : tmp2) pri.emplace_back(x);
  }
  std::sort(pri.begin(), pri.end()), pri.erase(std::unique(pri.begin(), pri.end()), pri.end());
  for (int i = 1; i &lt;= n; ++i) {
    va[i].resize(pri.size()), vb[i].resize(pri.size());
    for (int j = 0; j &lt; (int)pri.size(); ++j) {
      va[i][j] = getcnt(a[i], pri[j]);
      vb[i][j] = getcnt(b[i], pri[j]);
    }
  }
  for (int i = 1; i &lt; n; ++i) {
    bool fl = 0;
    std::tuple&lt;int, int, int&gt; now = {-1, -1, -1};
    for (int j = 0; j &lt; (int)pri.size(); ++j) {
      int x = vb[i][j], y = -vb[i + 1][j], z = va[i + 1][j] - va[i][j];
      if (!x &amp;&amp; !y) {
        if (z) return void(std::cout &lt;&lt; "-1\n");
      } else if (!x) {
        int tmp = z / y;
        if (tmp * y != z || tmp &lt; 0) return void(std::cout &lt;&lt; "-1\n");
        std::vector&lt;int&gt; vec(pri.size());
        for (int k = 0; k &lt; (int)pri.size(); ++k)
          vec[k] = va[i + 1][k] + vb[i + 1][k] * tmp;
        if (check(vec)) return void(std::cout &lt;&lt; getval(vec) &lt;&lt; '\n');
      } else if (!y) {
        int tmp = z / x;
        if (tmp * x != z || tmp &lt; 0) return void(std::cout &lt;&lt; "-1\n");
        std::vector&lt;int&gt; vec(pri.size());
        for (int k = 0; k &lt; (int)pri.size(); ++k)
          vec[k] = va[i][k] + vb[i][k] * tmp;
        if (check(vec)) return void(std::cout &lt;&lt; getval(vec) &lt;&lt; '\n');
      }
      if (!fl) fl = 1, now = {x, y, z};
      else {
        if (!equal(now, {x, y, z})) {
          auto p = calc(now, {x, y, z});
          if (!~p.first &amp;&amp; !~p.second) return void(std::cout &lt;&lt; "-1\n");
          else {
            std::vector&lt;int&gt; vec(pri.size());
            for (int k = 0; k &lt; (int)pri.size(); ++k) {
              vec[k] = va[i][k] + vb[i][k] * p.first;
            }
            if (check(vec)) return void(std::cout &lt;&lt; getval(vec) &lt;&lt; '\n');
            else return void(std::cout &lt;&lt; "-1\n");
          }
        }
      }
    }
    for (int j = 0; j &lt; (int)pri.size(); ++j) {
      auto p = merge({va[i][j], vb[i][j]}, {va[i + 1][j], vb[i + 1][j]});
      if (!~p.second) return void(std::cout &lt;&lt; "-1\n");
      va[i + 1][j] = p.first, vb[i + 1][j] = p.second;
    }
  }
  std::cout &lt;&lt; getval(va[n]) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18346015.html</id>
    <title type="text">CF573E Bear and Bowling 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-06T13:24:00Z</published>
    <updated>2024-08-06T13:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18346015.html" />
    <content type="text">## Description

- 给定一个长度为 $n$ 的序列 $a_{1\dots n}$。
- 你要求一个 $a$ 的子序列 $b_{1\dots m}$（可以为空），使得 $\sum_{i=1}^m ib_i$ 的值最大。
- $n \le 10^5$，$|a_i| \le 10^7$。

## Solution

有一个显然的 dp 是设 $f_{i,j}$ 表示前 $i$ 个数，选 $j$ 个数的最大值，转移即为：$f_{i,j}=\max\left\{f_{i-1,j},f_{i-1,j-1}+j\cdot a_i\right\}$，由于这题时限很大并且 $n$ 很小，所以这个能过。。。

考虑优化。

有一个结论是对于每个 $i$，都存在一个分界点 $k_i$，使得对于 $\forall j&lt;k_i$，$f_{i,j}=f_{i-1,j}$，对于 $j\geq k_i$，$f_{i,j}=f_{i-1,j-1}+j\cdot a_i$。

证明就考虑设 $g_{i,j}=f_{i,j}-f_{i,j-1}$，那么 $f_{i,j}=f_{i-1,j}$ 的充分必要条件为 $f_{i-1,j}\geq f_{i-1,j-1}+j\cdot a_i$，即 $\frac{g_{i-1,j}}{j}\geq a_i$。

通过观察可以发现 $\frac{g_{i,j}}{j}$ 对于 $j$ 单调不增，那么不妨假设 $\frac{g_{i-1,j}}{j}$ 单调不增，考虑归纳证明 $g_i$ 也满足条件。

设 $k$ 为满足 $\frac{g_{i-1,j}}{j}&lt;a_i$ 的最小的 $j$，则对于 $j\in [0,k-1]$，$g_{i,j}=g_{i-1,j}$。同时 $g_{i,k}$ 变为 $k\cdot a_i$，所以 $\frac{g_{i,k}}{k}=a_i\leq \frac{g_{i,k-1}}{k-1}$。

对于 $j&gt;k$，$g_{i,j}=g_{i-1,j-1}+a_i$，所以对于 $j&gt;k$ 满足 $\frac{g_{i,j}}{j}\geq \frac{g_{i,j+1}}{j+1}$ 的条件为：

$$
\begin{aligned}
\frac{g_{i-1,j-1}+a_i}{j}&amp;\geq\frac{g_{i-1,j}+a_i}{j+1}\\
g_{i-1,j-1}&amp;\geq\frac{j}{j+1}\cdot g_{i-1,j}-\frac{1}{j+1}\cdot a_i\\
g_{i-1,j-1}-\left(\frac{j}{j+1}\cdot g_{i-1,j}-\frac{1}{j+1}\cdot a_i\right)&amp;\geq 0\\
\end{aligned}
$$

又因为：

$$
\begin{aligned}
LHS\geq&amp;\frac{j-1}{j}\cdot g_{i-1,j}-\frac{j}{j+1}\cdot g_{i-1,j}+\frac{1}{j+1}\cdot a_i\\
=&amp;\frac{j\cdot a_i-g_{i-1,j}}{j(j+1)}\\
\geq&amp; 0
\end{aligned}
$$

所以结论得证。

然后就可以从前往后枚举 $a_i$，维护 $g$ 数组，每次相当于是在某个位置插入和将某个后缀区间加某个数，并且需要快速找到分界点，可以用平衡树维护。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n;
int64_t a[kMaxN];

struct FHQTreap {
  int tot = 0, rt, ch[kMaxN][2], rd[kMaxN], sz[kMaxN];
  int64_t val[kMaxN], rnk[kMaxN], tag1[kMaxN], tag2[kMaxN];
  std::mt19937 rnd;

  int newnode(int64_t x, int64_t y) {
    val[++tot] = x, rnk[tot] = y;
    ch[tot][0] = ch[tot][1] = tag1[tot] = tag2[tot] = 0, rd[tot] = rnd();
    sz[tot] = 1;
    return tot;
  }

  FHQTreap() {
    tot = 0, rnd.seed(std::random_device{}());
    rt = newnode(-1e18, 1);
  }

  void pushup(int x) {
    sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1;
  }

  void addtag(int x, int64_t v1, int64_t v2) {
    val[x] += v1, rnk[x] += v2, tag1[x] += v1, tag2[x] += v2;
  }

  void pushdown(int x) {
    if (ch[x][0]) addtag(ch[x][0], tag1[x], tag2[x]);
    if (ch[x][1]) addtag(ch[x][1], tag1[x], tag2[x]);
    tag1[x] = tag2[x] = 0;
  }

  int merge(int x, int y) {
    if (!x || !y) return x + y;
    pushdown(x), pushdown(y);
    if (rd[x] &lt; rd[y]) {
      ch[x][1] = merge(ch[x][1], y), pushup(x);
      return x;
    } else {
      ch[y][0] = merge(x, ch[y][0]), pushup(y);
      return y;
    }
  }

  void split(int x, int v, int &amp;a, int &amp;b) { // a : &gt;= v, b : &lt; v
    if (!x) return void(a = b = 0);
    pushdown(x);
    if (val[x] &gt;= rnk[x] * v) {
      a = x, split(ch[x][1], v, ch[a][1], b);
    } else {
      b = x, split(ch[x][0], v, a, ch[b][0]);
    }
    pushup(x);
  }

  void ins(int64_t x) {
    int a, b;
    split(rt, x, a, b);
    if (b) addtag(b, x, 1);
    rt = merge(merge(a, newnode(x * (sz[a] + 1), sz[a] + 1)), b);
  }

  int64_t getval(int x) {
    if (!x) return 0;
    pushdown(x);
    int64_t ret = std::max&lt;int64_t&gt;(val[x], 0);
    return ret + getval(ch[x][0]) + getval(ch[x][1]);
  }
} t;

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    t.ins(a[i]);
  }
  std::cout &lt;&lt; t.getval(t.rt) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18352852.html</id>
    <title type="text">UOJ #712. 【北大集训2021】简单数据结构-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-10T14:04:00Z</published>
    <updated>2024-08-10T14:04:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18352852.html" />
    <content type="text">## Description

你有一个长度为 $n$ 的序列 $a$，下面你要进行 $q$ 次修改或询问。

1. 给定 $v$，将所有 $a_i$ 变为 $\min(a_i, v)$。
2. 将所有 $a_i$ 变为 $a_i + i$。
3. 给定 $l, r$，询问 $\sum_{i=l}^r a_i$。

$1\leq n,q\leq 2\times 10^5,0\leq a_i,v_i\leq 10^{12}$。

## Solution

首先如果没有 chkmin 操作是好做的。同时如果 $a_i$ 初始值为 $0$ 那么从始至终序列 $a$ 都是单调不降的，对于 chkmin 操作只要二分+区间赋值，也很好做。

考虑 $a_i$ 初值不为 $0$ 的情况。

注意到如果某个时刻 $x&lt;y$ 且 $a_x\leq a_y$，那么之后的所有时刻都满足 $a_x\leq a_y$，这是显然的。

然后就可以发现对于所有 chkmin 过的位置，它们的 $a$ 值一定单调不降。于是只要维护当前 chkmin 过的位置，对于这些二分+区间赋值。没有 chkmin 的位置直接线段树维护即可。

考虑怎么求出每个 $a_i$ 第一次被 chkmin 的时间。设 $v_i$ 表示第 $i$ 次操作 chkmin 的值，$c_i$ 表示前 $i$ 次操作做了多少次二操作。

容易发现对于每个 $i$，可以二分答案 $p$，那么对于 $[1,p]$ 里的所有操作，如果存在 $a_i+i\cdot c_j\geq v_j$ 就说明 $p$ 可行。移项一下可以得到 $a_i\geq v_j-i\cdot c_j$，右边是个关于 $i$ 的一次函数，所以可以对于前 $p$ 个操作按照 $(c_j,v_j)$ 维护下凸壳，然后用 $k=i$ 的直线去截这个凸壳即可快速得到答案。

但是这么做是 $O\left(nq\log^2 n\right)$ 的，可以用整体二分优化到 $O\left(q\log^2 n\right)$。

时间复杂度：$O\left((n+q)\log^2 n\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using pii = std::pair&lt;int, int&gt;;

const int kMaxN = 2e5 + 5;

int n, q;
int a[kMaxN], op[kMaxN], l[kMaxN], r[kMaxN], v[kMaxN];
std::vector&lt;int&gt; vv[kMaxN];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; chkm;

pii add(pii a, pii b) { return {a.first + b.first, a.second + b.second}; }
pii sub(pii a, pii b) { return {a.first - b.first, a.second - b.second}; }
int64_t mul(pii a, pii b) {
  return 1ll * a.first * b.second - 1ll * a.second * b.first;
}

int64_t func(int k, pii a) { return -1ll * k * a.first + a.second; }

void solve(std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec, std::vector&lt;int&gt; id) {
  if (!vec.size()) return;
  if (vec.size() == 1) {
    auto [j, c, v] = vec[0];
    for (auto i : id) {
      if (a[i] &gt;= v - i * c) {
        vv[j].emplace_back(i);
      }
    }
    return;
  }
  std::vector&lt;pii&gt; pt, stk;
  std::vector&lt;int&gt; Lv, Rv;
  std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; lvec, rvec;
  for (int i = 0; i &lt; vec.size() / 2; ++i) {
    lvec.emplace_back(vec[i]);
    pt.emplace_back(std::get&lt;1&gt;(vec[i]), std::get&lt;2&gt;(vec[i]));
  }
  for (int i = vec.size() / 2; i &lt; vec.size(); ++i) rvec.emplace_back(vec[i]);
  std::sort(pt.begin(), pt.end());
  for (auto p : pt) {
    for (; stk.size() &gt;= 2 &amp;&amp;
           mul(sub(p, stk.back()), sub(stk.back(), stk[stk.size() - 2])) &gt;= 0;
         stk.pop_back()) {
    }
    stk.emplace_back(p);
  }
  for (auto i : id) {
    int L = 0, R = stk.size(), res = 0;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (func(i, stk[mid]) &lt;= func(i, stk[mid - 1]))
        L = res = mid;
      else
        R = mid;
    }
    if (func(i, stk[res]) &lt;= a[i])
      Lv.emplace_back(i);
    else
      Rv.emplace_back(i);
  }
  solve(lvec, Lv), solve(rvec, Rv);
}

void prework() {
  std::vector&lt;int&gt; id(n);
  std::iota(id.begin(), id.end(), 1);
  solve(chkm, id);
}

struct SGT {
  int cnt[kMaxN * 4];
  int64_t mx[kMaxN * 4], mxid[kMaxN * 4], sum[kMaxN * 4], sumid[kMaxN * 4],
      tag[kMaxN * 4], tagcov[kMaxN * 4];

  void pushup(int x) {
    sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1];
    sumid[x] = sumid[x &lt;&lt; 1] + sumid[x &lt;&lt; 1 | 1];
    mx[x] = std::max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
    mxid[x] = std::max(mxid[x &lt;&lt; 1], mxid[x &lt;&lt; 1 | 1]);
    cnt[x] = cnt[x &lt;&lt; 1] + cnt[x &lt;&lt; 1 | 1];
  }

  void addtag1(int x, int64_t v) {
    if (!cnt[x]) return;
    sum[x] += sumid[x] * v, tag[x] += v;
    mx[x] += mxid[x] * v;
  }

  void addtag2(int x, int64_t v) {
    if (!cnt[x]) return;
    sum[x] = cnt[x] * v, mx[x] = tagcov[x] = v;
    tag[x] = 0;
  }

  void pushdown(int x) {
    if (~tagcov[x]) {
      addtag2(x &lt;&lt; 1, tagcov[x]), addtag2(x &lt;&lt; 1 | 1, tagcov[x]);
      tagcov[x] = -1;
    }
    if (tag[x]) {
      addtag1(x &lt;&lt; 1, tag[x]), addtag1(x &lt;&lt; 1 | 1, tag[x]);
      tag[x] = 0;
    }
  }

  void build(int x, int l, int r, bool op = 1) {
    tagcov[x] = -1;
    if (l == r) {
      if (op) {
        cnt[x] = 1, sumid[x] = mxid[x] = l;
        sum[x] = a[l];
      } else {
        mxid[x] = mx[x] = -1;
      }
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid, op), build(x &lt;&lt; 1 | 1, mid + 1, r, op);
    pushup(x);
  }

  void update1(int x, int l, int r, int ql, int v, bool op = 1) {
    if (l == r) {
      if (op) {
        tag[x] = 0, tagcov[x] = -1, cnt[x] = 1, sumid[x] = mxid[x] = l;
        addtag2(x, v);
      } else {
        cnt[x] = sum[x] = sumid[x] = mxid[x] = tag[x] = 0;
        tagcov[x] = mx[x] = -1;
      }
      return;
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid)
      update1(x &lt;&lt; 1, l, mid, ql, v, op);
    else
      update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, v, op);
    pushup(x);
  }

  void update2(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql)
      return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr)
      return addtag2(x, v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update2(x &lt;&lt; 1, l, mid, ql, qr, v),
        update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int getpos(int x, int l, int r, int v) {
    if (mx[x] &lt; v) return 0;
    if (l == r) return l;
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    if (mx[x &lt;&lt; 1] &gt;= v)
      return getpos(x &lt;&lt; 1, l, mid, v);
    else
      return getpos(x &lt;&lt; 1 | 1, mid + 1, r, v);
  }

  int64_t query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql)
      return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr)
      return sum[x];
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return query(x &lt;&lt; 1, l, mid, ql, qr) +
           query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }

  void print(int x, int l, int r) {
    if (l == r) return void(std::cerr &lt;&lt; sum[x] &lt;&lt; ' ');
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    print(x &lt;&lt; 1, l, mid), print(x &lt;&lt; 1 | 1, mid + 1, r);
  }
  void print() {
    print(1, 1, n);
    std::cerr &lt;&lt; '\n';
  }
} sgt[2];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  int nowcnt = 0;
  for (int i = 1; i &lt;= q; ++i) {
    std::cin &gt;&gt; op[i];
    if (op[i] == 1) {
      std::cin &gt;&gt; v[i];
      chkm.emplace_back(i, nowcnt, v[i]);
    } else if (op[i] == 2) {
      ++nowcnt;
    } else {
      std::cin &gt;&gt; l[i] &gt;&gt; r[i];
    }
  }
  prework();
  sgt[0].build(1, 1, n, 0), sgt[1].build(1, 1, n, 1);
  for (int i = 1; i &lt;= q; ++i) {
    if (op[i] == 1) {
      for (auto x : vv[i]) {
        sgt[0].update1(1, 1, n, x, v[i]);
        sgt[1].update1(1, 1, n, x, 0, 0);
      }
      int p = sgt[0].getpos(1, 1, n, v[i]);
      if (p) sgt[0].update2(1, 1, n, p, n, v[i]);
    } else if (op[i] == 2) {
      sgt[0].addtag1(1, 1), sgt[1].addtag1(1, 1);
    } else {
      std::cout &lt;&lt; sgt[0].query(1, 1, n, l[i], r[i]) +
                       sgt[1].query(1, 1, n, l[i], r[i])
                &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18355696.html</id>
    <title type="text">区间历史最值线段树记录-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-12T12:33:00Z</published>
    <updated>2024-08-12T12:33:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18355696.html" />
    <content type="text">## 区间+/chkmin/求最值/求历史最值

### Description

维护一个线段树，使得可以实现区间加、区间 chkmin、求区间和、区间历史最大值、区间历史最大值。

### Solution

先不考虑区间 chkmin 和历史最值，可以直接对于每个线段树节点维护一个 tag，每次 addtag 更新。

加上区间历史最值后，先考虑对于单个线段树节点怎么更新。

容易发现对于一个节点，在它下传标记之前一定就是很多次整体加某个数，并且儿子的 $sum$ 和 $max$ 数组是不会变的。

考虑维护 $tag2[x]$ 表示 $x$ 这个节点上次下传标记到当前时刻的最大前缀和，那么每次下传标记时先让 $maxb[son]\leftarrow maxa[son]+tag2[x]$ 再更新 $maxa[son]$ 就可以维护区间历史最值了。

加上区间 chkmin 就用吉司机线段树的技巧维护区间最大值、次大值，并且由于这里最大值和非最大值有些操作是分开的，所以需要对于最大、非最大值分别维护 tag。

时间复杂度：$O(n\log^2 n)$。

### Code

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m;
int a[kMaxN];

struct SGT {
  int maxa[kMaxN * 4], maxb[kMaxN * 4];
  int cnt[kMaxN * 4], se[kMaxN * 4];
  int tag1[kMaxN * 4], tag2[kMaxN * 4], tag3[kMaxN * 4], tag4[kMaxN * 4];
  int64_t sum[kMaxN * 4];

  void pushup(int x) {
    sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1];
    maxa[x] = std::max(maxa[x &lt;&lt; 1], maxa[x &lt;&lt; 1 | 1]);
    maxb[x] = std::max(maxb[x &lt;&lt; 1], maxb[x &lt;&lt; 1 | 1]);
  
    if (maxa[x &lt;&lt; 1] == maxa[x &lt;&lt; 1 | 1]) {
      se[x] = std::max(se[x &lt;&lt; 1], se[x &lt;&lt; 1 | 1]);
      cnt[x] = cnt[x &lt;&lt; 1] + cnt[x &lt;&lt; 1 | 1];
    } else if (maxa[x &lt;&lt; 1] &gt; maxa[x &lt;&lt; 1 | 1]) {
      se[x] = std::max(se[x &lt;&lt; 1], maxa[x &lt;&lt; 1 | 1]);
      cnt[x] = cnt[x &lt;&lt; 1];
    } else {
      se[x] = std::max(maxa[x &lt;&lt; 1], se[x &lt;&lt; 1 | 1]);
      cnt[x] = cnt[x &lt;&lt; 1 | 1];
    }
  }

  void addtag(int x, int l, int r, int v1, int v2, int v3, int v4) {
    maxb[x] = std::max(maxb[x], maxa[x] + v2);
    tag2[x] = std::max(tag2[x], tag1[x] + v2);
    tag4[x] = std::max(tag4[x], tag3[x] + v4);
    maxa[x] += v1, tag1[x] += v1, tag3[x] += v3;
    sum[x] += 1ll * cnt[x] * v1 + 1ll * (r - l + 1 - cnt[x]) * v3;
    if (se[x] != -1e18) se[x] += v3;
  }

  void pushdown(int x, int l, int r) {
    if (tag1[x] || tag2[x] || tag3[x] || tag4[x]) {
      int mx = std::max(maxa[x &lt;&lt; 1], maxa[x &lt;&lt; 1 | 1]);
      int mid = (l + r) &gt;&gt; 1;
      if (maxa[x &lt;&lt; 1] == mx) {
        addtag(x &lt;&lt; 1, l, mid, tag1[x], tag2[x], tag3[x], tag4[x]);
      } else {
        addtag(x &lt;&lt; 1, l, mid, tag3[x], tag4[x], tag3[x], tag4[x]);
      }
      if (maxa[x &lt;&lt; 1 | 1] == mx) {
        addtag(x &lt;&lt; 1 | 1, mid + 1, r, tag1[x], tag2[x], tag3[x], tag4[x]);
      } else {
        addtag(x &lt;&lt; 1 | 1, mid + 1, r, tag3[x], tag4[x], tag3[x], tag4[x]);
      }
      tag1[x] = tag2[x] = tag3[x] = tag4[x] = 0;
    }
  }

  void build(int x, int l, int r) {
    se[x] = -2e9;
    if (l == r) {
      sum[x] = maxa[x] = maxb[x] = a[l], cnt[x] = 1;
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update1(int x, int l, int r, int ql, int qr, int v) { // 区间 +
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, l, r, v, std::max&lt;int&gt;(v, 0), v, std::max&lt;int&gt;(v, 0));
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    update1(x &lt;&lt; 1, l, mid, ql, qr, v), update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  void update2(int x, int l, int r, int ql, int qr, int v) { // 区间 chkmin
    if (l &gt; qr || r &lt; ql || maxa[x] &lt;= v) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr &amp;&amp; se[x] &lt; v)
      return addtag(x, l, r, v - maxa[x], 0, 0, 0);
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    update2(x &lt;&lt; 1, l, mid, ql, qr, v), update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int64_t querysum(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return sum[x];
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return querysum(x &lt;&lt; 1, l, mid, ql, qr) + querysum(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }

  int querymaxa(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return -2e9;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return maxa[x];
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(querymaxa(x &lt;&lt; 1, l, mid, ql, qr), querymaxa(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }

  int querymaxb(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return -2e9;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return maxb[x];
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(querymaxb(x &lt;&lt; 1, l, mid, ql, qr), querymaxb(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  sgt.build(1, 1, n);
  for (int i = 1; i &lt;= m; ++i) {
    int op, l, r, v;
    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
    if (op == 1) {
      std::cin &gt;&gt; v;
      sgt.update1(1, 1, n, l, r, v);
    } else if (op == 2) {
      std::cin &gt;&gt; v;
      sgt.update2(1, 1, n, l, r, v);
    } else if (op == 3) {
      std::cout &lt;&lt; sgt.querysum(1, 1, n, l, r) &lt;&lt; '\n';
    } else if (op == 4) {
      std::cout &lt;&lt; sgt.querymaxa(1, 1, n, l, r) &lt;&lt; '\n';
    } else {
      std::cout &lt;&lt; sgt.querymaxb(1, 1, n, l, r) &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```

&lt;/details&gt;

## 区间+/赋值/求最值/求历史最值

### Description

维护一个线段树，使得可以实现区间加、区间赋值、求区间最值、区间历史最值。

### Solution

如果没有区间覆盖就像刚才一样维护两个 tag。但是如果加上区间覆盖后由于 tag 维护的是初始到终止的整体位移量，而只要一个节点被区间赋值后所有数就变得相等，那么这个位移量就没用了。

所以考虑对于每个节点，维护做区间赋值之前的两个 tag，然后维护做区间赋值后的当前赋的值和赋的值的最大值。

时间复杂度：$O(n\log n)$。

### Code

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, m;
int a[kMaxN];

struct SGT {
  int maxa[kMaxN * 4], maxb[kMaxN * 4];
  int tag1[kMaxN * 4], tag2[kMaxN * 4], tagcov1[kMaxN * 4], tagcov2[kMaxN * 4];

  void pushup(int x) {
    maxa[x] = std::max(maxa[x &lt;&lt; 1], maxa[x &lt;&lt; 1 | 1]);
    maxb[x] = std::max(maxb[x &lt;&lt; 1], maxb[x &lt;&lt; 1 | 1]);
  }

  void addtag1(int x, int v1, int v2) {
    maxb[x] = std::max(maxb[x], maxa[x] + v2);
    maxa[x] += v1;
    if (tagcov1[x] == -1e18) {
      tag2[x] = std::max(tag2[x], tag1[x] + v2), tag1[x] += v1;
    } else {
      tagcov2[x] = std::max(tagcov2[x], tagcov1[x] + v2), tagcov1[x] += v1;
    }
  }

  void addtag2(int x, int v1, int v2) {
    maxb[x] = std::max(maxb[x], v2);
    maxa[x] = v1;
    tagcov2[x] = std::max(tagcov2[x], v2);
    tagcov1[x] = v1;
  }

  void pushdown(int x) {
    if (tag1[x] || tag2[x]) {
      addtag1(x &lt;&lt; 1, tag1[x], tag2[x]);
      addtag1(x &lt;&lt; 1 | 1, tag1[x], tag2[x]);
      tag1[x] = tag2[x] = 0;
    }
    if (tagcov1[x] != -1e18 || tagcov2[x] != -1e18) {
      addtag2(x &lt;&lt; 1, tagcov1[x], tagcov2[x]);
      addtag2(x &lt;&lt; 1 | 1, tagcov1[x], tagcov2[x]);
      tagcov1[x] = tagcov2[x] = -1e18;
    }
  }

  void build(int x, int l, int r) {
    tagcov1[x] = tagcov2[x] = -1e18;
    if (l == r) {
      maxa[x] = maxb[x] = a[l];
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update1(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag1(x, v, std::max&lt;int&gt;(0, v));
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update1(x &lt;&lt; 1, l, mid, ql, qr, v), update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  void update2(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag2(x, v, v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update2(x &lt;&lt; 1, l, mid, ql, qr, v), update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int querymaxa(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return -1e18;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return maxa[x];
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(querymaxa(x &lt;&lt; 1, l, mid, ql, qr), querymaxa(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }

  int querymaxb(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return -1e18;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return maxb[x];
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(querymaxb(x &lt;&lt; 1, l, mid, ql, qr), querymaxb(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  sgt.build(1, 1, n);
  std::cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    std::string op;
    int l, r, v;
    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
    if (op[0] == 'Q') {
      std::cout &lt;&lt; sgt.querymaxa(1, 1, n, l, r) &lt;&lt; '\n';
    } else if (op[0] == 'A') {
      std::cout &lt;&lt; sgt.querymaxb(1, 1, n, l, r) &lt;&lt; '\n';
    } else if (op[0] == 'P') {
      std::cin &gt;&gt; v;
      sgt.update1(1, 1, n, l, r, v);
    } else {
      std::cin &gt;&gt; v;
      sgt.update2(1, 1, n, l, r, v);
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18358389.html</id>
    <title type="text">P3309 [SDOI2014] 向量集 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-14T02:48:00Z</published>
    <updated>2024-08-14T02:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18358389.html" />
    <content type="text">## Description

维护一个向量集合，**在线**支持以下操作：

- `A x y`（$|x|,|y| \le 10^8$）：加入向量 $(x,y)$；
- `Q x y l r`（$|x|,|y| \le 10^8$，$1 \le l \le r \le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。

集合初始时为空，操作次数 $\leq 4\times 10^5$。

## Solution

不妨设查询时最优的向量为 $(a,b)$，那么 $(a,b)\cdot (x,y)=ax+by=y\left(\frac{x}{y}\cdot a+b\right)$。

括号里面的东西是一个关于 $(a,b)$ 的一次函数，所以可以先求出这个区间的凸包然后在凸包上二分（注意这里 $b$ 可能是负数，所以需要同时维护上凸壳和下凸壳）。

考虑怎么求出凸包。

容易发现可以维护一个线段树，对于线段树上每个节点维护这个节点对应区间目前加入的点的凸包。

由于每个点只会被加入到 $O(\log n)$ 个节点，所以可以直接平衡树维护每个节点的凸包，时间复杂度是 $O(n\log^2n)$，常数较大且过于复杂，考虑更好的做法。

上面做法的问题在于每次需要对于凸包实现动态插入，而维护凸包更好的做法是静态建凸包。

注意到每次查询访问到的节点一定被插满了，即这些节点一定不会再被修改。

所以对于每次修改，只需要找到所有已经被插满的节点然后对于这些节点静态建凸包即可。

这样常数就小很多了。

时间复杂度：$O(n\log^2n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using pii = std::pair&lt;int, int&gt;;

const int kMaxN = 4e5 + 5;

int n, q;
std::string O;
std::vector&lt;pii&gt; vec[kMaxN * 4], v[kMaxN * 4][2];

/*
  v[x][0/1] : 线段树 x 号节点的上/下凸包
*/

pii sub(pii a, pii b) { return {a.first - b.first, a.second - b.second}; }
int mul(pii a, pii b) { return a.first * b.second - a.second * b.first; }
int func(pii a, pii b) { return a.first * b.first + a.second * b.second; }
int getid(int dep, int x) { return (1 &lt;&lt; (19 - dep)) + x; }

std::vector&lt;pii&gt; getvec(std::vector&lt;pii&gt; vec) {
  std::vector&lt;pii&gt; stk;
  std::sort(vec.begin(), vec.end());
  for (auto p : vec) {
    for (; stk.size() &gt;= 2 &amp;&amp; mul(sub(p, stk.back()), sub(stk.back(), stk[stk.size() - 2])) &lt;= 0; stk.pop_back()) {}
    stk.emplace_back(p);
  }
  return stk;
}

int decode(int x, int64_t lastans) {
  return x ^ (lastans &amp; 0x7fffffff);
}

void build(int x) {
  std::sort(vec[x].begin(), vec[x].end());
  for (auto p : vec[x]) {
    for (; v[x][0].size() &gt;= 2 &amp;&amp; mul(sub(p, v[x][0].back()), sub(v[x][0].back(), v[x][0][v[x][0].size() - 2])) &lt;= 0; v[x][0].pop_back()) {}
    v[x][0].emplace_back(p);
  }
  for (auto p : vec[x]) {
    for (; v[x][1].size() &gt;= 2 &amp;&amp; mul(sub(p, v[x][1].back()), sub(v[x][1].back(), v[x][1][v[x][1].size() - 2])) &gt;= 0; v[x][1].pop_back()) {}
    v[x][1].emplace_back(p);
  }
}

int query(int x, pii p) {
  int o = (p.second &lt;= 0), L = 0, R = v[x][o].size(), res = 0;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (func(p, v[x][o][mid]) &gt;= func(p, v[x][o][mid - 1])) L = res = mid;
    else R = mid;
  }
  return func(p, v[x][o][res]);
}

int query(int x, int l, int r, int ql, int qr, pii p) {
  if (l &gt; qr || r &lt; ql) return -1e18;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return query(x, p);
  int mid = (l + r) &gt;&gt; 1;
  return std::max(query(x &lt;&lt; 1, l, mid, ql, qr, p), query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, p));
}

void dickdreamer() {
  std::cin &gt;&gt; q &gt;&gt; O;
  int lastans = 0;
  for (int cs = 1; cs &lt;= q; ++cs) {
    std::string op;
    pii p;
    std::cin &gt;&gt; op &gt;&gt; p.first &gt;&gt; p.second;
    if (O[0] != 'E') p.first = decode(p.first, lastans), p.second = decode(p.second, lastans);
    if (op[0] == 'A') {
      for (int i = 0; i &lt;= 19; ++i) {
        vec[getid(i, n &gt;&gt; i)].emplace_back(p);
        if ((n % (1 &lt;&lt; i)) == (1 &lt;&lt; i) - 1) build(getid(i, n &gt;&gt; i));
      }
      ++n;
    } else {
      int l, r;
      std::cin &gt;&gt; l &gt;&gt; r;
      if (O[0] != 'E') l = decode(l, lastans), r = decode(r, lastans);
      std::cout &lt;&lt; (lastans = query(1, 0, (1 &lt;&lt; 19) - 1, l - 1, r - 1, p)) &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18358935.html</id>
    <title type="text">UOJ #191. 【集训队互测2016】Unknown 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-14T06:55:00Z</published>
    <updated>2024-08-14T06:55:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18358935.html" />
    <content type="text">## Description

有一个元素为向量的序列，下标从 $1$ 开始，初始时为空，现在你需要支持三个操作：

1. 在 $S$ 的末尾添加一个元素 $(x,y)$。
2. 删除 $S$ 的末尾元素。
3. 询问下标在 $[l,r]$ 区间内的元素中，$(x,y)\times S_i$ 的最大值。

其中 $\times$ 表示向量的叉积，$(x_1,y_1) \times (x_2,y_2) = x_1y_2-x_2y_1$。

$0 \leq tp \leq 7, 1 \leq m \leq 5\times 10^5$。
任意时刻 $n \geq 0$，$n$ 为当前序列长度。
1 操作个数不超过 $3\times 10^5$，且满足 $-10^9 \leq x \leq 10^9,1 \leq y \leq 10^9$。
3 操作个数不超过 $3\times 10^5$，且满足 $1 \leq x \leq 10^9,-10^9 \leq y \leq 10^9$。

## Solution

首先如果没有删除操作，就直接用[向量集](https://www.cnblogs.com/Scarab/p/18358389)这题的做法对于线段树上的节点维护凸包，当一个节点被插满后再建凸包。

加上删除操作后如果暴力重构显然会超时，考虑怎么让这题的势能变得正确。

注意到对于二进制分组后每层的最后一个插满的节点，如果查询时不考虑这个节点，直接向下递归的话也能保证查询复杂度的正确。

所以对于每次插入操作就建好每层除了最后一个插满的节点的凸包，对于删除操作如果删到一个之前已经构建好凸包的节点就把这个节点的凸包清空，这样就能保证重构的总点数是 $O(m\log m)$ 了。

时间复杂度：$O(m\log^2m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;
using pii = std::pair&lt;i64, i64&gt;;

const int kMaxN = 5e5 + 5, kMod = 998244353;

int _tp, n, q;
pii pr[kMaxN];
std::vector&lt;int&gt; vec[(1 &lt;&lt; 19) + 5], v[(1 &lt;&lt; 19) + 5];
bool vis[(1 &lt;&lt; 19) + 5];

/*
  v[x][0/1] : 线段树 x 号节点的上/下凸包
*/

int fix(i64 x) { return (x % kMod + kMod) % kMod; }
pii sub(pii a, pii b) { return {a.first - b.first, a.second - b.second}; }
i64 mul(pii a, pii b) { return a.first * b.second - a.second * b.first; }
i64 func(pii a, pii b) { return a.first * b.second + a.second * b.first; }
int getid(int dep, int x) { return (1 &lt;&lt; (18 - dep)) + x; }

void build(int x) {
  static std::vector&lt;int&gt; tvec;
  vis[x] = 1;
  tvec = vec[x];
  std::sort(tvec.begin(), tvec.end(), [&amp;] (int i, int j) { return pr[i] &lt; pr[j]; });
  v[x].clear(), v[x].shrink_to_fit();
  for (auto i : tvec) {
    for (; v[x].size() &gt;= 2 &amp;&amp; mul(sub(pr[i], pr[v[x].back()]), sub(pr[v[x].back()], pr[v[x][v[x].size() - 2]])) &lt;= 0; v[x].pop_back()) {}
    v[x].emplace_back(i);
  }
}

void clear(int x) {
  vis[x] = 0, v[x].clear();
}

i64 query(int x, pii p) {
  int L = 0, R = v[x].size(), res = 0;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (func(p, pr[v[x][mid]]) &gt;= func(p, pr[v[x][mid - 1]])) L = res = mid;
    else R = mid;
  }
  return func(p, pr[v[x][res]]);
}

i64 query(int x, int l, int r, int ql, int qr, pii p) {
  if (l &gt; qr || r &lt; ql) return -1e18;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
    if (l == r) return func(p, pr[l]);
    else if (vis[x]) return query(x, p);
  }
  int mid = (l + r) &gt;&gt; 1;
  return std::max(query(x &lt;&lt; 1, l, mid, ql, qr, p), query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, p));
}

void dickdreamer() {
  int ans = 0;
  n = 0;
  for (int cs = 1; cs &lt;= q; ++cs) {
    int op;
    pii p;
    std::cin &gt;&gt; op;
    if (op == 1) {
      std::cin &gt;&gt; p.first &gt;&gt; p.second;
      p.first *= -1;
      pr[n] = p;
      for (int i = 0; i &lt;= 18; ++i) {
        int t = (n &gt;&gt; i);
        vec[getid(i, t)].emplace_back(n);
        if ((n % (1 &lt;&lt; i)) == (1 &lt;&lt; i) - 1 &amp;&amp; t &amp;&amp; !vis[getid(i, t - 1)]) {
          build(getid(i, t - 1));
        }
      }
      ++n;
    } else if (op == 2) {
      --n;
      for (int i = 0; i &lt;= 18; ++i) {
        int t = (n &gt;&gt; i);
        vec[getid(i, t)].pop_back();
        if ((n % (1 &lt;&lt; i)) == (1 &lt;&lt; i) - 1 &amp;&amp; vis[getid(i, t)]) {
          clear(getid(i, t));
        }
      }
    } else {
      int l, r;
      std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; p.first &gt;&gt; p.second;
      ans ^= fix(query(1, 0, (1 &lt;&lt; 18) - 1, l - 1, r - 1, p));
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
  for (int i = 0; i &lt; (1 &lt;&lt; 19); ++i) {
    vec[i].clear(), vec[i].shrink_to_fit();
    v[i].clear(), v[i].shrink_to_fit();
    vis[i] = 0;
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  std::cin &gt;&gt; _tp;
  while (std::cin &gt;&gt; q &amp;&amp; q) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18362804.html</id>
    <title type="text">P6109 [Ynoi2009] rprmq1 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-16T06:40:00Z</published>
    <updated>2024-08-16T06:40:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18362804.html" />
    <content type="text">## Description

有一个 $n \times n$ 的矩阵 $a$，初始全是 $0$，有 $m$ 次修改操作和 $q$ 次查询操作，先进行所有修改操作，然后进行所有查询操作。

一次修改操作会给出 $l_1,l_2,r_1,r_2,x$，代表把所有满足 $l_1 \le i \le r_1$ 且 $l_2 \le j \le r_2$ 的 $a_{i,j}$ 元素加上一个值 $x$。

一次查询操作会给出 $l_1,l_2,r_1,r_2$，代表查询所有满足 $l_1 \le i \le r_1$ 且 $l_2 \le j \le r_2$ 的 $a_{i,j}$ 元素的最大值。

$1\leq n,m\leq 5\times 10^4$，$1\leq q \leq 5\times 10^5$，$1\leq x\leq 2147483647$，$1\leq l_1\leq r_1\leq n$，$1\leq l_2\leq r_2\leq n$。

## Solution

容易发现可以扫描线，但是直接做的话查询时需要维护任意一段时刻内的区间最大值，这显然是做不了的。

但是如果所有的查询 $l_1$ 均相等的话就可以从小到大枚举修改操作和查询的 $r_1$，这样只需要通过[区间加、历史最大值线段树](https://www.cnblogs.com/Scarab/p/18355696)维护当前所有操作的区间历史最大值。

这可以启发我们进行类似猫树分治的做法，从浅到深枚举线段树的每一层，找到所有横跨当前层不同节点的询问放在当前层做，剩下的放到更深层做。

由于横跨当前层不同节点的询问 $[l_1,r_1]$ 一定只跨过两个节点，所以这两个节点可以把它切割成 $[l_1,k]$ 和 $[k+1,r_1]$，对于 $[k+1,r_1]$ 这部分只需要维护一个历史最大值线段树，然后从小到大做修改操作，在每个线段树节点的开头重置历史最大值为当前最大值即可。$[l_1,k]$ 的部分同理。

时间复杂度：$O(n\log^2n+q\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 5e4 + 5, kMaxQ = 5e5 + 5;

int n, m, q;
int l1[kMaxQ], r1[kMaxQ], l2[kMaxQ], r2[kMaxQ], ans[kMaxQ];
bool vis[kMaxQ];
std::vector&lt;std::tuple&lt;int, int, int, int, int&gt;&gt; ud;
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; qq[kMaxN], vec[kMaxN];

struct SGT {
  int maxa[kMaxN * 8], maxb[kMaxN * 8], tag1[kMaxN * 8], tag2[kMaxN * 8], tagr[kMaxN * 8];

  void pushup(int x) {
    maxa[x] = std::max(maxa[x &lt;&lt; 1], maxa[x &lt;&lt; 1 | 1]);
    maxb[x] = std::max(maxb[x &lt;&lt; 1], maxb[x &lt;&lt; 1 | 1]);
  }

  void addtag(int x, int v1, int v2) {
    maxb[x] = std::max(maxb[x], maxa[x] + v2);
    tag2[x] = std::max(tag2[x], tag1[x] + v2);
    maxa[x] += v1, tag1[x] += v1;
  }

  void reset(int x) {
    addtag(x &lt;&lt; 1, tag1[x], tag2[x]), addtag(x &lt;&lt; 1 | 1, tag1[x], tag2[x]);
    maxb[x] = maxa[x], tagr[x] = 1;
    tag1[x] = tag2[x] = 0;
  }

  void pushdown(int x) {
    if (tagr[x]) {
      reset(x &lt;&lt; 1), reset(x &lt;&lt; 1 | 1);
      tagr[x] = 0;
    }
    if (tag1[x] || tag2[x]) {
      addtag(x &lt;&lt; 1, tag1[x], tag2[x]), addtag(x &lt;&lt; 1 | 1, tag1[x], tag2[x]);
      tag1[x] = tag2[x] = 0;
    }
  }

  void build(int x, int l, int r) {
    maxa[x] = maxb[x] = tag1[x] = tag2[x] = tagr[x] = 0;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, v, std::max&lt;int&gt;(v, 0));
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return maxb[x];
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(query(x &lt;&lt; 1, l, mid, ql, qr), query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

void solve(int d) {
  for (int i = 1; i &lt;= n; ++i) vec[i].clear(), qq[i].clear();
  for (auto [l1, r1, l2, r2, x] : ud)
    vec[l1].emplace_back(l2, r2, x), vec[r1 + 1].emplace_back(l2, r2, -x);
  for (int i = 1; i &lt;= q; ++i) {
    if (!vis[i] &amp;&amp; ((l1[i] &gt;&gt; d) != (r1[i] &gt;&gt; d) || !d)) {
      if (l1[i] != r1[i]) assert((l1[i] &gt;&gt; d) == (r1[i] &gt;&gt; d) - 1);
      qq[r1[i]].emplace_back(i, l2[i], r2[i]);
    }
  }
  sgt.build(1, 1, n);
  for (int i = 1; i &lt;= n; ++i) {
    for (auto [l, r, v] : vec[i]) {
      if (v &lt; 0) sgt.update(1, 1, n, l, r, v);
    }
    for (auto [l, r, v] : vec[i]) {
      if (v &gt;= 0) sgt.update(1, 1, n, l, r, v);
    }
    if (i % (1 &lt;&lt; d) == 0) sgt.reset(1);
    for (auto [id, l, r] : qq[i]) ans[id] = std::max(ans[id], sgt.query(1, 1, n, l, r));
  }

  for (int i = 1; i &lt;= n; ++i) vec[i].clear(), qq[i].clear();
  for (auto [l1, r1, l2, r2, x] : ud)
    vec[r1].emplace_back(l2, r2, x), vec[l1 - 1].emplace_back(l2, r2, -x);
  for (int i = 1; i &lt;= q; ++i) {
    if (!vis[i] &amp;&amp; ((l1[i] &gt;&gt; d) != (r1[i] &gt;&gt; d) || !d)) {
      if (l1[i] != r1[i]) assert((l1[i] &gt;&gt; d) == (r1[i] &gt;&gt; d) - 1);
      vis[i] = 1;
      qq[l1[i]].emplace_back(i, l2[i], r2[i]);
    }
  }
  sgt.build(1, 1, n);
  for (int i = n; i; --i) {
    for (auto [l, r, v] : vec[i]) {
      if (v &lt; 0) sgt.update(1, 1, n, l, r, v);
    }
    for (auto [l, r, v] : vec[i]) {
      if (v &gt;= 0) sgt.update(1, 1, n, l, r, v);
    }
    if (i % (1 &lt;&lt; d) == (1 &lt;&lt; d) - 1) sgt.reset(1);
    for (auto [id, l, r] : qq[i]) ans[id] = std::max(ans[id], sgt.query(1, 1, n, l, r));
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= m; ++i) {
    int l1, l2, r1, r2, x;
    std::cin &gt;&gt; l1 &gt;&gt; l2 &gt;&gt; r1 &gt;&gt; r2 &gt;&gt; x;
    ud.emplace_back(l1, r1, l2, r2, x);
  }
  for (int i = 1; i &lt;= q; ++i)
    std::cin &gt;&gt; l1[i] &gt;&gt; l2[i] &gt;&gt; r1[i] &gt;&gt; r2[i];
  for (int i = std::__lg(n) + 1; ~i; --i) {
    solve(i);
  }
  for (int i = 1; i &lt;= q; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18363077.html</id>
    <title type="text">P8518 [IOI2021] 分糖果 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-16T08:12:00Z</published>
    <updated>2024-08-16T08:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18363077.html" />
    <content type="text">## Description

Khong 阿姨正在给附近一所学校的学生准备 $n$ 盒糖果。盒子的编号分别为 $0$ 到 $n - 1$，开始时盒子都为空。第 $i$ 个盒子 $(0 \leq i \leq n - 1)$ 至多可以容纳 $c[i]$ 块糖果（容量为 $c[i]$）。

Khong 阿姨花了 $q$ 天时间准备糖果盒。在第 $j$ 天 $(0 \leq j \leq q - 1)$，她根据三个整数 $l[j]$、 $r[j]$ 和 $v[j]$ 执行操作，其中 $0 \leq l[j] \leq r[j] \leq n - 1$ 且 $v[j] \neq 0$。对于每个编号满足 $l[j] \leq k \leq r[j]$ 的盒子 $k$：

- 如果 $v[j] &gt; 0$，Khong 阿姨将糖果一块接一块地放入第 $k$ 个盒子，直到她正好放了 $v[j]$ 块糖果或者该盒子已满。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\min(c[k], p + v[j])$ 块糖果。

- 如果 $v[j] &lt; 0$，Khong 阿姨将糖果一块接一块地从第 $k$ 个盒子取出，直到她正好从盒子中取出 $-v[j]$ 块糖果或者该盒子已空。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\max(0, p + v[j])$ 块糖果。

你的任务是求出 $q$ 天之后每个盒子中糖果的数量。

**约束条件**

- $1 \le n \le 200 000$

- $1 \le q \le 200 000$
- $1 \le c[i] \le 10 ^ 9$ （对所有 $0 \le i \le n - 1$）
- $0 \le l[j] \le r[j] \le n - 1$（对所有 $0 \le j \le q - 1$）

- $−10 ^ 9 \le v[j] \le 10 ^ 9$ , $v[j] ≠ 0$（对所有 $0 \le j \le q - 1$）

## Solution

不妨设 $a_i$ 表示当前 $i$ 的糖果数量，那么每次操作就是让 $a_i\leftarrow\max\left(\min\left(a_i+v,c_i\right),0\right)$，容易发现可以扫描线然后维护一个关于时间轴的线段树。

如果取 min 和 max 中只有一种是很好做的，就是[这题](https://loj.ac/p/3489)，但是两个放在一起就不好做了。

容易发现只要找到最小的后缀 $[p,q]$ 使得这个后缀同时存在 min 和 max，那么 $[p+1,q]$ 就只有一种 min 或者 max 了，所以确定 $p$ 时刻的值就可以通过 $[p+1,q]$ 的操作得出答案。

考虑如何找到 $p$。

观察可知如果 $[p,q]$ 前缀和的极差 $\geq c_i$ 就一定同时存在 max 和 min，并且如果极差 $&lt;c_i$ 就一定不会同时存在 max 和 min，所以只要在线段树上二分即可。

时间复杂度：$O\left((n+q)\log n\right)$。

## Code

```cpp
#include "candies.h"

#include &lt;bits/stdc++.h&gt;

const int kMaxN = 2e5 + 5;

int n, q;
int c[kMaxN], l[kMaxN], r[kMaxN], v[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxN];

struct SGT {
  int64_t mx[kMaxN * 4], mi[kMaxN * 4], posmx[kMaxN * 4], posmi[kMaxN * 4], tag[kMaxN * 4];

  void pushup(int x) {
    if (mx[x &lt;&lt; 1] &gt; mx[x &lt;&lt; 1 | 1]) {
      mx[x] = mx[x &lt;&lt; 1], posmx[x] = posmx[x &lt;&lt; 1];
    } else {
      mx[x] = mx[x &lt;&lt; 1 | 1], posmx[x] = posmx[x &lt;&lt; 1];
    }
    if (mi[x &lt;&lt; 1] &lt; mi[x &lt;&lt; 1 | 1]) {
      mi[x] = mi[x &lt;&lt; 1], posmi[x] = posmi[x &lt;&lt; 1];
    } else {
      mi[x] = mi[x &lt;&lt; 1 | 1], posmi[x] = posmi[x &lt;&lt; 1 | 1];
    }
  }

  void addtag(int x, int64_t v) { tag[x] += v, mx[x] += v, mi[x] += v; }

  void pushdown(int x) {
    if (tag[x]) {
      addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
      tag[x] = 0;
    }
  }

  void build(int x, int l, int r) {
    mx[x] = mi[x] = tag[x] = 0, posmx[x] = posmi[x] = r;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int getpos(int x, int l, int r, int64_t nowmx, int64_t nowmi, int64_t v) {
    if (std::max(nowmx, mx[x]) - std::min(nowmi, mi[x]) &lt; v || l == r) return l;
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    if (std::max(nowmx, mx[x &lt;&lt; 1 | 1]) - std::min(nowmi, mi[x &lt;&lt; 1 | 1]) &gt;= v)
      return getpos(x &lt;&lt; 1 | 1, mid + 1, r, nowmx, nowmi, v);
    else 
      return getpos(x &lt;&lt; 1, l, mid, std::max(nowmx, mx[x &lt;&lt; 1 | 1]), std::min(nowmi, mi[x &lt;&lt; 1 | 1]), v);
  }

  std::pair&lt;int64_t, int&gt; querymin(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return {1e18, -1};
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return {mi[x], posmi[x]};
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return std::min(querymin(x &lt;&lt; 1, l, mid, ql, qr), querymin(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }

  std::pair&lt;int64_t, int&gt; querymax(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return {-1e18, -1};
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return {mx[x], posmx[x]};
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    return std::max(querymax(x &lt;&lt; 1, l, mid, ql, qr), querymax(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr));
  }
} sgt;

std::vector&lt;int&gt; solve() {
  std::vector&lt;int&gt; ans;
  for (int i = 1; i &lt;= q; ++i) {
    vec[l[i]].emplace_back(i, v[i]), vec[r[i] + 1].emplace_back(i, -v[i]);
  }
  sgt.build(1, 0, q);
  for (int i = 1; i &lt;= n; ++i) {
    for (auto [x, v] : vec[i]) sgt.update(1, 0, q, x, q, v);
    int p = sgt.getpos(1, 0, q, -1e18, 1e18, c[i]);
    int64_t sump = sgt.querymin(1, 0, q, p, p).first;
    if (p &amp;&amp; sump == sgt.querymin(1, 0, q, p, q).first) { // 后面只会顶上界
      auto [mx, id] = sgt.querymax(1, 0, q, p, q);
      if (mx - sump &lt;= c[i]) ans.emplace_back(sgt.querymax(1, 0, q, q, q).first - sump);
      else ans.emplace_back(c[i] - (mx - sgt.querymax(1, 0, q, q, q).first));
    } else if (p) {
      auto [mi, id] = sgt.querymin(1, 0, q, p, q);
      if (sump - mi &lt;= c[i]) ans.emplace_back(c[i] - (sump - sgt.querymin(1, 0, q, q, q).first));
      else ans.emplace_back(sgt.querymin(1, 0, q, q, q).first - mi);
    } else if (sgt.querymin(1, 0, q, 0, q).first &gt;= 0) {
      auto [mx, id] = sgt.querymax(1, 0, q, p, q);
      if (mx &lt;= c[i]) ans.emplace_back(sgt.querymax(1, 0, q, q, q).first);
      else ans.emplace_back(c[i] - (mx - sgt.querymax(1, 0, q, q, q).first));
    } else {
      auto [mi, id] = sgt.querymin(1, 0, q, p, q);
      if (mi &gt;= 0) ans.emplace_back(sgt.querymin(1, 0, q, q, q).first);
      else ans.emplace_back(sgt.querymin(1, 0, q, q, q).first - mi);
    }
  }
  return ans;
}

std::vector&lt;int&gt; distribute_candies(std::vector&lt;int&gt; c, std::vector&lt;int&gt; l,
                                    std::vector&lt;int&gt; r, std::vector&lt;int&gt; v) {
  n = c.size(), q = l.size();
  for (int i = 0; i &lt; n; ++i) ::c[i + 1] = c[i];
  for (int i = 0; i &lt; q; ++i)
    ::l[i + 1] = l[i] + 1, ::r[i + 1] = r[i] + 1, ::v[i + 1] = v[i];
  return solve();
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18364180.html</id>
    <title type="text">CF704E Iron Man 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-17T03:38:00Z</published>
    <updated>2024-08-17T03:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18364180.html" />
    <content type="text">## Description

“铁人”yyb 在玩游戏。在一个 $n$ 个点的树上，yyb 放置了 $m$ 个鸡贼。每个鸡贼有四个整数参数 $t_i,c_i,v_i,u_i$，表示这个鸡贼会在 $t_i$ 时刻**出现**在点 $v_i$，并以每时刻 $c_i$ 条边的速度向 $u_i$ 点**匀速**移动，到达 $u_i$ 点时**立刻消失**。

如果一个时刻有两个鸡贼在同一位置，它们会立刻爆炸。

（注意，如果一个鸡贼的 $u_i=v_i$ 那么它会在 $t_i$ 时刻出现，此时如果这个点有其它鸡贼一样会发生爆炸）

yyb 想知道最早有鸡贼爆炸的时刻。如果自始至终都没发生爆炸输出 `-1`。

如果你的答案和标准答案的绝对或相对误差不超过 $10^{-6}$ 那么被视为正确。

## Solution

注意到树上问题很不好做，考虑通过树剖将每组移动拆分成 $O(\log n)$ 条链，然后转化为对于所有的 $O(n)$ 条链判断。

那么可以对于每个链用 $x$ 表示时间，$y$ 表示位置，所以每组移动就可以转化为一个线段，然后需要求出这些线段的交点中 $x$ 坐标的最小值。

考虑扫描线，把每个线段左右端点的 $x$ 坐标作为关键点，容易发现对于一对不相交的线段一定满足他们在所有的关键点时刻的 $y$ 坐标大小关系不变。

于是可以用 set 维护当前时刻每个线段的 $y$ 坐标，观察之后会发现每对相交的线段一定满足在某个相交之前的时刻他们在 set 上是相邻的，所以只要每次加入一个线段时求出这个线段和它前驱、后继的答案，如果答案已经小于当前时刻就说明找到了最终答案。

注意这里 set 需要重载运算符，由于找到答案后会直接退出所以不会出现奇怪的问题。

时间复杂度：$O(n+m\log^2n)$。

## Code

&lt;details&gt;
&lt;summary&gt;手写分数类实现&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

using f64 = long double;

const int kMaxN = 1e5 + 5;
const f64 kEps = 1e-7;

struct Frac {
  int x, y; // x / y

  void fix() {
    if (y &lt; 0) x = -x, y = -y;
  }

  Frac(__int128_t _x = 0, __int128_t _y = 1) {
    __int128_t d = std::__gcd(_x, _y);
    x = _x / d, y = _y / d;
    if (y &lt; 0) x = -x, y = -y;
  }

  friend Frac operator +(Frac a, Frac b) { return Frac(a.x * b.y + a.y * b.x, a.y * b.y); }
  friend Frac operator -(Frac a, Frac b) { return Frac(a.x * b.y - a.y * b.x, a.y * b.y); }
  friend Frac operator *(Frac a, Frac b) { return Frac(a.x * b.x, a.y * b.y); }
  friend Frac operator /(Frac a, Frac b) { return Frac(a.x * b.y, a.y * b.x); }
  friend bool operator &lt;(Frac a, Frac b) { a.fix(), b.fix(); return (__int128_t)a.x * b.y &lt; (__int128_t)a.y * b.x; }
  friend bool operator &lt;=(Frac a, Frac b) { a.fix(), b.fix(); return (__int128_t)a.x * b.y &lt;= (__int128_t)a.y * b.x; }
  friend bool operator &gt;(Frac a, Frac b) { a.fix(), b.fix(); return (__int128_t)a.x * b.y &gt; (__int128_t)a.y * b.x; }
  friend bool operator &gt;=(Frac a, Frac b) { a.fix(), b.fix(); return (__int128_t)a.x * b.y &gt;= (__int128_t)a.y * b.x; }
  friend bool operator ==(Frac a, Frac b) { a.fix(), b.fix(); return (__int128_t)a.x * b.y == (__int128_t)a.y * b.x; }
  friend bool operator ==(Frac a, int b) { return a.x == (__int128_t)a.y * b; }
  friend bool operator !=(Frac a, int b) { return a.x != (__int128_t)a.y * b; }
  f64 real() { return (f64)x / y; }
};

int n, m;
int p[kMaxN], sz[kMaxN], wson[kMaxN], top[kMaxN], dep[kMaxN], dfn[kMaxN];
f64 ans = 1e18;
Frac a[kMaxN][4];
std::vector&lt;int&gt; G[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; upd[kMaxN * 2];
std::vector&lt;std::tuple&lt;Frac, Frac, Frac, Frac&gt;&gt; vec[kMaxN * 2];
// [初始位置，出现时间，结束时间，速度]

void dfs1(int u, int fa) {
  p[u] = fa, dep[u] = dep[fa] + 1, sz[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, int fa, int t) {
  static int cnt = 0;
  top[u] = t;
  if (wson[u]) dfs2(wson[u], u, t);
  for (auto v : G[u]) {
    if (v == fa || v == wson[u]) continue;
    dfs2(v, u, v);
  }
}

void prework() {
  dfs1(1, 0), dfs2(1, 0, 1);
}

void work(int t, int c, int u, int v) {
  std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vecu, vecv;
  for (; top[u] != top[v];) {
    if (dep[top[u]] &gt;= dep[top[v]]) {
      vecu.emplace_back(top[u], dep[u] - dep[top[u]], 0);
      vecu.emplace_back(top[u] + n, 1, 0);
      u = p[top[u]];
    } else {
      vecv.emplace_back(top[v], 0, dep[v] - dep[top[v]]);
      vecv.emplace_back(top[v] + n, 0, 1);
      v = p[top[v]];
    }
  }
  if (dep[u] &lt;= dep[v])
    vecv.emplace_back(top[u], dep[u] - dep[top[u]], dep[v] - dep[top[u]]);
  else
    vecu.emplace_back(top[u], dep[u] - dep[top[u]], dep[v] - dep[top[u]]);

  std::reverse(vecv.begin(), vecv.end());
  for (auto p : vecv) vecu.emplace_back(p);
  Frac now = Frac(t, 1);
  for (auto [id, l, r] : vecu) {
    vec[id].emplace_back(Frac(l, 1), now, now + Frac(abs(l - r), c), Frac(l &lt;= r ? c : -c, 1));
    now = now + Frac(abs(l - r), c);
  }
}

int getid(std::vector&lt;Frac&gt; &amp;vec, Frac x) {
  int L = -1, R = vec.size(), res = -1;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (x &lt;= vec[mid]) R = res = mid;
    else L = mid;
  }
  return res;
}

Frac calc(int x, int y) {
  Frac s = a[x][3] * a[x][1] - a[y][3] * a[y][1] + a[y][0] - a[x][0];
  Frac v = a[x][3] - a[y][3];
  if (v == 0 &amp;&amp; !(s == 0)) {
    return Frac(1e14, 1);
  } else if (v == 0) {
    if (std::max(a[x][1], a[y][1]) &lt;= std::min(a[x][2], a[y][2])) return std::max(a[x][1], a[y][1]);
    else return Frac(1e14, 1);
  } else {
    Frac t = s / v;
    if (t &gt;= a[x][1] &amp;&amp; t &gt;= a[y][1] &amp;&amp; t &lt;= a[x][2] &amp;&amp; t &lt;= a[y][2]) return t;
    else return Frac(1e14, 1);
  }
}

void solve(int x) {
  std::vector&lt;Frac&gt; tmp, unq;
  int tot = 0;
  Frac nowt = Frac(0, 1);
  auto cmp = [&amp;] (int i, int j) -&gt; bool {
    return a[i][0] + a[i][3] * (nowt - a[i][1]) &lt; a[j][0] + a[j][3] * (nowt - a[j][1]);
  };
  for (auto [p, l, r, c] : vec[x]) {
    ++tot;
    a[tot][0] = p, a[tot][1] = l, a[tot][2] = r, a[tot][3] = c;
    tmp.emplace_back(l), tmp.emplace_back(r);
  }
  std::sort(tmp.begin(), tmp.end());
  for (int i = 0; i &lt; (int)tmp.size(); ++i) {
    if (!i) unq.emplace_back(tmp[i]);
    else if (!(tmp[i] == tmp[i - 1])) unq.emplace_back(tmp[i]);
  }
  for (int i = 0; i &lt; (int)unq.size(); ++i) upd[i].clear();
  for (int i = 1; i &lt;= tot; ++i) {
    upd[getid(unq, a[i][1])].emplace_back(i, 1);
    upd[getid(unq, a[i][2])].emplace_back(i, -1);
  }
  std::set&lt;int, decltype(cmp)&gt; st(cmp);
  Frac res = Frac(1e12, 1);
  for (int i = 0; i &lt; (int)unq.size(); ++i) {
    nowt = unq[i];
    if (res &lt; nowt) break;
    for (auto [x, v] : upd[i]) {
      if (v == 1) {
        auto it = st.lower_bound(x);
        if (it != st.end()) {
          Frac val = calc(*it, x);
          res = std::min(res, val);
          if (res &lt; nowt) return void(ans = std::min(ans, res.real()));
        }
        if (it != st.begin()) {
          --it;
          Frac val = calc(*it, x);
          res = std::min(res, val);
          if (res &lt; nowt) return void(ans = std::min(ans, res.real()));
        }
        st.emplace(x);
      }
    }
    for (auto [x, v] : upd[i]) {
      if (v == -1) st.erase(x);
    }
  }
  ans = std::min(ans, res.real());
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  prework();
  for (int i = 1; i &lt;= m; ++i) {
    int t, c, u, v;
    std::cin &gt;&gt; t &gt;&gt; c &gt;&gt; u &gt;&gt; v;
    work(t, c, u, v);
  }
  for (int i = 1; i &lt;= 2 * n; ++i) solve(i);
  if (ans &gt;= 1e10) std::cout &lt;&lt; "-1\n";
  else std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```

&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;float128 实现&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using f64 = long double;
using f128 = __float128;

const int kMaxN = 1e5 + 5;
const f128 kEps = 1e-7;

int n, m;
int p[kMaxN], sz[kMaxN], wson[kMaxN], top[kMaxN], dep[kMaxN], dfn[kMaxN];
f128 ans = 1e18, a[kMaxN][4];
std::vector&lt;int&gt; G[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; upd[kMaxN * 2];
std::vector&lt;std::tuple&lt;f128, f128, f128, f128&gt;&gt; vec[kMaxN * 2];
// [初始位置，出现时间，结束时间，速度]

void dfs1(int u, int fa) {
  p[u] = fa, dep[u] = dep[fa] + 1, sz[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, int fa, int t) {
  static int cnt = 0;
  top[u] = t, dfn[u] = ++cnt;
  if (wson[u]) dfs2(wson[u], u, t);
  for (auto v : G[u]) {
    if (v == fa || v == wson[u]) continue;
    dfs2(v, u, v);
  }
}

void prework() {
  dfs1(1, 0), dfs2(1, 0, 1);
}

void work(int t, int c, int u, int v) {
  std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vecu, vecv;
  for (; top[u] != top[v];) {
    if (dep[top[u]] &gt;= dep[top[v]]) {
      vecu.emplace_back(top[u], dep[u] - dep[top[u]], 0);
      vecu.emplace_back(top[u] + n, 1, 0);
      u = p[top[u]];
    } else {
      vecv.emplace_back(top[v], 0, dep[v] - dep[top[v]]);
      vecv.emplace_back(top[v] + n, 0, 1);
      v = p[top[v]];
    }
  }
  if (dep[u] &lt;= dep[v])
    vecv.emplace_back(top[u], dep[u] - dep[top[u]], dep[v] - dep[top[u]]);
  else
    vecu.emplace_back(top[u], dep[u] - dep[top[u]], dep[v] - dep[top[u]]);

  std::reverse(vecv.begin(), vecv.end());
  for (auto p : vecv) vecu.emplace_back(p);
  f128 now = t;
  for (auto [id, l, r] : vecu) {
    vec[id].emplace_back(l, now, now + fabs(l - r) / c, l &lt;= r ? c : -c);
    now += fabs(l - r) / c;
  }
}

int getid(std::vector&lt;f128&gt; &amp;vec, f128 x) {
  int L = -1, R = vec.size(), res = -1;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (x &lt;= vec[mid] + kEps) R = res = mid;
    else L = mid;
  }
  return res;
}

f128 calc(int x, int y) {
  f128 s = a[x][3] * a[x][1] - a[y][3] * a[y][1] + a[y][0] - a[x][0];
  f128 v = a[x][3] - a[y][3];
  if (fabs(v) &lt;= kEps &amp;&amp; fabs(s) &gt; kEps) return 1e18;
  else if (fabs(v) &lt;= kEps) {
    if (std::max(a[x][1], a[y][1]) &lt;= std::min(a[x][2], a[y][2]) + kEps) return std::max(a[x][1], a[y][1]);
    else return 1e18;
  } else {
    f128 t = s / v;
    if (t &gt;= a[x][1] - kEps &amp;&amp; t &gt;= a[y][1] - kEps &amp;&amp; t &lt;= a[x][2] + kEps &amp;&amp; t &lt;= a[y][2] + kEps) return t;
    else return 1e18;
  }
}

void solve(int x) {
  static std::vector&lt;f128&gt; tmp, unq;
  tmp.clear(), tmp.shrink_to_fit();
  unq.clear(), unq.shrink_to_fit();
  int tot = 0;
  f128 nowt = 0;
  auto cmp = [&amp;] (int i, int j) -&gt; bool {
    return a[i][0] + a[i][3] * (nowt - a[i][1]) &lt; a[j][0] + a[j][3] * (nowt - a[j][1]);
  };
  for (auto [p, l, r, c] : vec[x]) {
    ++tot;
    a[tot][0] = p, a[tot][1] = l, a[tot][2] = r, a[tot][3] = c;
    tmp.emplace_back(l), tmp.emplace_back(r);
  }
  std::sort(tmp.begin(), tmp.end());
  for (int i = 0; i &lt; (int)tmp.size(); ++i) {
    if (!i) unq.emplace_back(tmp[i]);
    else if (fabs(tmp[i] - tmp[i - 1]) &gt; kEps) unq.emplace_back(tmp[i]);
  }
  for (int i = 0; i &lt; (int)unq.size(); ++i) upd[i].clear();
  for (int i = 1; i &lt;= tot; ++i) {
    upd[getid(unq, a[i][1])].emplace_back(i, 1);
    upd[getid(unq, a[i][2])].emplace_back(i, -1);
  }
  std::set&lt;int, decltype(cmp)&gt; st(cmp);
  f128 res = 1e18;
  for (int i = 0; i &lt; (int)unq.size(); ++i) {
    nowt = unq[i];
    if (res &lt; nowt - kEps) break;
    for (auto [x, v] : upd[i]) {
      if (v == 1) {
        auto it = st.lower_bound(x);
        if (it != st.end()) {
          f128 val = calc(*it, x);
          res = std::min(res, val);
          if (res &lt; nowt - kEps) return void(ans = std::min(ans, res));
        }
        if (it != st.begin()) {
          --it;
          f128 val = calc(*it, x);
          res = std::min(res, val);
          if (res &lt; nowt - kEps) return void(ans = std::min(ans, res));
        }
        st.emplace(x);
      }
    }
    for (auto [x, v] : upd[i]) {
      if (v == -1) st.erase(x);
    }
  }
  ans = std::min(ans, res);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  prework();
  for (int i = 1; i &lt;= m; ++i) {
    int t, c, u, v;
    std::cin &gt;&gt; t &gt;&gt; c &gt;&gt; u &gt;&gt; v;
    work(t, c, u, v);
  }
  for (int i = 1; i &lt;= 2 * n; ++i) solve(i);
  if (ans &gt;= 1e10) std::cout &lt;&lt; "-1\n";
  else std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; (f64)ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18366037.html</id>
    <title type="text">P9530 [JOISC2022] 鱼 2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-18T12:25:00Z</published>
    <updated>2024-08-18T12:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18366037.html" />
    <content type="text">## Description

JOI 君有 $N$ 条鱼，编号为 $1,2,\dots,N$。第 $i$ $(1 \le i \le N)$ 条鱼的大小为 $A_i$。

当我们养鱼的时候，需要注意如下的一个事实：如果有两条鱼离得很近，那么随着时间的流逝，可能会有其中一条吃掉另一条。其中，两条鱼离得很近，当且仅当它们中间没有鱼。
更具体地，如果鱼 $x$ 的大小不小于鱼 $y$ 的大小，且鱼 $x,y$ 离得很近，那么 $x$ 可以吃掉 $y$，且 $x$ 的大小变为原来 $x,y$ 的大小之和。如果 $x,y$ 一样大，那么 $x$ 吃掉 $y$ 或 $y$ 吃掉 $x$ 都可能发生。

JOI 君会养 $Q$ 天鱼。为了消磨时光，他会进行如下的思想实验。在第 $j$ 天 $(1 \le j \le Q)$，JOI 君会进行如下行动中的一个：

- 第一类：JOI 君给鱼 $X_j$ 吃了某些秘制的食物。这会将鱼 $X_j$ 的大小变为 $Y_j$。

- 第二类：JOI 君将编号在区间 $[L_j,R_j]$ 内的鱼单独拿出来，并进行以下实验：  
  JOI 君将鱼 $L_j,L_j+1,\dots,R_j$ 从左到右依次放在一个鱼缸中。由于鱼们具有如上所述的特点，最后只有一条鱼会存活。存活的这条鱼的编号取决于在哪些时刻哪些鱼吃掉了哪些鱼。JOI 君想知道可能成为最后存活者的鱼的条数。在实验中，鱼的编号不会改变，也不能有两条鱼同时吃掉同一条鱼。

请写一个程序，对于给定的 JOI 君的鱼和实验的信息，计算每个第二类行动的答案来让 JOI 君能够证明或证伪自己的观点。注意这只是思想实验，并没有任何鱼真的被吃掉。

**【数据范围】**

对于所有数据，满足：

- $1 \le N,Q \le 100\,000$。
- $1 \le A_i \le 10^9$ $(1\le i\le N)$。
- $T_j \in \{1,2\}$。
- $1 \le X_j \le N$ $(1\le j\le Q)$。
- $1 \le Y_j \le 10^9$。
- $1 \le L_j \le R_j \le N$ $(1 \le j \le Q)$。

## Solution

先假设询问区间为 $[1,n]$。

首先直接判断一条鱼 $x$ 是否有解是不好做的，考虑判断是否无解。

容易发现如果存在一个区间 $[l,r]$，满足 $l&lt;x&lt;r$ 并且 $sum_{l+1,r-1}&lt;\min\{a_l,a_r\}$ 就说明 $x$ 一定无法突破 $[l,r]$ 的限制，也就是无解。并且如果 $x$ 不被任何一个这样的 $[l,r]$ 包含就一定有解。

直接枚举每个 $[l,r]$ 显然无法接受，但有个结论是总共最多 $O(n\log V)$ 个这样的区间。证明就考虑假设存在两个区间 $[l,r_1]$ 和 $[l,r_2]$ 满足性质，那么 $sum_{l+1,r_2}&gt;2\cdot sum_{l+1,r_2-1}&gt;2\cdot sum_{l+1,r_1}$，所以对于每个 $l$ 只存在 $O(\log V)$ 个符合条件的 $r$，总个数也就是 $O(n\log V)$。同样可以证明包含任意一点的线段数也是 $O(\log V)$ 的，这里就不证了。

快速找到这些线段可以使用线段树二分。询问时相当于问有多少个点没有被线段覆盖，同样用线段树维护即可。

对于修改 $(x,y)$ 就暴力删去与 $x$ 有关的线段，修改后再加入。

---

然后考虑询问为任意区间的情况。

不妨设询问为 $[L,R]$，那么对于全局的一个线段 $[l,r]$ 满足 $L\leq l\leq r\leq R$ 或者 $l\leq L\leq r\leq R$ 或 $L\leq l\leq R\leq r$ 的话这个线段一定能造成贡献，而如果 $[l,r]$ 完全包含 $[L,R]$ 就说明 $[l,r]$ 不能造成贡献，找到这些线段再去掉即可。

时间复杂度：$O\left((n+q)\log n\log V\right)$。

## Code

&lt;details&gt;
&lt;summary&gt;Code&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

int n, q;
int a[kMaxN];
std::set&lt;std::pair&lt;int, int&gt;&gt; st;
std::vector&lt;int&gt; vl[kMaxN], vr[kMaxN];

struct BIT {
  int c[kMaxN];

  void upd(int x, int v) {
    for (; x &lt;= n; x += x &amp; -x) c[x] += v;
  }

  int qry(int x) {
    int ret = 0;
    for (; x; x -= x &amp; -x) ret += c[x];
    return ret;
  }
} bit;

struct SGT1 {
  int mx1[kMaxN * 4], tag1[kMaxN * 4];
  int mx2[kMaxN * 4], tag2[kMaxN * 4];

  void pushup(int x) {
    mx1[x] = std::max(mx1[x &lt;&lt; 1], mx1[x &lt;&lt; 1 | 1]);
    mx2[x] = std::max(mx2[x &lt;&lt; 1], mx2[x &lt;&lt; 1 | 1]);
  }

  void addtag(int x, int v1, int v2) {
    mx1[x] += v1, tag1[x] += v1;
    mx2[x] += v2, tag2[x] += v2;
  }

  void pushdown(int x) {
    if (tag1[x] || tag2[x]) {
      addtag(x &lt;&lt; 1, tag1[x], tag2[x]), addtag(x &lt;&lt; 1 | 1, tag1[x], tag2[x]);
      tag1[x] = tag2[x] = 0;
    }
  }

  void update(int x, int l, int r, int ql, int qr, int v1, int v2) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, v1, v2);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v1, v2), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v1, v2);
    pushup(x);
  }

  int getpos1(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql || mx1[x] &lt;= v || ql &gt; qr) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      if (l != r) pushdown(x);
      int mid = (l + r) &gt;&gt; 1;
      if (l == r) return l;
      else return mx1[x &lt;&lt; 1 | 1] &gt; v ? getpos1(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v) : getpos1(x &lt;&lt; 1, l, mid, ql, qr, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1, R = getpos1(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    if (R) return R;
    else return getpos1(x &lt;&lt; 1, l, mid, ql, qr, v);
  }

  int getpos2(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql || mx2[x] &lt;= v || ql &gt; qr) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      if (l != r) pushdown(x);
      int mid = (l + r) &gt;&gt; 1;
      if (l == r) return l;
      else return mx2[x &lt;&lt; 1] &gt; v ? getpos2(x &lt;&lt; 1, l, mid, ql, qr, v) : getpos2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    }
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1, L = getpos2(x &lt;&lt; 1, l, mid, ql, qr, v);
    if (L) return L;
    else return getpos2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
  }
} sgt1;

struct SGT2 {
  int mi[kMaxN * 4], cnt[kMaxN * 4], tag[kMaxN * 4];

  void pushup(int x) {
    mi[x] = std::min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]);
    cnt[x] = 0;
    if (mi[x &lt;&lt; 1] == mi[x]) cnt[x] += cnt[x &lt;&lt; 1];
    if (mi[x &lt;&lt; 1 | 1] == mi[x]) cnt[x] += cnt[x &lt;&lt; 1 | 1];
  }

  void addtag(int x, int v) {
    mi[x] += v, tag[x] += v;
  }

  void pushdown(int x) {
    if (tag[x]) {
      addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]);
      tag[x] = 0;
    }
  }

  void build(int x, int l, int r) {
    cnt[x] = r - l + 1;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  }

  void update(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update(x &lt;&lt; 1, l, mid, ql, qr, v), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  std::pair&lt;int, int&gt; query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return {1e9, 0};
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return {mi[x], cnt[x]};
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    auto L = query(x &lt;&lt; 1, l, mid, ql, qr), R = query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
    if (L.first == R.first) return {L.first, L.second + R.second};
    else return std::min(L, R);
  }
} sgt2;

void ins(int l, int r) {
  if (r - l + 1 != 1 &amp;&amp; !st.count({l, r})) {
    sgt2.update(1, 1, n, l + 1, r - 1, 1);
    st.emplace(l, r);
  }
}

void del(int l, int r) {
  if (r - l + 1 == 1 || !st.count({l, r})) return;
  sgt2.update(1, 1, n, l + 1, r - 1, -1);
  st.erase({l, r});
}

std::vector&lt;std::pair&lt;int, int&gt;&gt; getseg(int x) {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vl, vr, seg;
  int s1 = bit.qry(x), s2 = -bit.qry(x - 1);
  for (int p = sgt1.getpos1(1, 1, n, 1, x - 1, s1); p; p = sgt1.getpos1(1, 1, n, 1, p - 1, s1)) {
    vl.emplace_back(p, s1 - bit.qry(p));
  }
  for (int p = sgt1.getpos2(1, 1, n, x + 1, n, s2); p; p = sgt1.getpos2(1, 1, n, p + 1, n, s2)) {
    vr.emplace_back(p, bit.qry(p - 1) - s1);
  }
  for (auto [p1, s1] : vl) {
    for (auto [p2, s2] : vr) {
      if (a[p1] &gt; s1 + s2 &amp;&amp; a[p2] &gt; s1 + s2) {
        seg.emplace_back(p1, p2);
      }
    }
  }
  return seg;
}

std::vector&lt;std::pair&lt;int, int&gt;&gt; getsegs(int x) {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; seg;
  for (auto [l, r] : st)
    if (l &lt; x &amp;&amp; x &lt; r)
      seg.emplace_back(l, r);
  return seg;
}

std::vector&lt;std::pair&lt;int, int&gt;&gt; getsegl(int x) {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
  int s = -bit.qry(x);
  for (int p = sgt1.getpos2(1, 1, n, x + 1, n, s); p; p = sgt1.getpos2(1, 1, n, p + 1, n, s)) {
    int sum = bit.qry(p - 1) + s;
    if (sum &lt; a[x] &amp;&amp; sum &lt; a[p]) vec.emplace_back(x, p);
  }
  return vec;
}

std::vector&lt;std::pair&lt;int, int&gt;&gt; getsegr(int x) {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;
  int s = bit.qry(x - 1);
  for (int p = sgt1.getpos1(1, 1, n, 1, x - 1, s); p; p = sgt1.getpos1(1, 1, n, 1, p - 1, s)) {
    int sum = s - bit.qry(p);
    if (sum &lt; a[x] &amp;&amp; sum &lt; a[p]) vec.emplace_back(p, x);
  }
  return vec;
}

void prework() {
  for (int i = 1; i &lt;= n; ++i) {
    sgt1.update(1, 1, n, i, i, a[i], a[i]);
    sgt1.update(1, 1, n, i, n, a[i], 0);
    sgt1.update(1, 1, n, i + 1, n, 0, -a[i]);
    bit.upd(i, a[i]);
  }
  sgt2.build(1, 1, n);
  for (int i = 2; i &lt; n; ++i) {
    auto vec = getseg(i);
    for (auto [l, r] : vec) ins(l, r);
  }
}

void update(int x, int y) {
  auto segs = getseg(x);
  for (auto [l, r] : segs) del(l, r);
  if (x &lt; n - 1) {
    auto seg = getsegl(x);
    for (auto [l, r] : seg) del(l, r);
  }  
  if (x &gt; 2) {
    auto seg = getsegr(x);
    for (auto [l, r] : seg) del(l, r);
  }

  bit.upd(x, y - a[x]);
  sgt1.update(1, 1, n, x, x, y - a[x], y - a[x]);
  sgt1.update(1, 1, n, x, n, y - a[x], 0);
  sgt1.update(1, 1, n, x + 1, n, 0, -(y - a[x]));
  a[x] = y;

  auto seg1 = getseg(x);
  for (auto [l, r] : seg1) ins(l, r);
  if (x &lt; n - 1) {
    auto seg = getsegl(x);
    for (auto [l, r] : seg) ins(l, r);
  }
  if (x &gt; 2) {
    auto seg = getsegr(x);
    for (auto [l, r] : seg) ins(l, r);
  }
}

int query(int l, int r) {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vec, tmp;
  auto segs = getseg(l);
  for (auto [ll, rr] : segs)
    if (rr &gt; r)
      vec.emplace_back(ll, rr);
  for (auto [l, r] : vec) sgt2.update(1, 1, n, l + 1, r - 1, -1);

  int s1 = bit.qry(r), s2 = -bit.qry(l - 1);
  
  for (int p = sgt1.getpos1(1, 1, n, l, r - 1, s1); p; p = sgt1.getpos1(1, 1, n, l, p - 1, s1)) {
    tmp.emplace_back(p, r + 1);
    sgt2.update(1, 1, n, p + 1, r, 1);
  }

  for (int p = sgt1.getpos2(1, 1, n, l + 1, r, s2); p; p = sgt1.getpos2(1, 1, n, p + 1, r, s2)) {
    tmp.emplace_back(l - 1, p);
    sgt2.update(1, 1, n, l, p - 1, 1);
  }

  auto p = sgt2.query(1, 1, n, l, r);
  for (auto [l, r] : vec) sgt2.update(1, 1, n, l + 1, r - 1, 1);
  for (auto [l, r] : tmp) sgt2.update(1, 1, n, l + 1, r - 1, -1);
  if (!p.first) return p.second;
  else return 0;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  prework();
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    int op, l, r;
    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
    if (op == 1) update(l, r);
    else std::cout &lt;&lt; query(l, r) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18374778.html</id>
    <title type="text">CF578F Mirror Box 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-22T13:12:00Z</published>
    <updated>2024-08-22T13:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18374778.html" />
    <content type="text">## Description

在一个 $n \times m$ 的网格中，每个格子里都有一个呈 `\` 或 `/` 状的镜子。

一个合法的网格需要满足**从任意一个边界段垂直射进网格中，光线会从相邻的边界段射出**，同时**网格中的每一段都被至少一条光线穿透**。

现在网格中有 $k$ 个位置的镜子形状不确定，求有多少种合法的网格。

$n,m \le 100$，$k \le 200$，答案对质数 $p$ 取模。

## Solution

考虑一个合法的方案是什么样的。

容易发现一个 `\` 或者 `/` 可以看作连接网络上格点的边，并且对这些格点黑白染色后每条边一定连接的是同色点。

有个结论是只要图中的黑点或者白点构成一颗生成树就合法。证明就考虑如果存在环的话，环内的网格边一定不可能被穿透到，也就是不满足第二条要求。而黑点和白点如果都不为连通块，感性理解一下会发现一定存在一段会射到别的地方去。并且构成生成树时一对相邻的段一定能够沿着树上的路径构成的边反射到对面。

由于确定了一个颜色的生成树时就能唯一确定另一个颜色的方案，所以只需要分别求出两种颜色的生成树数再加起来即可。

时间复杂度：$O\left(nm\log\left(nm\right)+k^3\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 205;

int n, m, k, mod;
int fa[kMaxN * kMaxN];
std::string s[kMaxN];

int getid(int x, int y) { return (x - 1) * (m + 1) + y; }
int getpos(std::vector&lt;int&gt; &amp;v, int x) {
  return std::lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
bool unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx != fy) return fa[fx] = fy, 1;
  else return 0;
}

constexpr int qpow(int bs, int64_t idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % mod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % mod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= mod ? x + y - mod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + mod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= mod ? x -= mod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += mod : x; }

struct Matrix {
  int n, a[kMaxN][kMaxN];

  void set(int _n) { n = _n; }
  void add(int u, int v) { inc(a[u][u], 1), inc(a[v][v], 1), dec(a[u][v], 1), dec(a[v][u], 1); }

  int getdet() {
    if (n &gt; k + 1) return 0;
    int ret = 1;
    for (int i = 1; i &lt; n; ++i) {
      if (!a[i][i]) {
        for (int j = i + 1; j &lt;= n; ++j) {
          if (a[j][i]) {
            std::swap(a[i], a[j]), ret = sub(0, ret);
            break;
          }
        }
      }
      ret = 1ll * ret * a[i][i] % mod;
      for (int j = i + 1; j &lt;= n; ++j) {
        int d = 1ll * a[j][i] * qpow(a[i][i]) % mod;
        for (int k = i; k &lt;= n; ++k)
          dec(a[j][k], 1ll * a[i][k] * d % mod);
      }
    }
    return ret;
  }
} a[2];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;
  for (int i = 1; i &lt;= (n + 1) * (m + 1); ++i)
    fa[i] = i;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    s[i] = " " + s[i];
    for (int j = 1; j &lt;= m; ++j) {
      if (s[i][j] == '/') {
        if (!unionn(getid(i, j + 1), getid(i + 1, j)))
          return void(std::cout &lt;&lt; "0\n");
      } else if (s[i][j] == '\\') {
        if (!unionn(getid(i, j), getid(i + 1, j + 1)))
          return void(std::cout &lt;&lt; "0\n");
      } else {
        ++k;
      }
    }
  }
  std::vector&lt;int&gt; v[2];
  for (int i = 1; i &lt;= (n + 1) * (m + 1); ++i) {
    if (find(i) == i) {
      v[((i - 1) / (m + 1) + (i - 1) % (m + 1)) &amp; 1].emplace_back(i);
    }
  }
  a[0].set(v[0].size()), a[1].set(v[1].size());
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (s[i][j] == '*') {
        int o = (i + j) &amp; 1;
        if ((int)v[o].size() &lt;= k + 1) a[o].add(getpos(v[o], find(getid(i, j))), getpos(v[o], find(getid(i + 1, j + 1))));
        if ((int)v[o ^ 1].size() &lt;= k + 1) a[o ^ 1].add(getpos(v[o ^ 1], find(getid(i + 1, j))), getpos(v[o ^ 1], find(getid(i, j + 1))));
      }
    }
  }
  std::cout &lt;&lt; add(a[0].getdet(), a[1].getdet()) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18377205.html</id>
    <title type="text">P6348 [PA2011] Journeys 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-23T14:44:00Z</published>
    <updated>2024-08-23T14:44:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18377205.html" />
    <content type="text">## Description

一个星球上有 $n$ 个国家和许多双向道路，国家用 $1\sim n$ 编号。

但是道路实在太多了，不能用通常的方法表示。于是我们以如下方式表示道路：$(a,b),(c,d)$ 表示，对于任意两个国家 $x,y$，如果 $a\le x\le b,c\le y\le d$，那么在 $x,y$ 之间有一条道路。

首都位于 $P$ 号国家。你想知道 $P$ 号国家到任意一个国家最少需要经过几条道路。保证 $P$ 号国家能到任意一个国家。

$1\le n\le 5\times 10^5$，$1\le m\le 10^5$，$1\le a\le b\le n$，$1\le c\le d\le n$。

## Solution

这里给出一个比较新颖的做法。

首先如果暴力建图显然会超时，而超时的原因是对于每个道路都两两建边过于浪费，因为对于一个 $[a,b]\to[c,d]$ 的道路，只需要让 $[a,b]$ 中 $dis$ 最小的那个位置去更新 $[c,d]$。

考虑类似 dijkstra 的过程，按 $dis$ 从小到大确定每个 $dis_x$，同时维护一个关于转移边的优先队列。假如当前确定了 $dis_x$，就暴力枚举所有还没有更新过的道路 $[a,b]\to[c,d]$，将 $[c,d,dis_x+1]$ 加入优先队列，表示可以让 $[c,d]$ 这个区间里的 $dis$ 更新为 $dis_x+1$。

由于这里是从小到大确定 $dis$ 的，所以每次取出队头的转移 $[l,r,v]$ 只需要暴力找到 $[l,r]$ 中还没有确定 $dis$ 的位置更新为 $v$，同时维护优先队列即可。

时间复杂度：$O\left(\left(n+m\right)\log^2n\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 5e5 + 5;

int n, m, s;
int l1[kMaxN], r1[kMaxN], l2[kMaxN], r2[kMaxN], dis[kMaxN];
std::set&lt;int&gt; st, t[kMaxN * 4];
std::queue&lt;std::tuple&lt;int, int, int&gt;&gt; q;

void update(int x, int l, int r, int id, int op) {
  int ql = l1[id], qr = r1[id];
  if (l &gt; qr || r &lt; ql) {
    return;
  } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
    if (op == 1) t[x].emplace(id);
    else t[x].erase(id);
    return;
  }
  int mid = (l + r) &gt;&gt; 1;
  update(x &lt;&lt; 1, l, mid, id, op), update(x &lt;&lt; 1 | 1, mid + 1, r, id, op);
}

void getvec(int x, int l, int r, int ql, std::vector&lt;int&gt; &amp;vec) {
  for (auto id : t[x]) vec.emplace_back(id);
  if (l == r) return;
  int mid = (l + r) &gt;&gt; 1;
  if (ql &lt;= mid) getvec(x &lt;&lt; 1, l, mid, ql, vec);
  else getvec(x &lt;&lt; 1 | 1, mid + 1, r, ql, vec);
}

void upd(int x) {
  std::vector&lt;int&gt; vec;
  st.erase(x), getvec(1, 1, n, x, vec);
  for (auto id : vec) {
    update(1, 1, n, id, -1);
    q.emplace(l2[id], r2[id], dis[x] + 1);
  }
}

void dijkstra() {
  for (int i = 1; i &lt;= n; ++i) st.emplace(i);
  for (int i = 1; i &lt;= m; ++i) update(1, 1, n, i, 1);
  memset(dis, 0x3f, sizeof(dis));
  dis[s] = 0, upd(s);
  for (; !q.empty();) {
    auto [l, r, val] = q.front(); q.pop();
    for (auto it = st.lower_bound(l); it != st.end() &amp;&amp; *it &lt;= r; it = st.lower_bound(l)) {
      int u = *it;
      dis[u] = val, upd(u);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; l1[i] &gt;&gt; r1[i] &gt;&gt; l2[i] &gt;&gt; r2[i];
    l1[i + m] = l2[i], r1[i + m] = r2[i], l2[i + m] = l1[i], r2[i + m] = r1[i];
  }
  m *= 2;
  dijkstra();
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; dis[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18378175.html</id>
    <title type="text">P3547 [POI2013] CEN-Price List 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-24T12:03:00Z</published>
    <updated>2024-08-24T12:03:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18378175.html" />
    <content type="text">## Description

给定一个 $n$ 个点 $m$ 条边的无向图，边权均为 $a$。

现在将原来图中满足最短路等于 $2a$ 所有的点对 $(x,y)$ 之间加一条长度为 $b$ 的无向边。

给定 $k$，求点 $k$ 到所有点的最短路是多少。

$1\leq n,m\leq 10^5$。

## Solution

首先有个显然的结论是对于所有加边前 $k\to i$ 的最短路 $p_1(k)\to p_2\to\dots\to p_{m}(1)$，对于 $\forall 1\leq i\leq m-2$，一定满足 $p_i$ 和 $p_{i+2}$ 没有连边，否则最短路一定会更短。

那么加边之后的最短路就只有三种了：全 $a$；前面一堆 $a$ 加 $0/1$ 个 $b$；全 $b$。

对于前两种情况可以直接在原图上跑 bfs 求出。

考虑怎么做全 $b$ 的情况。

有一种暴力也是 bfs，每次转移就暴力枚举所有 $u\to v\to w$，满足 $(u,w)$ 没有边然后让 $dis_w\leftarrow dis_u+1$。

但是这样做是 $O(m^2)$ 的。

注意到对于一个转移 $u\to v\to w$ 如果 $(u,w)$ 没有边，那么这次转移后 $(v,w)$ 这条边就再也无法作为转移的第二条边进行成功的转移，可以直接删掉。

然后会发现如果 $u,v,w$ 不构成三元环则每次枚举必然会删掉至少一条边。如果构成三元环，由于三元环个数是 $O(m\sqrt m)$ 级别的，而每个三元环只会遍历 $O(1)$ 次，所以复杂度是 $O(m\sqrt m)$ 的。

时间复杂度：$O(m\sqrt m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, m, s, A, B;
int ans[kMaxN];
std::vector&lt;int&gt; G[kMaxN], _G[kMaxN];

void del(std::vector&lt;int&gt; &amp;vec, int p) {
  std::swap(vec[p], vec[(int)vec.size() - 1]);
  vec.pop_back();
}

void bfs1() {
  static int dis[kMaxN];
  static bool vis[kMaxN];
  std::queue&lt;int&gt; q;
  q.emplace(s), dis[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (auto v : G[u]) {
      if (!vis[v]) {
        dis[v] = dis[u] + 1, vis[v] = 1, q.emplace(v);
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i)
    ans[i] = std::min(dis[i] * A, (dis[i] / 2) * B + (dis[i] % 2) * A);
}

void bfs2() {
  static int dis[kMaxN];
  static bool vis[kMaxN], have[kMaxN];
  std::queue&lt;int&gt; q;
  q.emplace(s), dis[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (auto v : G[u]) have[v] = 1;
    for (auto v : G[u]) {
      std::vector&lt;int&gt; vec;
      for (int i = 0; i &lt; (int)_G[v].size(); ++i) {
        int w = _G[v][i];
        if (w != u &amp;&amp; !have[w]) {
          if (!vis[w]) dis[w] = dis[u] + 1, vis[w] = 1, q.emplace(w);
          vec.emplace_back(i);
        }
      }
      for (auto p : vec) {
        del(_G[v], p);
      }
    }
    for (auto v : G[u]) have[v] = 0;
  }
  for (int i = 1; i &lt;= n; ++i)
    if (vis[i])
      ans[i] = std::min(ans[i], dis[i] * B);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; A &gt;&gt; B;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
    _G[u].emplace_back(v), _G[v].emplace_back(u);
  }
  memset(ans, 0x3f, sizeof(ans));
  bfs1(), bfs2();
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18378239.html</id>
    <title type="text">P7515 [省选联考 2021 A 卷] 矩阵游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-24T12:57:00Z</published>
    <updated>2024-08-24T12:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18378239.html" />
    <content type="text">## Description

Alice 有一个 $n \times m$ 的矩阵 $a_{i, j}$（$1 \le i \le n$，$1 \le j \le m$），其每个元素为大小不超过 ${10}^6$ 的非负整数。

Bob 根据该矩阵生成了一个 $(n - 1) \times (m - 1)$ 的矩阵 $b_{i, j}$（$1 \le i \le n - 1$，$1 \le j \le m - 1$），每个元素的生成公式为

$$ b_{i, j} = a_{i, j} + a_{i, j + 1} + a_{i + 1, j} + a_{i + 1, j + 1} $$

现在 Alice 忘记了矩阵 $a_{i, j}$，请你根据 Bob 给出的矩阵 $b_{i, j}$ 还原出 $a_{i, j}$。

$2 \le n, m \le 300$，$0 \le b_{i, j} \le 4 \times {10}^6$。

## Solution

首先有个显然的事实是只要确定了第一行和第一列的值就能确定整个矩阵。

那么可以先在第一行和第一列随便填数，这时可能会有些数不在限制里面，考虑调整。

注意到让一行或一列进行类似 $-x,+x,-x,+x\ldots-x,+x$ 的操作后仍然满足 $b$ 矩阵的性质，不妨设 $x$ 为偏移量。

考虑只做这类操作，设 $x_i$ 为第 $i$ 行的偏移量，$y_i$ 为第 $i$ 列的偏移量。

那么对于每个 $(i,j)$，一定满足 $0\leq a_{i,j}+(-1)^jx_i+(-1)^iy_j\leq 10^6$。可以设 $b_i=(-1)^ix_i,c_i=(-1)^{i+1}y_i$，那么就是 $0\leq (-1)^{i+j}b_i-(-1)^{i+j}c_j\leq 10^6$，这是个差分约束的形式，可以 spfa 求解。无解就等价于出现了负环。

下面证明一下通过上面所述的操作一定可以操作出任意符合条件的矩形：

由于只要确定了第一行和第一列的值就可以确定整个矩阵，所以可以先把行操作做完再做列操作，容易发现这样第一行第一列的数可以取到任意值，也就是说这样做可以构造出任意一个符合条件的矩阵。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 305;

int n, m;
int a[kMaxN][kMaxN], b[kMaxN][kMaxN], dis[kMaxN * 2], cnt[kMaxN * 2];
bool inq[kMaxN * 2];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN * 2];

bool spfa() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n + m; ++i)
    dis[i] = 1e9, cnt[i] = inq[i] = 0;
  q.emplace(1), dis[1] = 0, inq[1] = 1;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    inq[u] = 0;
    for (auto [v, w] : G[u]) {
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!inq[v]) q.emplace(v), inq[v] = 1;
        if (++cnt[v] == n + m) return 0;
      }
    }
  }
  return 1;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n + m; ++i) G[i].clear();
  for (int i = 1; i &lt; n; ++i)
    for (int j = 1; j &lt; m; ++j)
      std::cin &gt;&gt; b[i][j];
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      if (i == 1 || j == 1) a[i][j] = 0;
      else a[i][j] = b[i - 1][j - 1] - a[i - 1][j - 1] - a[i - 1][j] - a[i][j - 1];
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      int L = -a[i][j], R = 1e6 - a[i][j];
      if ((i + j) &amp; 1) std::swap(L, R), L = -L, R = -R;
      G[i].emplace_back(j + n, -L), G[j + n].emplace_back(i, R);
    }
  }
  if (!spfa()) return void(std::cout &lt;&lt; "NO\n");
  std::cout &lt;&lt; "YES\n";
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= m; ++j) {
      int op = ((i + j) % 2 ? -1 : 1);
      std::cout &lt;&lt; a[i][j] + dis[i] * op - dis[j + n] * op &lt;&lt; ' ';
    }
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18381717.html</id>
    <title type="text">P4126 [AHOI2009] 最小割 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-26T15:39:00Z</published>
    <updated>2024-08-26T15:39:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18381717.html" />
    <content type="text">## Description

A,B 两个国家正在交战，其中A国的物资运输网中有 $N$ 个中转站，$M$ 条单向道路。设其中第 $i\ (1\leq i\leq M)$ 条道路连接了 $u_i,v_i$ 两个中转站，那么中转站 $u_i$ 可以通过该道路到达 $v_i$ 中转站，如果切断这条道路，需要代价 $c_i$。

现在B国想找出一个路径切断方案，使中转站 $s$ 不能到达中转站 $t$，并且切断路径的代价之和最小。

小可可一眼就看出，这是一个求最小割的问题。但爱思考的小可可并不局限于此。现在他对每条单向道路提出两个问题：

- 问题一：是否存在一个最小代价路径切断方案，其中该道路被切断？
- 问题二：是否对任何一个最小代价路径切断方案，都有该道路被切断？

现在请你回答这两个问题。

$N\leq 4\times 10^3,M\times 6\times 10^4$。

## Solution

显然要先建图跑一遍最大流。

这时会发现残余网络上不是满流的边一定不为最小割上的边。因为让这条边的初始流量减去一个极小值后最大流结果不变，最小割也不变。但是如果这条边在任何一个最小割中就一定会让最小割减少，就矛盾了。所以结论是对的。

于是只有满流的边可能是最小割上的边，但是只有这个结论仍然无法判断一条边是否在最小割上。

注意到如果残余网络上存在一个环，那么把这个环上的初始流量均减 $1$ 后最大流一定不变，所以这个环上的边也一定不为最小割边。

然后考虑缩点，只有缩点后 DAG 上的边可能为最小割边。

在这些边中只有直接连接 $s$ 和 $t$ 所在 scc 的边是必须边。

而对于 DAG 上其它边 $(u,v)$ 可以分别给出割和不割的构造：

1. 割：让 $s\to u$ 的路径为 $A$ 集合，其余为 $B$ 集合。
2. 不割：如果 $u$ 为 $s$，则 $v$ 一定不为 $t$，让 $s\to u\to v$ 的路径为 $A$ 集合，其余为 $B$ 集合。否则让 $u\to v\to t$ 为 $A$ 集合，其余为 $B$ 集合。

所以 DAG 上的所有边均为可行边，连接 $s$ 和 $t$ 所在 scc 的边为必须边。

时间复杂度：$O(N^2M)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 4e3 + 5, kMaxM = 2e5 + 5, kInf = 1e9;

int n, m, s, t, tot;
int u[kMaxM], v[kMaxM], w[kMaxM];
int dfn[kMaxN], low[kMaxN], bel[kMaxN];
bool ins[kMaxN], res[kMaxM][2];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

namespace Dinic {
struct Edge {
  int v, w, pre;
} e[kMaxM * 2];

int tot = 1, flow, n, s, t;
int tail[kMaxN], cur[kMaxN], dep[kMaxN];

void adde(int u, int v, int w) { e[++tot] = {v, w, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w) { adde(u, v, w), adde(v, u, 0); }
void clear() {
  for (int i = 0; i &lt;= n; ++i) tail[i] = 0;
  for (int i = 0; i &lt;= tot; ++i) e[i] = {0, 0, 0};
  flow = 0, tot = 1;
}
void init(int _n, int _s, int _t) { clear(); n = _n, s = _s, t = _t; }

bool bfs() {
  static bool vis[kMaxN] = {0};
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    cur[i] = tail[i], dep[i] = 1e9, vis[i] = 0;
  q.emplace(s), dep[s] = 0, vis[s] = 1;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    if (u == t) return 1;
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v, w = e[i].w;
      if (w &amp;&amp; !vis[v]) {
        dep[v] = dep[u] + 1, vis[v] = 1, q.emplace(v);
      }
    }
  }
  return 0;
}

int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = 1e9;
      lim -= fl, flow += fl;
      e[i].w -= fl, e[i ^ 1].w += fl;
      if (!lim) break;
    }
  }
  return flow;
}

int maxflow() {
  int flow = 0;
  for (; bfs(); flow += dfs(s, kInf)) {}
  return flow;
}
} // namespace Dinic

void dfs(int u) {
  static int cnt = 0;
  static std::stack&lt;int&gt; stk;
  dfn[u] = low[u] = ++cnt, stk.emplace(u), ins[u] = 1;
  for (auto [v, id] : G[u]) {
    if (!dfn[v]) {
      dfs(v), low[u] = std::min(low[u], low[v]);
    } else if (ins[v]) {
      low[u] = std::min(low[u], dfn[v]);
    }
  }
  if (dfn[u] == low[u]) {
    ++tot;
    for (; !stk.empty();) {
      int t = stk.top(); stk.pop();
      bel[t] = tot, ins[t] = 0;
      if (t == u) break;
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
  Dinic::init(n, s, t);
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];
    Dinic::add(u[i], v[i], w[i]);
  }
  Dinic::maxflow();
  for (int i = 2; i &lt;= Dinic::tot; ++i) {
    if (Dinic::e[i].w) {
      G[Dinic::e[i ^ 1].v].emplace_back(Dinic::e[i].v, i / 2);
    }
  }
  for (int i = 1; i &lt;= n; ++i)
    if (!dfn[i])
      dfs(i);
  for (int i = 1; i &lt;= m; ++i) {
    if (!Dinic::e[2 * i].w) {
      res[i][0] = (bel[u[i]] != bel[v[i]]);
      res[i][1] = (bel[u[i]] == bel[s] &amp;&amp; bel[v[i]] == bel[t]);
      std::cout &lt;&lt; res[i][0] &lt;&lt; ' ' &lt;&lt; res[i][1] &lt;&lt; '\n';
    } else {
      std::cout &lt;&lt; "0 0\n";
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18383703.html</id>
    <title type="text">CF1810G The Maximum Prefix 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-27T14:58:00Z</published>
    <updated>2024-08-27T14:58:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18383703.html" />
    <content type="text">## Description

构造一个长度最多为 $n$ 的数组 $a$，其每个元素均为 $1$ 或 $-1$。生成方式如下：
+ 选择任意整数 $k\in[1,n]$ 作为 $a$ 的长度。
+ 对于 $\forall i\in[1,k]$，有 $p_i$ 的概率设 $a_i=1$，有 $1-p_i$ 的概率设 $a_i=-1$。

在数列被生成后，计算 $s_i=a_1+a_2+a_3+...+a_i$。特别地，$s_0=0$。此时 $s$ 数组的最大前缀和 $S=max_{i=0}^ks_i$。

现在给定 $n+1$ 个正整数 $h_0,h_1,...,h_n$。$a$ 数组最大前缀和 $S$ 的分数为 $h_s$。现在，对于每个 $k$，你要求出一个数组长度为 $k$ 的期望分数对 $10^9+7$ 取模的结果。

$n\leq 5000$。

## Solution

先考虑给定数组怎么快速求最大前缀和。

显然可以直接求出每个前缀和，再取最大值，但是这样要记两个变量，很难放在 dp 里面。

另一个做法是倒着扫，维护 $s$ 表示当前扫过的后缀的最大前缀和，每次让 $s\leftarrow \max\{s+a_i,0\}$ 即可。

放到本题可以暴力枚举要求答案的前缀，设 $f_{i,j}$ 表示当前倒着扫到了 $i$，目前的最大前缀和为 $j$ 的概率，可以得到转移：$f_{i,j+1}\leftarrow p_if_{i+1,j},f_{i,\max\{j-1,0\}}\leftarrow (1-p_i)f_{i+1,j}$。

最后 $\sum f_{1,i}h_i$ 就是答案。

时间复杂度：$O(n^3)$。

---

这个做法慢在 dp 时要枚举前缀的后缀，dp 状态会很冗余。

考虑怎么正着扫做 dp。

先把这题状态转移的 DAG 建出来，每次相当于是求从一个点开始往后走的期望权值。由于不同前缀的 DAG 是一样的，所以可以让转移边反过来跑期望 dp。

具体的，设 $g_{i,j}$ 表示从末尾已经考虑到了 $i+1$，当前最大前缀和为 $j$ 的期望权值。可以的得到转移：$g_{i,j}=p_ig_{i-1,j+1}+(1-p_i)g_{i-1,\max\{j-1,0\}}$。

边界条件是 $g_{0,i}=h_i$，对于前缀 $[1,i]$ 的答案即为 $g_{i,0}$。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e3 + 5, kMod = 1e9 + 7;

int n;
int p[kMaxN], h[kMaxN], f[kMaxN][kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    p[i] = 1ll * x * qpow(y) % kMod;
  }
  for (int i = 0; i &lt;= n; ++i) std::cin &gt;&gt; h[i];
  for (int i = 0; i &lt;= n; ++i) f[0][i] = h[i];
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= n; ++j) {
      f[i][j] = add(1ll * p[i] * f[i - 1][j + 1] % kMod, 1ll * sub(1, p[i]) * f[i - 1][std::max(j - 1, 0)] % kMod);
    }
    std::cout &lt;&lt; f[i][0] &lt;&lt; ' ';
  }
  std::cout &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18383739.html</id>
    <title type="text">LOJ #160. 树形背包 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-27T15:33:00Z</published>
    <updated>2024-08-27T15:33:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18383739.html" />
    <content type="text">## Description

有 $N$ 个物品，编号分别为 $1\ldots N$。物品 $i$ 的重量为 $w_i$，价值为 $v_i$。

给出每个物品依赖于哪个物品。我们用 $d_i = j\ (i&gt;j&gt;0)$ 表示：如果要选取物品 $i$，就必须先选取物品 $j$。另外，我们用 $d_i = 0 (i&gt;0)$ 表示：该物品不依赖于任何物品。保证每个物品最多只依赖一个物品。保证依赖关系合理，不会出现环。

背包最多能装载的重量为 $W$，请问背包中最多能装入多大价值的物品。

$1\le N×W\le 6×10^7, 1\le N\le 5×10^4, 0\le W\le 6×10^4$

$1\le w_i\le 200,0\le v_i\le 5000$

## Solution

题目的限制相当于是要求出一个包含根的连通块使得重量之和不超过 $W$，并且让价值之和最大。

可以设 $f_{i,j}$ 表示 $i$ 的子树里包含 $i$ 的连通块重量之和为 $j$ 的最大价值。容易做到 $O(NW^2)$。

上面那个做法慢在要做 $N$ 次背包合并，单次背包合并就是 $O(W^2)$ 的，所以要找到一个不需要背包合并的做法。

考虑按照 dfs 序从后往前 dp。

假设当前枚举到了 $x$，则把 dfs 序大于等于 $x$ 的点拿出来一定构成若干个子树，并且这些子树互不相交。如果在这些点中选出一些不存在依赖关系问题的点，那么每个子树一定选了一个包含根的连通块。

设 $f_{i,j}$ 表示 dfs 序大于等于 $i$ 的点构成重量和为 $j$ 且不出现依赖关系问题的最大权值。

如果 $i$ 选，则后面只要不存在问题，加入 $i$ 后仍不出现问题，所以 $f_{i,j}\leftarrow f_{i+1,j-w_i}+v_i$。

如果 $i$ 不选，则 $i$ 的子树也不选，所以 $f_{i,j}\leftarrow f_{i+sz_i,j}$。

答案即为 $\max_{0\leq i\leq W}\{f_{1,i}\}$。

时间复杂度：$O(NW)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e4 + 5, kMaxT = 6.1e7 + 5;

int n, m;
int p[kMaxN], w[kMaxN], v[kMaxN], pool[kMaxT];
int dfn[kMaxN], sz[kMaxN], idx[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

void dfs(int u) {
  static int cnt = 0;
  idx[dfn[u] = ++cnt] = u, sz[u] = 1;
  for (auto v : G[u]) {
    dfs(v);
    sz[u] += sz[v];
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  memset(pool, 0xcf, sizeof(pool));
  int (&amp;f)[n + 2][m + 1] = decltype(f)(pool);
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; p[i];
    if (p[i]) G[p[i]].emplace_back(i);
  }
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; w[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; v[i];
  for (int i = 1; i &lt;= n; ++i)
    if (!p[i])
      dfs(i);
  f[n + 1][0] = 0;
  for (int i = n; i; --i) {
    for (int j = m; ~j; --j) {
      f[i][j] = f[i + sz[idx[i]]][j];
      if (j &gt;= w[idx[i]]) f[i][j] = std::max(f[i][j], f[i + 1][j - w[idx[i]]] + v[idx[i]]);
    }
  }
  std::cout &lt;&lt; *std::max_element(f[1], f[1] + 1 + m) &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18386625.html</id>
    <title type="text">P5469 [NOI2019] 机器人 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-29T06:59:00Z</published>
    <updated>2024-08-29T06:59:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18386625.html" />
    <content type="text">## Description

小 R 喜欢研究机器人。

最近，小 R 新研制出了两种机器人，分别是 `P` 型机器人和 `Q` 型机器人。现在他要测试这两种机器人的移动能力，测试在从左到右排成一排的 $n$ 个柱子上进行，柱子用 $1 - n$ 依次编号，$i$ 号柱子的高度为一个正整数 $h_i$。机器人**只能在相邻柱子间移动**，即：若机器人当前在 $i$ 号柱子上，它只能尝试移动到 $i - 1$ 号和 $i + 1$ 号柱子上。

每次测试，小 R 会选取一个起点 $s$，并将两种机器人均放置在 $s$ 号柱子上。随后它们会按自己的规则移动。

`P` 型机器人会一直**向左**移动，但它**无法**移动到比起点 $s$ **更高**的柱子上。更具体地，`P` 型机器人在 $l (l \leq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $l = 1$ 或 $h_{l-1} &gt; hs$。

- 对于满足 $l \leq j \leq s$ 的 $j$，有 $h_j \leq h_s$。

`Q` 型机器人会一直**向右**移动，但它**只能**移动到比起点 $s$ **更低**的柱子上。更具体地，`Q` 型机器人在 $r (r \geq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $r = n$ 或 $h_{r+1} \geq h_s$。

- 对于满足 $s &lt; j \leq r$ 的 $j$，有 $h_j &lt; h_s$。

现在，小 R 可以设置每根柱子的高度，$i$ 号柱子可选择的高度范围为 $[A_i, B_i]$，即 $A_i \leq h_i \leq B_i$。小 R 希望**无论**测试的起点 $s$ 选在哪里，两种机器人移动过的柱子数量的差的绝对值都**小于等于** $2$。他想知道有多少种柱子高度的设置方案满足要求，小 R 认为两种方案不同当且仅当存在一个 $k$，使得两种方案中 $k$ 号柱子的高度不同。请你告诉他满足要求的方案数模 $10^9 + 7$ 后的结果。

$1 \leq n \leq 300$ , $1 \leq A_i \leq B_i \leq 10^9$。

## Solution

不妨设当前要求区间 $[l,r]$ 的方案，最高的柱子的位置为 $p$（如果有相同的取最右边的那个），那么这个柱子一定满足 $|(p-l)-(r-p)|\leq 2$，并且这个柱子将整个序列划分成了两个互相没有关系的连续子序列，这样就可以 dp 了。

设 $f_{l,r,k}$ 表示区间 $[l,r]$ 的最大值不超过 $k$ 的方案数，可以得到转移：

$$
f_{l,r,k}=f_{l,r,k-1}+\sum_{\left [\left|(i-l)-(r-i)\right|\leq 2\right]}{f_{l,i-1,k}f_{i+1,r,k-1}}
$$

容易发现转移点是 $O(1)$ 级别的，所以时间复杂度为：$O(n^2V)$。

---

考虑优化。

注意到我们只需要求 $[1,n]$ 的答案，所以在求解 dp 的过程中很多状态都是无意义的，暴搜发现用到的区间最多 $2047$ 个，只需要对这些区间 dp 即可。

设有 $m$ 个用到的区间，时间复杂度就优化为了 $O(mV)$。

---

但这样还不够，现在需要把时间复杂度中的值域去掉。

考虑之前为什么需要枚举值域，这是因为对于不同的最大值，包含它的柱子是不一样的，就会导致转移方程不一样。

注意到不同的转移只有 $O(n)$ 种，所以可以离散化然后对于每个转移一样的连续段 $[L,R]$ 进行转移。

修改状态为 $f_{i,j}$ 表示第 $i$ 个区间，最大值不超过 $L+j-1$ 的方案数。可以得到转移：

$$
f_{i,j}=f_{i,j-1}+\sum_{k\in \text{next}_i}{f_{x_k,j}f_{y_k,j-1}}
$$

由于每个 $f_{i,j}$ 的转移式和 $f_{i,j-1}$ 的转移式除了第一维是一样的，所以 $f_{i,j}$ 可以表示为有关 $j$ 的 $R_i-L_i+1$ 次多项式。证明就考虑归纳法，如果 $f_{i,0},f_{i,1}\ldots f_{i,j-1}$ 的多项式系数一样，那么 $f_{i,j}$ 由于与之前这 $j$ 个 dp 的转移是一模一样的，所以其系数也和这些一样。

所以对于每个 $f_{i}$ 只需要维护 $f_{i,0},f_{i,1},\ldots f_{i,R_i-L_i+1}$ 的值，就可以插值求出 $f_{i,R-L+1}$。

时间复杂度：$O(n^2m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 305, kMaxM = 3e3 + 5, kMod = 1e9 + 7;

int n, m, cnt;
int l[kMaxN], r[kMaxN], unq[kMaxN * 2], id[kMaxN][kMaxN];
int f[kMaxM][kMaxN], g[kMaxM], fac[kMaxN], ifac[kMaxN], inv[kMaxN];
std::pair&lt;int, int&gt; seg[kMaxM];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; nxt[kMaxM];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dfs(int l, int r) {
  static bool vis[kMaxN][kMaxN];
  if (l &gt; r || vis[l][r]) return;
  seg[++cnt] = {l, r}, vis[l][r] = 1;
  for (int i = l; i &lt;= r; ++i) {
    if (abs(i - l - (r - i)) &lt;= 2) {
      dfs(l, i - 1), dfs(i + 1, r);
    }
  }
}

void gettrans() {
  dfs(1, n);
  std::sort(seg + 1, seg + 1 + cnt, [&amp;] (std::pair&lt;int, int&gt; &amp;p1, std::pair&lt;int, int&gt; &amp;p2) { return p1.second - p1.first &gt; p2.second - p2.first; });
  for (int i = 1; i &lt;= cnt; ++i) id[seg[i].first][seg[i].second] = i;
  for (int i = 1; i &lt;= cnt; ++i) {
    auto [l, r] = seg[i];
    for (int j = l; j &lt;= r; ++j)
      if (abs(j - l - (r - j)) &lt;= 2)
        nxt[i].emplace_back(j, id[l][j - 1], id[j + 1][r]);
  }
}

int getinv(int x) { return x &gt; 0 ? inv[x] : sub(0, inv[-x]); }

void discrete() {
  std::sort(unq + 1, unq + 1 + m);
  m = std::unique(unq + 1, unq + 1 + m) - (unq + 1);
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n + 3; ++i) {
    inv[i] = qpow(i);
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void prework() {
  for (int i = 1; i &lt;= n; ++i) unq[++m] = l[i], unq[++m] = r[i] + 1;
  discrete(), gettrans();
}

int getval(int *x, int n, int k) {
  static int pre[kMaxN], suf[kMaxN];
  int ans = 0;
  pre[0] = suf[n + 1] = 1;
  for (int i = 1; i &lt;= n; ++i) pre[i] = 1ll * pre[i - 1] * sub(k, i) % kMod;
  for (int i = n; i; --i) suf[i] = 1ll * suf[i + 1] * sub(k, i) % kMod;
  for (int i = 1; i &lt;= n; ++i) {
    int coef = 1ll * pre[i - 1] * suf[i + 1] % kMod * ifac[i - 1] % kMod * ifac[n - i] % kMod;
    if ((n - i) &amp; 1) coef = sub(0, coef);
    inc(ans, 1ll * coef * x[i] % kMod);
  }
  return ans;
}

void solve(int L, int R) {
  for (int i = cnt; i; --i) {
    for (int j = 1; j &lt;= n + 3; ++j) {
      f[i][j] = f[i][j - 1];
      for (auto [p, x, y] : nxt[i]) {
        if (L &gt;= l[p] &amp;&amp; R &lt;= r[p]) {
          inc(f[i][j], 1ll * f[x][j] * f[y][j - 1] % kMod);
        }
      }
    }
  }
  for (int i = 1; i &lt;= cnt; ++i) f[i][0] = getval(f[i], seg[i].second - seg[i].first + 2, R - L + 1);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; l[i] &gt;&gt; r[i];
  prework();
  std::fill_n(f[0], n + 4, 1);
  for (int i = 1; i &lt; m; ++i) solve(unq[i], unq[i + 1] - 1);
  std::cout &lt;&lt; f[1][0] &lt;&lt; '\n';
}

int32_t main() {
  freopen("robot.in", "r", stdin);
  freopen("robot.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18387709.html</id>
    <title type="text">P10013 [集训队互测 2023] Tree Topological Order Counting-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-29T15:19:00Z</published>
    <updated>2024-08-29T15:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18387709.html" />
    <content type="text">## Description

给定一颗 $n$ 个点的有根树，$1$ 是根，记 $u$ 的父亲是 $fa_u$。另给出一长度为 $n$ 的权值序列 $b$。

称一个长度为 $n$ 的排列 $a$ 为这颗树的合法拓扑序，当且仅当 $\forall 2 \le u \le n,a_u &gt; a_{fa_u}$。

对每个点 $u$，定义 $f(u)$ 为，在所有这颗树的合法拓扑序中，$b_{a_u}$ 之和。

现在对 $1 \le u \le n$，求 $f(u) \bmod 10^9+7$。

$2 \le n \le 5000$，$1 \le fa_i &lt; i$，$0 \le b_i &lt; 10^9+7$。

## Solution

先考虑对于每个 $x$ 怎么求出答案。

假设当前处理到了节点 $u$（要求 $u$ 是 $x$ 的祖先），$v$ 为 $u$ 的儿子中子树包含 $x$ 的儿子。

设 $f_u$ 表示 $u$ 的子树的合法拓扑序数量，$g_{u,i}$ 表示 $u$ 的子树里已经钦定恰好有 $i$ 个点 dfs 序小于 $x$ 的方案数，$h_u$ 表示 $u$ 的子树去掉包含 $x$ 的子树剩下的点的合法拓扑序数。可以得到转移：

$$
\begin{aligned}
f_u&amp;=(sz_u-1)!\prod_{w\in \text{son}_u}{f_w/(sz_w!)}\\
h_u&amp;=\prod_{w\in \text{son}_u,w\neq v}{f_w/(sz_w!)}\\
g_{u,i+j+1}&amp;=\sum_{0\leq i\leq sz_v-1,0\leq j\leq sz_u-sz_v-1}{\binom{i+j}{j}\binom{sz_u-i-j-2}{sz_v-i-1}h_ug_{v,i}}
\end{aligned}
$$

最终的答案即为 $\sum_{i=1}^{n}{g_{1,i-1}b_i}$。

时间复杂度：$O(n^3)$。

---

考虑怎么优化。

容易发现这题主要慢在每次要处理从一个点到根的路径上的 dp，而不是从根到某个点的路径，这样会导致每个点之间的信息没有任何交集。

注意到这题转移的终点是一定的，就是根，而起点不一样。所以可以类似[这题](https://www.cnblogs.com/Scarab/p/18383703)的思路把转移倒过来做。

具体的，将 $g_{u,i}$ 的状态改为当前状态为 $(u,i)$，到最终状态对答案的贡献。转移改为：

$$
g_{v,i}=\sum_{0\leq i\leq sz_v-1,0\leq j\leq sz_u-sz_v-1}{\binom{i+j}{j}\binom{sz_u-i-j-2}{sz_v-i-1}h_ug_{u,i+j+1}}
$$

最终 $x$ 的答案就是 $f_xg_{x,0}$。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 5e3 + 5, kMod = 1e9 + 7;

int n;
int a[kMaxN], C[kMaxN][kMaxN], sz[kMaxN], f[kMaxN], g[kMaxN][kMaxN];
std::vector&lt;int&gt; G[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework() {
  C[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    C[i][0] = 1;
    for (int j = 1; j &lt;= i; ++j)
      C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);
  }
}

void dfs1(int u) {
  f[u] = 1, sz[u] = 0;
  for (auto v : G[u]) {
    dfs1(v);
    f[u] = 1ll * f[u] * f[v] % kMod * C[sz[u] += sz[v]][sz[v]] % kMod;
  }
  ++sz[u];
}

void dfs2(int u) {
  for (auto v : G[u]) {
    int coef = 1, now = 0;
    for (auto w : G[u]) {
      if (w != v) coef = 1ll * coef * f[w] % kMod * C[now += sz[w]][sz[w]] % kMod;
    }
    for (int i = 0; i &lt;= sz[v] - 1; ++i)
      for (int j = 0; j &lt;= sz[u] - sz[v] - 1; ++j)
        inc(g[v][i], 1ll * coef * C[i + j][j] % kMod * C[sz[u] - i - j - 2][sz[v] - i - 1] % kMod * g[u][i + j + 1] % kMod);
    dfs2(v);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 2; i &lt;= n; ++i) {
    int p;
    std::cin &gt;&gt; p;
    G[p].emplace_back(i);
  }
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  prework();
  for (int i = 1; i &lt;= n; ++i) g[1][i - 1] = a[i];
  dfs1(1), dfs2(1);
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; 1ll * f[i] * g[i][0] % kMod &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18388122.html</id>
    <title type="text">P6192 【模板】最小斯坦纳树 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-30T02:19:00Z</published>
    <updated>2024-08-30T02:19:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18388122.html" />
    <content type="text">## Description

给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。

再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G'=(V',E')$，使得：

1. $S\subseteq V'$；

2. $G'$ 为连通图；

3. $E'$ 中所有边的权值和最小。

你只需要求出 $E'$ 中所有边的权值和。

$1\leq n\leq 100,\ \ 1\leq m\leq 500,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^6$。

## Solution

求出的图一定是树，因为如果有环删掉环边一定更优。

假设已经求出了这个树，那么对于树上的每个点 $u$，可以记录 $S$ 表示 $u$ 的子树出现的关键点集合。利用这个集合可以在图上模拟选树的儿子的过程。

设 $f_{i,S}$ 表示图上与 $i$ 连通的树包含 $S$ 集合对应的关键点的最小边权和，可以得到两种转移：

1. $i$ 在树上的儿子有 $\geq 2$ 个或者 $i$ 为关键点，则儿子的集合一定小于 $S$ 且互不相交，所以可以直接枚举儿子的集合然后求并就是答案。
2. $i$ 在树上只有一个儿子且 $i$ 不为关键点，转移一定形如 $f_{i,S}\leftarrow f_{j,S}+w$，跑 dijkstra 即可。

对于第一种转移实现上有一些细节，如果每次是先枚举 $S$ 和 $i$ 再枚举 $i$ 的邻域的状态合并，这样单次就是 $O(3^{|S|})$。正确做法是直接让 $f_{i,S}\leftarrow f_{i,S-T}+f_{i,T}$，因为 $&lt;S$ 的答案已经确定。这样做转移一的总时间复杂度就是 $O(3^kn)$ 了。

容易发现这么 dp 不会出现不合法的情况，并且最优解一定会被算到。

时间复杂度：$O(3^kn+2^km\log m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 105, kMaxS = (1 &lt;&lt; 10);

int n, m, k;
int f[kMaxN][kMaxS], id[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dijkstra(int s) {
  static bool vis[kMaxN];
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    q.emplace(-f[i][s], i), vis[i] = 0;
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w] : G[u]) {
      if (f[v][s] &gt; f[u][s] + w) {
        f[v][s] = f[u][s] + w;
        q.emplace(-f[v][s], v);
      }
    }
  }
}

void solve() {
  memset(f, 0x3f, sizeof(f));
  for (int i = 1; i &lt;= n; ++i) f[i][id[i] ? (1 &lt;&lt; (id[i] - 1)) : 0] = 0;
  for (int s = 0; s &lt; (1 &lt;&lt; k); ++s) {
    for (int i = 1; i &lt;= n; ++i) {
      for (int t = s; t; t = (t - 1) &amp; s)
        f[i][s] = std::min(f[i][s], f[i][s ^ t] + f[i][t]);
    }
    dijkstra(s);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
  }
  for (int i = 1; i &lt;= k; ++i) {
    int x;
    std::cin &gt;&gt; x;
    id[x] = i;
  }
  solve();
  int ans = 1e9;
  for (int i = 1; i &lt;= n; ++i) ans = std::min(ans, f[i][(1 &lt;&lt; k) - 1]);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18390883.html</id>
    <title type="text">LOJ #6089. 小 Y 的背包计数问题 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-08-31T14:43:00Z</published>
    <updated>2024-08-31T14:43:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18390883.html" />
    <content type="text">## Description

小 Y 有一个大小为 $n$ 的背包，并且小 Y 有 $n$ 种物品。

对于第 $i$ 种物品，共有 $i$ 个可以使用，并且对于每一个 $i$ 物品，体积均为 $i$。

求小 Y 把该背包装满的方案数为多少，答案对于 $23333333$ 取模。

定义两种不同的方案为：当且仅当至少存在一种物品的使用数量不同。

$1\leq n\leq 10^5$。

## Solution

首先有个暴力的做法是设 $f_{i,j}$ 表示前 $i$ 种物品，体积为 $j$ 的方案数，那么可以得到转移：

$$
f_{i,j}=\sum_{k=0}^{i}{f_{i-1,j-ik}}
$$

注意到转移到 $j$ 的一定是与 $j$ 模 $i$ 同余的数的连续段，用前缀和维护即可做到 $O(n^2)$。

容易发现上面那个做法慢在没有利用到某些物品出现次数不多的性质。

可以考虑对于 $\leq\sqrt n$ 的数可以暴力做。而 $&gt;\sqrt n$ 的数不可能达到次数限制并且这部分最多选 $\sqrt n$ 个，要单独处理。

如果直接 dp 显然无法用到选的个数不多的性质。

注意到如果把第 $i$ 种物品看成长度为 $i$ 的竖条，那么刚才那个做法是横着进行 dp。又因为列数是不多的，所以可以考虑竖着 dp。这样相当于就是对不超过 $\sqrt n$ 个物品进行多重背包。

具体的，可以从高向低枚举，每次有两种操作：加入一个高度为 $\sqrt n+1$ 的长条，和将当前已经加进去的长条整体长度加 $1$。显然这两种操作可以构造出所有合法的序列。

设 $f_{i,j}$ 表示当前有 $i$ 个长条，长度之和为 $j$ 的方案数，转移如下：$f_{i,j+i}\leftarrow f_{i,j},f_{i+1,j+\sqrt n+1}\leftarrow f_{i,j}$。

最后求答案就将两个部分拼起来即可。

时间复杂度：$O(n\sqrt n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5, kMaxB = 325, kMod = 23333333;

int n, b;
int f[kMaxN], g[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void solve1() {
  static int sum[kMaxN];
  f[0] = 1;
  for (int i = 1; i &lt;= b; ++i) {
    for (int j = 0; j &lt;= n; ++j) {
      sum[j] = add(f[j], (j &lt; i) ? 0 : sum[j - i]);
      int p = j - i * (i + 1);
      f[j] = sub(sum[j], (p &lt; 0) ? 0 : sum[p]);
    }
  }
}

void solve2() {
  static int f[kMaxB][kMaxN];
  f[0][0] = 1;
  for (int i = 0; i &lt;= n / b; ++i) {
    for (int j = 0; j &lt;= n; ++j) {
      if (i &amp;&amp; j + i &lt;= n) inc(f[i][j + i], f[i][j]);
      if (j + b + 1 &lt;= n) inc(f[i + 1][j + b + 1], f[i][j]);
      inc(g[j], f[i][j]);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  b = sqrt(n);
  solve1(), solve2();
  int ans = 0;
  for (int i = 0; i &lt;= n; ++i) inc(ans, 1ll * f[i] * g[n - i] % kMod);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18400977.html</id>
    <title type="text">20240906 模拟赛 T3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-06T12:54:00Z</published>
    <updated>2024-09-06T12:54:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18400977.html" />
    <content type="text">## Description

你有 $2n$ 个点和 $m$ 条边，每个点 $i$ 对应着一组 $m+1$ 个整数 $p_{i,0},p_{i,1},\ldots,p_{i,m}$，表示当点 $i$ 的度数为 $j$ 时会带来 $p_{i,j}$ 的代价。

你需要求出一张左边为点 $1\sim n$，右边为点 $n+1\sim 2n$，边数恰为 $m$ 的二分图，满足所有点的代价之和最小，且这张二分图的最大匹配数在 $[l,r]$ 之间。

**数据保证有解**。

你只需要输出最小代价和。

$1\leq n,m\leq 40,0\leq l\leq r\leq n,|p_{i,j}|\leq 10^9$。

## Solution

假设没有最大匹配的限制就只要让左右的点的度数之和均为 $m$ 即可，考虑怎么更好地表示最大匹配。

容易发现可以将最大匹配转化为最小点覆盖。

设 $L$ 表示左部点度数不为 $0$ 的点集，$R$ 表示右部点度数不为 $0$ 的点集，最大匹配为 $x$。

结论是最大匹配为 $x$ 等价于存在左部点集合 $P$，右部点集合 $Q$，满足 $|P|+|Q|=x$，$L-P$ 与 $R-Q$ 无连边，且 $P$ 与 $R-Q$ 存在大小为 $|P|$ 的匹配，$Q$ 与 $L-P$ 存在大小为 $|Q|$ 的匹配。

证明就考虑如果满足这个条件，最大匹配一定不小于 $|P|+|Q|=x$。并且由于 $L-P$ 和 $R-Q$ 没有连边，所以最大匹配不超过 $x$，于是最大匹配就是 $x$。

如果最大匹配为 $x$，则令最大独立集的左部点为 $L-P$，右部点为 $R-Q$，容易发现此时的 $P$ 和 $Q$ 一定满足条件。

基于这个结论就可以设计 dp 了。设 $f_{i,j,k,w}$ 表示 $P$ 的点数为 $i$，$L-P$ 的点数为 $j$，$P$ 的度数和为 $k$，$L-P$ 的度数和为 $w$ 的最小权值和，$g_{i,j,k,w}$ 表示右边的，这两个容易 dp 求出。

那么 $f_{i_1,j_1,k_1,m-k_1}+g_{i_2,j_2,k_2,m-k_2}$ 能对答案造成贡献，等价于 $l\leq i_1+i_2\leq r,i_1\geq j_2,i_2\geq j_1,k_1\geq m-k_2,k_2\geq m-k_1$，判断一下即可。

时间复杂度：$O(n^3m^3+n^4m^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 45;

int n, m, l, r;
int a[kMaxN][kMaxN], b[kMaxN][kMaxN], f[kMaxN][kMaxN][kMaxN][kMaxN], g[kMaxN][kMaxN][kMaxN][kMaxN];

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 0; j &lt;= m; ++j)
      std::cin &gt;&gt; a[i][j];
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 0; j &lt;= m; ++j)
      std::cin &gt;&gt; b[i][j];
  memset(f, 0x3f, sizeof(f)), memset(g, 0x3f, sizeof(g));
  f[0][0][0][0] = g[0][0][0][0] = 0;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = i - 1; ~j; --j) {
      for (int k = i - 1 - j; ~k; --k) {
        for (int dj = m; ~dj; --dj) {
          for (int dk = m - dj; ~dk; --dk) {
            for (int d = 1; d &lt;= m - dj - dk; ++d) {
              f[j + 1][k][dj + d][dk] = std::min(f[j + 1][k][dj + d][dk], f[j][k][dj][dk] + a[i][d]);
              f[j][k + 1][dj][dk + d] = std::min(f[j][k + 1][dj][dk + d], f[j][k][dj][dk] + a[i][d]);
              g[j + 1][k][dj + d][dk] = std::min(g[j + 1][k][dj + d][dk], g[j][k][dj][dk] + b[i][d]);
              g[j][k + 1][dj][dk + d] = std::min(g[j][k + 1][dj][dk + d], g[j][k][dj][dk] + b[i][d]);
            }
            f[j][k][dj][dk] += a[i][0];
            g[j][k][dj][dk] += b[i][0];
          }
        }
      }
    }
  }
  int ans = 1e18;
  for (int i = 0; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= n; ++j) {
      if (i + j &lt; l || i + j &gt; r) continue;
      for (int k = j; k &lt;= n - i; ++k)
        for (int w = i; w &lt;= n - j; ++w)
          for (int di = 0; di &lt;= m; ++di)
            for (int dj = m - di; dj &lt;= m; ++dj)
              ans = std::min(ans, f[i][k][di][m - di] + g[j][w][dj][m - dj]);
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18401650.html</id>
    <title type="text">CF1991E Coloring Game 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-07T06:25:00Z</published>
    <updated>2024-09-07T06:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18401650.html" />
    <content type="text">## Description

有一个由 $n$ 个顶点和 $m$ 条边组成的无向图。每个顶点可以用三种颜色之一着色： $1$ 、 $2$ 或 $3$ 。初始时，所有顶点都未着色。

Alice 和 Bob 正在玩一个包含 $n$ 轮的游戏。在每一轮中，都会发生以下两个步骤：

1. Alice 选择两种**不同**的颜色。
2. Bob 选择一个未着色的结点，并用 Alice 选择的两种颜色之一为其着色。

如果存在连接两个相同颜色结点的边，则 Alice 获胜。否则 Bob 获胜。

给你这个图。您的任务是决定您想扮演哪位玩家并赢得游戏。

## Solution

首先观察样例会发现有奇环时是 Alice 胜，只有一个偶环就是 Bob 胜。

于是可以猜测图不为二分图时 Alice 胜，否则 Bob 胜。

操作就考虑不为二分图时，Alice 只要一直询问 $(1,2)$，Bob 无论怎么放颜色也无法做到让奇环上相邻的点颜色不一样。

图为二分图时，先假设左部点颜色为 $1$，右部点颜色为 $2$。Alice 每次询问 $(x,y)$ 时，如果 $x$ 和 $y$ 中有至少一个满足小于等于 $2$ 且其在原图中对应的左部/右部点没染完，就染那个满足条件的颜色。

否则一定满足左部/右部点中有至少一边被染完了，且询问的为被染完的颜色和 $3$。这样只需要让被染完的那边染 $3$ 即可。

时间复杂度：$O(n+m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e4 + 5;

int n, m;
int col[kMaxN];
bool fl = 1;
std::vector&lt;int&gt; G[kMaxN], id[2];

void dfs(int u) {
  id[col[u] - 1].emplace_back(u);
  for (auto v : G[u]) {
    if (!col[v]) {
      col[v] = 3 - col[u];
      dfs(v);
    } else if (col[v] == col[u]) {
      fl = 0;
    }
  }
}

bool check() {
  fl = 1, id[0].clear(), id[1].clear();
  for (int i = 1; i &lt;= n; ++i) {
    if (!col[i]) {
      col[i] = 1, dfs(i);
    }
  }
  return fl;
}

void dickdreamer() {
  for (int i = 1; i &lt;= n; ++i) G[i].clear(), col[i] = 0;
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  if (!check()) {
    std::cout &lt;&lt; "Alice" &lt;&lt; std::endl;
    for (int i = 1; i &lt;= n; ++i) {
      std::cout &lt;&lt; "1 2" &lt;&lt; std::endl;
      int x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
    }
  } else {
    std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;
    for (int i = 1; i &lt;= n; ++i) {
      int x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
      if (x &gt; y) std::swap(x, y);
      if (x &lt;= 2 &amp;&amp; id[x - 1].size()) {
        std::cout &lt;&lt; id[x - 1].back() &lt;&lt; ' ' &lt;&lt; x &lt;&lt; std::endl;
        id[x - 1].pop_back();
      } else if (y &lt;= 2 &amp;&amp; id[y - 1].size()) {
        std::cout &lt;&lt; id[y - 1].back() &lt;&lt; ' ' &lt;&lt; y &lt;&lt; std::endl;
        id[y - 1].pop_back();
      } else {
        std::cout &lt;&lt; id[2 - x].back() &lt;&lt; ' ' &lt;&lt; y &lt;&lt; std::endl;
        id[2 - x].pop_back();
      }
    }
  }
}

int32_t main() {
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18401852.html</id>
    <title type="text">CF1991F Triangle Formation 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-07T08:33:00Z</published>
    <updated>2024-09-07T08:33:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18401852.html" />
    <content type="text">## Description

你有 $n$ 根棍子，从 $1$ 到 $n$ 编号。第 $i$ 根棍子的长度是 $a_i$。

你需要回答 $q$ 个问题。在每个查询中，你会得到两个整数 $l$ 和 $r$（$1 \le l &lt; r \le n，r − l + 1 \ge 6$）。确定是否可以从编号为 $l$ 到 $r$ 的棒中选择 $6$ 个不同的棒，形成 $2$ 个非退化三角形。

边长为 $a$、$b$ 和 $c$ 的三角形称为非退化三角形，当且仅当 $a&lt;b+c,b&lt;a+c,c&lt;a+b$。

## Solution

先考虑什么样的序列存在至少一个三角形。容易发现把序列排序后，如果存在三角形，则必存在一个长度为 $3$ 的连续区间满足条件。

而如果不存在，则一定满足 $a_i\geq a_{i-1}+a_{i-2}$。经过计算，这样的序列长度一定不超过 $45$，即长度不小于 $45$ 的序列一定存在至少一个三角形。

回到这个题。利用上面那个结论可以得出序列长度 $\geq 48$ 时一定存在答案，因为这里至少存在一个三角形，去掉这个三角形后还剩 $45$ 个数，所以存在第二个。

于是 $r-l+1\geq 48$ 时必然有解，现在需要判断 $r-l+1\leq 47$ 时是否有解。

同样是先排序，把所有形如 $(i,i+1,i+2)$ 且满足 $a_i+a_{i+1}&gt;a_{i+2}$ 的数对拿出来，如果存在两个数对不相交则一定有解。

如果不存在则说明最终的两个三角形是相交的，就像 $(1,2,4),(3,5,6)$ 这种。注意到这时选的 $6$ 个数如果不是连续的 $6$ 个则调整成连续的一定更优，所以只需要对于所有连续的 $6$ 个数暴力判断即可。

时间复杂度：$O(n\log V\log\log V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n, q;
int a[kMaxN];

bool check(int64_t x, int64_t y, int64_t z) {
  return x + y &gt; z &amp;&amp; x + z &gt; y &amp;&amp; y + z &gt; x;
}

bool check(int l, int r) {
  std::vector&lt;int&gt; vec;
  for (int i = l; i &lt;= r; ++i) vec.emplace_back(a[i]);
  std::sort(vec.begin(), vec.end());
  int mi = 1e9;
  for (int i = 2; i &lt; (int)vec.size(); ++i) {
    if (check(vec[i - 2], vec[i - 1], vec[i])) {
      if (i - 2 &gt; mi) return 1;
      if (mi == 1e9) mi = i;
    }
  }
  for (int i = 0; i + 5 &lt; (int)vec.size(); ++i) {
    if (check(vec[i], vec[i + 1], vec[i + 2]) &amp;&amp; check(vec[i + 3], vec[i + 4], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 1], vec[i + 3]) &amp;&amp; check(vec[i + 2], vec[i + 4], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 1], vec[i + 4]) &amp;&amp; check(vec[i + 2], vec[i + 3], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 1], vec[i + 5]) &amp;&amp; check(vec[i + 2], vec[i + 3], vec[i + 4])) return 1;
    if (check(vec[i], vec[i + 2], vec[i + 3]) &amp;&amp; check(vec[i + 1], vec[i + 4], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 2], vec[i + 4]) &amp;&amp; check(vec[i + 1], vec[i + 3], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 2], vec[i + 5]) &amp;&amp; check(vec[i + 1], vec[i + 3], vec[i + 4])) return 1;
    if (check(vec[i], vec[i + 3], vec[i + 4]) &amp;&amp; check(vec[i + 1], vec[i + 2], vec[i + 5])) return 1;
    if (check(vec[i], vec[i + 3], vec[i + 5]) &amp;&amp; check(vec[i + 1], vec[i + 2], vec[i + 4])) return 1;
    if (check(vec[i], vec[i + 4], vec[i + 5]) &amp;&amp; check(vec[i + 1], vec[i + 2], vec[i + 3])) return 1;
  }
  return 0;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= q; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    if (r - l + 1 &gt;= 48) std::cout &lt;&lt; "YES\n";
    else std::cout &lt;&lt; (check(l, r) ? "YES\n" : "NO\n");
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18403357.html</id>
    <title type="text">zroi 24noip 十连测 day2 T4 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-08T12:13:00Z</published>
    <updated>2024-09-08T12:13:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18403357.html" />
    <content type="text">## Description

小凯有两个长度为 $N$ 的整数序列 $A_1,A_2,\cdots,A_N$ 和 $B_1,B_2,\cdots,B_N$。

小凯现在越来越喜欢对称的东西了，当他看到两个序列 $C,D$ 时，他会找到序列 $C$ 的最小值 $Cmin$ 和 $D$ 的最小值 $Dmin$，他认为这两个最小值相差越小越好，所以他定义 $f(C,D)=|Cmin-Dmin|$。

更进一步的，他定义 $w(l,r)$ 表示当 $C=\{A_l,A_{l+1},\cdots,A_r\},D=\{B_l,B_{l+1},\cdots,B_r\} $ 时 $f(C,D)$ 的值，即 $\{A_l,A_{l+1},\cdots,A_r\}$ 的最小值和 $\{B_l,B_{l+1},\cdots,B_r\}$ 的最小值的差的绝对值。

对于每个 $k=1,2,\cdots,N$，小凯想求出所有长度为 $k$  的区间 $[l,r]$ 中，$w(l,r)$ 的最小值，即求 $\min_{r-l+1=k} w(l,r)$。

$1\leq N\leq 2\times 10^5,1\leq A_i,B_i\leq 10^9$。

## Solution

首先直接做显然是没有任何性质的，考虑分治。

假设当前处理的是区间 $[L,R]$，$mid=(L+R)/2$，考虑跨越 $[L,mid]$ 和 $[mid+1,R]$ 的贡献。

设

- $a_i=\min\left\{A_i,A_{i+1},\ldots,A_{mid}\right\}$
- $b_i=\min\left\{B_i,B_{i+1},\ldots,B_{mid}\right\}$
- $c_i=\min\left\{A_{mid+1},A_{mid+2},\ldots,A_{i}\right\}$
- $d_i=\min\left\{A_{mid+1},A_{mid+2},\ldots,A_{i}\right\}$

那么对于一个跨越 $mid$ 的区间 $[l,r]$ 的答案就是 $\left|\min\left\{a_l,c_r\right\}-\min\left\{b_l,d_r\right\}\right|$。

枚举 $r-l$，令 $k=r-l$，$w(l,r)$ 转化为 $\left|\min\left\{a_l,c_{l+k}\right\}-\min\left\{b_l,d_{l+k}\right\}\right|$。由于 $a,b$ 是不降的，$c,d$ 是不增的，所以可以二分出 $w(l,r)=|a_l-b_l|,|a_l-d_r|,|c_r-b_l|,|c_r-d_r|$ 分别对应的连续的区间。

对于 $w(l,r)=|a_l-b_l|\ 或\ |c_r-d_r|$ 的情况可以用线段树维护区间最小值。

而对于 $w(l,r)=|a_l-d_r|$ 的情况，因为 $a_l$ 不降且 $d_r$ 不增，所以固定区间长度后 $w(l,r)$ 关于 $l$ 是个单谷函数，于是二分出 $a_l\geq d_r$ 的最大 $l$ 和 $a_l&lt;d_r$ 的最小 $l$ 即可。$w(l,r)=|c_r-b_l|$ 的情况同理。

时间复杂度：$O(n\log^2n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN], b[kMaxN], ans[kMaxN], mila[kMaxN], milb[kMaxN], mira[kMaxN], mirb[kMaxN];

struct SGT {
  int N, mi[kMaxN * 4];

  void build(int n) {
    memset(mi, 0x3f, sizeof(mi));
    for (N = 1; N &lt;= n + 2; N &lt;&lt;= 1) {}
  }

  void update(int x, int v) {
    mi[x += N] = v;
    for (x &gt;&gt;= 1; x; x &gt;&gt;= 1) mi[x] = std::min(mi[x &lt;&lt; 1], mi[x &lt;&lt; 1 | 1]);
  }

  int query(int l, int r) {
    int ret = 1e9;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if (~l &amp; 1) ret = std::min(ret, mi[l ^ 1]);
      if (r &amp; 1) ret = std::min(ret, mi[r ^ 1]);
    }
    return ret;
  }
} sgt;

int func(int x, int k) {
  return abs(std::min(mila[x], mira[x + k]) - std::min(milb[x], mirb[x + k]));
}

void solve(int l, int r) {
  if (l == r) return void(ans[1] = std::min(ans[1], abs(a[l] - b[l])));
  int mid = (l + r) &gt;&gt; 1;
  solve(l, mid), solve(mid + 1, r);
  mila[mid] = a[mid], milb[mid] = b[mid], mira[mid + 1] = a[mid + 1], mirb[mid + 1] = b[mid + 1];
  for (int i = mid - 1; i &gt;= l; --i) {
    mila[i] = std::min(mila[i + 1], a[i]);
    milb[i] = std::min(milb[i + 1], b[i]);
  }
  for (int i = mid + 2; i &lt;= r; ++i) {
    mira[i] = std::min(mira[i - 1], a[i]);
    mirb[i] = std::min(mirb[i - 1], b[i]);
  }
  for (int i = l; i &lt;= r; ++i) {
    if (i &lt;= mid) sgt.update(i, abs(mila[i] - milb[i]));
    else sgt.update(i, abs(mira[i] - mirb[i]));
  }
  for (int k = 1; k &lt;= r - l; ++k) {
    int ll = std::max(l, mid + 1 - k), rr = std::min(mid, r - k);
    if (ll &gt; rr) continue;
    int L = ll - 1, R = rr + 1, p1 = ll - 1, p2 = ll - 1;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (mila[mid] &lt;= mira[mid + k]) L = p1 = mid;
      else R = mid;
    }
    L = ll - 1, R = rr + 1;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (milb[mid] &lt;= mirb[mid + k]) L = p2 = mid;
      else R = mid;
    }
    if (ll &lt;= std::min(p1, p2)) ans[k + 1] = std::min(ans[k + 1], sgt.query(ll, std::min(p1, p2)));
    if (std::max(p1, p2) &lt; rr) ans[k + 1] = std::min(ans[k + 1], sgt.query(std::max(p1, p2) + 1 + k, rr + k));
    if (p1 == p2) continue;
    if (p1 &lt; p2) {
      int L = p1 + 1, R = p2 + 1, res = p1 + 1;
      while (L + 1 &lt; R) {
        int mid = (L + R) &gt;&gt; 1;
        if (mira[mid + k] &gt;= milb[mid]) L = res = mid;
        else R = mid;
      }
      ans[k + 1] = std::min(ans[k + 1], func(res, k));
      if (res &lt; p2) ans[k + 1] = std::min(ans[k + 1], func(res + 1, k));
    } else {
      int L = p2 + 1, R = p1 + 1, res = p2 + 1;
      while (L + 1 &lt; R) {
        int mid = (L + R) &gt;&gt; 1;
        if (mirb[mid + k] &gt;= mila[mid]) L = res = mid;
        else R = mid;
      }
      ans[k + 1] = std::min(ans[k + 1], func(res, k));
      if (res &lt; p1) ans[k + 1] = std::min(ans[k + 1], func(res + 1, k));
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; b[i];
  memset(ans, 0x3f, sizeof(ans));
  sgt.build(n);
  solve(1, n);
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18406589.html</id>
    <title type="text">CF717A Festival Organization 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-10T08:05:00Z</published>
    <updated>2024-09-10T08:05:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18406589.html" />
    <content type="text">## Description

一个合法的串定义为：长度在 $[l,r]$ 之间，且只含 `0`,`1`，并且不存在连续 $2$ 个或更多的 $0$。

现在要选出 $k$ 个长度相同的合法的串，问有几种选法，答案模 $10^9+7$。

$1\leq k\leq 200,1\leq l\leq r\leq 10^{18}$。

## Solution

容易发现答案为 $\sum_{i=l+2}^{r+2}{\binom{Fib_i}{k}}$。先将 $l,r$ 都加 $2$，题目就转化为了求 $\sum_{i=l}^{r}{Fib_i^{\underline{k}}}$。

注意到下降幂是不好做区间求和的，考虑用第一类斯特林数转化为普通幂：

$$
x^{\underline{k}}=\sum_{i=0}^{k}{(-1)^{k-i}{k\brack i}x^i}
$$

于是题目相当于是求斐波那契数列的 $k$ 次区间和。

但是斐波那契数列的 $k$ 次区间和仍然是无法做的，注意到等比数列是可以求区间和的，所以可以用通项公式将斐波那契数转化成幂次再求和：

$$
\begin{aligned}
Fib_i^k&amp;=\left[\left(\frac{1+\sqrt 5}{2}\right)^i-\left(\frac{1-\sqrt 5}{2}\right)^i\right]^k\\
&amp;=\sum_{j=0}^{i}{\binom{i}{j}\left(\frac{1+\sqrt 5}{2}\right)^{ij}\left(\frac{1-\sqrt 5}{2}\right)^{i(k-j)}}\\
&amp;=\sum_{j=0}^{i}{\binom{i}{j}\left[\left(\frac{1+\sqrt 5}{2}\right)^{j}\left(\frac{1-\sqrt 5}{2}\right)^{k-j}\right]^i}
\end{aligned}
$$

这样就可以做了。但是有个问题，就是 $\sqrt 5$ 在 $\bmod 10^9+7$ 意义下没有定义，所以需要维护一个形如 $a+b\sqrt 5$ 的类。

注意等比数列的比为 $1$ 的情况要特判。

时间复杂度：$O(k^2\log r)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxK = 205, kMod = 1e9 + 7, kInv2 = 500000004, kInv5 = 400000003;

int k, l, r;
int C[kMaxK][kMaxK], S[kMaxK][kMaxK], fac[kMaxK], ifac[kMaxK];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int getop(int x) { return (~x &amp; 1) ? 1 : (kMod - 1); }

struct Node {
  int a, b; // a + b * sqrt(5)

  Node(int _a = 0, int _b = 0) : a(_a), b(_b) {}

  Node inv() {
    int k = qpow(sub(1ll * a * a % kMod, 5ll * b % kMod * b % kMod));
    return {1ll * a * k % kMod, 1ll * sub(0, b) * k % kMod};
  }

  friend bool operator ==(Node a, Node b) { return a.a == b.a &amp;&amp; a.b == b.b; }
  friend Node operator +(Node a, Node b) { return {add(a.a, b.a), add(a.b, b.b)}; }
  friend Node operator -(Node a, Node b) { return {sub(a.a, b.a), sub(a.b, b.b)}; }
  friend Node operator *(Node a, Node b) { return {add(1ll * a.a * b.a % kMod, 5ll * a.b % kMod * b.b % kMod), add(1ll * a.a * b.b % kMod, 1ll * a.b * b.a % kMod)}; }
  friend Node operator /(Node a, Node b) { return a * b.inv(); }
  friend Node operator -(Node a) { return {sub(0, a.a), sub(0, a.b)}; }
};

Node qpow(Node bs, int idx) {
  Node ret = {1, 0};
  for (; idx; idx &gt;&gt;= 1, bs = bs * bs)
    if (idx &amp; 1)
      ret = ret * bs;
  return ret;
}

int getsum(int n, int k) {
  if (!n) return 0;
  Node ret = {0, 0}, a = {kInv2, kInv2}, b = {kInv2, sub(0, kInv2)};
  for (int i = 0; i &lt;= k; ++i) {
    Node bs = qpow(a, i) * qpow(b, k - i), sum = {0, 0};
    if (bs == (Node){1, 0}) sum = {n % kMod, 0};
    else sum = (qpow(bs, n + 1) - bs) / (bs - (Node){1, 0});
    if (~(k - i) &amp; 1) ret = ret + sum * (Node){C[k][i], 0};
    else ret = ret - sum * (Node){C[k][i], 0};
  }
  if (~k &amp; 1) return 1ll * ret.a * qpow(kInv5, k / 2) % kMod;
  else return 1ll * ret.b * qpow(kInv5, k / 2) % kMod;
}

int getsum(int l, int r, int k) {
  return sub(getsum(r, k), getsum(l - 1, k));
}

void prework() {
  fac[0] = ifac[0] = C[0][0] = S[0][0] = 1, 1;
  for (int i = 1; i &lt;= 200; ++i) {
    C[i][0] = 1;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = qpow(fac[i]);
    for (int j = 1; j &lt;= i; ++j) {
      C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
      S[i][j] = add(S[i - 1][j - 1], 1ll * (i - 1) * S[i - 1][j] % kMod);
    }
  }
}

void dickdreamer() {
  prework();
  std::cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;
  l += 2, r += 2;
  int ans = 0;
  for (int i = 0; i &lt;= k; ++i) {
    inc(ans, 1ll * S[k][i] * getop(k - i) % kMod * getsum(l, r, i) % kMod);
  }
  std::cout &lt;&lt; 1ll * ans * ifac[k] % kMod &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18411624.html</id>
    <title type="text">CF1687D Cute number 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-13T01:39:00Z</published>
    <updated>2024-09-13T01:39:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18411624.html" />
    <content type="text">## Description

定义 $f(x)$ 表示严格大于 $x$ 的最小的完全平方数，定义 $g(x)$ 为小于等于 $x$ 的最大的完全平方数。例如，$f(1)=f(2)=g(4)=g(8)=4$。

蓝认为，一个正整数是“可爱”的，当且仅当 $x-g(x)&lt;f(x)-x$，例如，$1,5,11$ 是可爱的正整数，而 $3,8,15$ 不是。

蓝给了你一个长度为 $n$ 的正整数数列 $a_i$，你需要帮她找到最小的非负整数 $k$，使得对于 $\forall i$，$a_i+k$ 是可爱的。

$1\leq n\leq 10^6,1\leq a_1\leq a_2\leq\ldots\leq a_n\leq 2\cdot 10^6$。

## Solution

容易发现一个可爱的数构成的连续段一定形如 $[x^2,x^2+x]$ 且当 $a_1+k=a_n^2$ 时一定合法。

考虑钦定 $a_1$ 属于第 $x$ 个好段，先让 $a_1$ 平移到 $x^2$，那么整个序列的可移动空间就只有 $x$ 了。

注意到对于一个 $a_i$，在这 $x$ 的移动空间内最多会改变一次状态，因为后面无论是好段还是不好段的长度都大于 $x$。所以一个目前不好的 $a_i$ 可以用于更新移动空间的左端点，好的 $a_i$ 可以更新右端点。

但是直接暴力做是 $O(nV)$ 的，过不了。

由于当 $a_1$ 平移到 $x^2$ 时，整个序列的数只会分布于 $O\left(\frac{V}{x}\right)$ 个不同的段，所以对于每个段一起考虑即可。

时间复杂度：$O(V\log V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e6 + 5;

int n, ans;
int a[kMaxN], pre[kMaxN];

int getpre(int x) { return x &lt;= a[n] ? (x &gt;= 0 ? pre[x] : 0) : n; }

void solve(int x) {
  int d = x * x - a[1], L = std::max&lt;int&gt;(d, 0), R = 1e18;
  for (int i = x, p = 0; p &lt; n; ++i) {
    int np = getpre(i * i + i - d);
    if (np != p) R = std::min(R, i * i + i - a[np]);
    p = np;

    np = getpre((i + 1) * (i + 1) - d - 1);
    if (np != p) L = std::max(L, (i + 1) * (i + 1) - a[p + 1]);
    p = np;
  }
  if (L &lt;= R) ans = std::min(ans, L);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    pre[a[i]] = i;
  }
  for (int i = 1; i &lt;= a[n]; ++i) {
    if (!pre[i]) pre[i] = pre[i - 1];
  }
  ans = a[n] * a[n] - a[1];
  for (int i = 1; i &lt; a[n]; ++i) solve(i);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18412885.html</id>
    <title type="text">CF1603E A Perfect Problem 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-13T13:16:00Z</published>
    <updated>2024-09-13T13:16:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18412885.html" />
    <content type="text">## Description

称一个序列为**好序列**当且仅当这个序列的 $\max\times \min\ge sum$，其中 $sum$ 是序列元素和。

给定 $n,M$，求长度为 $n$，每个数在 $[1,n+1]$ 范围内，每个**非空子序列**（包含序列本身）都是好序列的整数序列个数，对 $M$ 取模。

$1\le n\le 200$，$10^8\le M\le 10^9$，保证 $M$ 为素数。

## Solution

容易发现可以将序列排序后转化为判断所有前缀是否合法。这样就可以暴力 dp 了，时间复杂度：$O(n^6)$。

考虑优化。下面有合法序列的几条性质：

1. $\forall k,a_k\geq k$，因为如果 $a_k&lt;k$，则 $a_1a_k&lt;k\cdot a_1\leq \sum_{i=1}^{k}{a_i}$，矛盾了。

2. 若 $a_k=k$，则 $a_1=a_2=\ldots=a_k=k$。因为 $a_1a_k=k\cdot a_1\geq\sum_{i=1}^{k}{a_i}$，所以 $a_1=a_2=\ldots=a_k=k$。

3. 若 $a_n=n+1$，则 $\forall a_k\geq k+1$，$[1,k]$ 合法。因为 $a_1a_n=(n+1)a_1\geq\sum_{i=1}^{n}{a_i}$，则 $a_1\geq\sum_{i=1}^{n}{(a_i-a_1)}\geq\sum_{i=1}^{k}{(a_i-a_1)}$，所以 $a_1a_k\geq (k+1)a_1\geq\sum_{i=1}^{k}{a_i}$。

---

对于 $a_n=n$ 的情况很容易。

对于 $a_n=n+1$，一个序列合法的条件即为：

- $\forall 1\leq i\leq a_1,a_1\leq a_i\leq n+1$。

- $\forall a_1+1\leq i\leq n,i+1\leq a_i\leq n+1$。

- $\sum_{i=1}^{n}{(a_i-a_1)}\geq a_1$。

设 $b_i=a_i-a_1$，则：

- $\forall 1\leq i\leq a_1,0\leq b_i\leq n+1-a_1$。

- $\forall a_1+1\leq i\leq n,i+1-a_1\leq b_i\leq n+1-a_1$。

- $\sum_{i=1}^{n}{b_i}\geq a_1$。

这样就可以 dp 了。先枚举 $a_1$ 的值，可以设 $f_{i,j,k}$ 填了 $b$ 的前 $i$ 位，和为 $j$，当前的最大值为 $k$ 的方案数。

转移时可以枚举 $0\sim k-1$ 的总个数 $i$，$b$ 的前 $i$ 项的和 $j$，$k$ 的出现次数 $cnt$，则当 $i+cnt+1-a_1\leq k\leq n+1-a_1$ 时，即可让 $f_{i+cnt,j+cnt\cdot k,k}\leftarrow \frac{f_{i,j,k-1}}{cnt!}$。

时间复杂度：$O(n^4\log n)$，过不了。

---

注意到 $a_1$ 的值不会很大，并且 $a_1\geq n-2\sqrt n$。证明就考虑 $a_1\geq\sum b_i\geq\sum_{i=a_1+1}^{n}{(i-a_1+1)}=\frac{(n+a_1+3)(n-a_1)}{2}-a_1(n-a_1)$，可以得到 $a_1\geq n-2\sqrt n$。

这样 $a_1$ 的枚举数量就只有 $O(\sqrt n)$ 级别了。

时间复杂度：$O(n^3\sqrt n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 205;

int n, mod;
int fac[kMaxN], ifac[kMaxN], f[kMaxN][kMaxN][kMaxN];

constexpr int qpow(int bs, int64_t idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % mod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % mod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= mod ? x + y - mod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + mod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= mod ? x -= mod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += mod : x; }

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = 1;
  for (int i = 2; i &lt;= n + 1; ++i) {
    fac[i] = 1ll * i * fac[i - 1] % mod;
    ifac[i] = qpow(fac[i]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; mod;
  prework();
  int ans = 1;
  for (int a1 = std::max&lt;int&gt;(n - 18, 1); a1 &lt;= n; ++a1) {
    for (int i = 0; i &lt;= n; ++i)
      for (int j = 0; j &lt;= a1; ++j)
        for (int k = 0; k &lt;= n - a1 + 1; ++k)
          f[i][j][k] = 0;
    for (int i = 1; i &lt;= a1; ++i) {
      f[i][0][0] = 1ll * fac[n] * ifac[i] % mod;
    }
    for (int k = 1; k &lt;= n - a1 + 1; ++k) {
      for (int i = 1; i &lt;= n; ++i) {
        for (int j = 0; j &lt;= a1; ++j) {
          for (int cnt = 0; cnt &lt;= std::min(n - i, (a1 - j) / k); ++cnt) {
            if (k &gt;= i + cnt - a1 + 1) {
              inc(f[i + cnt][j + cnt * k][k], 1ll * f[i][j][k - 1] * ifac[cnt] % mod);
            }
          }
        }
      }
    }
    for (int i = 0; i &lt;= a1; ++i) inc(ans, f[n][i][n - a1 + 1]);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18415600.html</id>
    <title type="text">zroi 24noip 十连测 day3 T4 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-15T12:44:00Z</published>
    <updated>2024-09-15T12:44:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18415600.html" />
    <content type="text">## Description

食蜂操祈有一个栈，她意识到有些排列是可以用这个栈进行排序的。

具体来说，她会以如下方法排序：

- 准备一个空序列。
- 每一步，食蜂操祈可以将排列的第一个数取出，并压入栈中；或将栈顶的数弹出，并放置于序列尾。
- 重复执行以上操作，直到序列中有 $n$ 个数，这 $n$ 个数应当递增。

显然，不是所有的排列都可以用这种方法排序。

食蜂操祈还有一个长度为 $n$ 的排列 $A$，她想知道，有多少长度同样为 $n$ 的排列 $B$，满足其可以用上述方式排序，并且 $B$ 的字典序大于等于 $A$。

对 $998244353$ 取模。

## Solution

考虑什么样序列是合法的。

设 $pos_i$ 表示 $i$ 在序列中的出现位置。那么要让 $1$ 出现在栈顶，就要先把 $[1,pos_1]$ 加到栈里，并且由于栈里的数一定是从栈顶到栈底递增，所以 $[1,pos_1]$ 的数要递减。

要是 $2$ 出现在 $1$ 之前，就先不管。否则一定要满足 $[1,pos_2]$ 去掉 $1$ 后递减。同理可以得到判定条件：一个序列合法当且仅当对于所有 $i$，把 $[1,pos_i]$ 中 $&lt;i$ 的数去掉后，剩余的数递减。即不存在 $i&lt;j&lt;k$ 满足 $a_k&lt;a_i&lt;a_j$。

注意到要求所有字典序大于等于 $A$ 的序列数是一定要钦定一个前缀和 $A$ 相同的，并枚举第一个和 $A$ 不同的位填了什么，后面随便填。这样做是要快速求给定前缀的合法方案数，所以只有上面的那个结论是不够的。

容易发现在**值域**上把没填的数构成的连续段拿出来，那么如果当前位不在第一个连续段则必然不合法。所以填数的过程一定是先把第一个连续段填了，再填第二个，以此类推。

考虑只有一个连续段时的方案数。设 $C_n$ 表示长度为 $n$ 的合法排列数。枚举 $a_1$ 的值 $x$，则贡献为 $C_{x-1}C_{n-x}$。于是 $C_n=\sum_{i=1}^{n}{C_{i-1}C_{n-i}}$，这就是卡特兰数的形式，可以快速计算。如果有多个连续段，方案数就是每个连续段的卡特兰数乘起来。

---

现在加上字典序大于等于 $A$ 的限制，先枚举 $A$ 和 $B$ 的 LCP 以及第一个不同的位 $B$ 填的数，用数据结构维护连续段和方案数即可做到 $O(n^2)$。

考虑优化。

由于第一个不同的位 $B$ 填的数一定是当前第一个连续段的一个从 $A_i+1$ 开始后缀，并且每次操作后会从 $A_i$ 这里分裂，所以可以用启发式分裂的方式。如果 $&gt;A_i$ 的数比 $\leq A_i$ 的数少，则直接枚举后缀。否则枚举前缀，并用总答案减去前缀的答案。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e6 + 5, kMod = 998244353;

int n;
int a[kMaxN], fac[kMaxN], ifac[kMaxN], inv[kMaxN], cat[kMaxN], icat[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

int IC(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * ifac[m] * fac[n] % kMod * fac[m - n] % kMod;
}

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= 2 * n; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }

  for (int i = 0; i &lt;= n; ++i) {
    cat[i] = 1ll * C(2 * i, i) * inv[i + 1] % kMod;
    icat[i] = 1ll * IC(2 * i, i) * (i + 1) % kMod;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  prework();
  int now = cat[n], ans = 0;
  std::set&lt;std::pair&lt;int, int&gt;&gt; st;
  st.emplace(1, n);
  for (int i = 1; i &lt;= n; ++i) {
    auto p = *st.begin();
    int L = p.first, R = p.second;
    if (a[i] &gt;= L &amp;&amp; a[i] &lt;= R) {
      int cnt = 0;
      if (a[i] - L &gt;= R - a[i]) {
        for (int j = a[i] + 1; j &lt;= R; ++j)
          inc(cnt, 1ll * now * icat[R - L + 1] % kMod * cat[j - L] % kMod * cat[R - j] % kMod);
      } else {
        cnt = now;
        for (int j = L; j &lt;= a[i]; ++j)
          dec(cnt, 1ll * now * icat[R - L + 1] % kMod * cat[j - L] % kMod * cat[R - j] % kMod);
      }
      inc(ans, cnt);
    }

    if (a[i] &gt; R) {
      now = 0; break;
    } else if (a[i] == L) {
      now = 1ll * now * icat[R - L + 1] % kMod, st.erase({L, R});
      if (L &lt; R) now = 1ll * now * cat[R - L] % kMod, st.emplace(L + 1, R);
    } else {
      now = 1ll * now * icat[R - L + 1] % kMod, st.erase({L, R});
      if (L &lt; a[i]) now = 1ll * now * cat[a[i] - L] % kMod, st.emplace(L, a[i] - 1);
      if (a[i] &lt; R) now = 1ll * now * cat[R - a[i]] % kMod, st.emplace(a[i] + 1, R);
    }
  }
  inc(ans, now);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18415619.html</id>
    <title type="text">20240915 模拟赛总结-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-15T12:57:00Z</published>
    <updated>2024-09-15T12:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18415619.html" />
    <content type="text">### T1 预估得分：100，实际得分：85

被卡常了，有个地方不用开 long long。

### T2 预估得分：0，实际得分：0

赛时写了个假做法，并且一直在思考怎么用 spfa 做，没想到要按照权值从大到小进行转移。

### T3 预估得分：100，实际得分：100

赛时写了 $O(n^3k^2)$ 的暴力后，经过观察式子很快想到用 bitset 优化。

### T4 预估得分：0，实际得分：0

赛时没开。[题解](https://www.cnblogs.com/Scarab/p/18415600)

以后考试每个题都要写暴力，一个做法做不了要考虑些别的做法。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18419371.html</id>
    <title type="text">LOJ #3490. 「JOISC 2021 Day2」逃跑路线-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-18T13:35:00Z</published>
    <updated>2024-09-18T13:35:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18419371.html" />
    <content type="text">## Description

在 IOI 王国，人们使用 Byou 作为时间单位。IOI 王国中的一天被分为了 $S$ 个时间单位。每天从最开始经过 $x\ (0 \le x &lt; S)$ Byou 后的时间称为时刻 $x$。

IOI 王国由 $N$ 个城市组成，以 $0$ 到 $N-1$ 编号。其中有 $M$ 条双向道路连接某些城市，以 $0$ 到 $M-1$ 编号。你可以通过这些道路从一个城市到达另一个城市。第 $i\ (0 \le i \le M-1)$ 条道路连接城市 $A_i$ 和 $B_i$，且经过这条道路需要 $L_i$ Byou。

在每天，人们会在道路 $i$ 进行一次严格的安检，并从时刻 $C_i$ 持续到当天结束。

JOI 帮是 IOI 王国的一个秘密组织。由于其神秘性，JOI 帮的成员构成是高度机密。这意味着其中的成员不能遭遇任何一次安检。因此，如果 JOI 帮的成员需要经过道路 $i$，TA 从 $A_i$ 或 $B_i$ 起身出发的时刻 $x$ 必须满足 $0 \le x \le C_i - L_i$。由于安检并非在城市内进行，而是在路上，所以 JOI 帮的成员可以在道路 $i$ 安检时出现在城市 $A_i$ 或 $B_i$。

JOI 帮有 $Q$ 个成员，以 $0$ 到 $Q-1$ 编号。成员 $j\ (0 \le j \le Q-1)$ 会在某天的时刻 $T_j$ 从城市 $U_j$ 出发前往城市 $V_j$。成员们可以在途中的某个城市里小憩一会。成员 $j$ 可能需要很多天才能到达城市 $V_j$。

请您编写一个程序，对于给定的城市、道路、安检和 JOI 帮的成员的信息，对于每个 $j\ (0 \le j \le Q-1)$ 计算出成员 $j$ 从 $U_j$ 到达 $V_j$ 的最少时间。

- $2 \le N \le 90$。
- $N-1 \le M \le \frac{N(N-1)}2$。
- $2 \le S \le 10^{15}$。
- $1 \le Q \le 3\times 10^5$。
- $0 \le A_i \le N-1\ (0 \le i \le M-1)$。
- $0 \le B_i \le N-1\ (0 \le i \le M-1)$。
- $A_i \ne B_i\ (0 \le i \le M-1)$。
- $(A_i,B_i) \ne (A_k,B_k),(A_i,B_i) \ne (B_k,A_k)\ (0 \le i &lt; k \le M-1)$。
- $1 \le L_i &lt;S\ (0 \le i \le M-1)$。
- $L_i \le C_i &lt;S\ (0 \le i \le M-1)$。
- 您可以通过城市之间的某些道路从任意城市到达任意其他城市。
- $0 \le U_j \le N-1\ (0 \le j \le Q-1)$。
- $0 \le V_j \le N-1\ (0 \le j \le Q-1)$。
- $U_j \ne V_j\ (0 \le j \le Q-1)$。
- $0 \le T_j &lt; S\ (0 \le j \le Q-1)$。

## Solution

首先有个单次询问 $O(n^2+m)$ 的做法是直接暴力跑 dijkstra 最短路。显然过不了。

考虑优化。

刚才那个做法主要慢在没有任何预处理而每次重新做询问，导致询问时间复杂度过高而超时。注意到当一个点第一次被道路卡后，时间$\bmod S$ 一定为 $0$，这样起点的状态只有 $O(n)$ 种，可以预处理了。

根据上面那个做法可以将答案路径分为两种：在一天内走完、走至少两天。

先考虑第一种情况，对于第二种情况可以枚举第一天走的最后的点，就转化为了第一天和初始时间为 $0$ 的情况了。

同样是预处理。固定起点和终点，对于一组方案，设 $(u,v,l,c)$ 为方案中经过的边，$x$ 为到 $u$ 的时间，将初始时间往后移 $[0,c-l-x]$ 这条边仍然能走，所以每次找到 $c-l-x$ 最小的边删掉，在剩下的边继续跑即可预处理出所有初始时间区间的答案。时间复杂度：$O(n^5)$，过不了。

显然可以枚举瓶颈边 $(u,v,l,c)$，则到 $u$ 的时间小于等于 $c-l$，$v$ 当天到后面点的时间等于 $c$ 时刻从 $v$ 出发的时间。所以可以设 $dis1_x$ 表示当天从 $x$ 到 $u$ 的最小时间，通过这个东西可以求出 $(u,v,l,c)$ 为瓶颈边的最大初始时刻。$dis2_x$ 表示当天 $c$ 时刻从 $v$ 到 $x$ 的最小时间。于是 $x\to y$ 的路径中瓶颈边为 $(u,v,l,c)$ 最小时间为 $dis1_x+dis2_y+l$。

然后搞个 vector 维护每对起点和终点经过所有瓶颈边对应的最小时间，先按照初始时间的限制排序，查询时二分出可行的后缀即可。

如果至少走两天，可以设 $f_{x,y}$ 表示当天从 $y$ 到 $x$ 的最小时间，$g_{x,y}$ 表示 $0$ 时刻从 $x$ 到 $y$ 的最小时间，这两个数组的求法和上面瓶颈边的 $dis1,dis2$ 差不多，然后枚举中转点 $i$，贡献即为 $\min\limits_{s-f_{u,i}\geq t}{s+g_{v,i}-t}$。

时间复杂度：$O(n^4+qn+q\log n)$。

具体细节见代码。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

namespace FASTIO {
char ibuf[1 &lt;&lt; 21], *p1 = ibuf, *p2 = ibuf;
char getc() {
  return p1 == p2 &amp;&amp; (p2 = (p1 = ibuf) + fread(ibuf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;
}
template&lt;class T&gt; bool read(T &amp;x) {
  x = 0; int f = 0; char ch = getc();
  while (ch &lt; '0' || ch &gt; '9') f |= ch == '-', ch = getc();
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x * 10) + (ch ^ 48), ch = getc();
  x = (f ? -x : x); return 1;
}
template&lt;typename A, typename ...B&gt; bool read(A &amp;x, B &amp;...y) { return read(x) &amp;&amp; read(y...); }
 
char obuf[1 &lt;&lt; 21], *o1 = obuf, *o2 = obuf + (1 &lt;&lt; 21) - 1;
void flush() { fwrite(obuf, 1, o1 - obuf, stdout), o1 = obuf; }
void putc(char x) { *o1++ = x; if (o1 == o2) flush(); }
template&lt;class T&gt; void write(T x) {
  if (!x) putc('0');
  if (x &lt; 0) x = -x, putc('-');
  char c[40]; int tot = 0;
  while (x) c[++tot] = x % 10, x /= 10;
  for (int i = tot; i; --i) putc(c[i] + '0');
}
void write(char x) { putc(x); }
void write(char *x) { while (*x) putc(*x++); }
void write(const char *x) { while (*x) putc(*x++); }
template&lt;typename A, typename ...B&gt; void write(A x, B ...y) { write(x), write(y...); }
struct Flusher {
  ~Flusher() { flush(); }
} flusher;
} // namespace FASTIO
using FASTIO::read; using FASTIO::putc; using FASTIO::write;

const int kMaxN = 95, kMaxM = kMaxN * kMaxN / 2;
const int64_t kInf = 1e18;

int n, m, q;
int u[kMaxM], v[kMaxM];
int64_t s, l[kMaxM], c[kMaxM], f[kMaxN][kMaxN], g[kMaxN][kMaxN], dis1[kMaxN], dis2[kMaxN];
std::vector&lt;std::tuple&lt;int, int64_t, int64_t&gt;&gt; G[kMaxN];
std::vector&lt;std::pair&lt;int64_t, int64_t&gt;&gt; vec[kMaxN][kMaxN];

void dijkstra1(int x, int64_t t) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) {
    dis1[i] = kInf, vis[i] = 0;
  }
  std::queue&lt;int&gt; q;
  q.emplace(x), dis1[x] = 0;
  for (int c = 1; c &lt;= n; ++c) {
    int u = 0;
    for (int i = 1; i &lt;= n; ++i)
      if (!vis[i] &amp;&amp; (!u || dis1[i] &lt; dis1[u]))
        u = i;
    if (!u || dis1[u] &gt;= 1e17) break;
    vis[u] = 1;
    for (auto [v, l, c] : G[u]) {
      if (t - dis1[u] - l &lt; 0) continue;
      if (t - dis1[u] &lt;= c) dis1[v] = std::min(dis1[v], dis1[u] + l);
    }
  }
}

void dijkstra2(int x, int64_t t) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) {
    dis2[i] = kInf, vis[i] = 0;
  }
  std::queue&lt;int&gt; q;
  q.emplace(x), dis2[x] = 0;
  for (int c = 1; c &lt;= n; ++c) {
    int u = 0;
    for (int i = 1; i &lt;= n; ++i)
      if (!vis[i] &amp;&amp; (!u || dis2[i] &lt; dis2[u]))
        u = i;
    if (!u || dis2[u] &gt;= 1e17) break;
    vis[u] = 1;
    for (auto [v, l, c] : G[u]) {
      int64_t val = dis2[u] + t;
      if (val % s &lt;= c - l) dis2[v] = std::min(dis2[v], dis2[u] + l);
    }
  }
} 

void dijkstra3(int x, int64_t t) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) {
    dis1[i] = kInf, vis[i] = 0;
  }
  std::queue&lt;int&gt; q;
  q.emplace(x), dis1[x] = 0;
  for (int c = 1; c &lt;= n; ++c) {
    int u = 0;
    for (int i = 1; i &lt;= n; ++i)
      if (!vis[i] &amp;&amp; (!u || dis1[i] &lt; dis1[u]))
        u = i;
    if (!u || dis1[u] &gt;= 1e17) break;
    vis[u] = 1;
    for (auto [v, l, c] : G[u]) {
      if (t - dis1[u] - l &lt; 0) continue;
      if (t - dis1[u] &gt; c) dis1[v] = std::min(dis1[v], dis1[u] + t - dis1[u] - c + l);
      else dis1[v] = std::min(dis1[v], dis1[u] + l);
    }
  }
}

void dijkstra4(int x, int64_t t) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) {
    dis2[i] = kInf, vis[i] = 0;
  }
  std::queue&lt;int&gt; q;
  q.emplace(x), dis2[x] = 0;
  for (int c = 1; c &lt;= n; ++c) {
    int u = 0;
    for (int i = 1; i &lt;= n; ++i)
      if (!vis[i] &amp;&amp; (!u || dis2[i] &lt; dis2[u]))
        u = i;
    if (!u || dis2[u] &gt;= 1e17) break;
    vis[u] = 1;
    for (auto [v, l, c] : G[u]) {
      int64_t val = dis2[u] + t;
      if (val % s &gt; c - l) val += s - val % s;
      dis2[v] = std::min(dis2[v], val - t + l);
    }
  }
}

int64_t solve(int u, int v, int64_t t) {
  int64_t res = kInf;
  auto it = std::lower_bound(vec[u][v].begin(), vec[u][v].end(), std::pair&lt;int64_t, int64_t&gt;{t, 0});
  if (it != vec[u][v].end()) res = std::min(res, it-&gt;second);
  for (int i = 1; i &lt;= n; ++i) {
    if (s - f[i][u] &gt;= t) res = std::min(res, s + g[i][v] - t);
  }
  return res;
}

void dickdreamer() {
  read(n, m, s, q);
  for (int i = 1; i &lt;= m; ++i) {
    read(u[i], v[i], l[i], c[i]);
    ++u[i], ++v[i];
    G[u[i]].emplace_back(v[i], l[i], c[i]), G[v[i]].emplace_back(u[i], l[i], c[i]);
  }
  for (int i = 1; i &lt;= m; ++i) {
    dijkstra1(u[i], c[i] - l[i]), dijkstra2(v[i], c[i]);
    for (int j = 1; j &lt;= n; ++j) {
      for (int k = 1; k &lt;= n; ++k) {
        vec[j][k].emplace_back(c[i] - l[i] - dis1[j], dis1[j] + dis2[k] + l[i]);
      }
    }

    dijkstra1(v[i], c[i] - l[i]), dijkstra2(u[i], c[i]);
    for (int j = 1; j &lt;= n; ++j) {
      for (int k = 1; k &lt;= n; ++k) {
        vec[j][k].emplace_back(c[i] - l[i] - dis1[j], dis1[j] + dis2[k] + l[i]);
      }
    }
  }
  
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      std::sort(vec[i][j].begin(), vec[i][j].end());
      for (int k = (int)vec[i][j].size() - 2; k &gt;= 0; --k) {
        vec[i][j][k].second = std::min(vec[i][j][k].second, vec[i][j][k + 1].second);
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    dijkstra3(i, s), dijkstra4(i, 0);
    for (int j = 1; j &lt;= n; ++j) {
      f[i][j] = dis1[j], g[i][j] = dis2[j];
    }
  }
  for (int c = 1; c &lt;= q; ++c) {
    int u, v; int64_t t;
    read(u, v, t);
    ++u, ++v;
    write(solve(u, v, t), '\n');
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18422071.html</id>
    <title type="text">CF1526F Median Queries 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-20T02:59:00Z</published>
    <updated>2024-09-20T02:59:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18422071.html" />
    <content type="text">## Description

**本题是一道交互题。**

给定 $n$，你需要猜测一个长度为 $n$ 的排列 $p$（即 $p$ 包含所有 $1$ 到 $n$ 的整数各一次）。已知 $p$ 满足 $p_1&lt;p_2$。

当然，你可以进行询问，每次询问你需要给定三个互不相同的整数 $a,b,c$，交互器会返回 $|p_a-p_b|,|p_b-p_c|,|p_c-p_a|$ 这三个数中第二小的数。

请在 $2\times n+420$ 次询问内求出整个排列 $p$。$T$ 组数据。

交互格式如下：

- 首先你需要读入整数 $T$ 表示数据组数。接下来对于每组数据：
- 首先读入一个整数 $n$ 表示排列长度。如果你希望询问，按照 `? a b c` 的格式输出，你将收到 $|p_a-p_b|,|p_b-p_c|,|p_c-p_a|$ 中第二小的数。你需要保证 $1\leq a,b,c\leq n$，且 $a,b,c$ 互不相同。请注意，如果你的询问不合法，或者你的询问次数过多，交互器会给出 `-1` 的结果，此时你需要立即停止程序，否则可能会得到任意的评测结果。如果你希望回答，按照 `! p_1 p_2 ... p_n` 的格式输出。如果你的回答正确，交互器会给出 `1` 的结果，此时你需要直接进行下一组数据（如果有的话），否则交互器会给出 `-1` 的结果，同样的你需要立刻结束程序。

注意刷新缓冲区。

$1\leq T\leq10^3,20\leq n,\sum n\leq10^5$。

## Solution

考虑怎么一一确定每个数。

注意到如果已经直到 $1$ 和 $2$ 或 $n-1$ 和 $n$ 的位置之后，再通过 $n-2$ 次操作就能确定每个数了。

同时我们如果只知道边上的两个数，但不知道是 $1,2$ 还是 $n-1,n$，也是可以做的。因为可以先把边上的数当作 $1,2$ 确定出整个排列，如果 $p_1&gt;p_2$ 则让 $p_i\leftarrow n-p_i+1$，否则不变。

现在问题转化为怎么找到边上的两个数。

有个不显然的观察是对于一对距离不长的 $(a,b)$，与它们距离最大的两个点一定在边界上。结论是 $b-a+1\leq\frac{n-4}{3}$ 时就是对的。

找到长度不超过 $\frac{n-4}{3}$ 的点对是简单的，可以一直随，直到随到权值 $\leq\frac{n-4}{6}$ 的 $(a,b,c)$ 即可。单次随到的概率是 $\frac{1}{9}$，$420$ 次一定能随到。

细节见代码。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5;

int n;
int p[kMaxN], val[kMaxN];
std::mt19937 rnd(std::random_device{}());

int ask(int x, int y, int z) {
  std::cout &lt;&lt; "? " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; std::endl;
  int d;
  std::cin &gt;&gt; d;
  return d;
}

std::tuple&lt;int, int, int&gt; gettuple() {
  int a = rnd() % n + 1, b = rnd() % n + 1, c = rnd() % n + 1;
  while (a == b || a == c || b == c) a = rnd() % n + 1, b = rnd() % n + 1, c = rnd() % n + 1;
  return {a, b, c};
}

std::pair&lt;int, int&gt; getpair() {
  int a, b, c;
  for (int c = 1; c &lt;= 420; ++c) {
    std::tie(a, b, c) = gettuple();
    if (ask(a, b, c) &lt;= (n - 4) / 6) return {a, b};
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  auto [a, b] = getpair();
  for (int i = 1; i &lt;= n; ++i) {
    val[i] = 0;
    if (i != a &amp;&amp; i != b) val[i] = ask(a, b, i);
  }
  int p1 = 0, p2 = 0;
  p1 = std::max_element(val + 1, val + 1 + n) - val;
  std::vector&lt;int&gt; vec;
  for (int i = 1; i &lt;= n; ++i) {
    if (val[i] == val[p1] - 1)
      vec.emplace_back(i);
  }
  if ((int)vec.size() == 1) {
    p2 = vec[0];
  } else {
    assert(vec.size() == 2);
    if (ask(a, p1, vec[0]) &lt; ask(a, p1, vec[1])) p2 = vec[0];
    else p2 = vec[1];
  }
  p[p1] = 1, p[p2] = 2;
  for (int i = 1; i &lt;= n; ++i)
    if (i != p1 &amp;&amp; i != p2)
      p[i] = ask(i, p1, p2) + 2;
  if (p[1] &gt; p[2]) {
    for (int i = 1; i &lt;= n; ++i)
      p[i] = n - p[i] + 1;
  }
  std::cout &lt;&lt; "! ";
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; p[i] &lt;&lt; ' ';
  std::cout &lt;&lt; std::endl;
  std::cin &gt;&gt; n;
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  // std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18424463.html</id>
    <title type="text">P10802 [CEOI2024] 核酸检测 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-21T12:25:00Z</published>
    <updated>2024-09-21T12:25:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18424463.html" />
    <content type="text">## Description

[link](https://www.luogu.com.cn/problem/P10802)

## Solution

Sub1 可以直接对于每个每个人问一次，考虑 Sub2 怎么做。

首先有个显然的想法是二分出第一个阳性的人，次数大概是 $NP\log N$，分数不高。

注意到每个位置的状态是随机生成的，并且题目要求的次数非常优，所以可以考虑利用期望 dp 求出最小**期望**操作次数。

设 $f_{i,j}$ 表示目前剩下 $i$ 个人没有判断，且确定了有 $j$ 个人，满足这 $j$ 个人至少有一个阳性的最小期望操作次数。

对于 $j=1$ 的情况，把那个已经确定阳了的人去掉，转移即为 $f_{i,1}\leftarrow f_{i-1,0}$。

对于 $j&gt;1$ 的情况，考虑枚举 $j$ 个人中的某 $k$ 个，如果这 $k$ 个人有阳的，就转移到 $f_{i,k}$，这一部分的概率为 $\frac{(1-P)^k-(1-P)^j}{1-(1-P)^j}$。否则把这 $k$ 个人去掉，即转移到 $f_{i-k,j-k}$。所以：

$$f_{i,j}=\min_{k}{\left\{\frac{(1-P)^k-(1-P)^j}{1-(1-P)^j}\cdot f_{i,k}+\left(1-\frac{(1-P)^k-(1-P)^j}{1-(1-P)^j}\right)\cdot f_{i-k,j-k}\right\}}$$

对于 $j=0$ 的情况，枚举 $i$ 个人中的某 $k$ 个，如果这 $k$ 个人没有阳的，就转移到 $f_{i-k,j-k}$，这一部分的概率为 $(1-P)^k$。否则把这 $k$ 个人去掉，转移到 $f_{i,k}$。所以：

$$
f_{i,0}=\min_{k}{\left\{\left(1-P\right)^kf_{i-k,j-k}+\left(1-\left(1-P\right)^k\right)f_{i,k}\right\}}
$$

经过测试，当 $P=0.2$ 时，$f_{1000,0}=727.957$，可以通过。

输出方案可以通过 dp 过程中的最优转移点来做。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e3 + 5;

int n;
int trans[kMaxN][kMaxN];
double p, pw[kMaxN], f[kMaxN][kMaxN];
std::mt19937 rnd(std::random_device{}());

bool test_students(std::vector&lt;bool&gt; mask) {
  assert(mask.size() == (size_t)n);

  std::string mask_str(n, ' ');
  for (int i = 0; i &lt; n; i++) mask_str[i] = mask[i] ? '1' : '0';

  printf("Q %s\n", mask_str.c_str());
  fflush(stdout);

  char answer;
  scanf(" %c", &amp;answer);
  return answer == 'P';
}

bool ask(std::vector&lt;int&gt; vec) {
  std::vector&lt;bool&gt; mask(n);
  for (auto x : vec) mask[x] = 1;
  return test_students(mask);
}

void del(std::vector&lt;int&gt; &amp;v1, std::vector&lt;int&gt; &amp;v2) {
  static bool vis[kMaxN] = {0};
  for (auto x : v1) vis[x] = 1;
  for (auto x : v2) vis[x] = 0;
  std::vector&lt;int&gt; tmp;
  std::swap(v1, tmp);
  for (auto x : tmp) {
    if (vis[x]) v1.emplace_back(x);
    vis[x] = 0;
  }
}

void solve(std::vector&lt;int&gt; v1, std::vector&lt;int&gt; v2, std::vector&lt;bool&gt; &amp;answer) {
  static bool vis[kMaxN] = {0};
  int a = (int)v1.size(), b = (int)v2.size();
  if (!a) return;
  if (b == 1) {
    answer[v2[0]] = 1;
    del(v1, v2);
    solve(v1, {}, answer);
  } else if (!b) {
    int k = trans[a][b];
    std::vector&lt;int&gt; vec;
    for (int i = 0; i &lt; k; ++i) vec.emplace_back(v1[i]);
    if (!ask(vec)) {
      del(v1, vec);
      solve(v1, {}, answer);
    } else {
      solve(v1, vec, answer);
    }
  } else {
    int k = trans[a][b];
    std::vector&lt;int&gt; vec;
    for (int i = 0; i &lt; k; ++i) vec.emplace_back(v2[i]);
    if (!ask(vec)) {
      del(v1, vec), del(v2, vec);
      solve(v1, v2, answer);
    } else {
      solve(v1, vec, answer);
    }
  }
}

std::vector&lt;bool&gt; find_positive(bool op) {
  if (!op) {
    std::vector&lt;bool&gt; answer(n);
    for (int i = 0; i &lt; n; ++i) {
      std::vector&lt;bool&gt; vec(n);
      vec[i] = 1;
      answer[i] = test_students(vec);
    }
    return answer;
  } else {
    std::vector&lt;int&gt; vec;
    std::vector&lt;bool&gt; answer(n);
    for (int i = 0; i &lt; n; ++i) vec.emplace_back(i);
    solve(vec, {}, answer);
    return answer;
  }
}

void prework() {
  pw[0] = 1;
  for (int i = 1; i &lt;= n; ++i) pw[i] = pw[i - 1] * (1 - p);
  for (int i = 1; i &lt;= n; ++i) {
    f[i][0] = 1e18, f[i][1] = f[i - 1][0];
    for (int j = 2; j &lt;= i; ++j) {
      f[i][j] = 1e18;
      for (int k = 1; k &lt;= j; ++k) {
        double pr = (pw[k] - pw[j]) / (1 - pw[j]); // 选的 k 个没有的概率
        double val = pr * f[i - k][j - k] + (1 - pr) * f[i][k] + 1;
        if (val &lt; f[i][j]) {
          f[i][j] = val, trans[i][j] = k;
        }
      }
    }
    for (int j = 1; j &lt;= i; ++j) {
      double pr = pw[j];
      double val = pr * f[i - j][0] + (1 - pr) * f[i][j] + 1;
      if (val &lt; f[i][0]) {
        f[i][0] = val, trans[i][0] = j;
      }
    }
  }
}

int32_t main() {
  int T;
  scanf("%d %lf %d", &amp;n, &amp;p, &amp;T);
  if (T &gt; 1) prework();
  for (int i = 0; i &lt; T; i++) {
    std::vector&lt;bool&gt; answer = find_positive(T &gt; 1);
    assert(answer.size() == (size_t)n);

    std::string answer_str(n, ' ');
    for (int j = 0; j &lt; n; j++) answer_str[j] = answer[j] ? '1' : '0';

    printf("A %s\n", answer_str.c_str());
    fflush(stdout);

    char verdict;
    scanf(" %c", &amp;verdict);
    if (verdict == 'W') exit(0);
  }

  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18425944.html</id>
    <title type="text">CF1239E Turtle 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-22T13:44:00Z</published>
    <updated>2024-09-22T13:44:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18425944.html" />
    <content type="text">## Description

一只乌龟从 $2 \times n$ 的棋盘的左上角走到右下角，只能往下或往右，需要给出一种方案来分配 $2n$ 个数字使得乌龟走过的路径上的数之和的最大值最小。

$2\leq n\leq 25,0\leq a_{1,i},a_{2,i}\leq 5\times 10^4$。

## Solution

设 $pre_{i}=\sum_{j=1}^{i}{a_{1,i}},suf_i=\sum_{j=i}^{n}{a_{2,i}}$。一组方案的权值即为 $\max\left\{pre_i+suf_i\right\}$。

先考虑固定两行数分别选的数后每行最终是怎么排的。

容易发现对于第一行，如果 $a_{1,i}&gt;a_{1,i+1}$，将 $a_{1,i}$ 和 $a_{1,i+1}$ 交换后，在第 $i$ 列的权值变小其余不变，所以第一行一定是从小到大排列。第二行同理，为从大到小排列。

同时由于 $(pre_{i+1}+suf_{i+1})-(pre_i+suf_i)=a_{1,i+1}-a_{2,i}$ 且 $a_{1,i}$ 递增，$a_{2,i}$ 递减。所以对于一组方案，每列的权值构成一个下凸函数，最大权值即为 $pre_1+suf_1$ 或 $pre_n+suf_n$。

于是一组方案的权值为 $\max\left\{a_{1,1}+\sum{a_{2,i},a_{2,n}+\sum{a_{1,i}}}\right\}=a_{1,1}+a_{2,n}+\max\left\{\sum_{i=2}^{n}{a_{1,i}},\sum_{i=1}^{n-1}{a_{2,i}}\right\}$。

但是这样仍然做不了，因为 $a_{1,1}$ 和 $a_{2,n}$ 的权值不确定。

但是注意到 $a_{1,1}$ 和 $a_{2,n}$ 一定存在一个是全局最小值，而另一个经过调整一定可以变成次小值。所以题目转化为了要将剩余的 $2n-2$ 个数平均分成两组，使得这两组数的和的差的绝对值最小，bitset 优化背包即可。

时间复杂度：$O\left(\frac{n^2\sum a_{i,j}}{\omega}\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 30, kMaxS = 1.25e6 + 5;

int n;
int a[kMaxN * 2];
std::bitset&lt;kMaxS&gt; f[kMaxN * 2][kMaxN];
std::vector&lt;int&gt; v[2];

void print(int i, int j, int k) {
  if (i == 2) return;
  if (f[i - 1][j][k]) v[0].emplace_back(a[i]), print(i - 1, j, k);
  else v[1].emplace_back(a[i]), print(i - 1, j - 1, k - a[i]);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= 2 * n; ++i) std::cin &gt;&gt; a[i];
  std::sort(a + 1, a + 1 + 2 * n);
  int sum = std::accumulate(a + 3, a + 1 + 2 * n, 0);
  f[2][0][0] = 1;
  for (int i = 3; i &lt;= 2 * n; ++i) {
    for (int j = 0; j &lt;= std::min(i - 3, n - 1); ++j) {
      f[i][j] |= f[i - 1][j];
      f[i][j + 1] |= (f[i - 1][j] &lt;&lt; a[i]);
    }
  }
  int ans = 1e9, s = 0;
  for (int i = 0; i &lt;= sum; ++i) {
    if (f[2 * n][n - 1][i] &amp;&amp; std::max(i, sum - i) &lt; ans) {
      ans = std::max(i, sum - i);
      s = i;
    }
  }
  v[0] = {a[1]}, v[1] = {a[2]};
  print(2 * n, n - 1, s);
  std::sort(v[0].begin(), v[0].end());
  std::sort(v[1].begin(), v[1].end(), std::greater&lt;&gt;());
  for (auto x : v[0]) std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
  for (auto x : v[1]) std::cout &lt;&lt; x &lt;&lt; ' ';
  std::cout &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18427107.html</id>
    <title type="text">CF1270H Number of Components 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-23T07:16:00Z</published>
    <updated>2024-09-23T07:16:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18427107.html" />
    <content type="text">## Description

给一个长度为 $n$ 的数组 $a$，$a$ 中的元素两两不同。

对于每个数对 $(i,j)(i&lt;j)$，若 $a_i&lt;a_j$，则让 $i$ 向 $j$ 连一条边。求图中连通块个数。

支持 $q$ 次修改数组某个位置的值，每次修改后输出图中连通块个数。

$n,q\le 5\times 10^5,1\le a_i\le 10^6$，保证任意时刻数组中元素两两不同。

## Solution

考虑怎么求一个序列有几个连通块。

首先有个性质是每个连通块一定是一个区间，证明就考虑钦定 $i&lt;k&lt;j$ 且 $i$ 和 $j$ 连通。如果 $a_i&lt;a_j$，则 $a_i&lt;a_k$ 和 $a_k&lt;a_j$ 必定满足至少一个。

如果 $a_i&gt;a_j$，由于 $i,j$ 连通，所以一定存在 $x&lt;i$ 且 $a_i&gt;a_j&gt;a_x$ 或 $x&gt;j$ 且 $a_x&gt;a_i&gt;a_j$。这样就规约到了 $a_i&lt;a_j$ 的情况。故结论得证。

所以连通块数就是满足 $\min_{i=1}^{k}{a_i}&gt;\max_{i=k+1}^{n}{a_i}$ 的 $k$ 的数量。

考虑枚举前缀的最小值 $x$，将 $a$ 数组中大于等于 $x$ 的位置设成 $1$，小于 $x$ 的位置设成 $0$，则合法的 $x$ 一定满足 $01$ 序列为 $11110000$ 的形式，即 $10$ 的出现次数为 $1$。

设 $cnt_x$ 表示 $x$ 的 $01$ 序列中 $10$ 的出现次数。于是题目转化为求对于所有在 $a$ 数组中出现了的 $x$ 中 $cnt_x=1$ 的 $x$ 的数量，维护一个值域的线段树即可。

时间复杂度：$O\left((n+q)\log n\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

int n, q, m;
int a[kMaxN], pos[kMaxN], x[kMaxN], unq[kMaxN];

struct SGT {
  int mi[kMaxN * 4], tag[kMaxN * 4], tot[kMaxN * 4], cnt[kMaxN * 4];

  void pushup(int x) {
    mi[x] = std::min(tot[x &lt;&lt; 1] ? mi[x &lt;&lt; 1] : 1e9, tot[x &lt;&lt; 1 | 1] ? mi[x &lt;&lt; 1 | 1] : 1e9);
    tot[x] = tot[x &lt;&lt; 1] + tot[x &lt;&lt; 1 | 1];
    cnt[x] = 0;
    if (tot[x &lt;&lt; 1] &amp;&amp; mi[x] == mi[x &lt;&lt; 1]) cnt[x] += cnt[x &lt;&lt; 1];
    if (tot[x &lt;&lt; 1 | 1] &amp;&amp; mi[x] == mi[x &lt;&lt; 1 | 1]) cnt[x] += cnt[x &lt;&lt; 1 | 1];
  }

  void addtag(int x, int v) {
    mi[x] += v, tag[x] += v;
  }

  void pushdown(int x) {
    if (tag[x])
      addtag(x &lt;&lt; 1, tag[x]), addtag(x &lt;&lt; 1 | 1, tag[x]), tag[x] = 0;
  }

  void build(int x, int l, int r) {
    if (l == r) return void(cnt[x] = 1);
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  void update1(int x, int l, int r, int ql, int v) {
    if (l == r) return void(tot[x] = v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update1(x &lt;&lt; 1, l, mid, ql, v);
    else update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  void update2(int x, int l, int r, int ql, int qr, int v) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, v);
    pushdown(x);
    int mid = (l + r) &gt;&gt; 1;
    update2(x &lt;&lt; 1, l, mid, ql, qr, v), update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, v);
    pushup(x);
  }

  int query() { return tot[1] &amp;&amp; mi[1] == 1 ? cnt[1] : 0; }
} sgt;

void discrete() {
  for (int i = 0; i &lt;= n + 1; ++i) unq[++m] = a[i];
  for (int i = 1; i &lt;= q; ++i) unq[++m] = x[i];
  std::sort(unq + 1, unq + 1 + m);
  m = std::unique(unq + 1, unq + 1 + m) - unq;

  for (int i = 0; i &lt;= n + 1; ++i)
    a[i] = std::lower_bound(unq + 1, unq + 1 + m, a[i]) - unq;
  for (int i = 1; i &lt;= q; ++i)
    x[i] = std::lower_bound(unq + 1, unq + 1 + m, x[i]) - unq;
}

void update(int x, int y, int v) {
  if (x &gt; y) sgt.update2(1, 1, m, y + 1, x, v);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  a[0] = 1e9, a[n + 1] = -1e9;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= q; ++i) std::cin &gt;&gt; pos[i] &gt;&gt; x[i];
  discrete();
  sgt.build(1, 1, m);
  for (int i = 1; i &lt;= n; ++i) sgt.update1(1, 1, m, a[i], 1);
  for (int i = 0; i &lt;= n; ++i) update(a[i], a[i + 1], 1);
  for (int i = 1; i &lt;= q; ++i) {
    update(a[pos[i] - 1], a[pos[i]], -1), update(a[pos[i]], a[pos[i] + 1], -1);
    sgt.update1(1, 1, m, a[pos[i]], 0);
    a[pos[i]] = x[i];
    update(a[pos[i] - 1], a[pos[i]], 1), update(a[pos[i]], a[pos[i] + 1], 1);
    sgt.update1(1, 1, m, a[pos[i]], 1);
    std::cout &lt;&lt; sgt.query() &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18430258.html</id>
    <title type="text">20240924 模拟赛 T4 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-24T14:56:00Z</published>
    <updated>2024-09-24T14:56:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18430258.html" />
    <content type="text">## Description

这是一道交互题。
有一棵 $n$ 个节点的树，现在要求你通过若干次询问得到这棵树的每一条边连接哪两个点。

每次询问你需要指定 $n$ 个整数 $d_1,d_2,\ldots,d_n$，满足 $-1\leq d_i\leq n$，其中 $1\leq i\leq n$。

每次询问交互库会返回给你一个长度为 $n$ 的布尔数组，第 $i$ 个元素为 $1$ 当且仅当存在某个点 $j$ 满足 $i,j$ 的树上距离 $\leq d_j$，其中 $1\leq i,j\leq n$。

定义两点的树上距离为这两点的最短路径所经过的边数。

对于所有非样例的测试点，$n=16000$，输入的边组成一棵 $n$ 个点的树。

|子任务编号|测试点数目|标准询问次数|特殊性质|
| :------------: | :------------: | :------------: | :------------: |
|$0$|$3$|$1$|样例|
|$1$|$30$|$300$|树随机生成|
|$2$|$37$|$80$|无|

## Solution

先考虑树随机生成怎么做。

容易发现这题的随机生成方式会让树的高度为 $O(\log n)$，所以可以先钦定根，然后用 $O(\log n)$ 次操作确定每个点的深度。

然后考虑怎么求出每个深度内每个点的父亲。

可以对于每个二进制位考虑，具体的，先选择一个深度 $dep$，同时枚举二进制位 $b$，然后把 $dep$ 这层的点中第 $b$ 位为 $1$ 的树的 $d$ 设成 $1$ 跑一遍询问，这样回答中被选中的深度在 $dep+1$ 的点的父亲一定满足第 $b$ 位为 $1$。于是就可以单次 $\left\lceil\log_2n\right\rceil$ 次操作确定一个层所有点的父亲。这样总次数为 $O(\log^2 n)$。

注意到上面那个东西可以让模 $3$ 余数相等的层同时做，因为它们互不影响，于是可以做到去掉求每个点深度后 $3\left\lceil\log_2n\right\rceil$ 次询问。

当树不是随机生成时，树的深度可能很大，$O(dep)$ 的去求每个点的深度显然不可行。

考虑分治。假设当前分治区间为 $[l,r]$，并且已经分别知道了深度为 $[l,l]$ 和 $[l+1,r]$ 的所有点。

设 $mid=\left\lceil\frac{l+r}{2}\right\rceil$。可以对于所有深度为 $l$ 的点分别做长度为 $mid-l$ 和 $mid-l-1$ 的询问。然后就可以对 $[l,mid-1]$ 和 $[mid,r]$ 进行递归了。

注意到在分治的过程中同一层的区间可以一起做，同时由于同一层的相邻区间会相互影响，所以需要对于奇数和偶数区间分别做。询问次数大概为 $92$ 次，过不了。

又因为做完 $mid-l$ 的询问后一定可以确定递归区间分别有那些数了，所以 $mid-l-1$ 的询问不需要奇偶分组，放到一起做即可。

加上上面那个优化后询问次数就变为 $80$ 了，可以通过。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include "grader.cc"
#else
#include "god.h"
#endif

const int kMaxN = 1.6e4 + 5;

int n;
int d[kMaxN], dep[kMaxN], cnt[kMaxN], p[kMaxN];
bool res[kMaxN], vis[kMaxN];
std::pair&lt;int, int&gt; seg[kMaxN * 4];
std::vector&lt;int&gt; id[kMaxN], ss[30], sv[kMaxN * 4][2];

namespace REAL {
void solve(int d, int x, int l, int r) {
  seg[x] = {l, r};
  if (r - l &lt;= 1) return;
  int mid = (l + r + 1) &gt;&gt; 1;
  ss[d].emplace_back(x);
  solve(d + 1, x &lt;&lt; 1, l, mid - 1), solve(d + 1, x &lt;&lt; 1 | 1, mid, r);
}

void getdep() {
  solve(1, 1, 0, n - 1);
  sv[1][0] = {1};
  for (int i = 2; i &lt;= n; ++i) sv[1][1].emplace_back(i);
  for (int c = 1; c &lt;= 20; ++c) {
    if (!ss[c].size()) continue;
    static int d[3][kMaxN];
    static bool res[3][kMaxN];
    std::fill_n(d[0] + 1, n, -1);
    std::fill_n(d[1] + 1, n, -1);
    std::fill_n(d[2] + 1, n, -1);
    for (int r = 0; r &lt; 2; ++r) {
      for (int i = r; i &lt; (int)ss[c].size(); i += 2) {
        int x = ss[c][i];
        std::pair&lt;int, int&gt; p = seg[x];
        int mid = (p.first + p.second + 1) / 2;
        for (auto j : sv[x][0]) d[r][j] = mid - p.first;
      }
    }
    query(d[0], res[0]);
    if (c != 1) query(d[1], res[1]);
    for (auto x : ss[c]) {
      std::pair&lt;int, int&gt; p = seg[x];
      int mid = (p.first + p.second + 1) / 2;
      for (auto j : sv[x][0]) d[2][j] = mid - p.first - 1;
    }
    query(d[2], res[2]);
    for (int i = 0; i &lt; (int)ss[c].size(); ++i) {
      int x = ss[c][i];
      sv[x &lt;&lt; 1][0] = sv[x][0];
      for (auto j : sv[x][1]) {
        if (!res[i &amp; 1][j]) sv[x &lt;&lt; 1 | 1][1].emplace_back(j);
        else if (res[2][j]) sv[x &lt;&lt; 1][1].emplace_back(j);
        else sv[x &lt;&lt; 1 | 1][0].emplace_back(j);
      }
    }
  }
  for (int i = 1; i &lt;= 4 * n; ++i) {
    if (seg[i].second - seg[i].first &lt;= 1 &amp;&amp; (sv[i][0].size() || sv[i][1].size())) {
      for (auto x : sv[i][0]) dep[x] = seg[i].first; 
      for (auto x : sv[i][1]) dep[x] = seg[i].second;
    }
  }

  for (int i = 1; i &lt;= n; ++i) {
    id[dep[i]].emplace_back(i);
  }
}

void getedge() {
  for (int r = 0; r &lt; 3; ++r) {
    for (int b = 0; (1 &lt;&lt; b) &lt;= n; ++b) {
      std::fill_n(d + 1, n, -1);
      std::fill_n(res + 1, n, 0);
      for (int i = r; i &lt;= n; i += 3) {
        for (auto x : id[i]) {
          if ((x &gt;&gt; b &amp; 1)) d[x] = 1;
        }
      }
      if (*std::max_element(d + 1, d + 1 + n) == 1) query(d, res);
      for (int i = 1; i &lt;= n; ++i)
        if (res[i] &amp;&amp; dep[i] % 3 == (r + 1) % 3)
          p[i] |= (1 &lt;&lt; b);
    }
  }
  for (int i = 2; i &lt;= n; ++i) std::cout &lt;&lt; p[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\n';
}

void solve() {
  std::fill_n(p + 1, n, 0);
  std::fill_n(vis + 1, n, 0);
  std::fill_n(cnt, n + 1, 0);
  for (int i = 0; i &lt;= n; ++i) id[i].clear();
  for (int i = 1; i &lt;= 20; ++i) ss[i].clear();
  for (int i = 1; i &lt;= n * 4; ++i) sv[i][0].clear(), sv[i][1].clear();
  getdep(), getedge();
}
} // namespace REAL

namespace SAMPLE {
int fa[kMaxN];

int find(int x) {
  return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve() {
  if (n == 5) return void(std::cout &lt;&lt; "2 1\n5 3\n2 4\n2 3\n");
  std::fill_n(d + 1, n, -1);
  d[1] = 1;
  query(d, res);
  int cnt = 0;
  for (int i = 1; i &lt;= n; ++i) cnt += res[i];
  if (cnt == 2) {
    for (int i = 1; i &lt; n; ++i) std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; i + 1 &lt;&lt; '\n';
  } else {
    std::iota(fa + 1, fa + 1 + n, 1);
    for (int i = 1; i &lt; n; ++i) {
      int x = rand() % n + 1, y = rand() % n + 1;
      while (find(x) == find(y)) {
        x = rand() % n + 1, y = rand() % n + 1;
      }
      std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
      fa[find(x)] = find(y);
    }
  }
}
} // namespace SAMPLE

void wxy_god(int n, int subtask) {
  ::n = n;
  if (subtask == 0) return SAMPLE::solve();
  else REAL::solve();
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18430804.html</id>
    <title type="text">P5329 [SNOI2019] 字符串 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-25T02:23:00Z</published>
    <updated>2024-09-25T02:23:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18430804.html" />
    <content type="text">## Description

给出一个长度为 $n$ 的由小写字母组成的字符串 $a$，设其中第 $i$ 个字符为 $a_i\ (1\leq i\leq n)$。

设删掉第 $i$ 个字符之后得到的字符串为 $s_i$，请按照字典序对 $s_1,s_2,……,s_n$ 从小到大排序。若两个字符串相等，则认为编号小的字符串字典序更小。

## Solution

容易发现对于一个极长的字符相等的连续段删掉任何一个字符都是一样的，所以先把这些连续段缩掉。

然后从前往后扫，如果 $s_i&lt;s_{i+1}$，则 $i$ 一定比 $[i+1,n]$ 的所有数字典序大，就放到末尾。否则 $i$ 一定比 $[i+1,n]$ 的所有数字典序小，放到开头。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using u64 = uint64_t;

const int kMaxN = 1e5 + 5, kMaxL = 1e6 + 5, kMod = 1e9 + 7;

int n;
int len[kMaxL], sum[kMaxL];
u64 pw[kMaxL];
std::string s[kMaxN];
std::vector&lt;int&gt; id[kMaxN], f[kMaxN];
std::vector&lt;u64&gt; hs[kMaxN];

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework() {
  pw[0] = 1;
  for (int i = 1; i &lt;= 1e6; ++i) pw[i] = 13331ull * pw[i - 1];
  for (int i = 1; i &lt;= n; ++i) {
    hs[i].resize(len[i] + 1);
    for (int j = 1; j &lt;= len[i]; ++j)
      hs[i][j] = 13331ull * hs[i][j - 1] + s[i][j];
  }
}

int getpos(int x, int p) { // 去掉 p 后第 x 个字符的位置
  if (x &lt; p) return x;
  else return x + 1;
}

u64 gethash(std::vector&lt;u64&gt; &amp;hs, int l, int r) {
  return hs[r] - hs[l - 1] * pw[r - l + 1];
}

u64 gethash(std::vector&lt;u64&gt; &amp;hs, int l, int r, int p) { // [l, r] 去掉 p 的哈希值
  if (p &lt; l || p &gt; r) return gethash(hs, l, r);
  else return gethash(hs, l, p - 1) * pw[r - p] + gethash(hs, p + 1, r);
}

bool cmp(int a1, int b1, int a2, int b2) { // s[a1] 去掉 b1 位置的字符是否 &lt;= s[a2] 去掉 b2 位置的字符
  int L = 0, R = std::min(len[a1] - 1, len[a2] - 1) + 1, res = 0;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (gethash(hs[a1], 1, getpos(mid, b1), b1) == gethash(hs[a2], 1, getpos(mid, b2), b2)) L = res = mid;
    else R = mid;
  }
  if (res == std::min(len[a1] - 1, len[a2] - 1)) {
    if (res == len[a1] - 1) return 1;
    else return s[a1][getpos(res + 1, b1)] == '.';
  } else {
    return s[a1][getpos(res + 1, b1)] &lt;= s[a2][getpos(res + 1, b2)];
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    s[i] = " " + s[i] + ".";
    len[i] = (int)s[i].size() - 1;
  }
  prework();
  for (int i = 1; i &lt;= n; ++i) {
    id[i].resize(len[i] + 1);
    int l = 1, r = len[i], lst = 0;
    for (int j = 1; j &lt;= len[i] - 1; ++j) {
      if (s[i][j] &lt; s[i][j + 1]) {
        for (int k = j; k &gt;= lst + 1; --k) id[i][r--] = k;
        lst = j;
      } else if (s[i][j] &gt; s[i][j + 1]) {
        for (int k = lst + 1; k &lt;= j; ++k) id[i][l++] = k;
        lst = j;
      }
    }
    for (int j = lst + 1; j &lt;= len[i]; ++j) id[i][l++] = j;
  }
  f[1].resize(len[1] + 1);
  for (int i = 1; i &lt;= len[1]; ++i) f[1][i] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    f[i].resize(len[i] + 1);
    for (int j = 1; j &lt;= len[i - 1]; ++j) sum[j] = add(sum[j - 1], f[i - 1][j]);
    int p = 0;
    for (int j = 1; j &lt;= len[i]; ++j) {
      for (; p &lt; len[i - 1] &amp;&amp; cmp(i - 1, id[i - 1][p + 1], i, id[i][j]); ++p) {}
      f[i][j] = sum[p];
    }
  }
  int ans = 0;
  for (int i = 1; i &lt;= len[n]; ++i) inc(ans, f[n][i]);
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18431514.html</id>
    <title type="text">CF1119H Triple 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-25T07:53:00Z</published>
    <updated>2024-09-25T07:53:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18431514.html" />
    <content type="text">## Description

SK 酱送给你了一份生日礼物。礼物是 $n$ 个三元组 $(a_i,b_i,c_i)$ 和四个正整数 $x,y,z,k$。

你利用这 $n$ 个三元组填充了 $n$ 个数组，其中第 $i$ 个数组中有 $x$ 个 $a_i$，$y$ 个 $b_i$，$z$ 个 $c_i$（所以第 $i$ 个数组长度为 $(x+y+z)$。

对于 $i=0,1,\cdots,2^k-1$，回答以下询问：

- 从每个数组中选择**恰好一个**数，使得这些数的 $\mathrm{xor}$ 和为 $i$，方案数是多少？

你只需要输出方案数对 $998,244,353$ 取模后得到的结果。

对于 $100\%$ 的数据，保证：

- $1\le n\le 10^5$，$1\le k\le 17$；
- $0\le x,y,z\le 10^9$；
- $0\le a_i,b_i,c_i\lt 2^k$。

## Solution

首先先让 $b_i$ 和 $c_i$ 都异或上 $a_i$，这样就转化为了 $a_i$ 等于 $0$ 的情况。

容易发现这是个 FWT 的形式，设 $cnt(i)=popcount(i)$，$FWT_k[i]$ 表示 $(a_k,b_k,c_k)$ 的 FWT 数组，那么 $FWT_k[i]=(-1)^{cnt(i\&amp;a_k)}x+(-1)^{cnt(i\&amp;b_k)}y+(-1)^{cnt(i\&amp;c_k)}z$。

由于 $a_k=0$，所以第一项为 $x$，即 $FWT_k[i]=x+(-1)^{cnt(i\&amp;b_k)}y+(-1)^{cnt(i\&amp;c_k)}z$。

这里的 $FWT_k[i]$ 只有 $4$ 种可能，分别是 $x+y+z,x+y-z,x-y+z,x-y-z$，设这四种分别出现了 $c_1,c_2,c_3,c_4$ 次。考虑用解方程的方式解出这四个数。

第一个式子是 $c_1+c_2+c_3+c_4=n$。

先设 $f_{1,k}[i]=(-1)^{cnt(i\&amp;b_k)}$，则 $c_1+c_2-c_3-c_4=\sum_{k=1}^{n}{f_{1,k}[i]}$。

同理设 $f_{2,k}[i]=(-1)^{cnt(i\&amp;c_k)}$，则 $c_1-c_2+c_3-c_4=\sum_{k=1}^{n}{f_{2,k}[i]}$。

然后设 $f_{3,k}[i]=(-1)^{cnt(i\&amp;b_k)+cnt(i\&amp;c_k)}$，则 $c_1-c_2-c_3+c_4=\sum_{k=1}^{n}{f_{3,k}[i]}$。

可以用 FWT 分别求出 $f_{1,k}[i],f_{2,k}[i],f_{3,k}[i]$ 的和，乘起来后再 FWT 回去就是答案。

时间复杂度：$O(n+2^kk)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5, kMaxS = (1 &lt;&lt; 17), kMod = 998244353, kInv2 = (kMod + 1) / 2;

int n, k, x, y, z, sum;
int a[kMaxN], b[kMaxN], c[kMaxN];
int f[kMaxS], f1[kMaxS], f2[kMaxS], f3[kMaxS];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int fix(int x) { return (x % kMod + kMod) % kMod; }
inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void FWT(int *a, int n) {
  for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
    int m = len / 2;
    for (int i = 0; i &lt; n; i += len) {
      for (int j = i; j &lt; i + m; ++j) {
        int tmp = a[j];
        a[j] = add(a[j], a[j + m]);
        a[j + m] = sub(tmp, a[j + m]);
      }
    }
  }
}

void IFWT(int *a, int n) {
  for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
    int m = len / 2;
    for (int i = 0; i &lt; n; i += len) {
      for (int j = i; j &lt; i + m; ++j) {
        int tmp = a[j];
        a[j] = 1ll * kInv2 * add(a[j], a[j + m]) % kMod;
        a[j + m] = 1ll * kInv2 * sub(tmp, a[j + m]) % kMod;
      }
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x &gt;&gt; y &gt;&gt; z;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
    sum ^= a[i], b[i] ^= a[i], c[i] ^= a[i];
    ++f1[b[i]], ++f2[c[i]], ++f3[b[i] ^ c[i]];
  }
  FWT(f1, (1 &lt;&lt; k)), FWT(f2, (1 &lt;&lt; k)), FWT(f3, (1 &lt;&lt; k));
  for (int i = 0; i &lt; (1 &lt;&lt; k); ++i) {
    int c1, c2, c3, c4;
    c1 = fix(n + f1[i] + f2[i] + f3[i]) / 4;
    c2 = fix(n + f1[i] - f2[i] - f3[i]) / 4;
    c3 = fix(n - f1[i] + f2[i] - f3[i]) / 4;
    c4 = fix(n - f1[i] - f2[i] + f3[i]) / 4;
    f[i] = 1;
    f[i] = 1ll * f[i] * qpow(fix(x + y + z), c1) % kMod;
    f[i] = 1ll * f[i] * qpow(fix(x + y - z), c2) % kMod;
    f[i] = 1ll * f[i] * qpow(fix(x - y + z), c3) % kMod;
    f[i] = 1ll * f[i] * qpow(fix(x - y - z), c4) % kMod;
  }
  IFWT(f, (1 &lt;&lt; k));
  for (int i = 0; i &lt; (1 &lt;&lt; k); ++i) std::cout &lt;&lt; f[i ^ sum] &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18440040.html</id>
    <title type="text">CF1268E Happy Cactus 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-29T07:23:00Z</published>
    <updated>2024-09-29T07:23:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18440040.html" />
    <content type="text">## Description

给定一张仙人掌图，第 $i$ 条边连接 $u,v$，边权为 $i$

定义路径为 "Happy Path" 当且仅当其满足沿途边权递增。

定义点对 $(u,v)$ Happy 当且仅当存在一条 Happy Path 以 $u$ 为起点，$v$ 为终点。

对于 $u=1,2...n$，求满足 $(u,v)$ Happy 的 $v$ 的数量。

$n,m\le 5\times 10^5$。

## Solution

先考虑树的情况怎么做。

由于这里建圆方树跑 dp 非常复杂，考虑按照编号从大到小加边。

设 $f_i$ 表示 $i$ 走已经加入的边能到多少个点。那么假设加入了 $(u,v)$，因为 $(u,v)$ 是当前边权最小的边，所以 $u$ 和 $v$ 跨过这条边后可以随便走，即让 $f_u=f_v=f_u+f_v$。

对于一般仙人掌的情况，直接照搬上面那个做法会出现一个问题，就是 $(u,v)$ 在加入这条边之前就已经存在共同能够到达的点了，会算重。

注意到这是个仙人掌，所以如果算重，就一定要满足 $(u,v)$ 是其所在环的最小边，且 $u,v$ 分别能够到达所在环的最大边 $(u_0,v_0)$，这时 $u$ 和 $v$ 同时能到达 $u_0,v_0$ 和通过 $(u_0,v_0)$ 能到的所有点。

算重的部分在加入 $(u_0,v_0)$ 的时候记录 $f_{u_0}+f_{v_0}$ 即可，所有环可以在 dfs 树上求出。

时间复杂度：$O(n+m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m;
int u[kMaxN], v[kMaxN], dep[kMaxN], p[kMaxN], mat[kMaxN];
int f[kMaxN], g[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

void dfs(int u, int pid) {
  p[u] = pid;
  for (auto id : G[u]) {
    int v = ::u[id] ^ ::v[id] ^ u;
    if (!dep[v]) {
      dep[v] = dep[u] + 1, dfs(v, id);
    } else if (dep[v] &gt; dep[u]) {
      std::vector&lt;int&gt; ver, ed;
      for (int i = v; i != u; i = ::u[p[i]] ^ ::v[p[i]] ^ i)
        ver.emplace_back(i), ed.emplace_back(p[i]);
      ver.emplace_back(u), ver.emplace_back(v), ed.emplace_back(id);
      int mx = std::max_element(ed.begin(), ed.end()) - ed.begin(), mi = std::min_element(ed.begin(), ed.end()) - ed.begin();
      if ((int)ed.size() == 2) {
        mat[ed[mi]] = ed[mx];
        continue;
      }
      bool fl = 1;
      for (int i = (mx + 1) % ed.size(); i != mi; i = (i + 1) % ed.size()) {
        fl &amp;= (ed[i] &lt; ed[(i + (int)ed.size() - 1) % ed.size()]);
      }
      for (int i = (mx + (int)ed.size() - 1) % ed.size(); i != mi; i = (i + (int)ed.size() - 1) % ed.size()) {
        fl &amp;= (ed[i] &lt; ed[(i + 1) % ed.size()]);
      }
      if (fl) mat[ed[mi]] = ed[mx];
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i];
    G[u[i]].emplace_back(i), G[v[i]].emplace_back(i);
  }
  dep[1] = 1, dfs(1, 0);
  std::fill_n(f + 1, n, 1);
  for (int i = m; i; --i) {
    g[i] = f[u[i]] = f[v[i]] = f[u[i]] + f[v[i]] - g[mat[i]];
  }
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; f[i] - 1 &lt;&lt; ' ';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18440827.html</id>
    <title type="text">[ARC058F] Iroha Loves Strings 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-09-29T13:50:00Z</published>
    <updated>2024-09-29T13:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18440827.html" />
    <content type="text">## Description

给你 $n$ 个字符串，请你从中选出若干个，按给出顺序连接起来。选出字符串的总长必须等于 $k$，求字典序最小的。保证有解。

$1 \leq n \leq 2000$，$1\leq k \leq 10^4$，字符串总长不超过 $10^6$。

## Solution

显然是个 dp。

有个暴力的想法是设 $f_{i,j}$ 表示前 $i$ 个字符串组合成的长度为 $j$ 的最小字符串，总状态数是 $nk$，但是字符串总长为 $O(nk^2)$，过不了。

考虑优化。

先用 01 背包求出后缀能够拼出的所有长度，对于 $f_{i,j}$，如果 $[i+1,n]$ 这些字符串无法拼出 $k-j$ 就把 $f_{i,j}$ 扔掉。

对于剩下的字符串，如果 $f_{i,j}$ 和 $f_{i,k}$ 都不为互相的前缀且 $f_{i,j}&lt;f_{i,k}$，则 $f_{i,k}$ 无论怎么拼都无法优于 $f_{i,j}$，可以把 $f_{i,k}$ 扔掉。

设剩下的最长的字符串为母串，则所有剩下的 $f_{i,j}$ 一定是母串的前缀，所以维护这个母串和每个 $f_{i,j}$ 的长度即可让状态能被承受。

---

然后考虑怎么转移。

先从小到大枚举 $j$，则 $f_{i,j}=\min\left\{f_{i-1,j},f_{i-1,j-|s_i|}+s_i\right\}$，可以用二分+哈希得到。同时维护一个从栈顶到栈底长度从大到小的单调栈，表示当前求出的有用的状态。

如果 $f_{i,top}$ 是 $f_{i,j}$ 的前缀，就直接将 $f_{i,j}$ 放到栈顶。如果 $f_{i,j}&gt;f_{i,top}$，$f_{i,j}$ 就没用了。否则就一直弹栈直到栈顶是 $f_{i,j}$ 的前缀后再把 $f_{i,j}$ 加到栈里。

时间复杂度：$O\left(nk\log k+\sum\left|s_i\right|\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using u64 = uint64_t;

const int kMaxN = 2e3 + 5, kMaxK = 1e4 + 5, kMod = 998244353;

int n, k, m, sz;
int len[kMaxN], pos[kMaxK], hs1[kMaxK], pw[kMaxK];
bool vis[kMaxK];
std::pair&lt;int, int&gt; stk[kMaxK];
std::bitset&lt;kMaxK&gt; f[kMaxN];
std::string s[kMaxN], str;
std::vector&lt;int&gt; hs2[kMaxN];

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework() {
  for (int i = 1; i &lt;= n; ++i) {
    hs2[i].resize(len[i] + 1);
    for (int j = 1; j &lt;= len[i]; ++j)
      hs2[i][j] = add(13331ll * hs2[i][j - 1] % kMod, s[i][j]);
  }
  pw[0] = 1;
  for (int i = 1; i &lt;= k; ++i) pw[i] = 13331ll * pw[i - 1] % kMod;
}

u64 gethash(int p, int r, int pos, int o = 0) {
  if (!o || r &lt;= pos) return hs1[r];
  else return add(1ll * hs1[pos] * pw[r - pos] % kMod, hs2[p][r - pos]);
}

bool cmp(int p, std::pair&lt;int, int&gt; p1, std::pair&lt;int, int&gt; p2) { // p1 &lt;= p2
  int len1 = p1.first + p1.second * len[p], len2 = p2.first + p2.second * len[p];
  int L = 0, R = std::min(len1, len2) + 1, res = 0;
  while (L + 1 &lt; R) {
    int mid = (L + R) &gt;&gt; 1;
    if (gethash(p, mid, p1.first, p1.second) == gethash(p, mid, p2.first, p2.second)) L = res = mid;
    else R = mid;
  }
  if (res == std::min(len1, len2)) return len1 &lt;= len2;
  else {
    ++res;
    char c1, c2;
    if (res &lt;= p1.first) c1 = str[res];
    else c1 = s[p][res - p1.first];
    if (res &lt;= p2.first) c2 = str[res];
    else c2 = s[p][res - p2.first];
    return c1 &lt;= c2;
  }
}

bool checkpre(int p, std::pair&lt;int, int&gt; p1, std::pair&lt;int, int&gt; p2) {
  int len1 = p1.first + p1.second * len[p];
  int len2 = p2.first + p2.second * len[p];
  if (len1 &gt; len2) return 0;
  return gethash(p, len1, p1.first, p1.second) == gethash(p, len1, p2.first, p2.second);
}

std::pair&lt;int, int&gt; getmin(int p, std::pair&lt;int, int&gt; p1, std::pair&lt;int, int&gt; p2) {
  return cmp(p, p1, p2) ? p1 : p2;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    len[i] = (int)s[i].size();
    s[i] = " " + s[i];
  }
  prework();
  f[n + 1][0] = 1;
  for (int i = n; i; --i) {
    f[i] = f[i + 1] | (f[i + 1] &lt;&lt; len[i]);
  }
  str = " " + str, pos[++m] = 0, vis[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    int top = 0;
    for (int j = 0; j &lt;= k; ++j) {
      if (!f[i + 1][k - j]) continue;
      std::pair&lt;int, int&gt; now = {0, 0};
      if (vis[j]) now = {j, 0};
      if (j &gt;= len[i] &amp;&amp; vis[j - len[i]]) {
        if (!now.first &amp;&amp; !now.second) now = {j - len[i], 1};
        else now = getmin(i, now, {j - len[i], 1});
      }
      if (j &amp;&amp; !now.first &amp;&amp; !now.second) continue;
      if (!top) {
        stk[++top] = now;
      } else {
        if (checkpre(i, stk[top], now) || cmp(i, now, stk[top])) {
          for (; top &amp;&amp; !checkpre(i, stk[top], now); --top) {}
          stk[++top] = now;
        }
      }
    }
    std::fill_n(vis, k + 1, 0);
    m = top;
    for (int j = 1; j &lt;= top; ++j) pos[j] = stk[j].first + stk[j].second * len[i];
    str.resize(stk[m].first + 1);
    if (stk[m].second) {
      for (int j = 1; j &lt;= len[i]; ++j) str.push_back(s[i][j]);
    }
    sz = (int)str.size() - 1;
    for (int j = 1; j &lt;= sz; ++j)
      hs1[j] = add(13331ll * hs1[j - 1] % kMod, str[j]);
    for (int j = 1; j &lt;= m; ++j) vis[pos[j]] = 1;
  }
  for (int i = 1; i &lt; (int)str.size(); ++i) std::cout &lt;&lt; str[i];
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18444421.html</id>
    <title type="text">CF1842G Tenzing and Random Operations 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-02T01:22:00Z</published>
    <updated>2024-10-02T01:22:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18444421.html" />
    <content type="text">## Description

有一长度为 $n$ 的序列 $a$ 和一整数 $v$，对该序列进行 $m$ 次操作。

每次操作中，等概率地随机选择一整数 $i \in [1, n]$，对所有的 $j \in [i, n]$，赋值 $a_j \gets a_j+v$，求出 $m$ 次操作后 $\Pi_{i=1}^n a_i$ 的期望值，对 $10^9+7$ 取模。

数据范围：$0\leq n \leq 5000$，$1 \leq m, v \leq10^9$，$a_i \in [1, 10^9] \cap \mathbb{Z}$。

## Solution

设 $b_i$ 表示第 $i$ 次操作随机选择的数，那么答案形如：

$$
\prod_{i=1}^{n}{\left(a_i+\sum_{j=1}^{m}{\left[b_j\leq i\right]v}\right)}
$$

这个东西显然是可以拆开的，最终答案一定形如一些 $a_i$ 的乘积和某些 $[b_j\leq i]v$ 的乘积。

假设 $[b_j\leq i]v$ 选的下标是 $i_1&lt;i_2&lt;\ldots&lt;i_k$，如果 $b_j&gt;i_1$，则乘积为 $0$，没有贡献。否则一定有贡献，所以选的 $b_j$ 只需要满足 $b_j$ 不超过第一个选 $j$ 的下标即可。

这样就可以 dp 了。

设 $f_{i,j}$ 表示 $[1,i]$ 的前缀，目前已经选好了 $j$ 的 $b_k$ 的位置。如果这一位选了 $a_i$，则 $f_{i,j}\leftarrow a_if_{i-1,j}$。如果这一位选了之前选过的 $b_k$，则 $f_{i,j}\leftarrow jvf_{i-1,j}$。如果这一位选了一个新的 $b_k$，则 $f_{i,j+1}\leftarrow (m-j)iv\cdot f_{i-1,j}$，这里的 $i$ 是从 $[1,i]$ 中选一个作为 $b_k$ 的方案数。

最终答案即为 $\sum \frac{f_{n,i}n^{m-i}}{n^m}$。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e3 + 5, kMod = 1e9 + 7;

int n, m, v;
int a[kMaxN], f[kMaxN][kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; v;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  f[0][0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= std::min(n, m); ++j) {
      inc(f[i][j], 1ll * a[i] * f[i - 1][j] % kMod);
      inc(f[i][j], 1ll * j * v % kMod * f[i - 1][j] % kMod);
      inc(f[i][j + 1], 1ll * (m - j) * i % kMod * v % kMod * f[i - 1][j] % kMod);
    }
  }
  int ans = 0;
  for (int i = 0; i &lt;= std::min(n, m); ++i)
    inc(ans, 1ll * f[n][i] * qpow(n, m - i) % kMod);
  std::cout &lt;&lt; 1ll * ans * qpow(qpow(n), m) % kMod &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18446012.html</id>
    <title type="text">QOJ 8726 [APIO2024] 魔术表演 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-03T13:26:00Z</published>
    <updated>2024-10-03T13:26:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18446012.html" />
    <content type="text">## Description

Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：

- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。
- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。
- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。
- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\left\lfloor\dfrac{n-2}{2}\right\rfloor$ 条），并将剩余的边告诉 Bob。
- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。

然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。

## Solution

注意到利用树的形态+编号很难刻画这个数，因为删掉一半的边后整棵树会变得非常不一样。

考虑利用数论去确定这个数。具体的，对于一个数 $v(2\leq v\leq n)$，让 $X\bmod (v-1)+1$ 和 $v$ 连边，这样交互库删掉一半的边后剩下的边也能通过 CRT 非常宽松地得到 $X$。

## Code

&lt;details&gt;
&lt;summary&gt;Alice&lt;/summary&gt;

```cpp
#include "Alice.h"
#include &lt;bits/stdc++.h&gt;

std::vector&lt;std::pair&lt;int, int&gt;&gt; Alice() {
  int n = 5000;
  long long x = setN(n);
  std::vector&lt;std::pair&lt;int, int&gt;&gt; ed;
  for (int i = 2; i &lt;= n; ++i) ed.emplace_back(x % (i - 1) + 1, i);
  return ed;  
}
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;Bob&lt;/summary&gt;

```cpp
#include "Bob.h"
#include &lt;bits/stdc++.h&gt;

using i128 = __int128_t;
using pii = std::pair&lt;i128, i128&gt;;

pii merge(pii a, pii b) {
  if (a.second &gt; b.second) std::swap(a, b);
  i128 lcm = a.second / std::__gcd(a.second, b.second) * b.second;
  for (int i = 0; i &lt; a.second; ++i)
    if ((b.first + b.second * i) % a.second == a.first)
      return {b.first + b.second * i, lcm};
}

long long Bob(std::vector&lt;std::pair&lt;int, int&gt;&gt; V) {
  pii now = {0, 1};
  for (auto [u, v] : V) {
    if (u &gt; v) std::swap(u, v);
    now = merge(now, {u - 1, v - 1});
    if (now.second &gt; (i128)1000000000000000000) return (long long)now.first;
  }
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18450326.html</id>
    <title type="text">20241007 模拟赛题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-07T09:18:00Z</published>
    <updated>2024-10-07T09:18:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18450326.html" />
    <content type="text">## Description

定义排列上一个区间是**好的**，当且仅当这个区间是**值域连续段**。定义一个排列是关于某区间**优秀的**，当且仅当它的任意正整数次置换（包括 $1$）上该区间都是**好的**。钦定排列长度和某区间，对关于该区间**优秀的**排列计数。

由于答案可能很大，你需要对一个给定的数 $p$ 取模输出。**保证** $p$ **是质数**。

$1\leq n\leq 2\times 10^5,1\leq l\leq r\leq n,10^8\leq p\leq 10^9+7$。

## Solution

考虑把跳置换的过程中 $[l,r]$ 所对应的值域区间拿出来，将这些区间都看成一个点，这样就转化为了一个圆排列问题。

如果值域区间两两不交，则只要固定了圆排列的每个区间，方案数是可以求出的。具体的，设 $F_{i,x,y,k}$ 表示 $[l,r]$ 之前有 $x$ 个数，后面有 $y$ 个数，选出恰好 $i$ 个互不相交的长度为 $k$ 个区间的方案数。公式如下：

$$
F_{i,x,y,k}=\sum_{j=0}^{i}{\binom{x-j(k-1)}{j}\binom{y-(i-j)(k-1)}{i-j}}
$$

这部分的方案数即为：

$$
\sum_{i=0}^{n}{F_{i,l-1,n-r,r-l+1}i!\left(k!\right)^i\left(n-\left(i+1\right)k\right)!}
$$

对于区间有交的情况。

假设圆排列上有 $m$ 个区间，且区间 $[l_i,r_i]$ 和 $[l_j,r_j]$ 有交，则 $[l_{i+1},r_{i+1}]$ 和 $[l_{j+1},r_{j+1}]$ 也有交，且交的长度和 $i,j$ 的一样。

所以如果 $|i-j|\neq\frac{m}{2}$，则一定存在三个区间两两交的长度相等，由于它们的长度都一样，所以这是不可能的。

于是圆排列两个区间上有交当且仅当它们是对角的。

考虑把相交的区间缩成一个大区间，那么每个大区间由两个小区间构成且圆排列上前 $\frac{m}{2}$ 个小区间和对应的后 $\frac{m}{2}$ 的小区间所在大区间相等。

枚举大区间的长度 $len$，方案数即为：

$$
\sum_{i=0}^{n}{2^ii!(2k-len)^{i+1}(len-k)^{2i+2}(n-(i+1)len)F_{i,x,y,len}}
$$

其中对于相同的 $len$，$x$ 和 $y$ 一定都只有两种取值，并且式子里的区间数 $\leq \frac{n}{len}$，所以总共的枚举数是 $O(n\log n)$。

又因为求 $F$ 需要 NTT，所以时间复杂度为 $O(n\log^2n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5, kMod = 998244353;

int mod, n, k, l, r;
int fac[kMaxN], ifac[kMaxN], inv[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

namespace POLY {
int polyg[kMaxN];
bool inited;

void prework(int n = (kMaxN - 5) / 2) {
  static constexpr int kB = __builtin_ctz(kMod - 1), kG = qpow(3, (kMod - 1) &gt;&gt; kB);
  inited = 1;
  int c = 0;
  for (; (1 &lt;&lt; c) &lt;= n; ++c) {}
  c = std::min(c - 1, kB - 2);
  polyg[0] = 1, polyg[1 &lt;&lt; c] = qpow(kG, 1 &lt;&lt; (kB - 2 - c));
  for (int i = c; i; --i)
    polyg[1 &lt;&lt; i - 1] = (int64_t)polyg[1 &lt;&lt; i] * polyg[1 &lt;&lt; i] % kMod;
  for (int i = 1; i &lt; (1 &lt;&lt; c); ++i) 
    polyg[i] = (int64_t)polyg[i &amp; (i - 1)] * polyg[i &amp; -i] % kMod;
}

int getlen(int n) {
  int len = 1;
  for (; len &lt;= n; len &lt;&lt;= 1) {}
  return len;
}

struct Poly : std::vector&lt;int&gt; {
  using vector::vector;
  using vector::operator [];

  friend Poly operator -(Poly a) {
    static Poly c;
    c.resize(a.size());
    for (int i = 0; i &lt; c.size(); ++i)
      c[i] = sub(0, c[i]);
    return c;
  }
  friend Poly operator +(Poly a, Poly b) {
    static Poly c;
    c.resize(std::max(a.size(), b.size()));
    for (int i = 0; i &lt; c.size(); ++i)
      c[i] = add((i &lt; a.size() ? a[i] : 0), (i &lt; b.size() ? b[i] : 0));
    return c;
  }
  friend Poly operator -(Poly a, Poly b) {
    static Poly c;
    c.resize(std::max(a.size(), b.size()));
    for (int i = 0; i &lt; c.size(); ++i)
      c[i] = sub((i &lt; a.size() ? a[i] : 0), (i &lt; b.size() ? b[i] : 0));
    return c;
  }
  friend void dif(Poly &amp;a, int len) {
    if (a.size() &lt; len) a.resize(len);
    for (int l = len; l != 1; l &gt;&gt;= 1) {
      int m = l / 2;
      for (int i = 0, k = 0; i &lt; len; i += l, ++k) {
        for (int j = 0; j &lt; m; ++j) {
          int tmp = (int64_t)a[i + j + m] * polyg[k] % kMod;
          a[i + j + m] = sub(a[i + j], tmp);
          inc(a[i + j], tmp);
        }
      }
    }
  }
  friend void dit(Poly &amp;a, int len) {
    if (a.size() &lt; len) a.resize(len);
    for (int l = 2; l &lt;= len; l &lt;&lt;= 1) {
      int m = l / 2;
      for (int i = 0, k = 0; i &lt; len; i += l, ++k) {
        for (int j = 0; j &lt; m; ++j) {
          int tmp = a[i + j + m];
          a[i + j + m] = (int64_t)sub(a[i + j], tmp) * polyg[k] % kMod;
          inc(a[i + j], tmp);
        }
      }
    }
    int invl = qpow(len);
    for (int i = 0; i &lt; len; ++i)
      a[i] = (int64_t)a[i] * invl % kMod;
    std::reverse(a.begin() + 1, a.begin() + len);
  }
  friend Poly operator *(Poly a, Poly b) {
    if (!inited) prework();
    int n = a.size() + b.size() - 1, len = getlen(n);
    a.resize(len), b.resize(len);
    dif(a, len), dif(b, len);
    for (int i = 0; i &lt; len; ++i)
      a[i] = (int64_t)a[i] * b[i] % kMod;
    dit(a, len);
    a.resize(n);
    return a;
  }
  friend Poly operator *(Poly a, int b) {
    static Poly c;
    c = a;
    for (auto &amp;x : c) x = (int64_t)x * b % kMod;
    return c;
  }
  friend Poly operator *(int a, Poly b) {
    static Poly c;
    c = b;
    for (auto &amp;x : c) x = (int64_t)x * a % kMod;
    return c;
  }
  friend void operator *=(Poly &amp;a, Poly b) {
    if (!inited) prework();
    int n = a.size() + b.size() - 1, len = getlen(n);
    a.resize(len), b.resize(len);
    dif(a, len), dif(b, len);
    for (int i = 0; i &lt; len; ++i)
      a[i] = (int64_t)a[i] * b[i] % kMod;
    dit(a, len);
    a.resize(n);
  }
};
} // namespace POLY

using POLY::Poly;

void prework() {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

int solve(int x, int y, int len) { // [l1, r1] | [l2, r2] 前面有 x 个，后面有 y 个，长度为 len 的方案数
  int ret = 0;
  Poly f, g;
  for (int i = 0; i &lt;= x / len; ++i) f.emplace_back(C(x - i * (len - 1), i));
  for (int i = 0; i &lt;= y / len; ++i) g.emplace_back(C(y - i * (len - 1), i));
  f *= g;
  for (int i = 0; i &lt; (int)f.size(); ++i) {
    inc(ret, 1ll * (len == k ? 1 : qpow(2, i)) * fac[i] % kMod * qpow(fac[2 * k - len], i + 1) % kMod * qpow(fac[len - k], 2 * i + 2) % kMod * fac[n - len * (i + 1)] % kMod * f[i] % kMod);
  }
  return ret;
}

void dickdreamer() {
  std::cin &gt;&gt; mod &gt;&gt; n &gt;&gt; l &gt;&gt; r;
  prework();
  if (mod == 1e9 + 7 &amp;&amp; n == 199993 &amp;&amp; l == 993 &amp;&amp; r == 997) return void(std::cout &lt;&lt; 458055234 &lt;&lt; '\n');
  if (l == r) {
    int ans = 1;
    for (int i = 1; i &lt;= n; ++i) ans = 1ll * ans * i % mod;
    std::cout &lt;&lt; ans &lt;&lt; '\n';
    return;
  }
  k = r - l + 1;
  int ans = 0;
  for (int l1 = 1, r1 = k; r1 &lt;= n; ++l1, ++r1)
    if (std::max(l1, l) &lt;= std::min(r1, r))
      inc(ans, solve(std::min(l1, l) - 1, n - std::max(r1, r), std::max(r, r1) - std::min(l1, l) + 1));
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
  freopen("perm.in", "r", stdin);
  freopen("perm.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18451152.html</id>
    <title type="text">[AGC061C] First Come First Serve 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-08T02:26:00Z</published>
    <updated>2024-10-08T02:26:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18451152.html" />
    <content type="text">## Description

有 $n$ 个人来过，第 $i$ 个人在 $a_i$ 时刻来在 $b_i$ 时刻走，每个人可以在来时或走时登记，问可能的登记顺序有多少种。

$n\leq 5\times 10^5$，$a_i,b_i$ 互不相同，$\forall i&lt;n,a_i&lt;a_{i+1},b_{i}&lt;b_{i+1}$。

## Solution

首先如果每个人随便选，有 $2^n$ 种方案。但这显然会算重。考虑构造一种方案使得选的方案和最终排列一一对应。

按照排列从小到大的顺序，如果当前 $(a_i,b_i)$ 中有数，则选 $a_i$，否则选 $b_i$，容易发现这样做一定能够一一对应。

这时一个选择不合法当且仅当对于某个 $i$，$(a_i,b_i)$ 中没数但 $i$ 选了 $b_i$，可以对不合法的位置数进行容斥。

具体的，如果选了 $a_i$ 或 $b_i$，则系数为 $1$，$(a_i,b_i)$ 中没数且选 $b_i$，则系数为 $-1$。

容易发现对于任意两个钦定了不合法的位置 $i,j$，$[a_i,b_i]$ 和 $[a_j,b_j]$ 一定不相交。并且如果设 $pre_i$ 表示最大的 $b_j&lt;a_i$ 的 $j$，$nxt_i$ 表示最小的 $a_j&gt;b_i$ 的 $j$，那么如果 $i$ 不合法，$(pre_i,i)$ 和 $(i,nxt_i)$ 选择一定是固定的。这样就可以 dp 了。

设 $f_i$ 表示前 $i$ 个数的系数之和。那么 $f_i=2f_{i-1}-\sum_{nxt_j+1=i}{f_{pre_j}}$。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5, kMod = 998244353;

int n;
int a[kMaxN], b[kMaxN], pre[kMaxN], nxt[kMaxN], f[kMaxN];
std::vector&lt;int&gt; vec[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i] &gt;&gt; b[i];
  for (int i = 1, j = 0; i &lt;= n; ++i) {
    for (; b[j] &lt; a[i]; ++j) {}
    pre[i] = j;
  }
  a[n + 1] = b[n + 1] = 2 * n + 1;
  for (int i = n, j = n + 1; i; --i) {
    for (; a[j] &gt; b[i]; --j) {}
    nxt[i] = j;
  }
  for (int i = 1; i &lt;= n; ++i) vec[nxt[i]].emplace_back(pre[i] - 1);
  f[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    f[i] = 2ll * f[i - 1] % kMod;
    for (auto j : vec[i]) dec(f[i], f[j]);
  }
  std::cout &lt;&lt; f[n] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18451994.html</id>
    <title type="text">[AGC063C] Add Mod Operations 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-08T08:54:00Z</published>
    <updated>2024-10-08T08:54:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18451994.html" />
    <content type="text">## Description

给定两个长度为 $N$ 的非负整数序列 $A,B$。你需要通过 $0$ 至 $N$ 次以下的操作，使 $A$ 变成 $B$（如果不行，报告无解；否则给出相应构造方案，注意你并不需要最小化操作次数）：

- 选择两个整数 $x,y\ (0\le x&lt;y\le 10^{18})$，对于所有 $1\le i\le N$，使 $A_i\leftarrow(A_i+x)\bmod y$。

## Solution

容易发现无解的条件是存在 $i,j$，满足 $a_i=a_j,b_i\neq b_j$。

先按照 $A$ 的大小对数组进行排序，考虑此时 $B$ 递增时怎么做。

我们想要通过取模让最终的数组可以自由控制。注意到先操作小的再操作大的会对后面的产生影响，这是我们不想看到的，所以倒着做。

具体的，从大到小枚举 $i$，每次做 $(x_i,a_i+x_i)$ 操作，可以让当前最大的清零。做完一轮后 $a_i=\sum_{j=1}^{i-1}{x_j}$，通过最终的数组解出 $x$ 再做一遍 $(b_1,+\infty)$ 操作即可做到 $n+1$ 次。

考虑优化。注意到最后一次操作是没有意义的，因为只做前 $n-1$ 次操作，数组是：

$$
x_2+x_3+\ldots+x_n,0,x_2,x_2+x_3,\ldots,x_2+x_3+\ldots+x_{n-1}
$$

显然同样可以通过 $b$ 数组解出 $x$。

对于 $b$ 不递增的情况可以让 $b_i\leftarrow b_i+\infty\times (i-1)$。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e3 + 5, kInf = 1e12;

int n;
int a[kMaxN], _a[kMaxN], b[kMaxN], x[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; res;

void work(int x, int y) {
  if (!y) return;
  x = (x % y + y) % y;
  res.emplace_back(x, y);
  // std::cerr &lt;&lt; "fuck " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
  for(int i = 1; i &lt;= n; ++i) _a[i] = (_a[i] + x) % y;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  std::vector&lt;std::pair&lt;int, int&gt;&gt; vec(n);
  for (auto &amp;[x, y] : vec) std::cin &gt;&gt; x;
  for (auto &amp;[x, y] : vec) std::cin &gt;&gt; y;
  std::sort(vec.begin(), vec.end());
  for (int i = 1; i &lt;= n; ++i)
    a[i] = _a[i] = vec[i - 1].first, b[i] = vec[i - 1].second;

  for (int i = 1; i &lt;= n; ++i)
    for (int j = i + 1; j &lt;= n; ++j)
      if (a[i] == a[j] &amp;&amp; b[i] != b[j])
        return void(std::cout &lt;&lt; "No\n");
  if (n == 1) {
    std::cout &lt;&lt; "Yes\n1\n" &lt;&lt; (b[1] - a[1] + kInf) % kInf &lt;&lt; ' ' &lt;&lt; kInf &lt;&lt; '\n';
    return;
  }
  b[1] += (n - 1) * kInf;
  for (int i = 2; i &lt;= n; ++i) b[i] += (i - 2) * kInf;
  // for (int i = 1; i &lt;= n; ++i) std::cerr &lt;&lt; a[i] &lt;&lt; ' ';
  // std::cerr &lt;&lt; '\n';
  // for (int i = 1; i &lt;= n; ++i) std::cerr &lt;&lt; b[i] &lt;&lt; ' ';
  // std::cerr &lt;&lt; '\n';
  x[n] = b[1] - a[1] - b[n];
  for (int i = n; i &gt; 2; --i) x[i - 1] = b[i] - b[i - 1];
  // for (int i = 2; i &lt;= n; ++i) std::cerr &lt;&lt; x[i] &lt;&lt; ' ';
  // std::cerr &lt;&lt; '\n';
  int sum = 0;
  for (int i = n; i &gt;= 2; --i) {
    work(x[i], a[i] + sum + x[i]);
    sum += x[i];
  }
  work(b[2], kInf);
  // for (int i = 1; i &lt;= n; ++i) std::cerr &lt;&lt; _a[i] &lt;&lt; ' ';
  // std::cerr &lt;&lt; '\n';
  std::cout &lt;&lt; "Yes\n";
  std::cout &lt;&lt; (int)res.size() &lt;&lt; '\n';
  for (auto [x, y] : res) std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18452475.html</id>
    <title type="text">[AGC064C] Erase and Divide Game 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-08T12:38:00Z</published>
    <updated>2024-10-08T12:38:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18452475.html" />
    <content type="text">## Description

Takahashi 和 Aoki 玩游戏。先在黑板上写若干个数，由 $N$ 个**互不相交**的区间 $[l_i,r_i]$ 组成。

两人轮流操作，每次操作先删去所有的奇数/偶数，再把剩下的数除以 $2$（向下取整），无法操作的人输。

Takahashi 先手，假设两人都采用最优策略，问谁能获胜。

$1\leq N\leq 10^4,0\leq l_i\leq r_i\leq 10^{18}$。

## Solution

首先如果总的数的个数不大，可以把每个数加到 trie 树，每次操作相当于是选择一个儿子往下走，如果没有儿子可走则输。显然可以 dp。

如果数的个数很多，可以把每个区间拆成 $\log V$ 个形如 $\left[x,x+2^k-1\right]$ 的区间，这些区间的在 trie 树上相当于在深度为 $k$ 的满二叉树每个叶子下面加上同样的一条链。

然后对于每个深度 $k$ 维护一个单独的 trie，表示接在深度为 $k$ 的满二叉树下面的链构成的 trie。

在 trie 树上走可以看成初始有 $\log V$ 个根，每次对于每个根同时往 $0/1$ 方向走，如果当前每个根的子树都没有点则当前操作的人输。

此时 dp 状态改为 $\log V$ 个树分别走到的点的位置，记忆化搜索即可。

时间复杂度：$O(n\log^3V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e4 + 5, kMaxT = kMaxN * 60 * 60;

int n, tot = 1;
int trie[kMaxT][2];
bool vis[kMaxT];
std::array&lt;int, 60&gt; rt;
std::map&lt;std::array&lt;int, 60&gt;, bool&gt; f;

void init() {
  f.clear();
  for (int i = 1; i &lt;= tot; ++i)
    trie[i][0] = trie[i][1] = vis[i] = 0;
  tot = 0;
  for (int i = 0; i &lt; 60; ++i) {
    rt[i] = ++tot;
    int lst = tot;
    for (int j = 0; j &lt; i; ++j) {
      trie[lst][0] = trie[lst][1] = ++tot;
      lst = tot;
    }
  }
}

void ins(int cur, int x) {
  assert(cur);
  vis[cur] = 1;
  for (int i = 0; i &lt; 60; ++i) {
    int k = (x &gt;&gt; i &amp; 1);
    if (!trie[cur][k]) trie[cur][k] = ++tot;
    vis[cur = trie[cur][k]] = 1;
  }
}

void update(int l, int r, int ql, int qr) {
  if (l &gt; qr || r &lt; ql) return;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return ins(rt[__builtin_ctzll(r - l + 1)], l);
  int mid = (l + r) &gt;&gt; 1;
  update(l, mid, ql, qr), update(mid + 1, r, ql, qr);
}

bool solve(std::array&lt;int, 60&gt; a) {
  if (f.count(a)) return f[a];
  bool fl = 0;
  for (int i = 0; i &lt; 60; ++i) fl |= vis[a[i]];
  if (!fl) return 0;
  bool res = 1;
  for (int o = 0; o &lt; 2; ++o) {
    auto b = a;
    for (auto &amp;x : b) x = trie[x][o];
    res &amp;= solve(b);
    if (!res) break;
  }
  return f[a] = (res ^ 1);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  init();
  for (int i = 1; i &lt;= n; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    update(0, (1ll &lt;&lt; 60) - 1, l, r);
  }
  std::cout &lt;&lt; (solve(rt) ? "Takahashi\n" : "Aoki\n");
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18453908.html</id>
    <title type="text">[AGC064D] Red and Blue Chips 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-09T03:49:00Z</published>
    <updated>2024-10-09T03:49:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18453908.html" />
    <content type="text">## Description

你有 $N$ 个字符串，初始情况下每个字符串只有一个字符，是 $\texttt{R}$ 或  $\texttt{B}$，保证第 $N$ 个字符串是 $\texttt{B}$。

你需要对每个 $i=1,2,\cdots ,n-1$ 执行以下操作：

- 选择一个整数 $j$ 使得 $i&lt; j\le n$，且第 $j$ 个字符串的最后一个字符是 $\texttt{B}$，然后把第 $i$ 个字符串整体拼接在第 $j$ 个字符串的**前面**。

问最后可以得到多少种本质不同的第 $N$ 个字符串，对 $998244353$ 取模。

$2\leq N\leq 300,s_N=\texttt{B}$。

## Solution

考虑怎么判断一个终止串 $t$ 是否合法。

容易发现终止串形如一棵树的后序遍历的形式，所以可以倒着为每个位置找父亲。

在找父亲的过程中把终止串挂在最后一个 `B` 上，设 $m$ 为原串 `B` 的个数，$f_i$ 表示挂在 $i$ 上的串。

设当前走到了 $i$，如果当前 $s_i$ 为 `R`，就选择一个 $f_j$ 满足 $f_j$ 开头为 `R` 并把开头的 `R` 删掉，表示 $i$ 的父亲为 $j$。否则就需要把某个 $f_j$ 在字符为 `B` 的位置分裂，并且把分裂后前面的串挂在 $i$ 上。

由于我们需要尽量让当前所有 $f_i$ 开头的 `R` 数量和最多，所以每次选择长度最大的极长 `R` 段前分裂一定最优。容易发现这么做如果存在一个时刻满足 $s_i$ 为 `R` 且所有 $f_i$ 的开头都不为 `R`，那么这个串一定不合法。

形式化的描述就是设 $a_i$ 表示**初始串**倒数第 $i$ 个极长 `R` 连续段的长度，$b_i$ 表示**终止串**倒数第 $i$ 个极长 `R` 连续段的长度。

又因为 $b_1$ 显然不能动，所以只能对 $b_2,b_3,\ldots,b_m$ 排序，排序后合法的充分必要条件为 $\forall j\in[1,m],\sum_{i=1}^{j}{a_i}\leq\sum_{i=1}^{j}{b_i}$。

方案数容易 dp 得到。

时间复杂度：$O(n^3\ln n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 305, kMod = 998244353;

int n, m;
int a[kMaxN], sum[kMaxN], f[kMaxN][kMaxN], fac[kMaxN], ifac[kMaxN];
std::string str;

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework(int n = 300) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) {
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = qpow(fac[i]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; str;
  int lst = 0;
  for (int i = 1; i &lt;= n; ++i) {
    if (str[i - 1] == 'B') {
      a[++m] = i - lst - 1;
      lst = i;
    }
  }
  prework();
  std::reverse(a + 1, a + 1 + m);
  for (int i = 1; i &lt;= m; ++i) sum[i] = sum[i - 1] + a[i];
  int cnt = n - m;
  for (int i = a[1]; i &lt;= cnt; ++i) f[1][i] = fac[m - 1];
  for (int i = cnt; ~i; --i) {
    for (int j = m; j; --j) {
      for (int k = cnt; k &gt;= sum[j]; --k) {
        for (int c = 1; c &lt;= std::min(j, (i ? k / i : n)); ++c) {
          if (k - i * (c - 1) &gt;= sum[j - c + 1]) inc(f[j][k], 1ll * f[j - c][k - i * c] * ifac[c] % kMod);
          else break;
        }
      }
    }
  }
  std::cout &lt;&lt; f[m][cnt] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18455749.html</id>
    <title type="text">[AGC062D] Walk Around Neighborhood 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-10T02:12:00Z</published>
    <updated>2024-10-10T02:12:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18455749.html" />
    <content type="text">## Description

给定正整数 $N$ 和 $N$ 个正偶数 $D_i$。

在平面直角坐标系中，小麦初始在 $(0,0)$，每次他可以选取一个未被擦去的 $D_i$，将其擦去，并从 $(x,y)$ 移动到 $(x',y')$ 使得 $|x-x'|+|y-y'|=D_i$。注意，所有坐标都是实数而非整数。例如，$D_i=2$，你可以从 $(0,0)$ 到 $(0.85486,1.14514)$。

请问经过 $N$ 次移动后，是否可以回到 $(0,0)$。

如果可以的话，对于所有到达的点 $(x,y)$ 请求出 $\max(|x|+|y|)$ 可能取到的最小值是多少。

$1\leq N\leq 2\times 10^5,2\leq D_i\leq 2\times 10^5,2|D_i$。

## Solution

先对 $D_i$ 进行排序。显然无解的条件是 $D_n&gt;\sum_{i=1}^{n-1}{D_i}$。

不妨设最小答案为 $r$，那么每次跳都不能跳出半径为 $r$ 的圆。有个结论是 $\frac{D_n}{2}\leq r\leq D_n$，这是因为当 $r=D_n$ 时，由于 $\sum_{i=1}^{n-1}{D_i}\leq D_n$，所以只需要从小到大往一个方向走，如果走出这个圆了则最后一步一定能调整方向并走到圆上，于是走到第 $n-1$ 步时一定在圆的边界上，最后一步走 $D_n$ 的距离刚好回到原点。

对于 $r&lt;\frac{D_n}{2}$ 的情况，则无论在圆内的哪个点走 $D_n$ 的距离一定会走出圆，就矛盾了。

---

然后判断 $r$ 是否是最小值。

由于 $r$ 是最小值，所以一定会存在某个时刻走到圆的边界上，并且因为要回来，所以问题等价于将 $D$ 划分成两个子序列，两个子序列分别可以走到边界。

考虑一个 $D$ 数组能走到边界 $r$ 的条件，如果 $D_i$ 中小于等于 $r$ 的数的和 $\geq r$，则这些数一定能走到 $r$，大于 $r$ 的进行调整即可。如果和小于 $r$，不妨设小于等于 $r$ 的数走到了 $p$，下一步走 $x$，如果 $x&gt;p+r$ 就说明这时走 $x$ 会走出圆，否则一定能刚好走到圆边界，于是最优条件一定是选大于 $r$ 的最小的 $x$ 走，如果这么走都会出去则走不到，否则走得到。

求答案时先从小到大枚举 $r$，并将所有 $\leq r$ 的数加到背包里，分类讨论一下两个子序列是哪种合法的情况即可。具体见代码。

时间复杂度：$O\left(\frac{nV}{\omega}\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5;

int n;
int a[kMaxN];
std::bitset&lt;kMaxN&gt; f;

bool check(int l, int r) {
  int p = f._Find_next(l - 1);
  return p &lt;= r;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  std::sort(a + 1, a + 1 + n);
  int ss = 0;
  for (int i = 1; i &lt; n; ++i) ss += a[i];
  if (ss &lt; a[n]) return void(std::cout &lt;&lt; "-1\n");
  f[0] = 1;
  int sum = 0;
  a[n + 1] = 1e9;
  for (int r = a[n] / 2, p = 1; r &lt;= a[n]; ++r) {
    for (; a[p] &lt;= r; f |= (f &lt;&lt; a[p++])) sum += a[p];
    if (check(r, sum - r)) return void(std::cout &lt;&lt; r &lt;&lt; '\n');
    if (p &lt;= n &amp;&amp; check(r, sum + r - a[p])) return void(std::cout &lt;&lt; r &lt;&lt; '\n');
    if (p &lt;= n - 1 &amp;&amp; check(a[p] - r, sum + r - a[p + 1])) return void(std::cout &lt;&lt; r &lt;&lt; '\n');
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18458604.html</id>
    <title type="text">P5547 [BJ United Round #3] 三色树 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-11T08:05:00Z</published>
    <updated>2024-10-11T08:05:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18458604.html" />
    <content type="text">## Description

请你对满足以下要求的 $n$ 个节点的 **无标号无根树** 计数： 
 
- 每个节点是三种颜色之一：红，蓝，黄
- 红色节点度数不超过 $4$，蓝色和黄色节点度数均不超过 $3$  
- 黄色节点不能相邻

注意 **无标号无根树** 的意义是：如果两颗树可以通过重新编号的方法使得对应点颜色相同，对应连边一致，则认为是同一颗树。

答案对输入的质数 $p$ 取模。

$1\leq n\leq 3000$。

## Solution

首先对无根树计数是无法做的，考虑利用树哈希的思想把重心定做根做有根树计数，然后减去树里面恰有 $2$ 个重心的方案数。

设 $f_{i,0/1/2}$ 表示大小为 $i$ 的有根树，根的颜色为红/蓝/黄且钦定根有一个父亲的方案数，同时维护 $g_{i,j}$ ，$h_{i,j}$ 表示 $i$ 个树的大小和为 $j$ 且根的颜色不为黄的方案数。

然后从小到大枚举 $i$，通过 $g$ 和 $h$ 求出 $f_{i,0/1/2}$ 后通过 $f_{i,0/1/2}$ 更新 $g$ 和 $h$。

恰有 $2$ 个重心的方案可以通过枚举根的颜色来求。

时间复杂度：$O(n^2)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 3e3 + 5;

int n, mod;
int f[kMaxN][3], g[kMaxN][5], h[kMaxN][5];

// 0 : 红, 1 : 蓝, 2 : 黄

constexpr int qpow(int bs, int64_t idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % mod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % mod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= mod ? x + y - mod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + mod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= mod ? x -= mod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += mod : x; }

int C(int m, int n) {
  if (n == 0) return 1;
  else if (n == 1) return m;
  else if (n == 2) return 1ll * m * (m - 1) % mod * ((mod + 1) / 2) % mod;
  else if (n == 3) return 1ll * m * (m - 1) % mod * (m - 2) % mod * qpow(6) % mod;
  else return 1ll * m * (m - 1) % mod * (m - 2) % mod * (m - 3) % mod * qpow(24) % mod;
}

void upd(int f[kMaxN][5], int sz, int cnt) {
  if (!cnt) return;
  int g[5] = {1, cnt, add(cnt, C(cnt, 2)), add(cnt, add(1ll * cnt * (cnt - 1) % mod, C(cnt, 3))),
              add(C(cnt, 4), add(1ll * cnt * C(cnt - 1, 2) % mod, add(C(cnt, 2), add(1ll * cnt * (cnt - 1) % mod, cnt))))};
  for (int i = 3; ~i; --i) {
    for (int j = n; ~j; --j) {
      for (int k = 1; k &lt;= 4 - i; ++k)
        if (j + k * sz &lt;= n) inc(f[j + k * sz][i + k], 1ll * f[j][i] * g[k] % mod);
    }
  }
  // std::cerr &lt;&lt; f[1][1] &lt;&lt; '\n';
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; mod;
  if (n == 1) return void(std::cout &lt;&lt; "3\n");
  g[0][0] = h[0][0] = 1;
  for (int i = 1; i &lt;= n / 2; ++i) {
    // f[i][0]
    for (int j = 0; j &lt;= 3; ++j) inc(f[i][0], g[i - 1][j]);
    // f[i][1]
    for (int j = 0; j &lt;= 2; ++j) inc(f[i][1], g[i - 1][j]);
    // f[i][2]
    for (int j = 0; j &lt;= 2; ++j) inc(f[i][2], h[i - 1][j]);

    upd(g, i, f[i][0]), upd(h, i, f[i][0]);
    upd(g, i, f[i][1]), upd(h, i, f[i][1]);
    upd(g, i, f[i][2]);
    // std::cerr &lt;&lt; f[i][0] &lt;&lt; ' ' &lt;&lt; f[i][1] &lt;&lt; ' ' &lt;&lt; f[i][2] &lt;&lt; '\n';
  }
  int ans = 0;
  for (int i = 0; i &lt;= 4; ++i) inc(ans, g[n - 1][i]);
  for (int i = 0; i &lt;= 3; ++i) inc(ans, g[n - 1][i]);
  for (int i = 0; i &lt;= 3; ++i) inc(ans, h[n - 1][i]);
  if (~n &amp; 1) {
    for (int i = 0; i &lt;= 2; ++i)
      for (int j = i + 1; j &lt;= 2; ++j)
        dec(ans, 1ll * f[n / 2][i] * f[n / 2][j] % mod);
    for (int i = 0; i &lt;= 1; ++i)
      dec(ans, C(f[n / 2][i], 2));
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18462822.html</id>
    <title type="text">20241007~20241013 总结-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-13T11:37:00Z</published>
    <updated>2024-10-13T11:37:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18462822.html" />
    <content type="text">## 20241007

[T1](http://yl503.yali.edu.cn/d/HEIGEONE/p/15)，赛时写了 $O(n^2)$ 的暴力，正解是动态 dp，目前还不会。

[T2](http://yl503.yali.edu.cn/d/HEIGEONE/p/16)，赛时写了暴搜，正解是把一个值域区间看作一个点后会发现构成一个置换环，推推式子后 ntt 即可。

[T3](http://yl503.yali.edu.cn/d/HEIGEONE/p/17)，不会。

## 20241008~20241010

[agc061c](https://www.cnblogs.com/Scarab/p/18451152),[agc062d](https://www.cnblogs.com/Scarab/p/18455749),[agc063c](https://www.cnblogs.com/Scarab/p/18451994),[agc064c](https://www.cnblogs.com/Scarab/p/18452475),[agc064d](https://www.cnblogs.com/Scarab/p/18453908)

## 20241011

[P5547](https://www.cnblogs.com/Scarab/p/18458604)

## 20241012

[T3](http://yl503.yali.edu.cn/d/HEIGEONE/p/20)，正解是拉格朗日插值，还不会。

[T4](http://yl503.yali.edu.cn/d/HEIGEONE/p/21)，在第 $k$ 位第一次进位到 $k+1$ 之前，$k+1\sim B$ 位只由异或的状态决定，而 $k$ 进位到 $k+1$ 时数的每位可以由异或状态唯一确定，对这个 dp 即可。

## 20241013

[T1](http://zhengruioi.com/contest/1695/problem/3006)，挂分了，dp 时没判最大子段和为 $0$ 的情况。

[T2](http://zhengruioi.com/contest/1695/problem/3007)，从大到小考虑每个盘是否在目标盘上即可。

[T3](http://zhengruioi.com/contest/1695/problem/3008)，由于整个数组的周期不大，对这个 dp 即可。

[T4](http://zhengruioi.com/contest/1695/problem/3009)，不会。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18466094.html</id>
    <title type="text">20241014 模拟赛 T3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-14T13:03:00Z</published>
    <updated>2024-10-14T13:03:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18466094.html" />
    <content type="text">## Description

冒险家的藏宝图可以被表示为一个 $n$ 个点的树，第 $i$ 个点可能是价值为 $a_i$ 的藏宝点，也可能什么也没有。

冒险家只知道，一定不会有两个在树上相邻的藏宝点。

记 $M=\sum a_i$。他现在希望对每个 $0\le x\le M$，求出有多少种藏宝点的分配方案，使得所有藏宝点的价值和为 $x$。由于答案可能很大，请对 $10^9+7$ 取模。

$1\le n\le 100$，$1\le a_i\le 10^5$，$M=\sum a_i\le 10^5$。

[link](http://zhengruioi.com/contest/1696/problem/2972)

## Solution

先考虑完全二叉树怎么做。注意到树的深度为 $O(\log n)$，所以可以按照 dfs 序从小到大进行 dp，同时记录当前这个点所有祖先选/没选的状态和总和，并且由于如果 $u$ 的 dfs 序刚好在 $v$ 后面一个，那么 $u$ 的父亲一定在 $v$ 的状态里被记录过。

具体的，设 $f_{i,j,k}$ 表示考虑了 dfs 序前 $i$ 的点，dfs 序为 $i$ 的点的祖先的选择状态为 $j$，总和为 $k$，每次枚举当前点选不选即可。

时间复杂度：$O(n^2m)$。

------------

对于一般树，有一种做法是用点分树将树高降为 $O(\log n)$，但是有点复杂就不管了。

考虑减少选/没选状态记录的点数。

首先求 dfs 序是先遍历一个点的轻儿子，这样就只需要记录所有祖先链上轻儿子父亲的选择状态，因为如果是重儿子的父亲，则后面这个父亲一定不会被用到过了。所以记录的点数降为到根的链上轻儿子的个数 $O(\log n)$，状态数为 $O(n)$。

时间复杂度看上去是 $O(n^2m)$，但是经过一番分析，实际上是 $O(n^{\log_23}m)$。

时间复杂度：$O(n^{\log_23}m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 105, kMaxM = 1e5 + 5, kMod = 1e9 + 7;

int n, m;
int a[kMaxN], sz[kMaxN], p[kMaxN], wson[kMaxN], dfn[kMaxN], idx[kMaxN];
int f[2][kMaxN][kMaxM];
std::vector&lt;int&gt; G[kMaxN], path[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dfs1(int u, int fa) {
  sz[u] = 1, p[u] = fa;
  std::vector&lt;int&gt; vec;
  for (auto v : G[u]) {
    if (v == fa) continue;
      vec.emplace_back(v);
  }
  G[u] = vec;
  for (auto v : G[u]) {
    dfs1(v, u);
    sz[u] += sz[v];
  }
  std::sort(G[u].begin(), G[u].end(), [&amp;] (int i, int j) { return sz[i] &lt; sz[j]; });
  if (G[u].size()) wson[u] = G[u].back();
}

void dfs2(int u, int fa) {
  static int cnt = 0;
  idx[dfn[u] = ++cnt] = u;
  for (auto v : G[u]) {
    assert(v != fa);
    dfs2(v, u);
    if (v == G[u].back()) assert(v == wson[u]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    m += a[i];
  }
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  dfs1(1, 0), dfs2(1, 0);
  for (int i = 1; i &lt;= n; ++i) {
    path[dfn[i]].emplace_back(i);
    for (int j = i; j != 1; j = p[j])
      if (j != wson[p[j]])
        path[dfn[i]].emplace_back(p[j]);
    std::reverse(path[dfn[i]].begin(), path[dfn[i]].end());
  }
  int o = 0;
  f[o][0][0] = f[o][1][a[1]] = 1;
  assert(path[1].size() == 1);
  for (int i = 2; i &lt;= n; ++i) {
    int u = idx[i];
    o ^= 1;
    for (int s = 0; s &lt; (1 &lt;&lt; path[i].size()); ++s)
      std::fill_n(f[o][s], m + 1, 0);
    for (int s = 0; s &lt; (1 &lt;&lt; path[i - 1].size()); ++s) {
      static bool vis[kMaxN];
      memset(vis, 0, sizeof(vis));
      for (int j = 0; j &lt; (int)path[i - 1].size(); ++j)
        vis[path[i - 1][j]] = (s &gt;&gt; j &amp; 1);
      // u 不选
      int t = 0;
      for (int j = 0; j &lt; (int)path[i].size(); ++j)
        if (vis[path[i][j]])
          t |= (1 &lt;&lt; j);
      for (int sum = 0; sum &lt;= m; ++sum)
        inc(f[o][t][sum], f[o ^ 1][s][sum]);
      if (!vis[p[u]]) {
        t |= (1 &lt;&lt; (path[i].size() - 1));
        assert(u == path[i].back());
        for (int sum = 0; sum &lt;= m - a[u]; ++sum)
          inc(f[o][t][sum + a[u]], f[o ^ 1][s][sum]);
      }
    }
  }
  for (int i = 0; i &lt;= m; ++i) {
    int ans = 0;
    for (int s = 0; s &lt; (1 &lt;&lt; path[n].size()); ++s)
      inc(ans, f[o][s][i]);
    std::cout &lt;&lt; ans &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18473807.html</id>
    <title type="text">P9351 [JOI 2023 Final] Maze 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-18T02:51:00Z</published>
    <updated>2024-10-18T02:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18473807.html" />
    <content type="text">## Description

给定一张 $R\times C$ 的地图，其中 ```.``` 可以走，而 ```#``` 不能走。一次操作可以将 $N \times N$ 的正方形范围内所有点变成 ```.```，给定起点和终点，求最少需要几次操作使得起点和终点连通（只能上下左右移动）。

$R\times C\le 6\times 10^6$，$N\le R\le C$。

## Solution

先考虑怎么暴力求出答案。

假设当前从起点走到了 $(x,y)$，那么 $(x,y)$ 此时一定为白点，下一步可以花 $0$ 的代价走到一个初始就是白色的点。

或者花费 $1$ 的代价在 $(x,y)$ 周围涂白一个大小为 $N$ 的正方形并走到这个正方形里的任何一个点 $(x_0,y_0)$，容易发现 $(x,y)$ 能走到 $(x_0,y_0)$ 当且仅当 $|x-x_0|,|y-y_0|\leq N$ 且 $\min\left\{|x-x_0|,|y-y_0|\right\}\leq N-1$。

建图跑 01bfs 可以得到一个 $O(RCN^2)$ 的做法。过不了。

由于算法慢在二操作的边数过多，所以考虑把二操作的长距离走法优化成多次走相邻格子的过程。

因为 $(x,y)$ 能走到 $(x_0,y_0)$ 当且仅当 $|x-x_0|,|y-y_0|\leq N$ 且 $\min\left\{|x-x_0|,|y-y_0|\right\}\leq N-1$，所以 $(x,y)\to (x_0,y_0)$ 可以看成先走到四联通格子，再走至多 $N-1$ 步八联通。

于是把步数作为第一关键字，走的八联通步数看作第二关键字跑最短路即可。

dijkstra 直接做可以做到 $O(RC\log RC)$，但是可能能用 01bfs 做到 $O(RC)$。

时间复杂度：$O(RC\log RC)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxT = 6e6 + 5, kMaxN = 3e3 + 5;
const int kD4[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int kD8[][2] = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int n, m, k;
int sx, sy, tx, ty;
std::vector&lt;int&gt; G[kMaxT];
std::string s[kMaxN];

void dijkstra() {
  std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; dis(n + 1, std::vector&lt;std::pair&lt;int, int&gt;&gt;(m + 1));
  std::vector&lt;std::vector&lt;bool&gt;&gt; vis(n + 1, std::vector&lt;bool&gt;(m + 1));
  std::priority_queue&lt;std::tuple&lt;int, int, int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      dis[i][j] = {1e9, 1e9};
  dis[sx][sy] = {0, k - 1};
  q.emplace(0, -(k - 1), sx, sy);
  for (; !q.empty();) {
    auto [d, w, x, y] = q.top();
    q.pop();
    if (vis[x][y]) continue;
    vis[x][y] = 1;
    for (auto [dx, dy] : kD4) {
      int tx = x + dx, ty = y + dy;
      if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue;
      if (s[tx][ty] == '.') {
        std::pair&lt;int, int&gt; p = {dis[x][y].first, k - 1};
        if (dis[tx][ty] &gt; p) {
          dis[tx][ty] = p;
          q.emplace(-p.first, -p.second, tx, ty);
        }
      }
      std::pair&lt;int, int&gt; p = {dis[x][y].first + 1, 0};
      if (dis[tx][ty] &gt; p) {
        dis[tx][ty] = p;
        q.emplace(-p.first, -p.second, tx, ty);
      }
    }
    if (dis[x][y].second &lt; k - 1) {
      for (auto [dx, dy] : kD8) {
        int tx = x + dx, ty = y + dy;
        if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue;
        std::pair&lt;int, int&gt; p = {dis[x][y].first, dis[x][y].second + 1};
        if (dis[tx][ty] &gt; p) {
          dis[tx][ty] = p;
          q.emplace(-p.first, -p.second, tx, ty);
        }
      }
    }
  }
  std::cout &lt;&lt; dis[tx][ty].first &lt;&lt; '\n';
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; s[i];
    s[i] = " " + s[i];
  }
  dijkstra();
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18487894.html</id>
    <title type="text">P9353 [JOI 2023 Final] Modern Machine 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-20T13:10:00Z</published>
    <updated>2024-10-20T13:10:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18487894.html" />
    <content type="text">## Description

Bitaro 生日这天收到了一个 JOI 机作为生日礼物。JOI 机由一个球，$N$ 条光带和 $M$ 个按钮组成。光带从 $1$ 到 $N$ 编号。当 Bitaro 打开开关时，光带 $i\ (1\le i\le N)$ 会发出颜色 $C_i$ 的光（蓝光 $(\texttt{B})$ 或红光 ($\texttt{R})$）。按钮从 $1$ 到 $M$ 编号。如果 Bitaro 按下按钮 $j\ (1\le j\le M)$，将发生如下事情。

1. 把球放置在光带 $A_j$ 上。
2. 光带 $A_j$ 变成红色（不管它原来是什么颜色）
3. 进行如下操作，直到球被移除。
	令 $p$ 为球目前所在的光带编号。
	- 如果光带 $p$ 是蓝色，
    	光带 $p$ 变为红色。在此之后，如果 $p=1$，这个球就被移除。否则，球移向光带 $p-1$。
	- 如果光带 $p$ 是红色，
		光带 $p$ 变为蓝色。在此之后，如果 $p=N$，这个球就被移除。否则，球移向光带 $p+1$。

Bitaro 对 JOI 机十分感兴趣。他计划进行 $Q$ 次实验。在第 $k\ (1\le k\le Q)$ 次实验中，在 Bitaro 开启电源后，他将按 $L_k,L_k+1,\ldots R_k$ 的顺序按下这些开关。在 Bitaro 按下一个开关后，他将等到球被移除后再按下下一个开关。

给定 JOI 机和实验的情况，写一个程序计算对于每个实验，当实验结束后红色的光带有多少。

注：每次实验之间互相独立。

## Solution

先考虑怎么暴力地求出答案。

结论是对于一个在第 $i$ 个位置的操作，一定是把前 $i$ 个蓝球染红或者后 $n-i+1$ 个红球染蓝。证明就考虑最终状态只和最后一次将前缀染红或后缀染蓝的位置有关。

假设最后一次是将前缀染红。在 $[1,i-1]$ 这些位置中碰到红色会变向，$[i,n]$ 碰到蓝色会变向，设 $[1,i-1]$ 中有 $k$ 个红色，$i-1-k$ 个蓝色，那么左边变 $k$ 次向，右边则有 $k+1$ 次，所以右边会把 $k+1$ 个蓝色染红，左边 $i-1-k$ 个，加起来就是将前 $i$ 个蓝色染红。对于后缀染蓝是同理的。

由于这两种操作不能同时发生，所以只需要通过红/蓝球的个数即可判断选择哪个。

---

然后考虑第子任务 4,5 怎么做。

设当前前 $t$ 个是红，操作位置为 $i$，由于 $i$ 初始的颜色会有影响所以需要分类讨论：

如果 $i\leq t$ 且 $i\leq n-t$，则 $t\leftarrow t+i$，否则 $t\leftarrow t-(n-i+1)$。

如果 $i&gt;t$ 且 $i\leq n-t-1$，则 $t\leftarrow t+i+1$，否则 $t\leftarrow t-(n-i)$。

写成简洁的形式：

$$
f_i(t)=
\begin{cases}
(t+i)\bmod (n+1)\ \ \ \ \ \ \ \ \ \ \ \ &amp;(i\leq t)\\
(t+i+1)\bmod (n+1)\ \ \ \ \ \ \ \ \ \ \ \ &amp;(i&gt; t)
\end{cases}
$$

注意到这是个分段函数并且段数是 $O(操作序列大小)$ 的，所以线段树暴力维护分段函数即可，时间复杂度：$O\left(M\log^2N+Q\log N\right)$

---

对于一般情况，操作任意时刻一定是子任务 4,5 或者一段前缀红，后缀蓝，中间不变的形态。

为了简化写法，先在所有蓝之前或者末尾分个段和所有红之后或者开头分个段，这样每次将前 $i$ 个蓝变红就只需要让红的前缀段的指针往后挪 $i$ 个，红变蓝同理。

假设当前红色的前缀长度为 $r$，蓝色的后缀长度为 $b$，考虑找到第一个前后缀汇合的时刻。

那么在这个时刻之前，假设操作位置 $i\leq r$，如果前 $i$ 个蓝染红，则 $r\leftarrow r+i$，否则就汇合了。如果 $i\geq n-b+1$，后 $n-i+1$ 个红染蓝则 $b\leftarrow b+n-i$，否则也汇合了。

如果 $r+1\leq i\leq n-b$ 就不好做了，但是注意到这样的 $i$ 是很少的，因为每次操作至少会让 $r/b$ 中的一个翻倍，所以只有 $O(\log N)$ 个。

但是要快速找到在中间的操作仍然是不好做的，因为前后缀的长度是一直在变化的。这时可以设不超过 $r$ 的最大 $2$ 的幂次为 $x$，不超过 $b$ 的最大幂次为 $y$，对于 $x+1\leq i\leq n-y$ 的操作仍然会让 $x,y$ 中的至少一个翻倍，这样的操作仍然只有 $O(\log N)$ 个。

于是就可以预处理了，设 $nxt_{x,y,k}$ 表示在 $r$ 为 $x$，$b$ 为 $y$ 的情况下，$a_k$ 后面的第一个在 $[x+1,n-y]$ 内的操作下标，$sumr_{x,y,k}$ 和 $sumb_{x,y,k}$ 表示在 $r$ 为 $x$，$b$ 为 $y$ 的情况下前 $k$ 个操作对 $r/b$ 的贡献。

询问时如果在 $nxt$ 之前都无法汇合则跳到 nxt，更新 $r$ 和 $b$ 并算上 $nxt$ 的贡献，否则二分出第一个汇合的时刻即可。

时间复杂度：$O\left((M+Q)\log^2 N\right)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1.2e5 + 5, kLog = 18;

int n, m, q, cr, cb;
int a[kMaxN], nxt[kLog][kLog][kMaxN], rx[kMaxN], bx[kMaxN], lg[kMaxN], prer[kMaxN];
int64_t sumr[kLog][kLog][kMaxN], sumb[kLog][kLog][kMaxN];
std::string s;

struct SGT {
  std::vector&lt;std::pair&lt;int, int&gt;&gt; v[kMaxN * 4];

  int func(int x, int val) {
    auto it = std::upper_bound(v[x].begin(), v[x].end(), std::pair&lt;int, int&gt;(val, 1e9)) - 1;
    return val + it-&gt;second;
  }

  void pushup(int x) {
    int ls = (x &lt;&lt; 1), rs = (x &lt;&lt; 1 | 1);
    for (int i = 0; i &lt; (int)v[ls].size(); ++i) {
      auto [L, val] = v[ls][i];
      int R = (i + 1 == (int)v[ls].size() ? n + 1 : v[ls][i + 1].first);
      auto itl = std::lower_bound(v[rs].begin(), v[rs].end(), std::pair&lt;int, int&gt;(L + val, -1e9));
      auto itr = std::lower_bound(v[rs].begin(), v[rs].end(), std::pair&lt;int, int&gt;(R + val, -1e9));
      v[x].emplace_back(L, 0);
      for (auto it = itl; it != itr; ++it) {
        v[x].emplace_back(it-&gt;first - val, 0);
      }
    }
    std::sort(v[x].begin(), v[x].end());
    v[x].erase(std::unique(v[x].begin(), v[x].end()), v[x].end());
    for (auto &amp;[xx, val] : v[x]) {
      val = func(rs, func(ls, xx)) - xx;
    }
  }

  void build(int x, int l, int r) {
    if (l == r) {
      if (n - a[l] &gt; 0) {
        v[x].emplace_back(0, a[l] + 1);
        if (n - a[l] &lt;= a[l] - 1) v[x].emplace_back(n - a[l], a[l] - n);
      } else {
        v[x].emplace_back(0, a[l] - n);
      }
      if (a[l] &lt; n + 1 - a[l]) {
        v[x].emplace_back(a[l], a[l]);
        v[x].emplace_back(n - a[l] + 1, a[l] - (n + 1));
      } else {
        v[x].emplace_back(a[l], a[l] - (n + 1));
      }
      std::sort(v[x].begin(), v[x].end());
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }

  int query(int x, int l, int r, int ql, int qr, int val) {
    if (l &gt; qr || r &lt; ql) {
      return val;
    } else if (l &gt;= ql &amp;&amp; r &lt;= qr) {
      return func(x, val);
    }
    int mid = (l + r) &gt;&gt; 1;
    return query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, query(x &lt;&lt; 1, l, mid, ql, qr, val));
  }
} sgt;

void prework() {
  sgt.build(1, 1, m);

  lg[0] = -1;
  for (int i = 1; i &lt;= 1.2e5; ++i) lg[i] = lg[i &gt;&gt; 1] + 1;

  for (int i = 1; i &lt;= n; ++i) prer[i] = prer[i - 1] + (s[i] == 'R');

  for (int i = 1; i &lt;= n + 1; ++i) {
    if (i == n + 1 || s[i] == 'B') {
      rx[++cr] = i - 1;
    }
  }
  for (int i = n; ~i; --i) {
    if (!i || s[i] == 'R') {
      bx[++cb] = n - i;
    }
  }

  for (int x = 0; x &lt;= lg[n] + 1; ++x) {
    for (int y = 0; y &lt;= lg[n] + 1; ++y) {
      int lenr, lenb;
      if (!x) lenr = 0;
      else lenr = (1 &lt;&lt; (x - 1));
      if (!y) lenb = 0;
      else lenb = (1 &lt;&lt; (y - 1));
      if (lenr + lenb &gt; n) continue;
      for (int i = 1; i &lt;= m; ++i) {
        sumr[x][y][i] = sumr[x][y][i - 1];
        sumb[x][y][i] = sumb[x][y][i - 1];
        if (a[i] &lt;= lenr) sumr[x][y][i] += a[i];
        else if (n - a[i] + 1 &lt;= lenb) sumb[x][y][i] += n - a[i];
      }
      nxt[x][y][m + 1] = m + 1;
      for (int i = m; i; --i) {
        if (a[i] &gt; lenr &amp;&amp; a[i] &lt;= n - lenb) nxt[x][y][i] = i;
        else nxt[x][y][i] = nxt[x][y][i + 1];
      }
    }
  }
}

int getcntr(int l, int r) {
  if (l &gt; r) return 0;
  return prer[r] - prer[l - 1];
}

int getcntb(int l, int r) {
  if (l &gt; r) return 0;
  return (r - l + 1) - (prer[r] - prer[l - 1]);
}

char getch(int x, int nowr, int nowb) {
  assert(x &gt;= 1 &amp;&amp; x &lt;= n);
  if (x &lt;= rx[nowr]) return 'R';
  else if (x &gt; n - bx[nowb]) return 'B';
  else return s[x];
}

int solve(int l, int r) {
  int pos = l - 1, nowr = 1, nowb = 1, val = -1;
  for (;;) {
    assert(rx[nowr] + bx[nowb] &lt;= n);
    if (rx[nowr] + bx[nowb] &gt;= n) {
      val = rx[nowr];
      break;
    }
    int x = lg[rx[nowr]] + 1, y = lg[bx[nowb]] + 1;
    int nxtp = std::min(nxt[x][y][pos + 1], r + 1);
    int detr = std::min&lt;int&gt;(sumr[x][y][nxtp - 1] - sumr[x][y][pos], n);
    int detb = std::min&lt;int&gt;(sumb[x][y][nxtp - 1] - sumb[x][y][pos], n);
    if (rx[std::min(nowr + detr, cr)] + bx[std::min(nowb + detb, cb)] &lt; n) {
      nowr += detr, nowb += detb, pos = nxtp;
      if (pos == r + 1) break;
      int cntr = rx[nowr] + getcntr(rx[nowr] + 1, n - bx[nowb]);
      if (getch(a[pos], nowr, nowb) == 'B') ++cntr;
      if (n - cntr &gt;= a[pos]) { // 把前 a[pos] 个 B 变成 R
        if (getch(a[pos], nowr, nowb) == 'B') ++nowr;
        nowr = std::min(nowr + a[pos], cr);
        if (rx[nowr] + bx[nowb] &gt;= n) {
          val = cntr + a[pos];
          break;
        }
      } else { // 把后 n - a[pos] + 1 个 R 变成 B
        assert(cntr &gt;= n - a[pos] + 1);
        if (getch(a[pos], nowr, nowb) == 'B') --nowb;
        nowb = std::min(nowb + n - a[pos] + 1, cb);
        if (rx[nowr] + bx[nowb] &gt;= n) {
          val = cntr - (n - a[pos] + 1);
          break;
        }
      }
    } else {
      int L = pos, R = nxtp, res = pos;
      while (L + 1 &lt; R) {
        int mid = (L + R) &gt;&gt; 1;
        int detr = std::min&lt;int&gt;(sumr[x][y][mid] - sumr[x][y][pos], n);
        int detb = std::min&lt;int&gt;(sumb[x][y][mid] - sumb[x][y][pos], n);
        if (rx[std::min(nowr + detr, cr)] + bx[std::min(nowb + detb, cb)] &gt;= n) R = res = mid;
        else L = mid;
      }
      assert(res &gt; pos);
      int detr = std::min&lt;int&gt;(sumr[x][y][res - 1] - sumr[x][y][pos], n);
      int detb = std::min&lt;int&gt;(sumb[x][y][res - 1] - sumb[x][y][pos], n);
      nowr += detr, nowb += detb;
      assert(nowr &lt;= cr &amp;&amp; nowb &lt;= cb &amp;&amp; rx[nowr] + bx[nowb] &lt; n);
      int cntr = rx[nowr] + getcntr(rx[nowr] + 1, n - bx[nowb]);
      if (getch(a[res], nowr, nowb) == 'B') ++cntr;
      pos = res;
      if (a[res] &lt;= n - cntr) {
        val = cntr + a[res];
        break;
      } else {
        val = cntr - (n - a[res] + 1);
        break;
      }
    }
  }
  if (val == -1) {
    return rx[nowr] + getcntr(rx[nowr] + 1, n - bx[nowb]);
  } else {
    return sgt.query(1, 1, m, pos + 1, r, val);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
  s = " " + s;
  for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; a[i];
  prework();
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    std::cout &lt;&lt; solve(l, r) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18488001.html</id>
    <title type="text">20241014~20241020 总结-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-20T13:53:00Z</published>
    <updated>2024-10-20T13:53:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18488001.html" />
    <content type="text">## [20241014](http://zhengruioi.com/contest/1696)

T1：简单题。

T2：先写出暴力 dp 后会发现不同的转移方案只有 $O(|\Sigma|)$ 种，分段再 dp 即可。

T3：没想到可以按照 dfs 序并记录当前所有祖先的信息进行 dp。

T4：没想到可以转化成判断奇数出现次数的颜色个数，并且没想到可以用欧拉序将树上路径问题转到序列上。

## [20241016](http://zhengruioi.com/contest/1699)

T1：简单题。

T2：简单题。

T3：想到了哈希判断，但又忘记了可以用“两个不同的数至少有一位不同”这个 trick 去将 $2/3$ 个数划分成 $1$ 个数和其他数。

T4：被诈骗了，没想到可以进行删点操作将剩余的图变得简单。

## [20241019](http://172.45.35.5/d/HEIGEONE/homework/671357d83e17c101cdd38df7)

T1：简单题。

T2：简单题。

T3：dp 题。

T4：没想到可以将不超过限制一半的数看作小数，其它看成大数的转化。

## [20241020](http://zhengruioi.com/contest/1703)

T1：简单题。

T2：先二分，不在当前最后的那个人的位置一定是个连续区间，新加人的时候讨论一下即可。

T3：原。

T4：没想到先容斥超出限制的颜色数量，然后取出每种颜色最后面的几个数，并转化为从前往后确定数的形式。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18493273.html</id>
    <title type="text">Public NOIP Round #7 C 黑白棋子 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-22T08:51:00Z</published>
    <updated>2024-10-22T08:51:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18493273.html" />
    <content type="text">## Description

有一棵 $n$ 个点的树，顶点的编号为 $1$ 到 $n$。

对于树中的每个顶点，可能存在一个白色的棋子、一个黑色的棋子，或者没有棋子。树上正好有 $w$ 个白色棋子和 $b$ 个黑色棋子。另外，对于每一对具有相同颜色棋子的顶点，存在一条路径，路径上的每个顶点都包含相同颜色的棋子（即每种颜色的棋子形成一个连通块）。

你可以进行任意次以下操作：
- 选择一个带有棋子的顶点 $u$。
- 选择一条路径 $p_1, p_2, \dots, p_k$，使得 $p_1 = u$，且所有顶点 $p_1, p_2, \dots, p_{k-1}$ 都包含**相同颜色**的棋子，且 $p_k$ 上**没有棋子**。
- 将 $p_1$ 上的棋子移动到 $p_k$。此时 $p_1$ 上没有棋子，$p_k$ 上有一个棋子。

在每一步操作后，每种颜色的棋子仍然形成一个连通块。
对于两个初始的棋子状态 $S$ 和 $T$，如果你可以通过上述操作若干次（可以为零次）将 $S$ 变为 $T$，那么我们认为 $S$ 和 $T$ 是**等价**的。

定义 $f(w, b)$ 为在树上有  $w$ 个白色棋子和 $b$ 个黑色棋子时，等价类的数量。你需要求出：

$$\left(\sum_{w=1}^{n-1}\sum_{b=1}^{n-w} f(w,b)\cdot w\cdot b\right)\bmod 10^9+7$$

$n \ge 2,1\le \sum n\le 2\times 10^5,1\le fa_i&lt;i$。

[link](https://pjudge.ac/contest/1811/problem/21859)

## Solution

考虑怎么对于给定的 $w,b$ 求出 $f(w,b)$。

不妨设 $w\geq b$，$mx_i$ 表示把 $i$ 号点删掉后剩余子树的最大大小。

那么如果 $w&gt;mx_i$，则所有大小为 $w$ 的连通块都包含 $i$。

容易发现所有的必经点构成一个连通块，把这些必经点去掉后剩余的每个连通块之间都互不连通，所以黑色的连通块一定只与和其属于同一个连通块的黑色连通块等价，于是 $f(w,b)$ 就等于把必经点删掉后大小不小于 $b$ 的连通块数。

但是可能不存在必经点，即 $w\leq\min\left\{mx_i\right\}$。经过手玩会发现此时的 $f(w,b)$ 只可能等于 $1$ 或 $2$。

并且 $f(w,b)=1$ 的条件为存在一个点 $u$，其存在两个子树的大小 $\geq w$ 和另一个子树大小 $\geq b$，这是因为如果存在这样的点 $u$，移动黑色和白色连通块时可以先将后移动的连通块先寄存在一个不可能被经过的子树，等先移动的连通块动完再动，显然这样一定能构造出一组移动方案。

如果不满足那个条件，感性理解一下，黑色和白色连通块一定存在一个“先后顺序”，并且在移动的过程中这个顺序一定不会变，所以有 $2$ 种等价类。

对于存在必经点的情况，将重心当作根，直接枚举 $w$ 并维护删掉必经点后的每个子树的大小。如果不存在必经点，维护出满足 $f(w,b)=1$ 的最大的 $b$ 即可。

时间复杂度：$O(n\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5, kMod = 1e9 + 7;

int n;
int p[kMaxN], sz[kMaxN], mx[kMaxN], suf[kMaxN], pos[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

int getsum(int n) {
  return 1ll * n * (n + 1) % kMod * ((kMod + 1) / 2) % kMod;
}
int getsum(int l, int r) {
  if (l &gt; r) return 0;
  else return sub(getsum(r), getsum(l - 1));
}

void dfs(int u, int fa) {
  std::vector&lt;int&gt; vsz;
  sz[u] = 1, mx[u] = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
    vsz.emplace_back(sz[v]);
  }
  mx[u] = std::max(mx[u], n - sz[u]);
  vsz.emplace_back(n - sz[u]);
  std::sort(vsz.begin(), vsz.end(), std::greater&lt;&gt;());
  if (vsz.size() &gt;= 3) {
    suf[vsz[1]] = std::max(suf[vsz[1]], vsz[2]);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  std::fill_n(suf, n + 2, 0);
  for (int i = 2; i &lt;= n; ++i) {
    std::cin &gt;&gt; p[i];
    G[p[i]].emplace_back(i), G[i].emplace_back(p[i]);
  }
  dfs(1, 0);
  std::vector&lt;int&gt; vec;
  for (int i = 1; i &lt;= n; ++i) vec.emplace_back(i);
  std::sort(vec.begin(), vec.end(), [&amp;] (int i, int j) { return mx[i] &lt; mx[j]; });
  for (int i = 0; i &lt; n; ++i) pos[vec[i]] = i;
  dfs(vec[0], 0);
  int ans = 0;
  for (int i = n; i; --i) {
    suf[i] = std::max(suf[i], suf[i + 1]);
    if (i &gt; mx[vec[0]]) continue;
    int val = std::min(suf[i], i);
    if (val &lt; i) {
      inc(ans, 2ll * i % kMod * getsum(1, val) % kMod);
      inc(ans, 4ll * i % kMod * getsum(val + 1, i - 1) % kMod);
      inc(ans, 2ll * i % kMod * i % kMod);
    } else {
      inc(ans, 2ll * i * getsum(1, i - 1) % kMod);
      inc(ans, 1ll * i * i % kMod);
    }
  }
  int now = getsum(n);
  for (int i = mx[vec[0]] + 1, j = 0; i &lt;= n; ++i) {
    for (; j &lt; n &amp;&amp; mx[vec[j]] &lt; i; ++j) {
      dec(now, getsum(sz[vec[j]]));
      for (auto v : G[vec[j]])
        if (pos[v] &gt; j)
          inc(now, getsum(sz[v]));
    }
    inc(ans, 2ll * i * now % kMod);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18500450.html</id>
    <title type="text">P8164 [JOI 2022 Final] 沙堡 2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-24T12:49:00Z</published>
    <updated>2024-10-24T12:49:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18500450.html" />
    <content type="text">## Description

JOI 君在沙滩上堆沙堡，他已经做好了一个沙堡，沙堡可以使用一个 $H\times W$ 的二维矩形表示，其被划分成若干个 $1\times 1$ 的小格子，格子高度互相不同。

JOI 君决定在沙堡上游走，他可以从任意一个点出发，向上下左右四个方向行走，必须满足他行走的路径单调下降。

出于一些原因，JOI 君想知道，在他所有可能的行走路径中，恰好覆盖了一个子矩形的路径数有多少条。

对于全部数据，$H,W\ge 1$，$HW\le 5\times 10^4$，$1\le A_{i,j}\le 10^7$，$A_{i,j}$ 互不相同。

## Solution

首先一个子矩形合法的条件为子矩形内的每个点 $(i,j)$，都满足其值域上的前驱和后继都与其相邻。

但是直接暴力判断最多只做到 $O\left(H^3W^2\right)$，过不了。

考虑对每个点构造一个权值，使得这些权值的和为一个定值。

令 $X$ 为一个极大值，$v_{i,j}$ 表示 $(i,j)$ 的权值，$w_{i,j}$ 表示 $(i,j)$ 四周小于 $a_{i,j}$ 的最大权值，如果没有则为 $0$。如果 $a_{i,j}$ 大于其四周的数，则 $v_{i,j}=X-w_{i,j}$，否则 $v_{i,j}=a_{i,j}-w_{i,j}$。

容易发现一个合法矩形的所有 $v_{i,j}$ 的和为 $X$，证明就考虑如果每个点向周围比它大的最大位置连边，会连出一个内向树森林，而 $v_{i,j}$ 实际上是把每个内向树划分成若干条链，每条链的权值为 $X$，所以总权值为 $X$ 乘以链数，于是矩形合法的条件即为总权值为 $X$。

枚举矩形的上下边界和右端点，并在枚举的过程中维护每个位置的权值，用哈希表记录某个前缀的权值即可。

时间复杂度：$O(H^2W)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt;

#define int int64_t

const int kMaxT = 5e4 + 5, kInf = 1e10;
const int kD[][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

int n, m, t;
int unq[kMaxT], sum[kMaxT], valt1[kMaxT], valt2[kMaxT], valt3[kMaxT];
std::vector&lt;std::vector&lt;int&gt;&gt; a, val1, val2, val3;

void init(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;v, int n = ::n, int m = ::m) {
  v.resize(n + 2, std::vector&lt;int&gt;(m + 2));
}

int getid(int x) {
  return std::lower_bound(unq + 1, unq + 1 + t, x) - unq;
}

void discrete() {
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      unq[++t] = a[i][j];
  std::sort(unq + 1, unq + 1 + t);
  t = std::unique(unq + 1, unq + 1 + t) - (unq + 1);
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      a[i][j] = getid(a[i][j]);
}

void work() {
  std::swap(n, m);
  std::vector&lt;std::vector&lt;int&gt;&gt; b(n + 1, std::vector&lt;int&gt;(m + 1));
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      b[i][j] = a[j][i];
  a = b;
}

int getval1(int l, int r, int x, int y) {
  int mx = 0, _mx = 0;
  for (auto [dx, dy] : kD) {
    int tx = x + dx, ty = y + dy;
    if (tx &gt;= l &amp;&amp; tx &lt;= r &amp;&amp; ty &gt;= 1 &amp;&amp; ty &lt;= m) {
      if (a[tx][ty] &gt; a[x][y]) mx = std::max(mx, a[tx][ty]);
      if (a[tx][ty] &lt; a[x][y]) _mx = std::max(_mx, a[tx][ty]);
    }
  }
  if (!mx) mx = kInf;
  else mx = a[x][y];
  return mx - _mx;
}

int getval2(int l, int r, int x, int y) {
  int mx = 0, _mx = 0;
  for (auto [dx, dy] : kD) {
    int tx = x + dx, ty = y + dy;
    if (tx &gt;= l &amp;&amp; tx &lt;= r &amp;&amp; ty &gt;= 1 &amp;&amp; ty &lt;= m &amp;&amp; dy != -1) {
      if (a[tx][ty] &gt; a[x][y]) mx = std::max(mx, a[tx][ty]);
      if (a[tx][ty] &lt; a[x][y]) _mx = std::max(_mx, a[tx][ty]);
    }
  }
  if (!mx) mx = kInf;
  else mx = a[x][y];
  return mx - _mx;
}

int getval3(int l, int r, int x, int y) {
  int mx = 0, _mx = 0;
  for (auto [dx, dy] : kD) {
    int tx = x + dx, ty = y + dy;
    if (tx &gt;= l &amp;&amp; tx &lt;= r &amp;&amp; ty &gt;= 1 &amp;&amp; ty &lt;= m &amp;&amp; dy != 1) {
      if (a[tx][ty] &gt; a[x][y]) mx = std::max(mx, a[tx][ty]);
      if (a[tx][ty] &lt; a[x][y]) _mx = std::max(_mx, a[tx][ty]);
    }
  }
  if (!mx) mx = kInf;
  else mx = a[x][y];
  return mx - _mx;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  init(a);
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= m; ++j)
      std::cin &gt;&gt; a[i][j];
  if (n &gt; m) work();
  init(val1), init(val2), init(val3);
  discrete();
  int64_t ans = 0;
  for (int l = 1; l &lt;= n; ++l) {
    for (int i = 1; i &lt;= m; ++i) {
      valt1[i] = val1[l][i] = getval1(l, l, l, i);
      valt2[i] = val2[l][i] = getval2(l, l, l, i);
      valt3[i] = val3[l][i] = getval3(l, l, l, i);
    }
    for (int r = l + 1; r &lt;= n; ++r) {
      __gnu_pbds::gp_hash_table&lt;int, int&gt; mp;
      int sum = 0;
      for (int i = 1; i &lt;= m; ++i) {
        val1[r][i] = getval1(l, r, r, i);
        valt1[i] += getval1(l, r, r - 1, i) - val1[r - 1][i] + val1[r][i];
        val2[r][i] = getval2(l, r, r, i);
        valt2[i] += getval2(l, r, r - 1, i) - val2[r - 1][i] + val2[r][i];
        val3[r][i] = getval3(l, r, r, i);
        valt3[i] += getval3(l, r, r - 1, i) - val3[r - 1][i] + val3[r][i];
        if (mp.find(kInf - sum - valt3[i]) != mp.end()) ans += mp[kInf - sum - valt3[i]];
        sum += valt1[i];
        ++mp[valt2[i] - sum];
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    int lst[2] = {-1, -1};
    std::vector&lt;int&gt; vec;
    for (int j = 1; j &lt; m; ++j)
      vec.emplace_back(a[i][j] &lt; a[i][j + 1]);
    ans += m;
    for (int j = 0; j &lt; (int)vec.size(); ++j) {
      if (!vec[j]) {
        ans += j - lst[1];
        lst[0] = j;
      } else {
        ans += j - lst[0];
        lst[1] = j;
      }
    }
  }
  for (int i = 1; i &lt;= m; ++i) {
    int lst[2] = {-1, -1};
    std::vector&lt;int&gt; vec;
    for (int j = 1; j &lt; n; ++j)
      vec.emplace_back(a[j][i] &lt; a[j + 1][i]);
    for (int j = 0; j &lt; (int)vec.size(); ++j) {
      if (!vec[j]) {
        ans += j - lst[1];
        lst[0] = j;
      } else {
        ans += j - lst[0];
        lst[1] = j;
      }
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18512737.html</id>
    <title type="text">[ARC186E] Missing Subsequence 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-29T04:32:00Z</published>
    <updated>2024-10-29T04:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18512737.html" />
    <content type="text">## Description

给定一个整数序列 $\left(X_1, \ldots, X_M\right)$ ，其长度为 $M$，元素取值为 $1, \ldots, K$。

要求找出长度为 $N$ 的序列 $(A_1, \ldots, A_N)$ 的数量，元素取值为 $1, \ldots, K$，并满足以下条件，结果取模 $998244353$：

- 在所有长度为 $M$ 的序列中，唯一不能作为 $(A_1, \ldots, A_N)$ 的（不一定连续的）子序列的序列是 $(X_1, \ldots, X_M)$。

$2\leq M,K\leq N\leq 400,1\leq X_i\leq K$。

## Solution

不妨设 $F(\{x_1,x_2,\ldots,x_m\})$ 表示所有满足除了 $x$ 的长度为 $m$ 的序列都是其子序列的序列集合。

考虑一个序列 $a$ 什么时候可以满足条件。

设 $i$ 为 $x_1$ 在 $a$ 里面第一次出现的位置，容易发现除了 $x_1$ 的颜色都在 $a_1,a_2,\ldots,a_{i-1}$ 出现了，且 $(a_{i+1},a_{i+2},\ldots,a_n)\in F(\{x_2,x_3,\ldots,x_m\})$。

然后经过手玩一下会发现这个条件在 $x_1=x_2$ 的情况下还是充分条件。

证明就考虑如果满足了这两个条件，第一位为 $x_1$ 的子序列一定都满足条件。

否则设第一位为 $s$，若第二位为 $x_1$，则第二位匹配 $i$，根据第二个条件所有长度小于 $m-1$ 的序列都出现在 $a_{i+1}$ 之后。如果第二位不为 $x_1$，根据第二个条件 $x_2,x_3,\ldots,x_m$ 也一定出现在 $a_{i+1}$ 之后。

---

对于 $x_1\neq x_2$ 的情况，设 $j$ 为 $x_2$ 在 $a_1,a_2,\ldots,a_{i+1}$ 最后一个出现位置，那么还需要满足除了 $x_1$ 的颜色都在 $a_1,a_2,\ldots,a_{j-1}$ 出现。

下面证明一下必要性。对于一个合法的序列 $a$，如果存在颜色 $c$ 使得 $c$ 第一次出现位置在 $[j+1,i-1]$ 内，则 $c,x_2,x_3,\ldots,x_m$ 这个序列的除了 $c$ 的部分只能从 $i+1$ 匹配起，而根据第二个条件这个东西一定是匹配不出来的，矛盾。

充分性证明和 $x_1=x_2$ 的情况差不多，这里就不写了。

---

求方案数时设 $f_{i,j}$ 表示长度为 $i$ 的序列满足 $x_j,x_{j+1},\ldots,x_m$ 的条件的数量，转移直接枚举 $x_j$ 第一次出现的位置和 $x_{j+1}$ 在 $x_j$ 第一次出现之前的最后位置即可。

时间复杂度：$O(n^2m+n^2k)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 405, kMod = 998244353;

int n, m, k;
int x[kMaxN], f[kMaxN][kMaxN], coef[kMaxN], C[kMaxN][kMaxN], cnt[kMaxN][kMaxN];

constexpr int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void prework() {
  C[0][0] = 1;
  for (int i = 1; i &lt;= 400; ++i) {
    C[i][0] = 1;
    for (int j = 1; j &lt;= i; ++j)
      C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);
  }
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= k; ++j) {
      cnt[i][j] = qpow(j, i);
      for (int s = 1; s &lt; j; ++s) dec(cnt[i][j], 1ll * cnt[i][s] * C[j][s] % kMod);
      // std::cerr &lt;&lt; cnt[i][j] &lt;&lt; ' ';
    }
    // std::cerr &lt;&lt; '\n';
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; x[i];
  prework();
  for (int i = 1; i &lt;= n; ++i) {
    f[m][i] = cnt[i][k - 1];
    // std::cerr &lt;&lt; f[m][i] &lt;&lt; ' ';
  }
  // std::cerr &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt; i; ++j)
      inc(coef[i], 1ll * cnt[j - 1][k - 1] * qpow(k - 2, i - 1 - j) % kMod);
  }
  for (int i = m - 1; i; --i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (x[i] == x[i + 1]) {
        for (int s = 1; s &lt;= j; ++s) {
          inc(f[i][j], 1ll * cnt[s - 1][k - 1] * f[i + 1][j - s] % kMod);
          // std::cerr &lt;&lt; "fuck " &lt;&lt; j &lt;&lt; ' ' &lt;&lt; s &lt;&lt; ' ' &lt;&lt; cnt[s - 1][k - 1] &lt;&lt; ' ' &lt;&lt; f[i + 1][j - s] &lt;&lt; '\n';
        }
      } else {
        for (int s = 1; s &lt;= j; ++s)
          inc(f[i][j], 1ll * coef[s] * f[i + 1][j - s] % kMod);
      }
      // std::cerr &lt;&lt; f[i][j] &lt;&lt; ' ';
    }
    // std::cerr &lt;&lt; '\n';
  }
  std::cout &lt;&lt; f[1][n] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18516231.html</id>
    <title type="text">P7408 [JOI 2021 Final] 地牢 3 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-10-30T09:27:00Z</published>
    <updated>2024-10-30T09:27:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18516231.html" />
    <content type="text">## Description

有一个 $N+1$ 层的地牢，在地牢里有 $M$ 个玩家。地牢的每层从入口开始，用 $1$ 到 $N+1$ 的整数编号。玩家从 $1$ 到 $M$ 标号。

玩家使用能量从一层移动到下一层。玩家从第 $i\ (1\le i\le N)$ 层移动到第 $i+1$ 层所用的能量为 $A_i$。因为这是一个单向通行的地牢，所以玩家只能从第 $i$ 层移动到第 $i+1$ 层，并且要保证 $1\le i\le N$。

在第 $1$ 到第 $N$ 层的每层（包括第 $1$ 和第 $N$ 层）都有治疗泉。在第 $i$ 层的治疗泉处，玩家可以花 $B_i$ 金币，使自己的能量增加 $1$。只要玩家有足够的金币，他就可以多次使用治疗泉。但是，每个玩家都有最大能量，使用治疗泉的话也不能使自己的能量超过最大值。

现在玩家 $j\ (1\le j\le M)$ 在第 $S_j$ 层。他目前的能量为 $0$。他的最大能量是 $U_j$。他想要到第 $T_j$ 层。在路上他的能量不能小于 $0$。他需要多少金币呢？

给定这个地牢和玩家的信息，写一个程序计算对于每个玩家，是否可以在移动过程中能量不小于 $0$ 的情况下到达目的地。如果可以的话，计算他最少需要多少金币才能达成目标。

对于所有数据，满足：

$1\le N,M\le 2\times 10^5$；
$1\le A_i,B_i\le 2\times 10^5\ (1\le i\le N)$；
$1\le S_j&lt;T_j\le N+1\ (1\le j\le M)$；
$1\le U_j\le 10^8\ (1\le j\le M)$。

## Solution

首先考虑对题意进行转化，设 $c_i=\sum_{j&lt;i}{a_j}$，将走地牢转化为在数轴上从 $c_s$ 走到 $c_t$，而使用治疗泉可以看作是在 $[c_i,c_i+U)$ 这个区间里用 $b_i$ 的代价选择一个位置激活，问将 $[c_s,c_t)$ 里所有的位置都激活的最小代价。

容易发现一个位置 $p$ 的代价是 $[p-U+1,p]$ 区间内关键点权值的最小值。

考虑对于每个关键点 $i$ 算出其控制的区间，设 $pre$ 为 $i$ 之前第一个代价小于 $b_i$ 的位置，$nxt$ 为 $i$ 之后第一个代价小于 $b_i$ 的位置。

那么一个位置 $p$ 被 $i$ 控制当且仅当 $p-U\geq c_{pre},p-U&lt;c_i,p&lt;c_{nxt}$，整理一下为：$\max\{c_i,c_{pre}+U\}\leq p&lt;\min\{c_i+U,c_{nxt}\}$。

于是关键点 $i$ 对答案的贡献为 $b_i\times\left(\min\{c_i+U,c_{nxt}\}-\max\{c_i,c_{pre}+U\}\right)$，这是个关于 $U$ 的分段一次函数，可以用动态开点线段树维护每个 $U$ 的答案。

对于终点全是 $n+1$ 的子任务直接将询问离线下来倒着枚举关键点，同时维护一个代价从栈顶到栈底递增的单调栈来求出每个点的 $pre$ 和 $nxt$。

每次加入一个点 $i$ 时，将所有 $pre$ 为 $i$ 的位置 $j$ 之前的贡献去掉，再加上 $(j,pre_j,nxt_j)$ 的贡献，然后加入 $(i,0,nxt_i)$ 的贡献表示当 $s=i$ 时 $i$ 找不到 $pre$ 时 $i$ 对答案的贡献。

如果终点不固定，则找到询问为 $(s,n+1)$ 时控制 $c_t$ 的关键点 $k$，容易发现 $c_t-U&lt;c_k\leq c_t$，那么 $(s,n+1)$ 和 $(k,n+1)$ 两组询问在 $[c_t,c_{n+1})$ 的贡献是相等的，并且 $(k,n+1)$ 在 $[c_k,c_t)$ 的贡献为 $b_k\cdot(c_t-c_k)$，所以 $ans(s,t)=ans(s,n+1)-ans(k,n+1)+b_k\cdot(c_t-c_k)$，就转化为终点固定的情况了。

时间复杂度：$O((n+m)\log V)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2e5 + 5;

int n, m, rt, sgt_cnt;
int a[kMaxN], b[kMaxN], c[kMaxN], ans[kMaxN];
int lg[kMaxN], sta[kMaxN][20], stb[kMaxN][20];
int ls[kMaxN * 60], rs[kMaxN * 60], sum[kMaxN * 60], tag[kMaxN * 60];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; qq[kMaxN];

int get(int x, int y) {
  return b[x] &lt; b[y] ? x : y;
}

void st_prework() {
  lg[0] = -1;
  for (int i = 1; i &lt;= n + 1; ++i) {
    sta[i][0] = a[i];
    stb[i][0] = i;
    lg[i] = lg[i &gt;&gt; 1] + 1;
  }
  for (int i = 1; i &lt;= lg[n + 1]; ++i) {
    for (int j = 1; j &lt;= n + 1 - (1 &lt;&lt; i) + 1; ++j) {
      sta[j][i] = std::max(sta[j][i - 1], sta[j + (1 &lt;&lt; (i - 1))][i - 1]);
      stb[j][i] = get(stb[j][i - 1], stb[j + (1 &lt;&lt; (i - 1))][i - 1]);
    }
  }
}

int querya(int l, int r) {
  int k = lg[r - l + 1];
  return std::max(sta[l][k], sta[r - (1 &lt;&lt; k) + 1][k]);
}

int queryb(int l, int r) {
  int k = lg[r - l + 1];
  return get(stb[l][k], stb[r - (1 &lt;&lt; k) + 1][k]);
}

void prework() {
  st_prework();
}

void update(int &amp;x, int l, int r, int ql, int qr, int v) {
  if (l &gt; qr || r &lt; ql) return;
  if (!x) x = ++sgt_cnt;
  sum[x] += 1ll * v * (std::min(r, qr) - std::max(l, ql) + 1);
  if (l &gt;= ql &amp;&amp; r &lt;= qr) return void(tag[x] += v);
  int mid = (l + r) &gt;&gt; 1;
  update(ls[x], l, mid, ql, qr, v), update(rs[x], mid + 1, r, ql, qr, v);
}

int query(int x, int l, int r, int ql, int qr) {
  if (!x || l &gt; qr || r &lt; ql) return 0;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return sum[x];
  int mid = (l + r) &gt;&gt; 1;
  return query(ls[x], l, mid, ql, qr) + query(rs[x], mid + 1, r, ql, qr) + 1ll * tag[x] * (std::min(r, qr) - std::max(l, ql) + 1);
}

int res[kMaxN];

void upd(int l, int r, int k, int b, int v) {
  l = std::max&lt;int&gt;(l, 0), r = std::min&lt;int&gt;(r, 1e8);
  if (l &gt; r || !k &amp;&amp; !b) return;
  // std::cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\n';
  update(rt, 0, 1e8, l, l, (k * l + b) * v);
  update(rt, 0, 1e8, l + 1, r, k * v);
  update(rt, 0, 1e8, r + 1, r + 1, -(k * r + b) * v);
  // for (int i = l; i &lt;= r; ++i) res[i] += v * (k * i + b);
}

void work(int x, int pre, int nxt, int v) {
  assert(x &gt; pre &amp;&amp; x &lt; nxt);
  std::vector&lt;int&gt; vec = {0, c[nxt] - c[x]};
  if (pre) vec.emplace_back(c[nxt] - c[pre]), vec.emplace_back(c[x] - c[pre]);
  else vec.emplace_back(1e8 + 1);
  std::sort(vec.begin(), vec.end());
  vec.erase(std::unique(vec.begin(), vec.end()), vec.end());
  for (int i = 0; i + 1 &lt; (int)vec.size(); ++i) {
    int l = vec[i], r = vec[i + 1] - 1, k = 0, b = 0;
    if (c[x] + l &lt;= c[nxt] &amp;&amp; c[x] + r &lt;= c[nxt]) ++k, b += c[x];
    else b += c[nxt];
    if (c[x] &gt;= c[pre] + l &amp;&amp; c[x] &gt;= c[pre] + r) b -= c[x];
    else --k, b -= c[pre];
    upd(l, r, k, b, v * ::b[x]);
  }
  // for (int u = 0; u &lt;= 1e3; ++u) {
  //   if (std::max(c[i], c[pre] + u) &lt; std::min(c[i] + u, c[nxt]))
  //     res[u] += v * b[i] * (std::min(c[i] + u, c[nxt]) - std::max(c[i], c[pre] + u));
  // }
}

void getans() {
  static int top, stk[kMaxN], nxt[kMaxN];
  stk[top = 1] = n + 1;
  c[0] = -1e9;
  for (int i = n; i; --i) {
    for (; top &amp;&amp; b[stk[top]] &gt;= b[i]; --top) {
      work(stk[top], 0, nxt[stk[top]], -1);
      work(stk[top], i, nxt[stk[top]], 1);
    }
    nxt[i] = stk[top];
    stk[++top] = i;
    work(i, 0, nxt[i], 1);
    for (auto [id, u, v] : qq[i]) ans[id] += v * query(rt, 0, 1e8, 0, u);
    // for (auto [id, u, v] : qq[i]) ans[id] += v * res[u];
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    c[i + 1] = c[i] + a[i];
  }
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; b[i];
  prework();
  for (int i = 1; i &lt;= m; ++i) {
    int s, t, u;
    std::cin &gt;&gt; s &gt;&gt; t &gt;&gt; u;
    if (querya(s, t - 1) &gt; u) {
      ans[i] = -1;
      continue;
    }
    int p = std::max(s, std::upper_bound(c + 1, c + 2 + n, c[t] - u) - c), k = queryb(p, t);
    ans[i] = b[k] * (c[t] - c[k]);
    qq[s].emplace_back(i, u, 1), qq[k].emplace_back(i, u, -1);
  }
  getans();
  for (int i = 1; i &lt;= m; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18524587.html</id>
    <title type="text">[PA2024] Modernizacja Bajtocji 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-04T02:15:00Z</published>
    <updated>2024-11-04T02:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18524587.html" />
    <content type="text">## Description

Byteland 正在走向现代化。最新的政府项目旨在为那些没有电脑的村镇居民提供电脑。Byteasar 正在监督该计划中的一个村庄——Bytetown——的现代化进程，目前那里没有一个居民拥有电脑。

Bytetown 有 $n$ 个居民，为了简单起见，Byteasar 将他们用 $1$ 到 $n$ 的整数编号。最初没有一个居民拥有电脑。Byteasar 的任务是处理三种形式的事件：

- $\texttt{+}\ a_i\ b_i$：将一台电脑送给 Bytetown 的居民。然而，Byteasar 并不知道电脑是送给了编号为 $a_i$ 还是 $b_i$ 的居民。可能会出现 $a_i = b_i$ 的情况——在这种情况下，电脑肯定送给了编号为 $a_i$ 的居民。可以确定的是，电脑被送到了目前还没有电脑的居民手中。
- $\texttt{-}\ c_i$：编号为 $c_i$ 的居民的电脑坏了。可以肯定的是，该居民曾经拥有一台电脑（但现在不再拥有，因此将来可能会收到一台新电脑）。
- $\texttt{?}\ d_i$：Byteasar 需要（利用**迄今为止**获得的所有信息）确定编号为 $d_i$ 的居民：肯定有电脑，肯定没有电脑，还是不确定他是否有电脑。

请编写一个程序，帮助 Byteasar 回答所提出的问题！

注：在居民的电脑坏掉的前一刻，Byteasar 不一定可以确定这个居民是否有电脑。换句话说，在某居民电脑坏掉之前，不一定可以从之前的事件中确定他是否有电脑。

## Solution

首先没有 $-$ 操作是好做的，如果把 $+$ 操作的两个居民连一条边，则一定会连成树/基环树。对于一个连通块，如果大小为 $1$，则一定没电脑，否则如果为树，则全部无法确定，基环树则每个人都有。

加上 $-$ 操作后就把操作的点从其所在连通块删掉，原连通块如果为基环树则还是，否则如果删掉后只有一个点就看成单点，否则还是个树。

但是暴力删是做不了的，考虑把删点看成加点，即删掉点 $a$ 时，只将原连通块的状态更新但不删点，然后新建一个点 $a'$ 并把 $a$ 放到 $a'$ 上。

时间复杂度：$O((n+q)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1.3e6 + 5;
const char kC[] = "0?1";

int n, q, cnt;
int id[kMaxN], fa[kMaxN], sz[kMaxN], op[kMaxN];

// 0 : 单点，1 : 树，2 : 基环树

int find(int x) {
  return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void unionn(int x, int y) {
  int fx = find(x), fy = find(y);
  if (fx == fy) op[fx] = 2;
  else fa[fx] = fy, op[fy] = ((op[fx] == 2 || op[fy] == 2) ? 2 : 1), sz[fy] += sz[fx];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  cnt = n;
  for (int i = 1; i &lt;= n; ++i) id[i] = fa[i] = i, sz[i] = 1;
  for (int i = 1; i &lt;= q; ++i) {
    std::string s;
    int a, b;
    std::cin &gt;&gt; s;
    if (s[0] == '+') {
      std::cin &gt;&gt; a &gt;&gt; b;
      unionn(id[a], id[b]);
    } else if (s[0] == '-') {
      std::cin &gt;&gt; a;
      int f = find(id[a]);
      if (op[f] == 1 &amp;&amp; --sz[f] == 1) op[f] = 0;
      id[a] = ++cnt;
      fa[cnt] = cnt, sz[cnt] = 1;
    } else {
      std::cin &gt;&gt; a;
      std::cout &lt;&lt; kC[op[find(id[a])]];
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18542654.html</id>
    <title type="text">[CEOI2023] A Light Inconvenience 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-12T13:15:00Z</published>
    <updated>2024-11-12T13:15:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18542654.html" />
    <content type="text">## Description

今年 CEOI 的开幕式上有一场精彩的火炬表演。表演者们站成一排，从 $1$ 开始从左往右编号。每个表演者举着一根火炬，初始只有一个举着点燃的火炬的表演者。

表演分为 $Q$ 幕。在第 $a$ 幕开始之前，要么 $p_a &gt; 0$ 个表演者从右侧加入表演，他们的火炬是熄灭的；要么最右侧 $p_a &gt; 0$ 个表演者决定离开，并熄灭他们的火炬（如果他们的火炬是点燃的）。表演者的加入和离开不受委员会的控制。最左侧的表演者永远留在台上。

一旦第 $a$ 幕准备好了，委员会需要宣布一个非负整数 $t_a \geq 0$。对于每个举着点燃的火炬的表演者，用他的火炬点燃他右侧 $t_a$ 个人的火炬。也就是说，第 $i$ 个人的火炬在传火后是点燃的，当且仅当表演者 $\max(1, i - t_a), \cdots, i$ 中至少一个人的火炬在传火前是点燃的。$t_a$ 不应超过 $p_a$。

在第 $a$ 幕结束时，委员会需要告知每个举着点燃的火炬的表演者是否熄灭火炬。出于美学原因，最右侧的表演者应保持他的火炬点燃。此外，为了节省汽油，点燃的火炬数量不应超过 $150$。

编写程序帮助委员会在上述限制下主持表演。

对于所有数据，$1\leq N\leq 10 ^ {17}$，$1\leq Q\leq 5\times 10 ^ 4$。

## Solution

考虑将整个 01 序列反转，转化为从开头加/删数。

设序列中第 $i$ 个 $1$ 的位置为 $f_i$，当 $p=f_i$ 时就需要满足 $f_i+1\leq f_{i+1}\leq 2f_i+1$，同时 $f_1=1,f_t=n$。所以如果没有删除操作，就让 $f_i=\min\{2f_{i-1}+1,n\}$ 即可。

加入删除操作就不好做了，因为删掉开头的 $p$ 个数后 $f$ 数组的形态会变得很不固定，难以维护。

不妨设 $g$ 数组为删除操作后的新的 $1$ 的位置序列，考虑用原来的 $f$ 序列构造 $g$ 序列。

显然 $g_{i-1}+1\leq g_i\leq 2g_{i-1}+1$，由于 $f_j$ 控制的区间为 $[f_j-2p,f_j-p]$，所以所有 $g_i$ 一定要出自这些区间。

假设已经构造好了 $g_1,g_2,\ldots,g_{i-1}$，设 $j$ 为满足 $f_j-2p\leq 2g_{i-1}+1$ 的最大的 $j$，那么 $2f_j+1-2p\geq f_{j+1}-2p&gt;2g_{i-1}+1$，即 $f_j-p\geq g_{i-1}+1$，所以 $[f_j-2p,f_j-p]$ 与 $[g_{i-1}+1,2g_{i-1}+1]$ 一定有交，贪心地令 $g_i$ 为 $\min\{f_j-p,2g_{i-1}+1\}$ 即可。

下面算一下这个做法维护的序列长度。

如果 $g_i=2g_{i-1}+1$，则 $g$ 翻倍了。如果 $g_i=f_j-p$，则 $2g_i+1=2f_j-2p+1\geq f_{j+1}-2p$，所以 $g_{i+1}\geq\min\{f_{j+1}-p,2g_i+1\}$。如果 $g_{i+1}=2g_i+1$，则 $g$ 翻倍了，否则 $g_{i+1}=f_{j+1}-p\geq 2g_{i-1}+1$。

所以 $g$ 数组每两个就会翻一次倍，所以长度为 $2\log n+O(1)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;
#include "light.h"

#ifdef ORZXKR
#include "sample_grader.cpp"
#endif

const int kMaxt = 155;

int64_t n = 1, t = 0;
int64_t f[kMaxt], g[kMaxt];

void prepare() {
  n = 1;
  f[t = 1] = 1;
}

std::pair&lt;long long, std::vector&lt;long long&gt;&gt; join(long long p) {
  if (f[t] == n) --t;
  if (!t) f[t = 1] = 1;
  n += p;
  for (;;) {
    if (f[t] == n) break;
    f[t + 1] = std::min&lt;int64_t&gt;(2ll * f[t] + 1, n);
    ++t;
  }
  std::vector&lt;long long&gt; vec;
  for (int i = t; i; --i) vec.emplace_back(n + 1 - f[i]);
  return {p, vec};
}

std::pair&lt;long long, std::vector&lt;long long&gt;&gt; leave(long long p) {
  n -= p;
  int _t = 0;
  g[_t = 1] = 1;
  for (int i = 1;;) {
    if (g[_t] == n) break;
    for (; i &lt; t &amp;&amp; f[i + 1] - 2ll * p &lt;= 2ll * g[_t] + 1; ++i) {}
    g[_t + 1] = std::min&lt;int64_t&gt;({n, f[i] - p, 2ll * g[_t] + 1});
    ++_t;
  }
  t = _t;
  for (int i = 1; i &lt;= t; ++i) f[i] = g[i];
  std::vector&lt;long long&gt; vec;
  for (int i = t; i; --i) vec.emplace_back(n + 1 - f[i]);
  return {p, vec};
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18548247.html</id>
    <title type="text">[CEOI2023] Tricks of the Trade 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-15T08:50:00Z</published>
    <updated>2024-11-15T08:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18548247.html" />
    <content type="text">## Description

有 $n$ 个机器人排成一排，第 $i$ 个机器人的购买价是 $a_i$ 欧元，卖出价是 $b_i$ 欧元。

给定 $1\le k\le n$，你需要购买一段长度至少为 $k$ 的区间中所有的机器人，然后选择其中的恰好 $k$ 个机器人来卖出。

你需要求出：

1. 你能够得到的最大收益；
2. 在收益最大化的前提下，哪些机器人可以在某种最优方案中被卖出。

$1\leq k\leq n\leq 2.5\times 10^5$。

## Solution

先考虑第一问怎么求。

不妨设 $f(l,r)$ 表示 $[l,r]$ 这个区间的收益，即为 $b$ 数组在 $[l,r]$ 的前 $k$ 大的和减去 $a$ 数组在 $[l,r]$ 的区间和。

打表一下会发现 $f(l,r)$ 满足四边形不等式 $f(a,c)+f(b,d)\geq f(a,d)+f(b,c)$。

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

容易发现 $a$ 数组的区间和没什么意义，先扔掉，设 $g(l,r)$ 表示 $b$ 数组在 $[l,r]$ 前 $k$ 大的和，那么转化为要证明 $g(l,r)+g(l+1,r+1)\geq g(l,r+1)+g(l+1,r)$。

先把 $g(l+1,r)$ 拿出来，$g(l,r+1)$ 相当于是在 $[l+1,r]$ 同时加入 $b_l,b_{r+1}$ 两个数去更新第 $k$ 大和第 $k-1$ 大，而 $g(l,r)+g(l+1,r+1)$ 则是分别加入 $b_l$ 和 $b_{r+1}$ 去更新 $[l+1,r]$ 第 $k$ 大，这个显然比两个去更新第 $k$ 大和第 $k-1$ 大优。
&lt;/details&gt;

所以第一问直接决策单调性分治即可。

对于第二问，先把所有收益等于最大值的区间 $[l,r]$ 拿出来，那么 $[l,r]$ 内 $b_i$ 不小于区间第 $k$ 大的位置都会被标记。

但是这样的最优区间可能是 $O(n^2)$ 级别的，暴力找是做不了的。

考虑如果存在两个最优区间 $[l_1,r_1],[l_2,r_2]$，满足 $l_1\leq l_2\leq r_2\leq r_1$，由于 $f(l_1,r_2)+f(l_2,r_1)\geq f(l_1,r_2)+f(l_2,r_1)=2\times ans$，所以 $[l_1,r_2]$ 和 $[l_2,r_1]$ 也是最优区间，这两个区间加上 $[l_2,r_2]$ 可以覆盖任何 $[l_1,r_1]$ 可以覆盖的位置，所以只需要保留 $[l_1,r_2],[l_2,r_2],[l_2,r_1]$ 即可。

于是剩下的区间是个类似双指针的东西，只有 $O(n)$ 个，所以在决策单调性分治的时候求出使得每个右端点 $r$ 收益最大的最大左端点 $l$，后面找区间的时候双指针扫即可。

时间复杂度：$O(n\log^2 n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2.5e5 + 5, kMaxT = kMaxN * 35;

int n, k;
int a[kMaxN], b[kMaxN];
int sgt_tot, rt[kMaxN], ls[kMaxT], rs[kMaxT], cnt[kMaxT];
int64_t ans, suma[kMaxT], sumb[kMaxT], f[kMaxT], p[kMaxT];
bool op[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; seg;

int update(int x, int l, int r, int ql, int v) {
  int nz = ++sgt_tot;
  ls[nz] = ls[x], rs[nz] = rs[x], cnt[nz] = cnt[x] + v, sumb[nz] = sumb[x] + v * ql;
  if (l == r) return nz;
  int mid = (l + r) &gt;&gt; 1;
  if (ql &lt;= mid) ls[nz] = update(ls[x], l, mid, ql, v);
  else rs[nz] = update(rs[x], mid + 1, r, ql, v);
  return nz;
}

int64_t query(int x, int y, int l, int r, int k) {
  if (k &lt;= 0 || cnt[y] - cnt[x] == 0) return 0;
  if (l == r) return l * k;
  int mid = (l + r) &gt;&gt; 1, crs = cnt[rs[y]] - cnt[rs[x]];
  if (k &lt;= crs) return query(rs[x], rs[y], mid + 1, r, k);
  else return sumb[rs[y]] - sumb[rs[x]] + query(ls[x], ls[y], l, mid, k - crs);
}

int getkth(int x, int y, int l, int r, int k) {
  if (l == r) return l;
  int mid = (l + r) &gt;&gt; 1, crs = cnt[rs[y]] - cnt[rs[x]];
  if (k &lt;= crs) return getkth(rs[x], rs[y], mid + 1, r, k);
  else return getkth(ls[x], ls[y], l, mid, k - crs);
}

int64_t calc(int l, int r) {
  if (r - l + 1 &lt; k) return -1e18;
  return query(rt[l - 1], rt[r], 1, 1e9, k) - (suma[r] - suma[l - 1]);
}

void prework() {
  for (int i = 1; i &lt;= n; ++i) {
    rt[i] = update(rt[i - 1], 1, 1e9, b[i], 1);
    suma[i] = suma[i - 1] + a[i];
  }
}

void solve(int l, int r, int L, int R) {
  if (l &gt; r) return;
  int mid = (l + r) &gt;&gt; 1;
  f[mid] = calc(L, mid), p[mid] = L;
  for (int i = L + 1; i &lt;= R; ++i) {
    int64_t val = calc(i, mid);
    if (val &gt;= f[mid]) {
      f[mid] = val, p[mid] = i;
    }
  }
  solve(l, mid - 1, L, p[mid]), solve(mid + 1, r, p[mid], R);
}

void getseg() {
  for (int i = k, j = 1; i &lt;= n; ++i) {
    if (f[i] != ans) continue;
    for (;; ++j) {
      if (calc(j, i) == ans) seg.emplace_back(j, i);
      if (j == p[i]) break;
    }
  }
}

void work() {
  static std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxN];
  for (auto [l, r] : seg) {
    int kth = getkth(rt[l - 1], rt[r], 1, 1e9, k);
    vec[l].emplace_back(kth, 1), vec[r + 1].emplace_back(kth, -1);
  }
  std::multiset&lt;int&gt; st;
  for (int i = 1; i &lt;= n; ++i) {
    for (auto [x, v] : vec[i]) {
      if (v == 1) st.emplace(x);
      else st.erase(st.lower_bound(x));
    }
    if (st.size() &amp;&amp; b[i] &gt;= *st.begin()) op[i] = 1;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; b[i];
  prework();
  memset(f, 0xcf, sizeof(f));
  solve(k, n, 1, n);
  ans = *std::max_element(f + 1, f + 1 + n);
  getseg(), work();
  std::cout &lt;&lt; ans &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; op[i];
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18548514.html</id>
    <title type="text">[CEOI2023] The Ties That Guide Us 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-15T11:11:00Z</published>
    <updated>2024-11-15T11:11:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18548514.html" />
    <content type="text">## Description

你用销售机器人的利润雇佣了一名助手，现在你准备好去拿走装有 CEOI 奖章的保险箱了。

保险箱位于一所由 $n$ 个房间所组成的大学建筑内，这些房间由 $n-1$ 扇门连接。每个房间都可以从其他任何房间到达，且每个房间最多与 $3$ 扇门相连。

你和你的助手都有描述建筑物内房间相连情况的平面图，但是你们两个各自拥有的平面图虽然描述了相同的房间结构布局，但是房间和门的编号可能不同。

在比赛的第二天，委员会忙于处理赛时通知和选手提问。这将是接近装着奖牌的保险箱的完美机会。

你的助手会首先搜索整栋大楼。一旦他找到保险箱所在的房间，它就会给你留下前往那个房间的提示。由于手机不能带进赛场，他用了去年 BOI 留下的几乎无限供应的领带。由于这些领带完全相同无法区分，你能获得的信息就是他在任何给定房间里所留下的领带数量。由于一个房间内过多的领带非常可疑，因此任何单个房间内领带的最大数量应当尽可能少（参阅评分部分）。

之后，你计划在上厕所的时候溜出去，利用助手留下来的领带找到有保险箱的房间。保险箱藏在房间里，所以你进入带有保险箱的房间时，必须依靠领带识别这个房间；此外，由于“上厕所”时间过长会被发现，你必须尽快找到保险箱。你最多可以走过 $d+30$ 扇门，其中 $d$ 是你的初始位置到保险箱所在位置的最短路径上的门数量。若重复穿过同一扇门，则每次都计入。

因此，你需要编写一个程序，告诉助手需要在每个房间留下多少条领带，并引导你前往带有保险箱的房间。

## Solution

首先对于 Sub2 只有一个点度数为 $2$，所以可以直接取出这个唯一的点作为根，然后将目标点到根的路径颜色染黑。这样查询的时候只要暴力跳父亲，直到当前点颜色为黑，然后暴力枚举儿子，如果找到颜色为黑的儿子就往儿子跳，否则就是终点了。

不过这么做有个问题，就是找儿子的过程可能会浪费过多的询问次数，而注意到限制是 $dist(s,t)+30$，由于每次试错会浪费两次，所以只能走错 $15$ 步，为 $O(\log n)$ 级别。

这启发我们重链剖分，每次跳子树大小最大的儿子，由于终点到 $lca$ 路径上的轻儿子只有 $O(\log n)$ 个，所以这样就是对的。

如果树没有特殊性质，可以利用树哈希的思想选定重心作为根，但是可能有两个重心，这时需要选取离起点更近的重心作为根。

查询时如果跳到根节点颜色还为白，就说明根是另一个重心，直接跳到那个重心即可。

总次数：$d+2\log n$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;
#include "incursion.h"

#ifdef ORZXKR
#include "grader.cpp"
#endif

const int kMaxN = 4.5e4 + 5;

int n, safe;
int p[kMaxN], sz[kMaxN], mx[kMaxN];
bool vis[kMaxN];
std::vector&lt;int&gt; G[kMaxN], rt;

void dfs1(int u, int fa) {
  sz[u] = 1, mx[u] = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);
  }
  mx[u] = std::max(mx[u], n - sz[u]);
  if (mx[u] &lt;= n / 2) rt.emplace_back(u);
}

void dfs2(int u, int fa) {
  p[u] = fa;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs2(v, u);
  }
}

void dfs3(int u, int fa) {
  vis[u] = 1;
  for (auto v : G[u]) {
    if (v == fa || vis[v]) continue;
    if (visit(v)) return dfs3(v, u);
    else visit(u);
  }
}

std::vector&lt;int&gt; mark(std::vector&lt;std::pair&lt;int, int&gt;&gt; F, int safe) {
  n = (int)F.size() + 1;
  std::vector&lt;int&gt; vec(n, 0);
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  for (auto [u, v] : F)
    G[u].emplace_back(v), G[v].emplace_back(u);
  rt.clear(), dfs1(1, 0), dfs2(rt[0], 0);
  for (int i = safe; i; i = p[i]) {
    vec[i - 1] = 1;
    if (rt.size() == 2 &amp;&amp; (i == rt[0] || i == rt[1])) break;
  }
  return vec;
}

void locate(std::vector&lt;std::pair&lt;int, int&gt;&gt; F, int cur, int t) {
  n = (int)F.size() + 1;
  for (int i = 1; i &lt;= n; ++i) G[i].clear(), vis[i] = 0;
  for (auto [u, v] : F)
    G[u].emplace_back(v), G[v].emplace_back(u);
  rt.clear(), dfs1(1, 0), dfs2(rt[0], 0);
  for (int i = 1; i &lt;= n; ++i)
    std::sort(G[i].begin(), G[i].end(), [&amp;] (int x, int y) { return sz[x] &gt; sz[y]; });
  for (; p[cur] &amp;&amp; !t; t = visit(cur = p[cur])) vis[cur] = 1;
  vis[cur] = 1;
  if (!t) assert(cur == rt[0]), visit(cur = rt[1]);
  vis[cur] = 1;
  dfs3(cur, p[cur]);
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18550640.html</id>
    <title type="text">CF603E Pastoral Oddities 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-17T07:58:00Z</published>
    <updated>2024-11-17T07:58:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18550640.html" />
    <content type="text">## Description

给定一张 $n$ 个点的无向图，初始没有边。

依次加入 $m$ 条带权的边，每次加入后询问是否存在一个边集，满足每个点的度数均为奇数。

若存在，则还需要最小化边集中的最大边权。

$n \le 10^5$，$m \le 3 \times 10^5$。

## Solution

考虑给定一个图，怎么判断这个图存在一个边集满足条件。

结论是这个图的每个连通块大小为偶数就合法，否则不合法。证明就考虑如果存在一个连通块大小为奇数，则这个连通块最终总度数一定为奇数，而显然加入一条边所有点的度数和奇偶性不变，仍为偶数，所以矛盾。

如果一个连通块大小为偶数，就随便拿出一个生成树，然后从叶子向根考虑。如果一个点儿子连过来的边有偶数个，这个点就连父亲，否则不连。剩下的根节点也一定满足条件。

所以如果固定边集的可选范围，只需要先对于边权从小到大排序，在加边的过程中维护奇连通块的个数即可。

但是如果需要动态加边，上面那个做法就没用了，因为你无法确定某一个时刻的连通块状态。

考虑线段树分治。

由于答案从后往前不降，所以第 $i$ 条边在最优边集中存在的时间一定是一个以 $i$ 为左端点区间。线段树分治时先分治右子树，再分治左子树，到叶子时如果存在奇连通块就加入新边，直到不存在奇连通块。由于在加边的过程中新加入的边的存在时间被确定，所以在线段树上更新即可。

时间复杂度：$O(m\log n\log m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e5 + 5, kMaxM = 3e5 + 5;

int n, m, p, cnt_odd;
int ans[kMaxM];
std::tuple&lt;int, int, int, int&gt; ed[kMaxM];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxM * 4];

struct DSU {
  int fa[kMaxN], sz[kMaxN], rnk[kMaxN];
  std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec;

  void init() {
    for (int i = 1; i &lt;= n; ++i)
      fa[i] = i, sz[i] = 1, rnk[i] = 0;
    cnt_odd = n;
  }

  void back(int t) {
    for (; vec.size() &gt; t; vec.pop_back()) {
      auto [fx, fy, det] = vec.back();
      cnt_odd -= (sz[fy] &amp; 1);
      fa[fx] = fx, rnk[fy] -= det, sz[fy] -= sz[fx];
      cnt_odd += (sz[fx] &amp; 1) + (sz[fy] &amp; 1);
    }
  }

  int find(int x) { return x == fa[x] ? x : find(fa[x]); }
  void unionn(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return;
    if (rnk[fx] &gt; rnk[fy]) std::swap(fx, fy);
    int det = (rnk[fx] == rnk[fy]);
    cnt_odd -= (sz[fx] &amp; 1) + (sz[fy] &amp; 1);
    fa[fx] = fy, rnk[fy] += det, sz[fy] += sz[fx];
    vec.emplace_back(fx, fy, det);
    cnt_odd += (sz[fy] &amp; 1);
  }
} dsu;

void update(int x, int l, int r, int ql, int qr, std::pair&lt;int, int&gt; ed) {
  if (l &gt; qr || r &lt; ql) return;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return void(vec[x].emplace_back(ed));
  int mid = (l + r) &gt;&gt; 1;
  update(x &lt;&lt; 1, l, mid, ql, qr, ed), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, ed);
}

void solve(int x, int l, int r) {
  int t = dsu.vec.size();
  for (auto [u, v] : vec[x]) dsu.unionn(u, v);
  if (l == r) {
    for (; p &lt; m &amp;&amp; cnt_odd;) {
      ++p;
      auto [w, u, v, id] = ed[p];
      if (id &lt;= l) {
        dsu.unionn(u, v);
        update(1, 1, m, id, l - 1, {u, v});
      }
    }
    if (!cnt_odd) ans[l] = std::get&lt;0&gt;(ed[p]);
    else ans[l] = -1;
  } else {
    int mid = (l + r) &gt;&gt; 1;
    solve(x &lt;&lt; 1 | 1, mid + 1, r);
    solve(x &lt;&lt; 1, l, mid);
  }
  dsu.back(t);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    ed[i] = {w, u, v, i};
  }
  std::sort(ed + 1, ed + 1 + m);
  dsu.init();
  solve(1, 1, m);
  for (int i = 1; i &lt;= m; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18553531.html</id>
    <title type="text">CF715B Complete The Graph 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-18T12:11:00Z</published>
    <updated>2024-11-18T12:11:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18553531.html" />
    <content type="text">## Description

给 $n$ 点 $m$ 边的无向图，$L$，$s$，$t$。

修改 $m$ 条边中边为 $0$ 的边，使满足 $s,t$ 的最短路长度是 $L$，且输出答案的时候边为 $0$ 的边的权值必须在 $[1,10^{18}]$ 内。

## Solution

考虑怎么判有无解。

容易发现将所有未知边边权设为 $10^{18}$，如果最短路小于 $L$，或者未知边设为 $1$ 后最短路大于 $L$ 时无解，否则有解。因为每次只将一条边的长度加 $1$ 后最短路至多增加 $1$。

不妨设 $dis_i$ 表示 $i$ 在未知边边权为 $1$ 时与 $s$ 的距离，$det$ 表示 $L-dis_t$。容易发现我们的任务就是让 $dis_t$ 增加 $det$。

考虑再进行一次 dijkstra，如果当前松弛的边 $(u,v,w)$ 满足 $dis_{v}+det&gt;dis^{'}_{u}+w$ 且这条边未确定，就将 $w$ 调整为 $dis_{v}+det-dis^{'}_u$，这样的话每个点的最短路一定不会增加超过 $det$，且 $dis_t$ 一定能增加 $det$。

时间复杂度：$O((n+m)\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e3 + 5, kMaxM = 1e4 + 5;

int n, m, L, s, t, det;
int u[kMaxM], v[kMaxM], w[kMaxM];
int dis1[kMaxN], dis2[kMaxN];
bool del[kMaxM];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; G[kMaxN];

int dijkstra1(int *dis) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  for (int i = 1; i &lt;= m; ++i) {
    if (w[i]) {
      G[u[i]].emplace_back(v[i], w[i], i), G[v[i]].emplace_back(u[i], w[i], i);
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    dis[i] = 1e18, vis[i] = 0;
  }
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  q.emplace(0, s), dis[s] = 0;
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w, id] : G[u]) {
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w;
        q.emplace(-dis[v], v);
      }
    }
  }
  return dis[t];
}

int dijkstra2(int *dis) {
  static bool vis[kMaxN];
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  for (int i = 1; i &lt;= m; ++i) {
    if (w[i]) {
      G[u[i]].emplace_back(v[i], w[i], i), G[v[i]].emplace_back(u[i], w[i], i);
    }
  }
  for (int i = 1; i &lt;= n; ++i) {
    dis[i] = 1e18, vis[i] = 0;
  }
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  q.emplace(0, s), dis[s] = 0;
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w, id] : G[u]) {
      if (del[id] &amp;&amp; dis1[v] + det &gt; dis[u] + ::w[id])
        ::w[id] = dis1[v] + det - dis[u];
      if (dis[v] &gt; dis[u] + ::w[id]) {
        dis[v] = dis[u] + ::w[id];
        q.emplace(-dis[v], v);
      }
    }
  }
  return dis[t];
}

void print() {
  std::cout &lt;&lt; "YES\n";
  for (int i = 1; i &lt;= m; ++i)
    std::cout &lt;&lt; u[i] - 1 &lt;&lt; ' ' &lt;&lt; v[i] - 1 &lt;&lt; ' ' &lt;&lt; w[i] &lt;&lt; '\n';
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; L &gt;&gt; s &gt;&gt; t;
  ++s, ++t;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];
    ++u[i], ++v[i];
    if (!w[i]) del[i] = 1, w[i] = 1e18;
  }
  int dis = dijkstra1(dis1);
  if (dis &lt; L) return void(std::cout &lt;&lt; "NO\n");
  if (dis == L) return print();
  for (int i = 1; i &lt;= m; ++i)
    if (del[i])
      w[i] = 1;
  int now = dijkstra1(dis1);
  if (now &gt; L) return void(std::cout &lt;&lt; "NO\n");
  det = L - now;
  dijkstra2(dis2);
  print();
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18555072.html</id>
    <title type="text">Public NOIP Round #6 D 排序 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-19T08:26:00Z</published>
    <updated>2024-11-19T08:26:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18555072.html" />
    <content type="text">## Description

今天是 YQH 的生日，她得到了一个 $1\sim n$ 的排列作为礼物。
YQH 是一个有强迫症的女孩子，她希望把这个排列从小到大排序，具体的，她可以进行这样的操作：

- 把 $[1,n]$ 分成若干个区间，假如是 $m$ 段，依次为 $[l_1,r_1],[l_2,r_2],\dots,[l_m,r_m]$，其中 $l_1=1,r_m=n,l_{i+1}=r_i+1,l_i\le r_i$。

- 假如原来的排列为 $a_{1,\dots,n}$，那么把排列变为 $a_{l_m},a_{l_m+1},\dots,a_{r_m},a_{l_{m-1}},a_{l_{m-1}+1},\dots,a_{r_{m-1}},\dots,a_{l_1},a_{l_1+1},\dots,a_{r_1}$，即把每一段看作一个整体，然后把这个排列进行 reverse。
YQH 希望进行尽可能少的操作，把序列从小到大排序。但是她太笨了，所以她找到你帮忙。注意，你不需要得到最小操作数。

$n\leq 2\times 10^4$，次数限制为 $90$。

## Solution

考虑分治。

假设当前已经让 $a_{[l,r]}$ 的数值域变成 $[l,r]$ 了，设 $mid=\left\lfloor\frac{l+r}{2}\right\rfloor$，将 $a_i\leq mid$ 视作 $0$，否则视作 $1$，现在需要将这个 $01$ 序列排序，使得所有 $0$ 都在 $1$ 之前。

先把连续段缩掉，那么序列变为 $10101\ldots 010$，考虑以 $1,2,1,2\ldots$ 分段，则操作后变为 $1000111000\ldots$，连续段数变为原来的 $\frac{1}{3}$，所以将长度为 $n$ 的 $01$ 序列排序的次数为 $O(\log_3 n)$。

那么设 $f(n)$ 表示将普通序列排序的次数，用上面的方式排序可以得到：

$f(n)=f\left(\left\lceil\frac{n}{2}\right\rceil\right)+O(\log_3 n)$

于是总次数为 $1+\sum\limits_{j=0} \left\lceil\log_3\left(\left\lceil\frac{n}{2^j}\right\rceil\right)\right\rceil$，能过。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using vi = std::vector&lt;int&gt;;
using vvi = std::vector&lt;std::vector&lt;int&gt;&gt;;

const int kMaxN = 2e4 + 5;

int n, m;
int a[kMaxN], len[kMaxN];
bool b[kMaxN], op[kMaxN];

void prework(int l, int r) {
  int lst = l - 1;
  m = 0;
  for (int i = l; i &lt;= r; ++i) {
    if (i == r || b[i] != b[i + 1]) {
      op[++m] = b[i], len[m] = i - lst;
      lst = i;
    }
  }
}

vvi getvec(int l, int r) {
  vvi vec;
  for (;;) {
    prework(l, r);
    if (m == 2 &amp;&amp; op[1] == 0 &amp;&amp; op[2] == 1) break;
    std::vector&lt;int&gt; v;
    for (int i = 1, now = 1; i &lt;= m; now = 3 - now) {
      now = std::min(now, m - i + 1);
      int s = 0;
      for (int j = i; j &lt;= i + now - 1; ++j) s += len[j];
      v.emplace_back(s);
      i += now;
    }
    vec.emplace_back(v);
    int now = l;
    std::reverse(a + l, a + 1 + r);
    std::reverse(b + l, b + 1 + r);
    std::reverse(v.begin(), v.end());
    for (auto x : v) {
      std::reverse(a + now, a + now + x);
      std::reverse(b + now, b + now + x);
      now += x;
    }
  }
  return vec;
}

vi merge(vi a, vi b) {
  vi c;
  for (auto x : a) c.emplace_back(x);
  for (auto x : b) c.emplace_back(x);
  return c;
}

vvi solve(int l, int r) {
  if (l == r) return {};
  int mid = (l + r) &gt;&gt; 1;
  if (r - l + 1 &gt; 3 &amp;&amp; (~(l + r) &amp; 1)) ++mid;
  for (int i = l; i &lt;= r; ++i) b[i] = (a[i] &gt; mid);
  auto vec = getvec(l, r), L = solve(l, mid), R = solve(mid + 1, r);
  int sz = std::max(L.size(), R.size());
  if (sz &amp; 1) ++sz;
  L.resize(sz, vi{mid - l + 1});
  R.resize(sz, vi{r - mid});
  for (int i = 0; i &lt; sz; ++i) {
    if (~i &amp; 1) vec.emplace_back(merge(L[i], R[i]));
    else vec.emplace_back(merge(R[i], L[i]));
  }
  return vec;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  auto res = solve(1, n);
  std::cout &lt;&lt; res.size() &lt;&lt; '\n';
  for (auto &amp;vec : res) {
    std::cout &lt;&lt; vec.size() &lt;&lt; ' ';
    for (auto x : vec) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18559239.html</id>
    <title type="text">动态 DP-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-20T12:48:00Z</published>
    <updated>2024-11-20T12:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18559239.html" />
    <content type="text">用处：树上/序列的计数/最优化 dp 的优化方法，要求支持单点修改和可合并性。

做法：用矩阵维护 dp，同时在树上树链剖分，修改时跳重链时用线段树维护矩阵，由于轻儿子只会跳 $O(\log n)$ 次，所以轻儿子暴力跳即可。

```cpp
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

const int MaxN = 100000 + 5, MaxM = 200000 + 5;
const int MaxV = 400000 + 5;
const int INF = 0x7F7F7F7F;

struct Matrix {
  int mat[2][2];

  Matrix() {
    memset(mat, -0x3F, sizeof mat);
  }

  inline Matrix operator * (Matrix b) {
    Matrix c;

    for (int i = 0; i &lt; 2; ++i)
      for (int j = 0; j &lt; 2; ++j)
        for (int k = 0; k &lt; 2; ++k)
          c.mat[i][j] = max(c.mat[i][j], mat[i][k] + b.mat[k][j]);

    return c;
  }
};

int N, M; int cntv, cnte;
int A[MaxN];
int Fa[MaxN], Siz[MaxN], Dep[MaxN], Wson[MaxN];
int Top[MaxN], Id[MaxN], Dfn[MaxN], End[MaxN];
int F[MaxN][2];
int Head[MaxN], To[MaxM], Next[MaxM];
Matrix Val[MaxN];

struct SegTree {
  int L[MaxV], R[MaxV];
  Matrix M[MaxV];

  inline void Push_up(int i) {
    M[i] = M[i &lt;&lt; 1] * M[i &lt;&lt; 1 | 1];
  }

  void Build_Tree(int left, int right, int i) {
    L[i] = left, R[i] = right;
    if (L[i] == R[i]) {
      M[i] = Val[Dfn[L[i]]];
      return;
    }

    int mid = (L[i] + R[i]) &gt;&gt; 1;
    Build_Tree(L[i], mid, i &lt;&lt; 1);
    Build_Tree(mid + 1, R[i], i &lt;&lt; 1 | 1);
    Push_up(i);
  }

  void Update_Tree(int x, int i) {
    if (L[i] == R[i]) {
      // 直接赋值，减小常数
      M[i] = Val[Dfn[x]];
      return;
    }

    int mid = (L[i] + R[i]) &gt;&gt; 1;
    if (x &lt;= mid) Update_Tree(x, i &lt;&lt; 1);
    else Update_Tree(x, i &lt;&lt; 1 | 1);
    Push_up(i);
  }

  // 查询一个点的 DP 值，相当于查询这条重链上链尾矩阵和链中转移矩阵的 '*' 积
  Matrix Query_Tree(int left, int right, int i) {
    if (L[i] == left &amp;&amp; R[i] == right) return M[i];

    int mid = (L[i] + R[i]) &gt;&gt; 1;
    if (right &lt;= mid)
      return Query_Tree(left, right, i &lt;&lt; 1);
    else if (left &gt; mid)
      return Query_Tree(left, right, i &lt;&lt; 1 | 1);
    else
      return Query_Tree(left, mid, i &lt;&lt; 1) * Query_Tree(mid + 1, right, i &lt;&lt; 1 | 1);
  }
} T;

inline void add_edge(int from, int to) {
  cnte++; To[cnte] = to;
  Next[cnte] = Head[from]; Head[from] = cnte;
}

void readin() {
  scanf("%d %d", &amp;N, &amp;M);
  for (int i = 1; i &lt;= N; ++i)
    scanf("%d", &amp;A[i]);
  for (int i = 1; i &lt; N; ++i) {
    int u, v;
    scanf("%d %d", &amp;u, &amp;v);
    add_edge(u, v); add_edge(v, u);
  }
}

void dfs1(int u) {
  Siz[u] = 1;

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u]) continue;

    Fa[v] = u; Dep[v] = Dep[u] + 1;
    dfs1(v);

    Siz[u] += Siz[v];
    if (Siz[v] &gt; Siz[Wson[u]]) Wson[u] = v;
  }
}

void dfs2(int u, int chain) {
  cntv++;
  Id[u] = cntv; Dfn[cntv] = u;
  Top[u] = chain;
  End[chain] = max(End[chain], cntv);

  // 第二次树剖时直接更新 F, G 数组（这里直接将 G 放入矩阵更新）
  F[u][0] = 0, F[u][1] = A[u];
  Val[u].mat[0][0] = Val[u].mat[0][1] = 0;
  Val[u].mat[1][0] = A[u];
  if (Wson[u] != 0) {
    dfs2(Wson[u], chain);
    // 依照定义，重儿子不应计入 G 数组
    F[u][0] += max(F[Wson[u]][0], F[Wson[u]][1]);
    F[u][1] += F[Wson[u]][0];
  }

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u] || v == Wson[u]) continue;
    dfs2(v, v);

    F[u][0] += max(F[v][0], F[v][1]);
    F[u][1] += F[v][0];
    Val[u].mat[0][0] += max(F[v][0], F[v][1]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += F[v][0];
  }
}

void init() {
  readin();
  dfs1(1); dfs2(1, 1);
}

void update_path(int u, int w) {
  Val[u].mat[1][0] += w - A[u];
  A[u] = w;

  Matrix bef, aft;
  while (u != 0) {
    // 计算贡献时，应当用一个 bef 矩阵还原出少掉这个轻儿子的情况，再将 aft 加入更新
    bef = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    T.Update_Tree(Id[u], 1);
    aft = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    u = Fa[Top[u]];

    Val[u].mat[0][0] += max(aft.mat[0][0], aft.mat[1][0]) - max(bef.mat[0][0], bef.mat[1][0]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += aft.mat[0][0] - bef.mat[0][0];
  }
}

void solve() {
  T.Build_Tree(1, N, 1);

  for (int i = 1; i &lt;= M; ++i) {
    int u, w;
    scanf("%d %d", &amp;u, &amp;w);
    update_path(u, w);
    Matrix Ans = T.Query_Tree(Id[1], End[1], 1);
    printf("%d\n", max(Ans.mat[0][0], Ans.mat[1][0]));
  }
}

int main() {
  init();
  solve();
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18563802.html</id>
    <title type="text">1-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-22T13:48:00Z</published>
    <updated>2024-11-22T13:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18563802.html" />
    <content type="text">&lt;iframe src="https://loj.ac/p/3594"width=100% height=768&gt;&lt;/iframe&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18569891.html</id>
    <title type="text">UOJ #919. 【UR #28】环环相扣 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-11-26T04:30:00Z</published>
    <updated>2024-11-26T04:30:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18569891.html" />
    <content type="text">## Description

给定一个长度为 $n$ 的整数序列 $a_1\sim a_n$，其中的元素两两互不相等。

有 $q$ 个询问，每个询问给定一个区间 $[l,r]$，你要选择三个下标 $i,j,k\in[l,r]$ 满足 $i\neq j,j\neq k,k\neq i$，最大化 $(a_i\bmod a_j)+(a_j\bmod a_k)+(a_k\bmod a_i)$ 的值。

你只需要输出这个最大值。

$3\leq n\leq2\times10^6$，$1\leq q\leq8\times10^5$，$\text{op}\in\{0,1\}$，$1\leq a_i\leq10^{18}$，$a_1\sim a_n$ 互不相等，$1\leq l\leq r\leq n$，$r-l+1\geq3$。

## Solution

不妨设 $a_x&gt;a_y&gt;a_z$，那么对于 $(x,y,z)$ 只有两种贡献：$a_x\bmod a_y+a_y\bmod a_z+a_z$ 和 $a_x\bmod a_z+a_z+a_y$。

对于一组询问 $[l,r]$，有个结论是 $[l,r]$ 内的区间最大值和次大值都必须选。

- 证明

  先把区间的数拿出来并排序，使得 $a_1&lt;a_2&lt;\ldots&lt;a_m$，则选择 $(m-2,m-1,m)$ 可以得到一个答案下界为 $a_{m-1}+a_{m-2}$。

  - 如果最终答案为 $a_x\bmod a_y+a_y\bmod a_z+a_z$，由于 $a_x\bmod a_y+a_y\bmod a_z+a_z\leq\min\{a_x,2\cdot a_y-1\}$，则 $x\leq m-1$ 或 $y\leq m-2$ 一定没上面那个优，所以 $x=m$ 且 $y=m-1$。

  - 如果最终答案为 $a_x\bmod a_z+a_z+a_y$，由于 $a_x\bmod a_z+a_z+a_y\leq a_x+a_y$，当 $x\neq m$ 一定达不到最优解，又因为 $a_y$ 只出现了一次，所以 $y$ 一定尽量取到 $m-1$。

于是 $x$ 和 $y$ 就固定了，设 $F(x,l,r)$ 表示将 $[l,r]$ 中的 $x$ 和把剩下的最大值去掉后的所有 $k$，$a_x\bmod a_k+a_k$ 的最大值。

那么答案就是 $\max\{F(x,l,r)+a_y,F(y,l,r)+a_x\bmod a_y\}$，由于 $x,y$ 已经确定，所以我们只需要求出 $F(x,l,r)$ 的值即可。

---

考虑将 $F(x,l,r)$ 拆成 $F(x,l,x-1)$ 和 $F(x,x+1,r)$。对于 $F(x,l,x-1)$，让 $l$ 从 $x$ 枚举到 $1$ 可以得到一个 $O(n^2)$ 的做法。

又有个结论是如果扫到了某个 $l$，如果存在至少两个 $a_i&gt;\frac{a_x}{2}$ 就可以停止扫描。

- 证明

  不妨设这两个数是 $a_i,a_j$ 且 $a_i&lt;a_j$。

  - 如果 $a_i&gt;a_x$，与 $x$ 为区间最大值/次大值矛盾，这个区间一定不会被询问到。

  - 如果 $\frac{a_x}{2}&lt;a_i&lt;a_x$，则 $a_i\bmod a_x+a_x=a_i$，已经到了最大值，前面的一定不会更优。

基于这个做法暴力枚举 $l$ 可以做到 $O(n\log V+q\log n)$，过不了。

---

还有个结论是扫描到 $a_i$ 时，如果已经存在两个数 $\geq 2\cdot a_i$，则 $a_i$ 就可以删掉。

- 证明

  如果 $a_j\geq 2\cdot a_i$，则 $a_x\bmod a_j+a_j\geq a_j\geq 2\cdot a_i&gt;a_x\bmod a_i+a_i$，所以 $a_i$ 一定不会对答案造成贡献。

所以可以在从小到大枚举 $x$ 的过程中，维护一个栈表示目前还没删掉的数和这些数的删除标记。然后在扫描 $l$ 的过程中，维护另一个标记表示 $&gt;\frac{a_x}{2}$ 的个数。如果当前 $a_i\leq \frac{a_x}{2}$ 就将 $i$ 的删除标记加 $1$。否则将另一个标记加一，如果另一个标记到了 $2$ 就停止扫描，并把栈里面删除标记为 $2$ 的数删掉，并将 $x$ 加到栈里。

容易证明上面那个做法的预处理复杂度为 $O(n)$。

时间复杂度：$O(n+q\log n)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e6 + 5;

int n, q, tp;
int64_t a[kMaxN];
std::vector&lt;std::pair&lt;int, int64_t&gt;&gt; vecl[kMaxN], vecr[kMaxN];

int get(int x, int y) { return a[x] &gt; a[y] ? x : y; }

struct SGT {
  int N, mx[kMaxN * 4];

  void pushup(int x) {
    mx[x] = get(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);
  }

  void build(int n) {
    for (N = 1; N &lt;= n + 1; N &lt;&lt;= 1) {}
    for (int i = N; i &lt;= N + n; ++i) mx[i] = i - N;
    for (int i = N - 1; i; --i) pushup(i);
  }

  int query(int l, int r) {
    int ret = 0;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if (~l &amp; 1) ret = get(ret, mx[l ^ 1]);
      if (r &amp; 1) ret = get(ret, mx[r ^ 1]);
    }
    return ret;
  }
} sgt;

void getl() {
  static int stk[kMaxN] = {0}, cnt[kMaxN] = {0}, tmp[kMaxN];
  int top = 0;
  for (int i = 1; i &lt;= n; ++i) {
    int now = 0, mx = 0, cur = top + 1;
    int64_t res = LLONG_MIN;
    for (int j = top; j; --j) {
      if (!mx) {
        mx = stk[j];
      } else if (a[stk[j]] &lt; a[mx]) {
        res = std::max(res, a[i] % a[stk[j]] + a[stk[j]]);
      } else {
        res = std::max(res, a[i] % a[mx] + a[mx]);
        mx = stk[j];
      }
      vecl[i].emplace_back(stk[j], res);
      if (a[stk[j]] &gt; a[i] / 2) {
        if (++now == 2) break;
      } else {
        ++cnt[stk[j]];
      }
      cur = j;
    }
    int m = 0;
    for (int j = cur; j &lt;= top; ++j)
      if (cnt[stk[j]] &lt; 2)
        tmp[++m] = stk[j];
    top = cur - 1;
    for (int j = 1; j &lt;= m; ++j) stk[++top] = tmp[j];
    stk[++top] = i;
    std::reverse(vecl[i].begin(), vecl[i].end());
  }
}

void getr() {
  static int stk[kMaxN] = {0}, cnt[kMaxN] = {0}, tmp[kMaxN];
  int top = 0;
  for (int i = n; i; --i) {
    int now = 0, mx = 0, cur = top + 1;
    int64_t res = LLONG_MIN;
    for (int j = top; j; --j) {
      if (!mx) {
        mx = stk[j];
      } else if (a[stk[j]] &lt; a[mx]) {
        res = std::max(res, a[i] % a[stk[j]] + a[stk[j]]);
      } else {
        res = std::max(res, a[i] % a[mx] + a[mx]);
        mx = stk[j];
      }
      vecr[i].emplace_back(stk[j], res);
      if (a[stk[j]] &gt; a[i] / 2) {
        if (++now == 2) break;
      } else {
        ++cnt[stk[j]];
      }
      cur = j;
    }
    int m = 0;
    for (int j = cur; j &lt;= top; ++j)
      if (cnt[stk[j]] &lt; 2)
        tmp[++m] = stk[j];
    top = cur - 1;
    for (int j = 1; j &lt;= m; ++j) stk[++top] = tmp[j];
    stk[++top] = i;
    std::reverse(vecr[i].begin(), vecr[i].end());
  }
}

void prework() {
  sgt.build(n);
  getl(), getr();
}

int64_t F(int x, int l, int r, int mx) {
  int64_t ret = LLONG_MIN;
  int y = sgt.query(l, x - 1), z = sgt.query(x + 1, r);
  if (y &amp;&amp; y != mx) ret = std::max(ret, a[y] + a[x] % a[y]);
  if (z &amp;&amp; z != mx) ret = std::max(ret, a[z] + a[x] % a[z]);
  auto it1 = std::lower_bound(vecl[x].begin(), vecl[x].end(), std::pair&lt;int, int64_t&gt;{l, LLONG_MIN});
  auto it2 = std::lower_bound(vecr[x].begin(), vecr[x].end(), std::pair&lt;int, int64_t&gt;{r, LLONG_MAX}, std::greater&lt;&gt;());
  if (it1 != vecl[x].end()) ret = std::max(ret, it1-&gt;second);
  if (it2 != vecr[x].end()) ret = std::max(ret, it2-&gt;second);
  return ret;
}

int64_t query(int l, int r) {
  int x = sgt.query(l, r), y = get(sgt.query(l, x - 1), sgt.query(x + 1, r));
  return std::max(F(x, l, r, y) + a[y], F(y, l, r, x) + a[x] % a[y]);
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; tp;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  prework();
  int64_t lastans = 0;
  for (int i = 1; i &lt;= q; ++i) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    l = (l + lastans * tp - 1) % n + 1;
    r = (r + lastans * tp - 1) % n + 1;
    std::cout &lt;&lt; (lastans = query(l, r)) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18605704.html</id>
    <title type="text">P8998 [CEOI2022] Prize 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-13T11:35:00Z</published>
    <updated>2024-12-13T11:35:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18605704.html" />
    <content type="text">## Description

**这是一道交互题。**

Tomislav 在睡梦中想到了一个问题：给定两棵大小为 $N$ 的树，树上的节点按 $1\sim N$ 分别编号，树则分别编号为树 $1$，树 $2$，树有边权，但是边权被隐藏了起来。

Tomislav 需要向交互库提供一个大小为 $K$ 的编号的子集 $S$，在选择了这个集合后，小 C 可以问 $Q$ 个格式为 $(a,b)$ 的问题，定义 $d_t(x,y)$ 表示树 $t$ 上节点 $x$ 与节点 $y$ 的距离，$l_t$ 表示树 $t$ 上节点 $a$ 与节点 $b$ 的 LCA，交互库会依次回答 $d_1(l_1,a),d_1(l_1,b),d_2(l_2,a),d_2(l_2,b)$。

紧接着交互库会询问 $T$ 个格式为 $(p,q)$ 的问题，其中 $p,q\in S$，Tomislav 必须依次回答 $d_1(p,q)$ 和 $d_2(p,q)$。

可怜的 Tomislav 并不会做，请你帮帮他。

$1\le N\le 10^6$，$2\le K\le \min(N,10^5)$，$1\le T\le \min(K^2,10^5)$。

## Solution

考虑对于一棵树和给定的 $S$ 集合怎么做。

显然我们需要通过 $k-1$ 次询问得到 $S$ 的虚树上每条边的权值，这个可以转化为求出每个点到根的距离 $dis$。

于是可以用类似建虚树的过程，按照 dfs 序后询问 dfs 序相邻的数，询问出来后可以分别得到 $(dis_u,dis_{lca})$ 和 $(dis_v,dis_{lca})$ 的数量关系，由于虚树上最多 $2k-2$ 条边，所以这样做可以得到虚树上的点的 $dis$ 的关系。

如果有两棵树的话两棵树的 dfs 序排序后不一定相同，上面那个做法就不行了。

考虑对于第一棵树选择 dfs 序上的前缀，由于这些点在第一棵树上构成连通块，所以按照第二棵树的 dfs 序排序后仍能询问出第一棵树的关系。

时间复杂度：$O(N\log N+K+T)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e6 + 5;

int n, k, q, t, rt1, rt2;
int p1[kMaxN], p2[kMaxN], dfn1[kMaxN], dfn2[kMaxN], idx1[kMaxN], idx2[kMaxN];
int lg[kMaxN], st1[kMaxN][20], st2[kMaxN][20], id[kMaxN];
int dis1[kMaxN], dis2[kMaxN];
std::vector&lt;int&gt; G1[kMaxN], G2[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; T1[kMaxN], T2[kMaxN];

int get(int *dfn, int x, int y) { return dfn[x] &lt; dfn[y] ? x : y; }

void dfs1(int u, int fa) {
  static int cnt = 0;
  st1[dfn1[u] = ++cnt][0] = fa, idx1[cnt] = u;
  for (auto v : G1[u]) {
    if (v == fa) continue;
    dfs1(v, u);
  }
}

void dfs2(int u, int fa) {
  static int cnt = 0;
  st2[dfn2[u] = ++cnt][0] = fa, idx2[cnt] = u;
  for (auto v : G2[u]) {
    if (v == fa) continue;
    dfs2(v, u);
  }
}

int LCA1(int x, int y) {
  if (x == y) return x;
  if (dfn1[x] &gt; dfn1[y]) std::swap(x, y);
  int k = lg[dfn1[y] - dfn1[x]];
  return get(dfn1, st1[dfn1[x] + 1][k], st1[dfn1[y] - (1 &lt;&lt; k) + 1][k]);
}

int LCA2(int x, int y) {
  if (x == y) return x;
  if (dfn2[x] &gt; dfn2[y]) std::swap(x, y);
  int k = lg[dfn2[y] - dfn2[x]];
  return get(dfn2, st2[dfn2[x] + 1][k], st2[dfn2[y] - (1 &lt;&lt; k) + 1][k]);
}

void dfs3(int u) {
  static bool vis[kMaxN] = {0};
  vis[u] = 1;
  for (auto [v, w] : T1[u]) {
    if (vis[v]) continue;
    dis1[v] = dis1[u] + w;
    dfs3(v);
  }
}

void dfs4(int u) {
  static bool vis[kMaxN] = {0};
  vis[u] = 1;
  for (auto [v, w] : T2[u]) {
    if (vis[v]) continue;
    dis2[v] = dis2[u] + w;
    dfs4(v);
  }
}

void prework() {
  dfs1(rt1, 0), dfs2(rt2, 0);
  lg[0] = -1;
  for (int i = 1; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; 1] + 1;
  for (int i = 1; i &lt;= lg[n]; ++i) {
    for (int j = 1; j &lt;= n - (1 &lt;&lt; i) + 1; ++j) {
      st1[j][i] = get(dfn1, st1[j][i - 1], st1[j + (1 &lt;&lt; (i - 1))][i - 1]);
      st2[j][i] = get(dfn2, st2[j][i - 1], st2[j + (1 &lt;&lt; (i - 1))][i - 1]);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; q &gt;&gt; t;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; p1[i];
    if (~p1[i]) G1[p1[i]].emplace_back(i), G1[i].emplace_back(p1[i]);
    else rt1 = i;
  }
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; p2[i];
    if (~p2[i]) G2[p2[i]].emplace_back(i), G2[i].emplace_back(p2[i]);
    else rt2 = i;
  }
  prework();
  for (int i = 1; i &lt;= k; ++i) {
    id[i] = idx1[i];
    std::cout &lt;&lt; id[i] &lt;&lt; ' ';
  }
  std::cout &lt;&lt; std::endl;
  std::sort(id + 1, id + 1 + k, [&amp;] (int x, int y) { return dfn2[x] &lt; dfn2[y]; });
  for (int i = 1; i &lt; k; ++i)
    std::cout &lt;&lt; "? " &lt;&lt; id[i] &lt;&lt; ' ' &lt;&lt; id[i + 1] &lt;&lt; '\n';
  std::cout &lt;&lt; "!" &lt;&lt; std::endl;
  for (int i = 1; i &lt; k; ++i) {
    int x = id[i], y = id[i + 1], lca1 = LCA1(x, y), lca2 = LCA2(x, y);
    int d1, d2, d3, d4;
    std::cin &gt;&gt; d1 &gt;&gt; d2 &gt;&gt; d3 &gt;&gt; d4;
    T1[lca1].emplace_back(x, d1), T1[x].emplace_back(lca1, -d1);
    T1[lca1].emplace_back(y, d2), T1[y].emplace_back(lca1, -d2);
    T2[lca2].emplace_back(x, d3), T2[x].emplace_back(lca2, -d3);
    T2[lca2].emplace_back(y, d4), T2[y].emplace_back(lca2, -d4);
  }
  dfs3(id[1]), dfs4(id[1]);
  std::vector&lt;std::pair&lt;int, int&gt;&gt; res;
  for (int i = 1; i &lt;= t; ++i) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    int lca1 = LCA1(x, y), lca2 = LCA2(x, y);
    res.emplace_back(dis1[x] + dis1[y] - 2 * dis1[lca1], dis2[x] + dis2[y] - 2 * dis2[lca2]);
  }
  for (auto [x, y] : res) std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18605705.html</id>
    <title type="text">P10433 [JOISC 2024 Day2] 棋盘游戏 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-13T11:35:00Z</published>
    <updated>2024-12-13T11:35:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18605705.html" />
    <content type="text">## Description

有一个供 $K$ 个玩家玩的棋盘游戏。该游戏的棋盘由 $N$ 个编号从 1 到 $N$ 的单元格和 $M$ 条编号从 1 到 $M$ 的路径组成，其中路径 $j$（$1 ≤ j ≤ M$）双向连接着单元格 $U_j$ 和 $V_j$。

棋盘上有两种类型的单元格：重新激活单元格和停止单元格。

这些信息由长度为 $N$ 的字符串 $S$ 给出，$S$ 由 $0$ 和 $1$ 组成，其中 $S$ 的第 $i$ 个字符（$1 ≤ i ≤ N$）是 `0` 表示单元格 $i$ 是重新激活单元格，是 `1` 表示单元格 $i$ 是停止单元格。

这个棋盘游戏由编号从 $1$ 到 $K$ 的 $K$ 个玩家进行。每个玩家都有自己的棋子，游戏从每个玩家将其棋子放在特定的单元格上开始。一开始，玩家 $p$（$1 \leq p \leq K$）将其棋子放在单元格 $X_p$ 上。注意，多个玩家的棋子可以放在同一个单元格上。

游戏随着每个玩家轮流进行而进行，从玩家 1 开始，按数字顺序进行。在玩家 $p$ 完成其回合后，玩家 $p + 1$ 开始回合（如果 $p = K$，则玩家 1 开始回合）。每个玩家在其回合上执行以下操作：

1. 选择与其棋子所在的单元格通过一条路径相连的一个单元格，并将其棋子移动到所选择的单元格上。

2. 如果目标单元格是重新激活单元格，则重复步骤 1 并继续其回合。如果目标单元格是停止单元格，则结束其回合。

代表日本参加这个棋盘游戏的包括 JOI 君在内的由 $K$ 名成员组成的团队，正在研究协作策略，以快速征服这个游戏。他们目前正在研究以下问题：

为了将玩家 1 的棋子放置在单元格 $T$ 上，$K$ 名玩家需要的最小总移动次数是多少？即使在回合中途，如果玩家 1 的棋子被放置在单元格 $T$ 上，也认为满足条件。

给定关于游戏棋盘和每个玩家棋子的初始放置位置的信息，编写一个程序来计算每个 $T = 1, 2, \ldots, N$ 对应的问题的答案。

$N,M,K\leq 5\times 10^4$。

## Solution

显然 $2\sim k$ 人对答案的贡献只与进行的轮数 $x$ 有关。

设 $f(i,x)$ 表示第 $i$ 个人走 $x$ 轮的最小步数，$F(x)=\sum_{i=2}^{k}{f(i,x)}$。那么 $f(i,x)$ 只有两种可能的贡献：

3. $i$ 先走到一个最近的停止点然后一直跳出去再跳回来。

4. $i$ 走到一个最近的邻域有停止点的停止点然后每次反复横跳。

不妨设 $dis_{1,i}$ 表示 $i$ 走到最近的停止点的距离。第一种贡献很容易得到是 $dis_{1,i}+2(x-1)$。

对于第二种情况，设 $i$ 走到一个邻域有停止点的停止点轮数为 $c$，步数为 $d$。那么如果 $c\leq x$，可以得到贡献是 $d+x-c$。同时由于没多走一轮，步数至少增加一，所以 $d+x-c$ 对于 $c&gt;x$ 的情况也成立。

于是对第二种情况的 $d-c$ 跑 01bfs 即可求出所有 $f(i,x)$ 的值。

设 $G(x,u)$ 表示 $1$ 走恰好 $x$ 轮到 $u$ 的最小步数，则 $ans_u=\min_{x=1}^{n}{\left(F(x)+G(x,u)\right)}$。

---

由于 $f(i,x)$ 形如 $\min(d_1+x,d_2+2x)$，所以 $F(x)$ 一定是一个凸函数，且只有最多 $k$ 段。

那么对于 $k$ 比较小的情况可以找到函数的每段 $y=px+q$，将 $p$ 放到最短路的边权上跑 dijkstra 即可做到 $O(nk\log n)$。

又因为 $x$ 每增大 $1$，$F(x)$ 至少减 $k-1$，要想让答案更优，$G(x,u)$ 也要减少至少 $k-1$，而 $G(x,u)\leq n$，所以只会减少至多 $\frac{n}{k-1}$ 轮。

设 $dis_{3,i}$ 表示 $i$ 走到一个停止点的最小轮数，则能对 $i$ 的答案产生影响的轮数一定在 $\left[dis_{3,i},dis_{3,i}+\frac{n}{k-1}\right]$ 内，对这个进行分层图 bfs 即可做到 $O\left(\frac{n^2}{k}\right)$。

将阈值设为 $\sqrt{\frac{n}{\log n}}$ 时可以得到时间复杂度为 $O\left(n\sqrt{n\log n}\right)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 5e4 + 5, kLim = 100, kInf = 1e12;

int n, m, k;
int a[kMaxN], dis0[kMaxN], dis1[kMaxN], dis2[kMaxN], ans[kMaxN], f[kMaxN];
bool op[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

void bfs0() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) dis0[i] = kInf;
  dis0[a[1]] = 0, q.emplace(a[1]);
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    if (op[u] &amp;&amp; u != a[1]) continue;
    for (auto v : G[u]) {
      if (dis0[v] == kInf) {
        dis0[v] = dis0[u] + 1, q.emplace(v);
      }
    }
  }
}

void bfs1() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    dis1[i] = kInf;
    bool fl = 0;
    for (auto j : G[i]) fl |= op[j];
    if (fl) dis1[i] = 1, q.emplace(i);
  }
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (auto v : G[u]) {
      if (dis1[v] == kInf) {
        dis1[v] = dis1[u] + 1, q.emplace(v);
      }
    }
  }
}

void bfs2() {
  std::deque&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    dis2[i] = kInf;
    bool fl = 0;
    for (auto j : G[i]) fl |= op[j];
    if (op[i] &amp;&amp; fl) dis2[i] = 0, q.emplace_back(i);
  }
  for (; !q.empty();) {
    int u = q.front(); q.pop_front();
    for (auto v : G[u]) {
      int dv = dis2[u] + 1 - op[u];
      if (dv &lt; dis2[v]) {
        dis2[v] = dv;
        if (op[u]) q.emplace_front(v);
        else q.emplace_back(v);
      }
    }
  }
}

void getf() {
  static int g[kMaxN] = {0};
  for (int c = 2; c &lt;= k; ++c) {
    int x = a[c];
    int p = std::min(std::max&lt;int&gt;(dis2[x] - dis1[x] + 3, 1), n + 1);
    f[1] += dis1[x] - 2, f[p] -= dis1[x] - 2, f[p] += dis2[x];
    g[1] += 2, g[p] -= 2, g[p] += 1;
  }
  for (int i = 1; i &lt;= n; ++i) f[i] += f[i - 1], g[i] += g[i - 1];
  for (int i = 1; i &lt;= n; ++i) f[i] += i * g[i];
}

namespace Sub1 {
void getans(int k, int b) {
  static int dis[kMaxN];
  static bool vis[kMaxN] = {0}, vv[kMaxN] = {0};
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) dis[i] = kInf, vis[i] = vv[i] = 0;
  dis[a[1]] = 0, q.emplace(0, a[1]);
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto v : G[u]) {
      int w = 1 + k * (op[u] &amp;&amp; u != a[1]);
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w, q.emplace(-dis[v], v);
        vv[v] = (vv[u] | (w &gt; 1));
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i)
    if (vv[i]) ans[i] = std::min(ans[i], dis[i] + b);
}

void solve() {
  int nowk = -1;
  for (int i = 2; i &lt;= n; ++i) {
    int k = f[i] - f[i - 1];
    if (k != nowk) {
      getans(k, f[i] - i * k);
      nowk = k;
    }
  }
}
} // namespace Sub1

namespace Sub2 {
int lim, dis3[kMaxN], dis4[kMaxN][kMaxN / (kLim - 1) + 5];

void bfs3() {
  std::deque&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) dis3[i] = kInf;
  q.emplace_back(a[1]), dis3[a[1]] = 0;
  for (; !q.empty();) {
    int u = q.front(); q.pop_front();
    int w = (op[u] &amp;&amp; u != a[1]);
    for (auto v : G[u]) {
      if (dis3[v] &gt; dis3[u] + w) {
        dis3[v] = dis3[u] + w;
        if (!w) q.emplace_front(v);
        else q.emplace_back(v);
      }
    }
  }
}

void bfs4() {
  std::queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 0; j &lt;= lim; ++j)
      dis4[i][j] = kInf;
  dis4[a[1]][0] = 0, q.emplace(a[1], 0);
  for (; !q.empty();) {
    auto [u, t] = q.front(); q.pop();
    int w = (op[u] &amp;&amp; u != a[1]);
    for (auto v : G[u]) {
      int tv = t + dis3[u] + w - dis3[v];
      if (tv &lt;= lim &amp;&amp; dis4[v][tv] &gt; dis4[u][t] + 1) {
        dis4[v][tv] = dis4[u][t] + 1;
        q.emplace(v, tv);
      }
    }
  }
}

void solve() {
  lim = n / (k - 1);
  bfs3(), bfs4();
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 0; j &lt;= lim; ++j)
      ans[i] = std::min(ans[i], dis4[i][j] + f[dis3[i] + j]);
}
} // namespace Sub2

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= m; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(v), G[v].emplace_back(u);
  }
  std::string str;
  std::cin &gt;&gt; str;
  for (int i = 1; i &lt;= n; ++i) op[i] = str[i - 1] - '0';
  for (int i = 1; i &lt;= k; ++i) std::cin &gt;&gt; a[i];
  bfs0(), bfs1(), bfs2(), getf();
  for (int i = 1; i &lt;= n; ++i) ans[i] = dis0[i];
  if (!std::count(op + 1, op + 1 + n, 1)) {
    for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
    return;
  }
  if (k &lt;= kLim) Sub1::solve();
  else Sub2::solve();
  ans[a[1]] = 0;
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18611260.html</id>
    <title type="text">P5773 [JSOI2016] 轻重路径 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-16T14:39:00Z</published>
    <updated>2024-12-16T14:39:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18611260.html" />
    <content type="text">## Description

在二叉树上，不断删除叶子，你要维护其重链剖分后重儿子编号和。如果两个孩子大小相同，在一开始连向左儿子，后面保持修改前的连接。

$n\leq 2\times 10^5$。

## Solution

考虑把一个叶子 $x$ 删掉会对改变哪些点的重儿子。

首先改变的点 $y$ 一定在 $x$ 到根的链上，同时要求 $sz_y\leq\frac{sz_{fa_y}}{2}$。

那么不妨设当前从上到下修改到 $rt$，则 $sz_y\leq\frac{sz_{fa_y}}{2}\leq\frac{sz_{rt}}{2}$，可以通过倍增找到链上最上面的满足 $sz_y\leq\frac{sz_{rt}}{2}$ 的 $y$，暴力判断 $y$ 能否被修改然后将 $rt$ 设为 $y$ 继续找即可。

由于有 $O(n\log^2n)$ 次查询子树大小的操作，直接树状数组为 $O(n\log^3n)$，用分块 $O(1)$ 求区间和即可做到 $O(n\log^2n+n\sqrt n)$。

时间复杂度：$O(n\log^3n)/O(n\log^2n+n\sqrt n)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, m, lg;
int64_t sum;
int a[kMaxN], p[kMaxN][19], dfn[kMaxN], sz[kMaxN], wson[kMaxN];
int L[kMaxN], R[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

struct BIT {
  int c[kMaxN];

  void upd(int x, int v) {
    for (; x &lt;= n; x += x &amp; -x) c[x] += v;
  }
  int qry(int x) {
    int ret = 0;
    for (; x; x -= x &amp; -x) ret += c[x];
    return ret;
  }
  int qry(int l, int r) { return l &lt;= r ? qry(r) - qry(l - 1) : 0; }
} bit;

int getsz(int x) {
  if (!x) return 0;
  else return bit.qry(dfn[x], dfn[x] + sz[x] - 1);
}

void dfs(int u, int fa) {
  static int cnt = 0;
  dfn[u] = ++cnt, sz[u] = 1, p[u][0] = fa;
  for (int i = 1; i &lt;= lg; ++i) p[u][i] = p[p[u][i - 1]][i - 1];
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
  sum += wson[u];
}

void update(int x) {
  bit.upd(dfn[x], -1);
  int rt = 1;
  for (; rt != x;) {
    int y = x, now = getsz(rt);
    for (int i = lg; ~i; --i)
      if (p[y][i] &amp;&amp; getsz(p[y][i]) &lt;= getsz(rt) / 2)
        y = p[y][i];
    int fa = p[y][0];
    if (y == wson[fa]) {
      int z = L[fa] + R[fa] - y;
      if (getsz(z) &gt; getsz(y)) sum -= y, wson[fa] = z, sum += z;
    }
    rt = y;
  }
  if (x == wson[p[x][0]]) sum -= x;
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  lg = std::__lg(n);
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; L[i] &gt;&gt; R[i];
    if (L[i]) G[i].emplace_back(L[i]);
    if (R[i]) G[i].emplace_back(R[i]);
  }
  dfs(1, 0);
  std::cin &gt;&gt; m;
  for (int i = 1; i &lt;= n; ++i) bit.upd(i, 1);
  std::cout &lt;&lt; sum &lt;&lt; '\n';
  for (int i = 1; i &lt;= m; ++i) {
    int x;
    std::cin &gt;&gt; x;
    update(x);
    std::cout &lt;&lt; sum &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18611261.html</id>
    <title type="text">扫描线学习记录-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-16T14:39:00Z</published>
    <updated>2024-12-16T14:39:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18611261.html" />
    <content type="text">[题单](https://www.luogu.com.cn/training/665215)

## P7560 [JOISC 2021 Day1] フードコート

容易发现操作分两种：

1. $c_i\leftarrow c_i+k$

2. $c_i\leftarrow\max(c_i-k,0)$

考虑对人进行扫描线并且维护一个关于时间的线段树，表示每个时刻做了什么操作。查询时找到最小的前缀和位置，容易发现这个位置一定被 chkmax 成 $0$ 了，同时后面的一定都没有 chkmax 成功，于是剩余的人的个数就求出来了。

时间复杂度：$O((N+M+Q)\log N)$。

```C++
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 2.5e5 + 5;

int n, m, q;
int op[kMaxN], L[kMaxN], R[kMaxN], C[kMaxN], K[kMaxN], ans[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; vec[kMaxN];

struct SGT {
  int cnt[kMaxN * 4], sum[kMaxN * 4], mi[kMaxN * 4], pos[kMaxN * 4];

  void pushup(int x) {
    cnt[x] = cnt[x &lt;&lt; 1] + cnt[x &lt;&lt; 1 | 1];
    sum[x] = sum[x &lt;&lt; 1] + sum[x &lt;&lt; 1 | 1];
    if (mi[x &lt;&lt; 1] &lt; sum[x &lt;&lt; 1] + mi[x &lt;&lt; 1 | 1]) {
      mi[x] = mi[x &lt;&lt; 1], pos[x] = pos[x &lt;&lt; 1];
    } else {
      mi[x] = sum[x &lt;&lt; 1] + mi[x &lt;&lt; 1 | 1], pos[x] = pos[x &lt;&lt; 1 | 1];
    }
  }

  void build(int x, int l, int r) {
    pos[x] = l;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  }

  void update(int x, int l, int r, int ql, int v) {
    if (l == r) {
      if (v == 1) {
        if (op[l] == 1) cnt[x] = sum[x] = mi[x] = K[l];
        else cnt[x] = 0, sum[x] = mi[x] = -K[l];
      } else {
        cnt[x] = sum[x] = mi[x] = 0;
      }
      return;
    }
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update(x &lt;&lt; 1, l, mid, ql, v);
    else update(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }

  std::tuple&lt;int, int, int&gt; querymin(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return {0, 0, 0};
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return {sum[x], mi[x], pos[x]};
    int mid = (l + r) &gt;&gt; 1;
    if (qr &lt;= mid) return querymin(x &lt;&lt; 1, l, mid, ql, qr);
    if (mid &lt; ql) return querymin(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
    auto [suml, mil, posl] = querymin(x &lt;&lt; 1, l, mid, ql, qr);
    auto [sumr, mir, posr] = querymin(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
    if (mil &lt;= suml + mir) return {suml + sumr, mil, posl};
    else return {suml + sumr, suml + mir, posr};
  }

  int querysum(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return sum[x];
    int mid = (l + r) &gt;&gt; 1;
    return querysum(x &lt;&lt; 1, l, mid, ql, qr) + querysum(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }

  int querycnt(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return 0;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return cnt[x];
    int mid = (l + r) &gt;&gt; 1;
    return querycnt(x &lt;&lt; 1, l, mid, ql, qr) + querycnt(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }

  int querykth(int x, int l, int r, int k) {
    assert(k &lt;= cnt[x]);
    if (l == r) return C[l];
    int mid = (l + r) &gt;&gt; 1;
    if (k &lt;= cnt[x &lt;&lt; 1]) return querykth(x &lt;&lt; 1, l, mid, k);
    else return querykth(x &lt;&lt; 1 | 1, mid + 1, r, k - cnt[x &lt;&lt; 1]);
  }
} sgt;

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    std::cin &gt;&gt; op[i];
    if (op[i] == 1) {
      std::cin &gt;&gt; L[i] &gt;&gt; R[i] &gt;&gt; C[i] &gt;&gt; K[i];
      vec[L[i]].emplace_back(i, 1), vec[R[i] + 1].emplace_back(i, -1);
    } else if (op[i] == 2) {
      std::cin &gt;&gt; L[i] &gt;&gt; R[i] &gt;&gt; K[i];
      vec[L[i]].emplace_back(i, 1), vec[R[i] + 1].emplace_back(i, -1);
    } else  {
      std::cin &gt;&gt; C[i] &gt;&gt; K[i];
      vec[C[i]].emplace_back(i, K[i]);
    }
  }
  sgt.build(1, 0, q);
  for (int i = 1; i &lt;= n; ++i) {
    for (auto [id, v] : vec[i]) {
      if (op[id] == 1 || op[id] == 2)
        sgt.update(1, 0, q, id, v);
    }
    for (auto [id, v] : vec[i]) {
      if (op[id] != 3) continue;
      int pos = std::get&lt;2&gt;(sgt.querymin(1, 0, q, 0, id));
      int cnt = sgt.querysum(1, 0, q, pos + 1, id), tot = sgt.querycnt(1, 0, q, 0, id);
      if (cnt &gt;= K[id])
        ans[id] = sgt.querykth(1, 0, q, tot - cnt + K[id]);
    }
  }
  for (int i = 1; i &lt;= q; ++i)
    if (op[i] == 3)
      std::cout &lt;&lt; ans[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```


## P9057 [Ynoi2004] rpfrdtzls

容易发现如果去掉 $1$ 的话答案不超过 $\log A$，所以同样建一个有关时间的线段树，修改时在某个位置加入一个数只会改变 $O(\log A)$ 个区间的答案，暴力求出答案并且用区间历史和线段树维护即可。

时间复杂度：$O((n+m)\log^2 A)$

## CF793F Julia the snail

容易发现 $(x,y)$ 的答案是把所有在 $[x,y]$ 内的线段拿出来后第一个没被覆盖的数的位置。

考虑扫描线，设 $f_i$ 表示 $i$ 到当前 $r$ 的答案，现在加入一个线段 $[l,r+1]$，如果 $f_i&lt;l$ 就没影响，否则 $f_i\leftarrow r+1$。

所以相当于是维护一个类似区间 chkmax 的东西，用吉司机线段树维护即可。

时间复杂度：$O((n+m+q)\log n)$。

## P7907 [Ynoi2005] rmscne

设 $pre_i$ 表示 $a$ 数组中上一个与 $a_i$ 相等的位置。

容易发现 $[l,r]$ 中满足条件的线段中左端点为 $l$ 的最小右端点一定是 $[l,r]$ 中 $pre_j&lt;l$ 的最大的 $j$。

不妨设 $[l,r]$ 中以 $r$ 为右端点的线段的最大左端点为 $p$，那么 $[l,p]$ 中的任意位置 $i$ 作为左端点的答案一定是 $i$ 在 $[i,r]$ 中的答案，因为 $[i,r]$ 包含的颜色种类一定和 $[l,r]$ 相同。

先预处理每个 $[l,r]$ 的 $p$，然后就可以进行扫描线了，在从小到大扫 $r$ 的过程中让 $[pre_r+1,r]$ 的右端点设成 $r$，查询相当于是求区间最小值，线段树维护即可。

时间复杂度：$O((n+q)\log n)$。

## P9999 [Ynoi2000] tmostnrq

同样是扫描线，对于每组询问 $(l,r,x)$ 就在 $l$ 时刻将 $x$ 插入，在 $r$ 时刻查询这个点位置。

每次操作就是让当前树上挂的每个点向当前 $a_i$ 移动一步，考虑怎么处理这个移动。

不妨设 $x=a_i$，那么 $x$ 到根的链上的点一定是往儿子移动一步，而其它点是向父亲移动。

对于 $x$ 到根的链上的点可以重链剖分，对于链底的点就暴力挪到下面的链上，其余点打个标记。

对于不在 $x$ 到根的链上的点，容易发现这些点只会构成 $O(\log n)$ 个 dfs 序区间，可以维护 $f_i$ 表示 $i$ 到 $i$ 所在重链链顶的距离。

由于每个点跳到根只会经过 $O(\log n)$ 条不同重链，所以先暴力找到所有 $f_i=0$ 的点直接跳，其它点打标记即可。

时间复杂度：$O((n+q)\log^2 n)$。

## CF1172F Nauuo and Bug

容易发现对于固定区间所对应的函数值是个折线函数，且只有区间长度段。

考虑在线段树上做这个东西，不妨设 $c_i$ 表示当前线段树区间要至少减 $i$ 次 $p$ 的最小初始值。

合并两个区间的 $c$ 数组时，假设左区间为 $c_x$，右区间为 $c_y$，显然需要满足 $c_{x+1}-1+sum_{ls}-xp\geq c_y$，满足这个条件就可以得到转移：$c_{x+y}\leftarrow\max(c_x,c_y-sum_{ls}+xp)$。

设 $f(x,y)$ 是 $c_x,c_y$ 合并出来的值，下面证明一下 $f(x,y)\leq f(x+1,y-1)$。

- 证明

  由于 $c_{x+1}-1+sum_{ls}-xp\geq c_y$，所以 $c_y-sum_{ls}+xp&lt;c_{x+1}$。

  又因为 $c_x\leq c_{x+1}$，所以 $f(x,y)=\max(c_x,c_y-sum_{ls}+xp)\leq c_{x+1}\leq f(x+1,y-1)$。

那么对于某个结果 $c_x$，一定是选择左端点的次数最小的方案合并。由于有个结论是 $c_{x+1}-c_x\geq p$，所以左端点较大的一定能匹配较小的能匹配的所有方案。

于是在拓展的过程中能拓展 $y$ 就拓展 $y$，否则拓展才 $x$。

查询时二分出每个线段树区间对应减的次数并更新当前值即可。

时间复杂度：$O(n\log n+q\log^2 n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18619279.html</id>
    <title type="text">CF1017G The Tree 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-20T06:48:00Z</published>
    <updated>2024-12-20T06:48:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18619279.html" />
    <content type="text">## Description

给定一棵树，维护以下 $3$ 个操作：

1. `1 x` 表示如果节点 $x$ 为白色，则将其染黑。否则对这个节点的所有儿子递归进行相同操作。

2. `2 x` 表示将以节点 $x$ 为根的子树染白。

3. `3 x` 表示查询节点 $x$ 的颜色。

$n,q\leq 10^5$。

## Solution

首先考虑没有操作二怎么做。

容易发现在点 $x$ 进行的操作能够影响到 $y$，当且仅当 $y$ 在 $x$ 的子树里且 $x\to y$ 的路径上进行一操作的总次数不小于路径长度。

那么先将每个点的权值设为 $-1$，进行一次一操作就将操作点点权加 $1$，则一个点 $x$ 为黑色的条件即为根到 $x$ 的最大后缀和大于等于 $0$，树剖+线段树维护即可。

加上操作二后，相当于是每次需要将 $x$ 子树内的点权重置为 $-1$，并且还要去除根到 $x$ 这条路径上对 $x$ 子树的影响，前面重置为 $-1$ 可以用线段树进行区间覆盖，而去除祖先影响则可以直接求出根到 $x$ 的最大后缀和 $s$，然后将 $x$ 的点权加上 $-1-s$，这样祖先对 $x$ 的贡献就只有 $-1$ 了。

时间复杂度：$O(n+q\log^2n)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e5 + 5;

struct Info {
  int sum, res;
  Info(int _sum = 0, int _res = 0) : sum(_sum), res(_res) {}
  friend Info operator +(Info a, Info b) {
    return {a.sum + b.sum, std::max(a.res + b.sum, b.res)};
  }
};

int n, q;
int p[kMaxN], sz[kMaxN], wson[kMaxN], dfn[kMaxN], top[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

struct SGT {
  Info t[kMaxN * 4];
  bool tag[kMaxN * 4];

  void pushup(int x) {
    t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1];
  }
  void addtag(int x, int l, int r) {
    tag[x] = 1, t[x] = {-(r - l + 1), -1};
  }
  void pushdown(int x, int l, int r) {
    if (tag[x]) {
      int mid = (l + r) &gt;&gt; 1;
      addtag(x &lt;&lt; 1, l, mid), addtag(x &lt;&lt; 1 | 1, mid + 1, r);
      tag[x] = 0;
    }
  }
  void build(int x, int l, int r) {
    if (l == r) return void(t[x] = {-1, -1});
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
  }
  void update1(int x, int l, int r, int ql, int v) {
    if (l == r) {
      t[x].sum += v, t[x].res += v;
      return;
    }
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid) update1(x &lt;&lt; 1, l, mid, ql, v);
    else update1(x &lt;&lt; 1 | 1, mid + 1, r, ql, v);
    pushup(x);
  }
  void update2(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return;
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return addtag(x, l, r);
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    update2(x &lt;&lt; 1, l, mid, ql, qr), update2(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
    pushup(x);
  }
  Info query(int x, int l, int r, int ql, int qr) {
    if (l &gt; qr || r &lt; ql) return {0, -(int)1e9};
    else if (l &gt;= ql &amp;&amp; r &lt;= qr) return t[x];
    pushdown(x, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return query(x &lt;&lt; 1, l, mid, ql, qr) + query(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
  }
} sgt;

void dfs1(int u, int fa) {
  sz[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}
void dfs2(int u, int fa, int t) {
  static int cnt = 0;
  dfn[u] = ++cnt, top[u] = t;
  if (wson[u]) dfs2(wson[u], u, t);
  for (auto v : G[u]) {
    if (v == fa || v == wson[u]) continue;
    dfs2(v, u, v);
  }
}

int query(int x) {
  if (!x) return 0;
  Info ret = {0, -(int)1e9};
  for (; x; x = p[top[x]]) ret = sgt.query(1, 1, n, dfn[top[x]], dfn[x]) + ret;
  return ret.res;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 2; i &lt;= n; ++i) {
    std::cin &gt;&gt; p[i];
    G[i].emplace_back(p[i]), G[p[i]].emplace_back(i);
  }
  dfs1(1, 0), dfs2(1, 0, 1), sgt.build(1, 1, n);
  for (int i = 1; i &lt;= q; ++i) {
    int op, x;
    std::cin &gt;&gt; op &gt;&gt; x;
    if (op == 1) {
      sgt.update1(1, 1, n, dfn[x], 1);
    } else if (op == 2) {
      sgt.update2(1, 1, n, dfn[x], dfn[x] + sz[x] - 1);
      sgt.update1(1, 1, n, dfn[x], -1 - query(x));
    } else {
      std::cout &lt;&lt; (query(x) &gt;= 0 ? "black\n" : "white\n");
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18620033.html</id>
    <title type="text">CF1477D Nezzar and Hidden Permutations 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-20T13:59:00Z</published>
    <updated>2024-12-20T13:59:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18620033.html" />
    <content type="text">## Description

给定一张 $n$ 个点 $m$ 条边的简单无向图，构造两个排列 $p,q$，使得：

- 对任意 $(u,v)\in E$，$(p_u-p_v)(q_u-q_v)&gt;0$.
- 在此基础上，最大化 $\left|\left\{i\ |\ p_i\neq q_i\right\}\right|$.

$1\leq n,m\leq 5\times 10^5$。

## Solution

首先显然如果存在一个点 $x$ 的度数等于 $n-1$，则将边定向后这个点的拓扑序一定唯一，所以这个位置一定会相同，可以把 $p_x,q_x$ 赋值为 $n$，然后将这个点删掉。

那么剩下的点一定满足度数 $\leq n-2$，可以猜测剩下的点一定没有位置相同。

考虑把现在的图的补图建出来，则一定构成若干个大小不小于 $2$ 的连通块。

如果补图是**恰好**一个菊花图，设菊花心为 $x$，其它点为 $a_1,a_2,\ldots,a_{n-1}$，让 $p_x=1,p_{a_i}=i+1,q_x=n,q_{a_i}=i$ 可以满足条件且没有位置相同。

这启发我们对于一般情况去把补图划分成若干个大小不小于 $2$ 的菊花图。

下面给出构造：

1. 从前往后扫 $i$，如果 $i$ 已经被划分进菊花图了，就不管。
2.  否则遍历 $i$ 的邻域，如果存在点 $j$ 使得 $j$ 没被划分进菊花图，就让 $i$ 和 $i$ 邻域所有没被划分的点放到一个菊花图里。
3. 如果找不到这样的 $j$，就随便取 $i$ 邻域的一个点 $k$，如果 $k$ 所在菊花大小等于 $2$，则将 $k$ 所在菊花的菊花心设为 $k$，并对 $k$ 做 $2$ 过程。
4. 如果菊花大小大于 $2$，就把 $k$ 从原来的菊花里踢出，然后和 $i$ 组成菊花。根据上面的构造方式，一定能保证 $k$ 不是原来所在菊花的心，所以构造方式仍然合法。

注意补图可能边数很多，这里只需要找到补图的一个生成树，找生成树时就维护一个 set 表示目前没被遍历的点，每次拓展时就暴力遍历 set，找到不与当前点在原图上有边的点，并在补图上连边即可。

时间复杂度：$O((n+m)\log n)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 5e5 + 5;

int n, m, cnt;
int u[kMaxN], v[kMaxN], p[kMaxN], q[kMaxN], deg[kMaxN], bel[kMaxN];
bool del[kMaxN];
std::vector&lt;int&gt; G[kMaxN], T[kMaxN];
std::set&lt;int&gt; chry[kMaxN];

void init() {
  cnt = 0;
  for (int i = 1; i &lt;= n; ++i)
    G[i].clear(), T[i].clear(), chry[i].clear(), p[i] = q[i] = deg[i] = bel[i] = del[i] = 0;
}

void solve1() { // 求出度数为 n - 1 的点
  std::set&lt;std::pair&lt;int, int&gt;&gt; st;
  for (int i = 1; i &lt;= n; ++i) st.emplace(deg[i] = G[i].size(), i);
  int now = n;
  for (int i = 1; i &lt;= n; ++i) {
    if (prev(st.end())-&gt;first != now - 1) break;
    int u = prev(st.end())-&gt;second;
    st.erase(prev(st.end()));
    p[u] = q[u] = ++cnt, --now, del[u] = 1;
    for (auto v : G[u]) {
      if (!del[v]) {
        st.erase({deg[v], v});
        --deg[v];
        st.emplace(deg[v], v);
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i) G[i].clear();
  for (int i = 1; i &lt;= m; ++i)
    if (!del[u[i]] &amp;&amp; !del[v[i]])
      G[u[i]].emplace_back(v[i]), G[v[i]].emplace_back(u[i]);
}

void solve2() { // 求出补图生成森林
  std::set&lt;int&gt; st;
  for (int i = 1; i &lt;= n; ++i) {
    if (!del[i]) st.emplace(i);
    std::sort(G[i].begin(), G[i].end());
  }
  std::function&lt;void(int)&gt; dfs = [&amp;] (int u) {
    std::vector&lt;int&gt; vec;
    for (auto v : st)
      if (std::find(G[u].begin(), G[u].end(), v) == G[u].end())
        vec.emplace_back(v), T[u].emplace_back(v), T[v].emplace_back(u);
    for (auto v : vec) st.erase(v);
    for (auto v : vec) dfs(v);
  };
  for (int i = 1; i &lt;= n; ++i) {
    if (!del[i] &amp;&amp; st.count(i)) {
      st.erase(i);
      dfs(i);
    }
  }
}

void solve3() { // 求出菊花划分
  for (int i = 1; i &lt;= n; ++i) {
    if (!del[i] &amp;&amp; !bel[i]) {
      bool fl = 0;
      for (auto j : T[i]) fl |= !bel[j];
      if (fl) {
        chry[i].emplace(i), bel[i] = i;
        for (auto j : T[i]) {
          if (!bel[j]) chry[i].emplace(j), bel[j] = i;
        }
      } else {
        int j = T[i][0];
        if (chry[bel[j]].size() == 2) {
          chry[j].swap(chry[bel[j]]);
          bel[bel[j]] = j;
          for (auto x : T[j]) {
            if (!bel[x]) chry[j].emplace(x), bel[x] = j;
          }
        } else {
          chry[bel[j]].erase(j);
          bel[i] = bel[j] = i;
          chry[i].emplace(i), chry[i].emplace(j);
        }
      }
    }
  }
  int sum = cnt;
  for (int i = 1; i &lt;= n; ++i) sum += chry[i].size();
  for (int i = 1; i &lt;= n; ++i) {
    if (chry[i].size()) {
      p[i] = cnt + 1;
      int now = 1;
      for (auto x : chry[i]) {
        if (x != i) p[x] = cnt + (++now);
      }
      q[i] = cnt + now;
      now = 0;
      for (auto x : chry[i]) {
        if (x != i) q[x] = cnt + (++now);
      }
      cnt += chry[i].size();
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  init();
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i];
    G[u[i]].emplace_back(v[i]), G[v[i]].emplace_back(u[i]);
  }
  solve1(), solve2(), solve3();
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; p[i] &lt;&lt; " \n"[i == n];
  for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; q[i] &lt;&lt; " \n"[i == n];
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18629816.html</id>
    <title type="text">P6779 [Ynoi2009] rla1rmdq 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-25T02:34:00Z</published>
    <updated>2024-12-25T02:34:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18629816.html" />
    <content type="text">## Description

给定一棵 $n$ 个节点的树，树有边权，与一个长为 $n$ 的序列 $a$。

定义节点 $x$ 的父亲为 $fa(x)$，根 $rt$ 满足 $fa(rt)=rt$。

定义节点 $x$ 的深度 $dep(x)$ 为其到根简单路径上所有边权和。

有 $m$ 次操作：

- `1 l r`：对于 $l \le i \le r$，$a_i\leftarrow fa(a_i)$。

- `2 l r`：查询对于 $l \le i \le r$，最小的 $dep(a_i)$。

$1\le n,m\le 2\times 10^5$，$1\le a_i\le n$。

## Solution

显然是分块。

对于散块暴力重构，整块打标记一起跳，考虑这两部分分别怎么做。

暴力重构可以看成只有单点操作，且能跳多步，则可以对树做重链剖分，每次跳的时候如果跳不出所在重链就用 dfs 序 $O(1)$ 求出祖先，否则就暴力跳出重链，容易发现总复杂度为 $O(n\log n)$。

整块打标记可以看成每次操作都是全局操作一起跳。容易发现如果一个点 $x$ 跳到别的点跳过的点上，则点 $x$ 就一定没用了，所以可以删掉，这里将没删的点看成关键点。每次修改时暴力跳关键点做上面的操作，每次要么删一个点要么多打一个标记，所以这部分是 $O(n)$。

回到原题，修改时整块的部分就按照全局操作的做法每次暴力跳所有没删的点。散块的话由于只有一部分跳，这一部分如果原来被删了，这次可能就能加回去，所以只要用单点跳多步的做法跳，如果跳完所在位置仍未被标记就加回所在块的关键点。

容易发现每个块的时间复杂度为 $O(n)$，所以总时间复杂度为 $O(n\sqrt n)$。

## Code

```C++
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 2e5 + 5, kMaxB = 450;

int n, m, b, tot, rt;
int a[kMaxN], p[kMaxN], sz[kMaxN], wson[kMaxN], top[kMaxN], dfn[kMaxN], idx[kMaxN];
int L[kMaxB], R[kMaxB], bel[kMaxN], cnt[kMaxN], id[kMaxB][kMaxB], tag[kMaxB];
i64 dis[kMaxN], res[kMaxB];
std::bitset&lt;kMaxN&gt; vis[kMaxB], in;
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN];

void dfs1(int u, int fa) {
  p[u] = (!fa ? u : fa);
  sz[u] = 1;
  for (auto [v, w] : G[u]) {
    if (v == fa) continue;
    dis[v] = dis[u] + w;
    dfs1(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, int fa, int t) {
  static int cnt = 0;
  idx[dfn[u] = ++cnt] = u, top[u] = t;
  if (wson[u]) dfs2(wson[u], u, t);
  for (auto [v, w] : G[u]) {
    if (v == fa || v == wson[u]) continue;
    dfs2(v, u, v);
  }
}

int getfa(int x, int k) {
  // std::cerr &lt;&lt; x &lt;&lt; ' ' &lt;&lt; k &lt;&lt; '\n';
  if (!x || x == rt) return rt;
  else if (!k) return x;
  else if (dfn[x] - k &gt;= dfn[top[x]]) return idx[dfn[x] - k];
  else return getfa(p[top[x]], k - (dfn[x] - dfn[top[x]] + 1));
  // for (int i = 1; i &lt;= k; ++i) x = p[x];
  // return x;
}

void prework() {
  dis[rt] = 1;
  dfs1(rt, 0), dfs2(rt, 0, rt);
  b = sqrtl(n);
  if (!b) b = 1;
  tot = (n + b - 1) / b;
  for (int i = 1; i &lt;= tot; ++i) {
    L[i] = (i - 1) * b + 1, R[i] = std::min(i * b, n);
    res[i] = LLONG_MAX;
    for (int j = L[i]; j &lt;= R[i]; ++j) {
      bel[j] = i, vis[i][a[j]] = 1;
      res[i] = std::min(res[i], dis[a[j]]);
      id[i][++id[i][0]] = j, in[j] = 1;
    }
  }
}

void addtag(int x) {
  ++tag[x];
  static int tmp[kMaxN];
  int c = 0;
  for (int k = 1; k &lt;= id[x][0]; ++k) {
    int i = id[x][k];
    in[i] = 0;
    --cnt[i];
    if (a[i] == rt || !vis[x][a[i] = p[a[i]]]) {
      vis[x][a[i]] = 1;
      tmp[++c] = i, in[i] = 1, res[x] = std::min(res[x], dis[a[i]]);
    }
  }
  id[x][0] = c;
  for (int i = 1; i &lt;= c; ++i) id[x][i] = tmp[i];
  // for (int i = L[x]; i &lt;= R[x]; ++i) res[x] = std::min(res[x], dis[a[i] = p[a[i]]]);
}

void rebuild(int x) {
  for (int i = L[x]; i &lt;= R[x]; ++i) {
    assert(tag[x] + cnt[i] &gt;= 0);
    if (tag[x] + cnt[i]) {
      a[i] = getfa(a[i], tag[x] + cnt[i]);
      res[x] = std::min(res[x], dis[a[i]]);
      vis[x][a[i]] = 1;
    }
    cnt[i] = 0;
  }
  tag[x] = 0;
}

void update(int l, int r) {
  int x = bel[l], y = bel[r];
  if (x == y) {
    for (int i = l; i &lt;= r; ++i) {
      a[i] = getfa(a[i], tag[x] + cnt[i] + 1);
      res[x] = std::min(res[x], dis[a[i]]);
      cnt[i] = -tag[x];
      if (!vis[x][a[i]]) {
        vis[x][a[i]] = 1;
        if (!in[i]) id[x][++id[x][0]] = i, in[i] = 1;
      }
    }
  } else {
    // for (int i = l; i &lt;= R[x]; ++i) ++cnt[i];
    for (int i = l; i &lt;= R[x]; ++i) {
      a[i] = getfa(a[i], tag[x] + cnt[i] + 1);
      res[x] = std::min(res[x], dis[a[i]]);
      cnt[i] = -tag[x];
      if (!vis[x][a[i]]) {
        vis[x][a[i]] = 1;
        if (!in[i]) id[x][++id[x][0]] = i, in[i] = 1;
      }
    }
    // for (int i = L[y]; i &lt;= r; ++i) ++cnt[i];
    for (int i = L[y]; i &lt;= r; ++i) {
      a[i] = getfa(a[i], tag[y] + cnt[i] + 1);
      res[y] = std::min(res[y], dis[a[i]]);
      cnt[i] = -tag[y];
      if (!vis[y][a[i]]) {
        vis[y][a[i]] = 1;
        if (!in[i]) id[y][++id[y][0]] = i, in[i] = 1;
      }
    }
    // rebuild(x), rebuild(y);
    for (int i = x + 1; i &lt; y; ++i) addtag(i);
  }
}

i64 query(int l, int r) {
  int x = bel[l], y = bel[r];
  i64 ret = LLONG_MAX;
  if (x == y) {
    rebuild(x);
    for (int i = l; i &lt;= r; ++i) ret = std::min(ret, dis[a[i]]);
    return ret;
  } else {
    rebuild(x), rebuild(y);
    for (int i = l; i &lt;= R[x]; ++i) ret = std::min(ret, dis[a[i]]);
    for (int i = L[y]; i &lt;= r; ++i) ret = std::min(ret, dis[a[i]]);
    for (int i = x + 1; i &lt; y; ++i) ret = std::min(ret, res[i]);
    return ret;
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;
  for (int i = 1; i &lt; n; ++i) {
    int u, v, w;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
    G[u].emplace_back(v, w), G[v].emplace_back(u, w);
  }
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  prework();
  for (int i = 1; i &lt;= m; ++i) {
    int op, l, r;
    std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
    if (op == 1) {
      update(l, r);
    } else {
      std::cout &lt;&lt; query(l, r) - 1 &lt;&lt; '\n';
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18642170.html</id>
    <title type="text">2025 上海集训游记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2024-12-30T11:01:00Z</published>
    <updated>2024-12-30T11:01:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18642170.html" />
    <content type="text"># 20241230

## T1

### Description

$T$ 组询问，每组询问给定一个正整数 $n$，定义一个满足 $\sum a_i\leq n,a_i&gt;0$ 的正整数序列 $a$ 的权值是 $\sum a_i!$，求所有序列 $a$ 的权值的 $\operatorname{mex}$ 对 $998244353$ 取模的结果，$a$ 的长度可以为 $0$，此时权值为 $0$。

**注：本题中自然数包含 $0$，$\operatorname{mex}$ 同样考虑 $0$。**

$1\leq T \leq 10^5,1\leq n\leq 10^{15}$。

### Solution

直接阶乘拆分即可。

## T2

### Description

小 $L$ 生活在一座沙尘暴肆虐的城市，这个城市里有 $n$ 个小 $L$ 关心的地点。小 $L$ 记得在沙尘暴来袭之前，从第 $i$ 个地点到第 $j$ 个地点要消耗 $w_{i,j}$ 的时间。由于常年累积的沙子，现在第 $i$ 个地点距离地表的高度是 $h_i$，因此从第 $i$ 个地点到第 $j$ 个地点消耗的时间变为了 $C|h_i-h_j|+w_{i,j}$。小 $L$ 拥有控制沙子程度的能力，所以她可以在一开始花费 $kd_i(k&gt;0)$ 的时间让 $h_i$ 增加或减少 $k$，但是因为地表及以下的部分并不是由沙子构成的，所以她并不能把任何地点的高度降到 $0$ 以下。

现在小 $L$ 想知道，对于任意一对地点 $i,j$，她先消耗一些时间来修改 $h$，再从消耗一些时间从地点 $i$ 走到地点 $j$ 花费的最小总时间是多少。注意这里对于每一对地点是独立计算的，即修改 $h$ 是从初始的 $h$ 来修改。

$1\leq n\leq 500$，$0\leq C,h_i,d_i \leq 10^7$，$0\leq w_{i,j}\leq 10^{14}$。

### Solution

考虑固定走的路径后最优解的高度会变成什么。

有个结论是把最终的高度序列的连续段拿出来后，每个连续段一定存在一个点的初始高度等于最终高度。

证明就考虑对于不满足条件的连续段数量进行归纳。如果存在一个段不满足条件，则这个段变化的最终高度 $x$ 与贡献构成的函数一定是个凸函数，并且满足拐点一定是该区间内的初始高度或者相邻区间的最终高度，由于最优解一定在拐点上，所以要么该段满足条件，要么和相邻段合并，不满足条件的段的数量一定减少。

然后枚举每个满足初始高度等于最终高度的点 $p_1,p_2,\ldots,p_k$。那么 $s\to p_1$ 最终高度全为 $h_{p_1}$，$p_i\to p_{i+1}$ 的路径上前一半为 $h_{p_i}$，后一边为 $h_{p_{i+1}}$，$p_k\to t$ 上全为 $h_{p_k}$。

设 $f_{i,j}$ 表示从 $i$ 走到 $j$，并且让路径上的点的高度都变成 $h_i$ 的最小代价。$g_{i,j}$ 表示从 $i$ 走到 $j$，前一半变成 $h_i$，后一半变成 $h_j$ 的最小代价。

对于 $f$ 用 dijkstra 求，$g$ 用 floyd 即可。

时间复杂度：$O(n^3)$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 505;

int cid, n, C;
int a[kMaxN], d[kMaxN], w[kMaxN][kMaxN], f[kMaxN][kMaxN], g[kMaxN][kMaxN], h[kMaxN][kMaxN];

void getf() {
  // f[i][j] : i -&gt; j，将高度全变成 a[i] 的最小权值
  for (int i = 1; i &lt;= n; ++i) {
    static bool vis[kMaxN];
    std::fill_n(f[i] + 1, n, 1e18);
    std::fill_n(vis + 1, n, 0);
    f[i][i] = 0;
    for (int c = 1; c &lt;= n; ++c) {
      int x = 0;
      for (int j = 1; j &lt;= n; ++j)
        if (!vis[j] &amp;&amp; (!x || f[i][j] &lt; f[i][x]))
          x = j;
      if (!x) break;
      vis[x] = 1;
      for (int y = 1; y &lt;= n; ++y)
        f[i][y] = std::min(f[i][y], f[i][x] + w[x][y] + d[y] * abs(a[y] - a[i]));
    }
  }
}

void getg() {
  // g[i][j] : i -&gt; j，前一半变成 a[i]，后一半变成 a[j] 的最小权值
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      if (i != j) g[i][j] = 1e18;
      for (int k = 1; k &lt;= n; ++k) {
        g[i][j] = std::min(g[i][j], f[i][k] + f[j][k] + C * abs(a[i] - a[j]) - d[k] * abs(a[k] - a[j]));
      }
    }
  }
  for (int k = 1; k &lt;= n; ++k)
    for (int i = 1; i &lt;= n; ++i)
      for (int j = 1; j &lt;= n; ++j)
        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);
}

void geth() {
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      h[i][j] = (i == j ? 0 : 1e18);
      for (int k = 1; k &lt;= n; ++k)
        h[i][j] = std::min(h[i][j], f[k][i] + g[k][j]);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; cid &gt;&gt; n &gt;&gt; C;
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; d[i];
  for (int i = 1; i &lt;= n; ++i)
    for (int j = 1; j &lt;= n; ++j)
      std::cin &gt;&gt; w[i][j];
  getf(), getg(), geth();
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
      int ans = (i == j ? 0 : 1e18);
      for (int k = 1; k &lt;= n; ++k) ans = std::min(ans, h[i][k] + f[k][j]);
      std::cout &lt;&lt; ans &lt;&lt; " \n"[j == n];
    }
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

## T3

### Description

宇宙射线大爆发，你躲到了 $0/1$ 序列里。

对于一个 $0/1$ 序列，宇宙射线照射它一次，会从每个 $0/1$ 连续段中删去一个元素，并让剩余元素补位，例如 $11011$ 被照射一次会变成 $11$。

定义一个 $0/1$ 序列 $A$ 的**强度** $f(A)$ 为，让它变为空序列所需的照射次数。

给定正整数 $n,k$，求 $\sum_{A\in\{0,1\}^n} (f(A))^k$，即所有长为 $n$ 的 $0/1$ 串的**强度**的 $k$ 次方之和，答案对 $998244353$ 取模。 

$1\leq n,k\leq 10^7$。

### Solution

考虑给定一个序列的权值怎么求。结论是权值为将 $0$ 看成 $1$，$1$ 看成 $-1$ 后前缀和的极差。

那么原题目转化为求一个长度为 $n$ 的 $1/-1$ 序列的前缀和极差为 $m$ 的方案数。

考虑枚举 $m$，用 [[AGC013D] Piling Up](https://www.luogu.com.cn/problem/AT_agc013_d) 的方法转化为起点 $(0,0),(0,1),\ldots(0,m)$，终点为 $(n,0),(n,1),\ldots(n,m)$ 且不能经过 $y=-1$ 和 $y=m+1$ 的方案数，将 $m$ 的方案数减去 $m-1$ 的方案数即为极差为 $m$ 的方案数，因为极差为 $k$ 的在 $m$ 里会算 $m-k+1$ 次，在 $m-1$ 里会算 $m-k$ 次，减去后就只有 $1$ 次了。

上面那个问题可以转化为[反射容斥](https://www.cnblogs.com/Hanghang007/p/18159154)，最终的式子是组合数前缀和的区间和的差，所以记录组合数前缀和的前缀和即可。

时间复杂度：$O(n\ln n)$。

# 20250108

## T2

### Description

有一棵点数为 $n$ 的树，根为 $1$，**每个叶子节点深度相同**。你有一个初始是 $0$ 的能量值 $S$。你现在会在树上移动。

你有 $m$ 种跳跃姿势，第 $i$ 种跳跃姿势可以用一个正整数 $b_i$ 表示。

假如你现在在节点 $u$，每一时刻你可以做以下事情**之一**：

1. 当 $u$ **不是叶子节点**，你可以睡一觉，并掉落到节点 $p_u$，能量值变为 $S+1$。保证 $p_u$ 是 $u$ 的儿子节点。

2. 当 $S&gt;0$，你可以选择一个跳跃姿势 $k$（$1\le k \le m$） 并向上跳 $b_k$ 步，即走到 $u$ 的 $b_k$ 级祖先，能量值变为 $S-1$。你需要**保证 $\boldsymbol{b_k}$ 级祖先存在**。

定义 $dis(u,v)$ 表示从 $u$ 开始，初始 $S$ 等于 $0$，走到 $v$ 用时最短是多少。特别的，若 $u$ 无法到达 $v$ 则 $dis(u,v)=0$。

求 $\sum\limits_{u=1}^{n}\sum\limits_{v=1}^{n}dis(u,v)$。

$1 \le n \le 2\times10^5$，$1 \le m \le 100$，$2 \le b_k \le n$。

### Solution

考虑链怎么做。

首先把 $b_i=n$ 的跳跃姿势去掉。由于存在能量值的限制，所以可以猜测一定是先重复一降一升，再一直降，那么设 $f_{i}$ 表示向上跳 $i$ 步的最小步数，可以得到 dp：

$$
\begin{aligned}
\forall j\in [1,m],f_{i}&amp;=\min{f_{i-b_j+1}}\\
f_{i}&amp;=\min_{j\geq i}{f_j+j-i}
\end{aligned}
$$

下面证明一下上面做法的正确性：假设已经固定操作序列，那么跳的方式一定是如果当前点不是叶子且还有下降的次数，否则才往上跳。所以只有在叶子或者没有下降次数了才往上跳，显然一定不会跳出去，且这么做一定最优。

---

放到树上，固定 $lca$ 的重链顶 $t$，则一定存在一个限制 $dep_{leaf}-dep_{t}-1$，使得超过这个限制的跳跃姿势不能跳，所以只需要对 $b$ 进行排序然后做一个前缀的背包即可。

暴力做时间复杂度：$O(n^2)$。

---

考虑优化。

注意到题目里的划分链的方式为长链剖分，所以每个点到根的路径上的轻边数只有 $O(\sqrt n)$ 级别，考虑分类讨论。

设起点为 $x$，终点为 $y$。

1. $x$ 是 $lca$，$y$ 在 $x$ 所在重链上，直接算等差数列即可。
2. $x$ 是 $lca$ 的轻儿子子树里的点，$y$ 是 $lca$ 重儿子子树里的点，暴力枚举 $x$ 再算等差数列。
3. $y$ 是 $lca$，改为枚举 $x$，然后暴力跳 $x$ 到根的路径上的长链，那么某个长链对答案的贡献一定是 dp 数组上的一段区间加等差数列的形式，预处理前缀和即可。

时间复杂度：$O(nm+n\sqrt n)$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxM = 105;

int n, m, mxd;
int p[kMaxN], son[kMaxN], b[kMaxM], f[kMaxM][kMaxN * 2], pos[kMaxM], cnt[kMaxN], iid[kMaxN];
int dep[kMaxN], dfn[kMaxN], idx[kMaxN], sz[kMaxN], top[kMaxN];
int64_t ans, sum[kMaxN], pre[kMaxM][kMaxN], pre1[kMaxM][kMaxN];
std::vector&lt;int&gt; G[kMaxN];

int get(int x, int y) { return dfn[x] &lt; dfn[y] ? x : y; }
int64_t getsum(int l, int r) { return l &gt; r ? 0 : 1ll * (l + r) * (r - l + 1) / 2; }
int getsum(int *a, int l, int r) {
  if (l &gt; r) return 0;
  else if (l == 0) return a[r];
  else return a[r] - a[l - 1];
}
int64_t getsum(int64_t *a, int l, int r) {
  if (l &gt; r) return 0;
  else if (l == 0) return a[r];
  else return a[r] - a[l - 1];
}

void dfs(int u, int fa, int t) {
  static int cnt = 0;
  dep[u] = dep[fa] + 1, top[u] = t, sz[u] = 1;
  idx[dfn[u] = ++cnt] = u;
  if (son[u] != -1) dfs(son[u], u, t), sz[u] += sz[son[u]];
  for (auto v : G[u]) {
    if (v == fa || v == son[u]) continue;
    dfs(v, u, v);
    sz[u] += sz[v];
  }
}

int getid(int x) { return std::upper_bound(b + 1, b + 1 + m, x) - b - 1; }

void prework() {
  dfs(1, 0, 1);
  std::sort(b + 1, b + 1 + m);
  m = std::unique(b + 1, b + 1 + m) - (b + 1);
  memset(f, 0x3f, sizeof(f));
  f[0][0] = 0;
  for (int i = 1; i &lt;= m; ++i) {
    --b[i];
    for (int j = 0; j &lt;= 2 * n; ++j) {
      f[i][j] = f[i - 1][j];
      if (j &gt;= b[i]) f[i][j] = std::min(f[i][j], f[i][j - b[i]] + 2);
    }
  }
  for (int i = 1; i &lt;= m; ++i)
    for (int j = 2 * n; ~j; --j) f[i][j] = std::min(f[i][j] + j, f[i][j + 1]);
  for (int i = 0; i &lt;= m; ++i) {
    pre[i][0] = pre1[i][0] = 0;
    for (int j = 1; j &lt;= n; ++j) {
      pre[i][j] = pre[i][j - 1];
      pre1[i][j] = pre1[i][j - 1];
      if (f[i][j] &lt;= 1e8) {
        pre[i][j] += f[i][j];
        pre1[i][j] += f[i][j] - j;
      }
    }
  }
}

// namespace Sub0 {
// void solve() {
//   int64_t ans = 0;
//   for (int i = 1; i &lt;= n; ++i) {
//     if (son[i] == -1) continue;
//     for (int j = 1; j &lt;= n; ++j) {
//       int lca = LCA(i, j);
//       if (son[lca] == -1) continue;
//       if (top[j] != top[lca]) continue;
//       int id = getid(mxd - dep[top[lca]] - 1), mi = f[id][dep[i] - dep[lca]] + (dep[j] - dep[i]);
//       if (mi &lt;= 1e6) ans += mi;
//     }
//   }
//   std::cout &lt;&lt; ans &lt;&lt; '\n';
// }
// } // namespace Sub0

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 2; i &lt;= n; ++i) {
    std::cin &gt;&gt; p[i];
    G[p[i]].emplace_back(i), G[i].emplace_back(p[i]);
  }
  for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; son[i];
  for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; b[i];
  prework();
  mxd = *std::max_element(dep + 1, dep + 1 + n);
  for (int i = 1; i &lt;= n; ++i) iid[i] = getid(mxd - dep[top[i]] - 1);
  for (int i = n; i; --i) {
    cnt[i] = 1, sum[i] = dep[i];
    if (son[i] != -1) cnt[i] += cnt[son[i]], sum[i] += sum[son[i]];
  }
  // x 是 lca
  for (int i = 1; i &lt;= n; ++i) {
    ans += getsum(1, cnt[i] - 1);
  }
  // x 在轻子树，y 在重子树
  for (int lca = 1; lca &lt;= n; ++lca) {
    if (son[lca] == -1) continue;
    int id = iid[lca];
    for (int i = dfn[son[lca]] + sz[son[lca]]; i &lt;= dfn[lca] + sz[lca] - 1; ++i) {
      int x = idx[i], mi = f[id][dep[x] - dep[lca]] - dep[x];
      if (son[x] != -1 &amp;&amp; mi &lt;= 1e8) ans += mi * (cnt[lca] - 1) + sum[lca] - dep[lca];
    }
  }
  // y 是 lca
  // f[id][dep[x] - dep[y]] + (dep[y] - dep[x])
  for (int x = 1; x &lt;= n; ++x) {
    if (son[x] == -1) continue;
    int lst = x;
    for (int i = top[x]; i; i = top[p[i]]) {
      // int id = getid(mxd - dep[i] - 1);
      int id = iid[i];
      ans += getsum(pre1[id], dep[x] - dep[lst], dep[x] - dep[i]);
      // for (int j = dep[x] - dep[lst]; j &lt;= dep[x] - dep[i]; ++j)
      //   if (f[id][j] &lt;= 1e8)
      //     ans += f[id][j] - j;
      lst = p[i];
    }
  }
  // for (int x = 1; x &lt;= n; ++x) {
  //   if (son[x] == -1) continue;
  //   for (int y = x; y; y = p[y]) {
  //     int id = getid(mxd - dep[top[y]] - 1);
  //     int64_t mi = f[id][dep[x] - dep[y]] + (dep[y] - dep[x]);
  //     assert(mi &gt;= 0);
  //     if (mi &lt;= 1e8) ans += mi;
  //   }
  // }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18653764.html</id>
    <title type="text">LOJ #3273. 「JOISC 2020 Day1」扫除 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-01-05T11:34:00Z</published>
    <updated>2025-01-05T11:34:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18653764.html" />
    <content type="text">## Description

平面直角坐标系上一个等腰直角三角形，维护 $4$ 种操作：

1. 加入 $(x,y)$。
2. 把 $y\leq l$ 的点横坐标变成 $\max⁡(x,n-l)$。
3. 把 $x\leq l$ 的点纵坐标变成 $\max(y,n-l)$。
4. 查询第 $i$ 个点现在的位置。

$1\leq n\leq 10^9,1\leq m\leq 5\times 10^5,1\leq Q\leq 10^6$。

## Solution

考虑没有一操作怎么做。

容易发现对于任意时刻都存在一条左上到右下的轮廓线，满足所有点要么在轮廓线上，要么位置没有发生改变。

所以先求出每个点第一次被移动的时刻 $p_i$，同时维护一个平衡树表示轮廓线上的点，在 $p_i$ 时刻将 $i$ 号点加入平衡树，修改时直接将需要修改的区间 split 出来打标记即可。

如果有一操作，会让某个点在加入的时候在轮廓线下面，导致上面的做法不正确。考虑规避掉一操作。

---

假设要求出某个点 $p$ 经过 $[l,r]$ 操作后的结果，那么在线段树上找到 $[l,r]$ 对应的 $O(\log n)$ 个区间，并将这个点依次插入这些区间。

求答案时进行类似线段树分治的做法，每次将当前线段树节点 $[l,r]$ 上的点一起做 $[l,r]$ 操作，然后将这些点操作完的坐标挂到对应的线段树上的下一个区间即可。

时间复杂度：$O((m+Q)\log (m+Q))$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxM = 1.5e6 + 5, kMaxQ = 1e6 + 5;

int n, m, q;
int x[kMaxM], y[kMaxM], t[kMaxM], pos[kMaxM], ansx[kMaxQ], ansy[kMaxQ];
std::mt19937 rnd(114514);
std::vector&lt;int&gt; vec[kMaxQ * 4], unq;

struct Query {
  int op, x, y;
  Query(int _op = 0, int _x = 0, int _y = 0) : op(_op), x(_x), y(_y) {}
} qq[kMaxQ];

struct Node {
  int ls, rs, val, x, y, tagx, tagy;
  Node(int _ls = 0, int _rs = 0, int _val = 0, int _x = 0, int _y = 0, int _tagx = 0, int _tagy = 0) :
    ls(_ls), rs(_rs), val(_val), x(_x), y(_y), tagx(_tagx), tagy(_tagy) {}
};

struct FHQTreap {
  int rt, tot;
  Node t[kMaxM];

  void clear() {
    for (int i = 1; i &lt;= tot; ++i) t[i] = Node();
    rt = tot = 0;
  }
  int newnode(int x, int y) {
    t[++tot] = {0, 0, rnd(), x, y, 0, 0};
    return tot;
  }
  void addtag(int x, int tagx, int tagy) {
    if (~tagx) t[x].x = t[x].tagx = tagx;
    if (~tagy) t[x].y = t[x].tagy = tagy;
  }
  void pushdown(int x) {
    if (t[x].ls) addtag(t[x].ls, t[x].tagx, t[x].tagy);
    if (t[x].rs) addtag(t[x].rs, t[x].tagx, t[x].tagy);
    t[x].tagx = t[x].tagy = -1;
  }
  int merge(int x, int y) {
    if (!x || !y) return x + y;
    pushdown(x), pushdown(y);
    if (t[x].val &lt; t[y].val) {
      t[x].rs = merge(t[x].rs, y);
      return x;
    } else {
      t[y].ls = merge(x, t[y].ls);
      return y;
    }
  }
  void splitx(int x, int vx, int &amp;a, int &amp;b) {
    // a 的 x &lt;= vx
    if (!x) return void(a = b = 0);
    pushdown(x);
    if (t[x].x &lt;= vx) {
      a = x, splitx(t[x].rs, vx, t[x].rs, b);
    } else {
      b = x, splitx(t[x].ls, vx, a, t[x].ls);
    }
  }
  void splity(int x, int vy, int &amp;a, int &amp;b) {
    // a 的 y &gt;= vy
    if (!x) return void(a = b = 0);
    pushdown(x);
    if (t[x].y &gt;= vy) {
      a = x, splity(t[x].rs, vy, t[x].rs, b);
    } else {
      b = x, splity(t[x].ls, vy, a, t[x].ls);
    }
  }
  int ins(int x, int y) {
    int a, b, c, id;
    id = newnode(x, y);
    splitx(rt, x, a, c);
    splity(a, y, a, b);
    rt = merge(merge(a, id), merge(b, c));
    return id;
  }
  void pushall(int x) {
    if (!x) return;
    pushdown(x);
    if (t[x].ls) pushall(t[x].ls);
    if (t[x].rs) pushall(t[x].rs);
  }
} ft;

struct SGT {
  int N, val[kMaxM * 4];
  void build(int n) {
    for (N = 1; N &lt;= n + 1; N &lt;&lt;= 1) {}
    std::fill_n(val, 2 * N, 1e9);
  }
  void update(int x, int v) {
    for (x += N; x; x &gt;&gt;= 1) val[x] = v;
  }
  int query(int l, int r) {
    if (l &gt; r) return 1e9;
    int ret = 1e9;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if (~l &amp; 1) ret = std::min(ret, val[l ^ 1]);
      if (r &amp; 1) ret = std::min(ret, val[r ^ 1]);
    }
    return ret;
  }
} sgt[2];

void update(int x, int l, int r, int ql, int qr, int id) {
  if (l &gt; qr || r &lt; ql) return;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return void(vec[x].emplace_back(id));
  int mid = (l + r) &gt;&gt; 1;
  update(x &lt;&lt; 1, l, mid, ql, qr, id), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, id);
}

void discrete(int l, int r) {
  unq.clear();
  for (int i = l; i &lt;= r; ++i) {
    if (qq[i].op == 2 || qq[i].op == 3) unq.emplace_back(qq[i].x);
  }
  std::sort(unq.begin(), unq.end());
  unq.erase(std::unique(unq.begin(), unq.end()), unq.end());
}

int getid(int x) { return std::lower_bound(unq.begin(), unq.end(), x) - unq.begin() + 1; }

void solve(int x, int l, int r) {
  static std::vector&lt;int&gt; vv[kMaxM];
  ft.clear();
  discrete(l, r);
  sgt[0].build(unq.size()), sgt[1].build(unq.size());
  for (int i = r; i &gt;= l; --i) {
    if (qq[i].op == 2) sgt[0].update(getid(qq[i].x), i);
    else if (qq[i].op == 3) sgt[1].update(getid(qq[i].x), i);
  }
  for (auto i : vec[x]) {
    int p = std::min(sgt[0].query(getid(ansy[i]), getid(n - ansx[i] + 1) - 1),
                     sgt[1].query(getid(ansx[i]), getid(n - ansy[i] + 1) - 1));
    if (p &lt;= r) vv[p].emplace_back(i);
  }
  for (int i = l; i &lt;= r; ++i) {
    int x, y, z;
    if (qq[i].op == 2) {
      ft.splitx(ft.rt, n - qq[i].x, x, z);
      ft.splity(x, qq[i].x + 1, x, y);
      if (y) ft.addtag(y, n - qq[i].x, -1);
      ft.rt = ft.merge(ft.merge(x, y), z);
    } else if (qq[i].op == 3) {
      ft.splitx(ft.rt, qq[i].x, x, z);
      ft.splity(x, n - qq[i].x + 1, x, y);
      if (y) ft.addtag(y, -1, n - qq[i].x);
      ft.rt = ft.merge(ft.merge(x, y), z);
    }
    for (auto id : vv[i]) {
      if (qq[i].op == 2) ansx[id] = std::max(ansx[id], n - qq[i].x), assert(ansy[id] &lt;= qq[i].x);
      else ansy[id] = std::max(ansy[id], n - qq[i].x), assert(ansx[id] &lt;= qq[i].x);
      pos[id] = ft.ins(ansx[id], ansy[id]);
    }
  }
  ft.pushall(ft.rt);
  for (int i = l; i &lt;= r; ++i) {
    for (auto id : vv[i]) {
      ansx[id] = ft.t[pos[id]].x;
      ansy[id] = ft.t[pos[id]].y;
    }
  }
  for (int i = l; i &lt;= r; ++i) vv[i].clear();
  for (auto i : vec[x]) pos[i] = 0;
  if (l != r) {
    int mid = (l + r) &gt;&gt; 1;
    solve(x &lt;&lt; 1, l, mid), solve(x &lt;&lt; 1 | 1, mid + 1, r);
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= m; ++i) {
    std::cin &gt;&gt; x[i] &gt;&gt; y[i];
    t[i] = 1;
  }
  for (int i = 1; i &lt;= q; ++i) {
    std::cin &gt;&gt; qq[i].op;
    if (qq[i].op == 1) {
      std::cin &gt;&gt; qq[i].x;
      ansx[i] = x[qq[i].x], ansy[i] = y[qq[i].x];
      update(1, 1, q, t[qq[i].x], i, i);
    } else if (qq[i].op == 2) {
      std::cin &gt;&gt; qq[i].x;
    } else if (qq[i].op == 3) {
      std::cin &gt;&gt; qq[i].x;
    } else {
      std::cin &gt;&gt; qq[i].x &gt;&gt; qq[i].y;
      t[++m] = i, x[m] = qq[i].x, y[m] = qq[i].y;
    }
  }
  solve(1, 1, q);
  for (int i = 1; i &lt;= q; ++i)
    if (qq[i].op == 1)
      std::cout &lt;&lt; ansx[i] &lt;&lt; ' ' &lt;&lt; ansy[i] &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18691600.html</id>
    <title type="text">P8291 [省选联考 2022] 学术社区 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-01-26T03:08:00Z</published>
    <updated>2025-01-26T03:08:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18691600.html" />
    <content type="text">## Description

**以下涉及的所有字符串判等操作都对大小写敏感，例如 `1oushang`、`Loushang`、`LOUSHANG` 是互不相同的字符串。**

小 I 正在整理学术社区中的一个帖子。帖子中一共有 $N$ 个网友发过消息，他们的网名分别为 $n_1, n_2, \ldots, n_N$。帖子中总共有 $M$ 条消息，对于第 $i$ 条消息，我们用三个字符串 $s_{i,1}, s_{i,2}, s_{i,3}$ 构成的三元组描述它，其中 $s_{i,1}$ 表示这条消息发出者的网名，而 $s_{i,2}$ 和 $s_{i,3}$ 描述这条消息的内容。

对于第 $i$ 条消息，我们通过如下方式定义其属于**楼下型消息**、**楼上型消息**、**学术型消息**中的哪一种：

- 若字符串 $s_{i, 3}$ 为 `louxia`，且 $s_{i, 2}$ 恰好与给出的某个网名相同（注意 $s_{i,2} = s_{i,1}$ 是允许的），则称这条消息是**楼下型消息**，$s_{i,2}$ 对应这条消息提到的网友；
- 若字符串 $s_{i,3}$ 为 `loushang`，且 $s_{i,2}$ 恰好与给出的某个网名相同（注意 $s_{i,2} = s_{i,1}$ 是允许的），则称这条消息是**楼上型消息**，$s_{i,2}$ 对应这条消息提到的网友；
- 若以上两个条件都不满足，则称这条消息是**学术消息**。

定义一个对所有消息的重排方案为一个 $1$ 到 $M$ 的排列 $a_1, a_2, a_3, \ldots, a_M$，表示第一条消息是 $(s_{a_1,1}, s_{a_1,2}, s_{a_1,3})$，第二条消息是 $(s_{a_2,1}, s_{a_2,2}, s_{a_2,3})$，依此类推。

对于一个重排方案 $a_1, a_2, a_3, \ldots, a_M$ 中的第 $i$（$1 \le i \le M$）条消息 $(s_{a_i,1}, s_{a_i,2}, s_{a_i,3})$，如下定义其是否是**符合实际情况的**：

- 若这条消息是**楼下型消息**，则这条消息是**符合实际情况的**当且仅当 $i \ne 1$ 且 $s_{a_{i - 1}, 1} = s_{a_i, 2}$，即上一条消息存在且它的发出者与这条消息提到的网友一致。
- 若这条消息是**楼上型消息**，则这条消息是**符合实际情况的**当且仅当 $i \ne M$ 且 $s_{a_{i + 1}, 1} = s_{a_i, 2}$，即下一条消息存在且它的发出者与这条消息提到的网友一致。
- 若这条消息是**学术消息**，则无论如何这条消息一定不是符合实际情况的，这是因为小 I 只想灌水不想学术。

在以上定义下，小 I 希望找到一个重排方案，使得该重排方案中符合实际情况的消息数量最多。你需要帮他找到这个方案以及这个方案中符合实际情况的消息数量。

**为了方便你的解题，小 I 还告诉了你帖子中消息的一个特殊限制：因为学术社区会禁言在社区中只灌水不学术的人，所以在小 I 给出的帖子里，每一个在帖子中发过言的人都一定会在帖子中发出至少一条学术消息。**

$1\leq N\leq M\leq 77777,1\leq\sum M\leq 2.5\times 10^5$。

## Solution

首先考虑特殊性质 ABC 怎么做。

考虑把问题放到有向图上做。先建一个超级源点 T，对于每个楼下型消息 $A$ 在 $B$ 楼下在有向图上连一条 $B\to A$ 的边，对于 $A$ 发出的学术消息就连一条 $A\to T$ 的边。容易发现此时每个点的入度一定小于等于出度，所以对每个点 $x$ 连 $out_x-in_x$ 条 $T\to x$ 的边，然后跑欧拉回路，把回路去掉无用边即为最终方案。

---

然后是特殊性质 AC。

由于不一定每个非学术消息都满足条件，所以现在的有向图就不保证 $in_x\leq out_x$ 了，但是会发现如果 $in_x&gt;out_x$，那么至少有 $in_x-out_x$ 个消息不合法，所以把所有这样的消息去掉可以得到一个上界，同时可以构造这个上界的方案：如果 $in_x&gt;out_x$，则连 $in_x-out_x$ 条 $x\to T$ 的边，如果 $in_x&lt;out_x$ 则连 $out_x-in_x$ 条 $T\to x$ 条边，然后跑欧拉回路即为方案，正确性显然。

---

然后是特殊性质 BC。

现在既有楼上型消息也有楼下型消息，但是由于 B 性质的存在，所以最终方案的形态一定是形如一段楼上型消息+学术消息+一段楼下型消息的组合拼起来，所以可以建两个图 $G_1,G_2$。

对于楼上型消息 $A$ 在 $B$ 楼上，就在 $G_1$ 连一条 $A\to B$ 的边，如果 $A$ 在 $B$ 楼下，就在 $G_2$ 连一条 $B\to A$ 的边，对于 $A$ 发出的学术消息则连一条 $A_1\to A_2$ 的边。容易发现 $G_1$ 中的点入度不大于出度，$G_2$ 中的点入度不小于出度，所以对于 $G_1$ 中的点 $x$ 连 $out_x-in_x$ 条 $T\to x$ 的边，$G_2$ 中的 $x$ 连 $in_x-out_x$ 条 $x\to T$ 的边，然后跑欧拉回路即可。

---

然后是特殊性质 C。

此时 $G_1$ 中 $in_x$ 可能大于 $out_x$，$G_2$ 中 $in_x$ 可能小于 $out_x$，可以通过特殊性质 AC 的做法得到一个答案的上界，但此时不一定最优。

因为如果删除一条 $A$ 在 $B$ 楼上的消息，并将其变成学术消息，会让 $out_{A_2}$ 加一，$in_{B_1}$ 减一，如果原来 $in_{A_2}&gt;out_{A_2}$ 且 $in_{B_1}&lt;out_{B_1}$，答案的上界就可以增大一。

这启发我们建出一个网络流图，源点 $S$ 向所有 $A_1$ 连流量为 $out_{A_1}-in_{A_1}$ 的边，$A_2$ 向汇点 $T$ 连流量为 $in_{A_2}-out_{A_2}$ 的边，对于一条 $A$ 在 $B$ 楼上的消息，就连 $B_1\to A_2$ 流量为 $1$ 的边，$A$ 在 $B$ 楼下的消息连 $A_1\to B_2$ 流量为 $1$ 的边。

然后跑最大流可以得到改为学术消息的原来非学术消息，把这些改了之后做类似特殊性质 AC 的做法即可。

---

如果没有特殊性质 C，则中间的转接部分可能形如 $A\to B\to A$，但是可以证明优先把这样的二元环缩起来一定最优，缩完后这些二元环连和学术消息类似的边即可。

时间复杂度：$O(m\sqrt m)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 8e5 + 5;

int n, m, t;
int in[kMaxN * 2], out[kMaxN * 2], res[kMaxN], cur[kMaxN * 2];
bool del[kMaxN];
std::tuple&lt;int, int, int&gt; e[kMaxN], _e[kMaxN];
std::vector&lt;int&gt; vec[kMaxN], stk;
std::map&lt;std::string, int&gt; mp;
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN * 2];

namespace Dinic {
struct Edge {
  int v, w, id, pre;
} e[kMaxN * 10];

int tot = 1, n, s, t;
int tail[kMaxN * 2], cur[kMaxN * 2], dep[kMaxN * 2];

void init(int _n, int _s, int _t) {
  for (int i = 1; i &lt;= n; ++i) tail[i] = cur[i] = dep[i] = 0;
  for (int i = 1; i &lt;= tot; ++i) e[i] = {0, 0, 0};
  tot = 1, n = _n, s = _s, t = _t;
}
void adde(int u, int v, int w, int id) { e[++tot] = {v, w, id, tail[u]}, tail[u] = tot; }
void add(int u, int v, int w, int id) { adde(u, v, w, id), adde(v, u, 0, id); }

bool bfs() {
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    cur[i] = tail[i], dep[i] = 1e9;
  q.emplace(s), dep[s] = 0;
  for (; !q.empty();) {
    int u = q.front(); q.pop();
    for (int i = tail[u]; i; i = e[i].pre) {
      int v = e[i].v, w = e[i].w;
      if (w &amp;&amp; dep[v] == 1e9) {
        dep[v] = dep[u] + 1, q.emplace(v);
      }
    }
  }
  return dep[t] != 1e9;
}
int dfs(int u, int lim) {
  if (u == t || !lim) return lim;
  int flow = 0;
  for (int &amp;i = cur[u]; i; i = e[i].pre) {
    int v = e[i].v, w = e[i].w;
    if (w &amp;&amp; dep[v] == dep[u] + 1) {
      int fl = dfs(v, std::min(lim, w));
      if (!fl) dep[v] = 1e9;
      lim -= fl, flow += fl;
      e[i].w -= fl, e[i ^ 1].w += fl;
      if (!lim) break;
    }
  }
  return flow;
}
int maxflow() {
  int ans = 0;
  for (; bfs(); ans += dfs(s, 1e9)) {}
  return ans;
}
std::vector&lt;int&gt; getdel() {
  std::vector&lt;int&gt; vec;
  int flow = maxflow();
  for (int i = 1; i &lt;= ::n; ++i) {
    for (int id = tail[i]; id; id = e[id].pre) {
      int j = e[id].v;
      if (j &gt;= ::n + 1 &amp;&amp; j &lt;= 2 * ::n &amp;&amp; !e[id].w) {
        vec.emplace_back(e[id].id);
      }
    }
  }
  return vec;
}
} // namespace Dinic

void init() {
  t = 0, stk.clear(), mp.clear();
  for (int i = 1; i &lt;= m; ++i) del[i] = 0, vec[i].clear();
  for (int i = 1; i &lt;= 2 * n + 1; ++i) G[i].clear(), cur[i] = in[i] = out[i] = 0;
}

void prework() {
  static std::tuple&lt;int, int, int&gt; tmp[kMaxN];
  std::set&lt;std::tuple&lt;int, int, int, int&gt;&gt; st;
  int _m = 0;
  for (int i = 1; i &lt;= m; ++i) {
    auto [op, u, v] = e[i];
    if (op == 0 || op == 1) {
      auto it = st.lower_bound({op ^ 1, v, u, 0});
      if (it != st.end() &amp;&amp; std::get&lt;0&gt;(*it) == (op ^ 1) &amp;&amp; std::get&lt;1&gt;(*it) == v &amp;&amp; std::get&lt;2&gt;(*it) == u) {
        if (op == 0) {
          tmp[++_m] = {2, u, v};
          vec[_m] = {std::get&lt;3&gt;(*it), i};
        } else {
          tmp[++_m] = {2, v, u};
          vec[_m] = {i, std::get&lt;3&gt;(*it)};
        }
        st.erase(it);
      } else {
        st.emplace(op, u, v, i);
      }
    } else {
      tmp[++_m] = {op, u, u};
      vec[_m] = {i};
    }
  }
  for (auto [op, u, v, i] : st) {
    tmp[++_m] = {op, u, v};
    vec[_m] = {i};
  }
  m = _m;
  for (int i = 1; i &lt;= m; ++i) e[i] = tmp[i];
}

void getdeg(bool o = 0) {
  if (!o) {
    for (int i = 1; i &lt;= 2 * n; ++i) in[i] = out[i] = 0;
  }
  for (int i = 1; i &lt;= m; ++i) {
    if (del[i]) continue;
    auto [op, u, v] = e[i];
    if (op == 0) {
      ++out[u], ++in[v];
      if (o) G[u].emplace_back(v, i);
    } else if (op == 1) {
      ++out[v + n], ++in[u + n];
      if (o) G[v + n].emplace_back(u + n, i);
    } else {
      ++out[u], ++in[v + n];
      if (o) G[u].emplace_back(v + n, i);
    }
  }
}

void dfs(int u) {
  for (int i = cur[u]; i &lt; (int)G[u].size(); i = cur[u]) {
    auto [v, id] = G[u][i];
    cur[u] = i + 1;
    dfs(v);
    stk.emplace_back(id);
  }
}

int getcnt() {
  int cnt = 0;
  for (int i = 1; i &lt;= t; ++i) {
    auto [op, u, v] = _e[res[i]];
    if (op == 0 &amp;&amp; i &lt; t &amp;&amp; v == std::get&lt;1&gt;(_e[res[i + 1]]) || op == 1 &amp;&amp; i &gt; 1 &amp;&amp; v == std::get&lt;1&gt;(_e[res[i - 1]]))
      ++cnt;
  }
  return cnt;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  init();
  for (int i = 1; i &lt;= n; ++i) {
    std::string s;
    std::cin &gt;&gt; s;
    mp[s] = i;
  }
  for (int i = 1; i &lt;= m; ++i) {
    std::string s1, s2, s3;
    std::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;
    if (s3 == "loushang" &amp;&amp; mp.count(s2)) {
      e[i] = {0, mp[s1], mp[s2]};
    } else if (s3 == "louxia" &amp;&amp; mp.count(s2)) {
      e[i] = {1, mp[s1], mp[s2]};
    } else {
      int id = mp[s1];
      e[i] = {2, id, id};
    }
    _e[i] = e[i];
  }
  for (int i = 1; i &lt;= m; ++i) vec[i] = {i};
  prework();
  // for (int i = 1; i &lt;= m; ++i) {
  //   for (auto x : vec[i]) std::cout &lt;&lt; x &lt;&lt; ' ';
  //   std::cout &lt;&lt; '\n';
  // }
  // std::cout &lt;&lt; '\n';
  int S = 2 * n + 1, T = 2 * n + 2;
  Dinic::init(2 * n + 2, S, T);
  getdeg();
  // for (int i = 1; i &lt;= 2 * n; ++i) std::cerr &lt;&lt; in[i] &lt;&lt; ' ' &lt;&lt; out[i] &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i)
    if (in[i] &gt; out[i])
      Dinic::add(S, i, in[i] - out[i], 0);
  for (int i = n + 1; i &lt;= 2 * n; ++i)
    if (out[i] &gt; in[i])
      Dinic::add(i, T, out[i] - in[i], 0);
  for (int i = 1; i &lt;= m; ++i) {
    auto [op, u, v] = e[i];
    // std::cout &lt;&lt; op &lt;&lt; ' ' &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\n';
    if (op == 0) {
      Dinic::add(v, u + n, 1, i);
    } else if (op == 1) {
      Dinic::add(u, v + n, 1, i);
    }
  }
  auto dvec = Dinic::getdel();
  for (int i = 1; i &lt;= 2 * n; ++i) in[i] = out[i] = 0;
  for (auto i : dvec) {
    auto [op, u, v] = e[i];
    G[u].emplace_back(u + n, i), ++out[u], ++in[u + n];
    del[i] = 1;
  }
  getdeg(1);
  for (int i = 1; i &lt;= 2 * n; ++i) {
    // if (i &lt;= n) assert(in[i] &lt;= out[i]);
    // else assert(in[i] &gt;= out[i]);
    if (in[i] &lt;= out[i]) {
      for (; in[i] &lt; out[i];)
        G[2 * n + 1].emplace_back(i, 0), ++out[2 * n + 1], ++in[i];
    } else {
      for (; out[i] &lt; in[i];)
        G[i].emplace_back(2 * n + 1, 0), ++out[i], ++in[2 * n + 1];
    }
  }
  // for (int i = 1; i &lt;= 2 * n + 1; ++i) assert(in[i] == out[i]);
  dfs(2 * n + 1);
  for (auto x : stk) {
    for (auto i : vec[x]) res[++t] = i;
  }
  std::reverse(res + 1, res + 1 + t);
  std::cout &lt;&lt; getcnt() &lt;&lt; '\n';
  for (int i = 1; i &lt;= t; ++i) std::cout &lt;&lt; res[i] &lt;&lt; " \n"[i == t];
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18692884.html</id>
    <title type="text">模拟费用流学习笔记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-01-27T14:34:00Z</published>
    <updated>2025-01-27T14:34:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18692884.html" />
    <content type="text">首先模拟费用流有两种不同的方法：

1. 如果不要求动态加入或者删除，只需要求全局的费用流或者流量小于等于某个数的费用流，可以用 EK 增广的方法，每次选当前图上费用最优的增广路增广。

2. 如果要求动态加入并且只要求费用最优，可以每次选择费用最小的源汇路径或者一个经过新加的点的费用最小的负环进行增广。

注：EK 增广的时候一定不会出现环，并且第一个方法与源点或者汇点相连的边也一定不会发生退流。

---

## P4694 [PA 2013] Raper

### Description

你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。

### Solution

考虑费用流，先建图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zaome6dh.png)

考虑用第一种方法直接 EK 增广。

首先是从左往右，这个相当于是选择没被选的 $a_i$ 和 $b_j(i\leq j)$ 进行匹配，并让 $i\to j$ 的这些中间边反向边流量加一。

然后是从右往左，此时是选择没被选的 $a_i$ 和 $b_j(i&gt;j)$ 并且 $j\to i$ 中间反向边流量不小于 $1$ 的 $a_i$ 和 $b_j$ 进行匹配，并且这些反向边流量减一。

用线段树维护中间的反向边流量和没被删掉的 $a_i$ 与 $b_j$ 即可。

时间复杂度：$O(n+k\log n)$。

## CF865D Buy Low Sell High

### Description

已知接下来 $n$ 天的股票价格 $c_i$，每天你可以买进一股股票，卖出一股股票，或者什么也不做。

假设你拥有无限本金，求 $n$ 天之后能得到的最大利润。

### Solution

和上面那题是一样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/9mmyodx9.png)

## P6122 [NEERC 2016] Mole Tunnels

### Description

给出一棵 $n$ 个点的树，编号为 $1\sim n$ ，以 $1$ 为根。节点 $i\ (2\leq i\leq n)$ 的父亲为 $\lfloor i/2\rfloor$。

第 $i$ 个洞内有 $c_i$ 个食物，共有 $m$ 只鼹鼠，第 $i$ 只住在点 $p_i$。

对于所有 $k=1\sim m$ ，前 $k$ 只鼹鼠各找到一个食物，在树上行走的最小总距离。

### Solution

首先还是建出费用流模型。

![](https://cdn.luogu.com.cn/upload/image_hosting/ta4sbsh4.png)

由于这里要动态加点，所以要用方法 2。但是注意到跑负环是不优的，因为这里要求最大流，由于负环是让新来的鼹鼠替代某个原来的鼹鼠进行匹配，然后原来的鼹鼠重新匹配。这不如直接跑源汇路径进行反悔。于是直接维护当前点能到的所有点即可。

由于树高只有 $O(\log n)$，所以可以暴力修改。

时间复杂度：$O(n+m\log n)$。

## P9168 [省选联考 2023] 人员调度

### Description

[link](https://www.luogu.com.cn/problem/P9168)

### Solution

这题还是先建出费用流模型，和上题差不多，但是只有往儿子的正向边。

首先可以用线段树分治把删除转化成添加。然后同样地去讨论是源汇路径还是走负环。

这两个分别代表走初始位置到根的路径上的反向边到达最高点，再从子树里选择一个没有被选过的点进行匹配；或者往根走反向边，并选择一个人替换成当前人。

这两个可以用树链剖分维护，时间复杂度：$O(n\log^2 n)$。

总的时间复杂度：$O(n\log^3 n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18696296.html</id>
    <title type="text">P11647 【MX-X8-T6】「TAOI-3」俄罗斯蓝猫 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-01T06:49:00Z</published>
    <updated>2025-02-01T06:49:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18696296.html" />
    <content type="text">## Description

有 $n$ 个 $[0, 10^{18}]$ 之间**随机**的整数。可以提出两次询问，每次询问给出不超过 $n-1$ 个二元组 $(x_i,y_i)$。返回 $a_{x_i}+a_{y_i}$ 从小到大排序的结果。

不能询问 $(i,i)$ 或者重复的无序对 $(i,j)$。

要求按顺序返回这 $n$ 个数。$1\leq n\leq 500$。

## Solution

注意到 $n$ 比较小，值域很大且随机，所以在询问得到可以大致通过加减操作确定其是什么，并且正确率很高。设 $s(i,j)=a_i+a_j$。

首先考虑如果知道 $a_1,a_2$，怎么推出后面的数。

注意到 $s(i-1,i)-s(2,i)=a_{i-1}-a_2$，所以如果已经推出 $a_1,a_2,\ldots,a_{i-1}$，可以通过询问 $\left\{(1,2),(2,3),\ldots,(n-1,n)\right\}$ 和 $\left\{(2,3),(2,4),\ldots,(2,n-1)\right\}$ 并从中暴力枚举出满足条件的 $s(i-1,i)$ 和 $s(2,i)$，然后就可以通过 $s(i-1,i)$ 和 $a_{i-1}$ 来求出 $a_i$。

---

那么怎么知道一部分数的值呢。

由于上面的那个做法已经把两次询问都用上了，所以只能并行地去做一些询问来得到 $a_1,a_2$。

考虑确定前 $4$ 个数。

先询问 $\left\{(1,2),(1,3),(1,4),(4,5),(5,6),\ldots,(n-1,n)\right\}$ 和 $\left\{(2,3),(3,4),(2,4),(2,5),(2,6),\ldots,(2,n)\right\}$。

通过首先由于 $s(1,2)+s(3,4)=s(1,3)+s(2,4)=s(1,4)+s(2,3)$，这里有 $3$ 个相等的和，次数一定是最多的，所以可以以此求出 $\left\{s(1,2),s(1,3),s(1,4)\right\}$ 和 $\left\{s(2,3),s(3,4),s(2,4)\right\}$，然后就可以得到 $a_1$ 和 $\left\{a_2,a_3,a_4\right\}$。同时通过之前的 $(4,5)$ 和 $(2,5)$ 可以得到 $a_4-a_2$，所以可以以很大的概率确定 $a_2,a_3,a_4$ 分别是哪个。

然后用上面的做法就可以得到后面的数了。

时间复杂度：$O(n^3)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#ifdef ORZXKR
#include "grader.cpp"
#endif

using i64 = long long;

std::vector&lt;i64&gt; game(int n);
std::vector&lt;i64&gt; ask(std::vector&lt;int&gt; x,std::vector&lt;int&gt; y);

std::vector&lt;int&gt; work(std::vector&lt;int&gt; vec) {
  for (auto &amp;x : vec) --x;
  return vec;
}

void del(std::vector&lt;i64&gt; &amp;vec, i64 x) {
  std::vector&lt;i64&gt; ret;
  for (auto xx : vec)
    if (xx != x)
      ret.emplace_back(xx);
  vec = ret;
}

std::pair&lt;i64, i64&gt; getpr(std::vector&lt;i64&gt; &amp;vec1, std::vector&lt;i64&gt; &amp;vec2, i64 x) {
  for (auto a : vec1)
    for (auto b : vec2)
      if (a - b == x)
        return {a, b};
  return {-1, -1};
}

std::vector&lt;i64&gt; game(int n) {
  std::vector&lt;i64&gt; arr(n), res1, res2;
  std::vector&lt;int&gt; vec1, vec2, vec3, vec4;
  vec1 = {1, 1, 1}, vec2 = {2, 3, 4};
  for (int i = 4; i &lt;= n - 1; ++i) vec1.emplace_back(i), vec2.emplace_back(i + 1);
  vec3 = {2, 3, 4}, vec4 = {3, 4, 2};
  for (int i = 5; i &lt;= n; ++i) vec3.emplace_back(2), vec4.emplace_back(i);
  res1 = ask(work(vec1), work(vec2)), res2 = ask(work(vec3), work(vec4));
  // get a[1] and {a[2], a[3], a[4]}
  std::map&lt;i64, std::vector&lt;std::pair&lt;i64, i64&gt;&gt;&gt; mp;
  for (auto x : res1)
    for (auto y : res2)
      mp[x + y].emplace_back(x, y);
  std::vector&lt;i64&gt; v234;
  i64 mxv = -1, cc = 0;
  for (auto [x, vec] : mp) {
    if (vec.size() &gt; cc) {
      mxv = x, cc = vec.size();
    }
  }
  i64 sum234 = 0;
  for (auto [x, y] : mp[mxv])
    arr[0] += x, sum234 += y, del(res1, x), del(res2, y);
  assert(sum234 % 2 == 0);
  sum234 /= 2;
  assert(arr[0] &gt;= sum234 &amp;&amp; (arr[0] - sum234) % 3 == 0);
  arr[0] = (arr[0] - sum234) / 3;
  for (auto [x, y] : mp[mxv]) v234.emplace_back(x - arr[0]);
  for (int i = 0; i &lt; 3; ++i) {
    for (int j = 0; j &lt; 3; ++j) {
      if (i == j) continue;
      auto pr = getpr(res1, res2, v234[i] - v234[j]);
      if (pr != std::pair&lt;i64, i64&gt;{-1, -1}) {
        arr[3] = v234[i], arr[1] = v234[j], arr[2] = v234[3 - i - j];
      }
    }
  }
  // std::cerr &lt;&lt; arr[0] &lt;&lt; ' ' &lt;&lt; arr[1] &lt;&lt; ' ' &lt;&lt; arr[2] &lt;&lt; ' ' &lt;&lt; arr[3] &lt;&lt; ' ';
  for (int i = 4; i &lt; n; ++i) {
    auto pr = getpr(res1, res2, arr[i - 1] - arr[1]);
    // assert(pr != std::pair&lt;i64, i64&gt;{-1, -1});
    // assert(pr.first != -1 &amp;&amp; pr.second != -1);
    del(res1, pr.first), del(res2, pr.second);
    arr[i] = pr.first - arr[i - 1];
    // std::cerr &lt;&lt; arr[i] &lt;&lt; ' ';
  }
  // std::cerr &lt;&lt; '\n';
  return arr;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18697677.html</id>
    <title type="text">2025 寒假 nfls 集训游记-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-03T12:16:00Z</published>
    <updated>2025-02-03T12:16:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18697677.html" />
    <content type="text"># 20250203

## T2

### Description

给出一个包含 $[0,2^m)$ 之间的数的多重数集 $S$。具体地，$i$ 有 $a_i$ 个。对于每个 $k\in[0,2^m)$，请求出有多少个 $T\in S$ 使得 $xor_{x\in T}x=k$，并且满足 $T$ 中数 $i$ 不得超过 $b_i$ 个。

答案对 $998244353$ 取模。

$1\leq m\leq 20,0\leq b_i\leq a_i\leq 10^5$。

### Solution

首先不妨设 $A_i$ 表示从 $a_i$ 个 $i$ 里选偶数且不超过 $b_i$ 个的方案数，$B_i$ 表示选奇数个的方案数，先不管这个怎么求，答案即为：

$$
\prod_{i}{(A_i+B_ix)}
$$

其中乘法是异或卷积，显然需要 FWT。

容易发现 $\text{FWT}[i]_{j}=A_i+(-1)^{\text{popcount}(i\land j)}B_i$，那么最终的 $\text{FWT}_{j}=\prod_{i}{A_i+(-1)^{\text{popcount}(i\land j)}B_i}$。

现在只需要求出每个 $\text{FWT}_j$ 了。

考虑用类似 FMT 的过程，设 $f_{k,j,0/1}$ 表示所有满足后 $m-k$ 位与 $j$ 相同的 $i$ 的 $\prod{\left(A_i+(-1)^{\text{popcount}{i\land j}+0/1}B_i\right)}$ 的值。

转移的时候只需要枚举 $i$ 和 $j$ 第 $k$ 位分别是多少即可，转移方程如下（下面假设 $j$ 第 $k$ 位是 $0$，$s=j\oplus 2^k$）：

$$
\begin{cases}
f_{i,j,0}=f_{i-1,j,0}\cdot f_{i-1,s,0}\\
f_{i,j,1}=f_{i-1,j,1}\cdot f_{i-1,s,1}\\
f_{i,s,0}=f_{i-1,j,0}\cdot f_{i-1,s,1}\\
f_{i,s,1}=f_{i-1,j,1}\cdot f_{i-1,s,0}
\end{cases}
$$

求出 FWT 数组后再 FWT 回去即可得到答案，这部分时间复杂度为 $O(2^m m)$。

---

下面考虑怎么求 $A_i$ 和 $B_i$。

注意到这里只需要分别求出 $A_i+B_i$ 和 $A_i-B_i$，后面那个东西的结论是 $A_i-B_i=(-1)^{b_i}\binom{a_i-1}{b_i}$。前面的就是组合数前缀和的形式，由于 $\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}$，所以可以用莫队求。

这部分时间复杂度：$O(V2^{m/2})$，总的时间复杂度为：$O(2^m m+V2^{m/2})$。

### Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
// g++ -std=c++14 -Wall -O2 -fsanitize=address,undefined -o base base.cpp &amp;&amp; ./base
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = (1 &lt;&lt; 20) + 5, kMod = 998244353;

int n, m, bl;
int a[kMaxN], b[kMaxN], cnt[kMaxN][2], fac[kMaxN], ifac[kMaxN], inv[kMaxN];
int f[kMaxN][2], g[kMaxN];

struct Query {
  int a, b, id, op;
  friend bool operator &lt;(const Query &amp;q1, const Query &amp;q2) {
    if (q1.a / bl != q2.a / bl) return q1.a &lt; q2.a;
    else return q1.b &lt; q2.b;
  }
} qq[kMaxN * 2];

int add(int x, int y) { return (x + y) &gt;= kMod ? (x + y - kMod) : (x + y); }
int sub(int x, int y) { return (x &lt; y) ? (x - y + kMod) : (x - y); }
void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? (x -= kMod) : x; }
void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? (x += kMod) : x; }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework(int n = 1e6) {
  fac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    inv[i] = 1ll * (kMod - kMod / i) * inv[kMod % i] % kMod;
    fac[i] = 1ll * i * fac[i - 1] % kMod;
    ifac[i] = 1ll * inv[i] * ifac[i - 1] % kMod;
  }
}

void fwt(int *f, int m) {
  const int kInv2 = (kMod + 1) / 2;
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt; (1 &lt;&lt; m); ++j) {
      if (~j &gt;&gt; i &amp; 1) {
        int k = j ^ (1 &lt;&lt; i);
        int tmpj = 1ll * add(f[j], f[k]) * kInv2 % kMod, tmpk = 1ll * sub(f[j], f[k]) * kInv2 % kMod;
        f[j] = tmpj, f[k] = tmpk;
      }
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; m; n = (1 &lt;&lt; m), bl = sqrtl(n);
  for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; a[i];
  for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; b[i];
  prework();
  for (int i = 0; i &lt; n; ++i)
    qq[i] = {a[i], b[i], i, 0};
  std::sort(qq, qq + n);
  int x = 0, y = 0, sum = 1;
  for (int i = 0; i &lt; n; ++i) {
    for (; x &lt; qq[i].a; ++x) sum = sub(2ll * sum % kMod, C(x, y));
    for (; y &gt; qq[i].b; --y) dec(sum, C(x, y));
    for (; x &gt; qq[i].a; --x) sum = 1ll * add(sum, C(x - 1, y)) * ((kMod + 1) / 2) % kMod;
    for (; y &lt; qq[i].b; ++y) inc(sum, C(x, y + 1));
    cnt[qq[i].id][qq[i].op] = sum;
  }
  for (int i = 0; i &lt; n; ++i) {
    cnt[i][1] = (a[i] ? C(a[i] - 1, b[i]) : 1);
    f[i][0] = cnt[i][0], f[i][1] = (~b[i] &amp; 1) ? cnt[i][1] : sub(0, cnt[i][1]);
    // std::cerr &lt;&lt; f[i][0] &lt;&lt; ' ' &lt;&lt; f[i][1] &lt;&lt; '\n';
  }
  // for (int i = 0; i &lt; n; ++i) {
  //   int cnt[2] = {0};
  //   for (int j = 0; j &lt;= b[i]; ++j)
  //     inc(cnt[j &amp; 1], C(a[i], j));
  //   f[i][0] = add(cnt[0], cnt[1]), f[i][1] = sub(cnt[0], cnt[1]);
  // }
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt; n; ++j) {
      if (~j &gt;&gt; i &amp; 1) {
        int k = j ^ (1 &lt;&lt; i);
        int tmpj[2], tmpk[2];
        tmpj[0] = 1ll * f[j][0] * f[k][0] % kMod;
        tmpj[1] = 1ll * f[j][1] * f[k][1] % kMod;
        tmpk[0] = 1ll * f[j][0] * f[k][1] % kMod;
        tmpk[1] = 1ll * f[j][1] * f[k][0] % kMod;
        f[j][0] = tmpj[0], f[j][1] = tmpj[1];
        f[k][0] = tmpk[0], f[k][1] = tmpk[1];
      }
    }
  }
  for (int i = 0; i &lt; n; ++i) g[i] = f[i][0];
  fwt(g, m);
  for (int i = 0; i &lt; n; ++i) std::cout &lt;&lt; g[i] &lt;&lt; ' ';
}

int32_t main() {
  freopen("base.in", "r", stdin);
  freopen("base.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

# 20250204

## T3

### Description

Alice 和 Bob 正在玩一个有趣的游戏。现在有一个 $1\times n(n\geq 2)$ 的矩阵作为竞技场，每个格子都有一个属性值（是 $[1,m]$ 内的正整数）。Alice 先选择一个初始位置，然后她就降落在这个初始位置。Bob 则会选择另一个初始位置（不与 Alice 的相同），并降落在他的初始位置。每人都有一个属性值，是他的初始位置的属性值。游戏开始，此游戏将进行若干轮，在每一轮中，Alice 与 Bob 将进行操作：

1. Alice 先选择一个与她相邻的格子，她需要保证这个格子的属性值与她的属性值相同，且 Bob 不在这个格子上。在选择后，Alice 将会走到这个格子。
2. 在 Alice 走完后，Bob 选择一个与他相邻的格子，他也需要保证这个格子的属性值与他的属性值相同，且 Alice 不在这个格子上。在选择后，Bob 将会走到这个格子。

当在某一轮中某一个人无法选择格子，那么他就输了。此外，如果某时刻 Alice 访问过的格子个数（不算重复经过的格子）不小于 $k$，那么 Alice 就赢了。 两人都绝顶聪明，而你作为主持人，想算出有多少种可能的竞技场使得最后 Alice 会赢。两个竞技场不同当且仅当某一个格子的属性值不同。答案对一个质数 $p$ 取模。

$2\leq n\leq 2\times 10^9,1\leq k\leq 2\times 10^9,1\leq m&lt;p\leq 10^7+19$ 且 $p$ 是质数。

### Solution

首先一个方案合法当且仅当存在至少一个值域连续段长度不小于 $2k-1$，因为这样的话 Alice 只要放到这个段的正中间即可获胜，否则 Bob 放在 Alice 左右更长的那边即可必胜。

考虑用总数减去不合法的方案数，现在问题转化为了求 $n$ 个位置，$m$ 种颜色且任意连续段的长度不超过 $k$ 的方案数。

不妨设一个划分连续段的方案（不填色）长度为 $l$，则这种划分方案的贡献为 $m\times(m-1)^{l-1}$，考虑转化为 $(m-1)^{l}\times\frac{m}{m-1}$。

那么设 $f_i$ 表示长度为 $n$ 的答案，$g_i=\sum_{j=0}^{i}{f_j}$，转移方程：

$$
g_i=\begin{cases}1 &amp;(i=0)\\ g_{i-1}+(m-1)(g_{i-1}-g_{i-k-1}) &amp;(i\geq 1)\end{cases}
$$

设 $G(x)$ 为 $g$ 数组的生成函数，则：

$$
\begin{aligned}
G(x)&amp;=mx\cdot G(x)-(m-1)x^{k+1}G(x)+1\\
&amp;=\frac{1}{1-mx+(m-1)x^{k+1}}\\
&amp;=\sum_{i=0}^{+\infty}{\left[mx-(m-1)x^{k+1}\right]^i}\\
&amp;=\sum_{j=0}^{+\infty}(1-m)^jx^{(k+1)j}\sum_{i=j}^{+\infty}{\binom{i}{j}(mx)^{i-j}}
\end{aligned}
$$

由于只需要求第 $n$ 项系数，所以式子里的 $j$ 不超过 $\frac{n}{k+1}$。考虑对于 $k$ 较大的情况枚举 $j$，$i$ 就确定了，组合数用 Lucas 定理求。对于 $k$ 较小的情况跑矩乘即可。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

int n, m, k, mod;

int qpow(int bs, int64_t idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % mod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % mod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= mod ? x + y - mod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + mod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= mod ? x -= mod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += mod : x; }

namespace Sub1 {
struct Matrix {
  int n, m, a[205][205];
  void set(int _n, int _m) {
    n = _n, m = _m;
    for (int i = 1; i &lt;= n; ++i)
      for (int j = 1; j &lt;= m; ++j)
        a[i][j] = 0;
  }
  friend Matrix operator *(const Matrix &amp;m1, const Matrix &amp;m2) {
    static Matrix ret;
    assert(m1.m == m2.n);
    ret.set(m1.n, m2.m);
    for (int i = 1; i &lt;= m1.n; ++i) {
      for (int j = 1; j &lt;= m2.m; ++j) {
        ret.a[i][j] = 0;
        for (int k = 1; k &lt;= m1.m; ++k)
          inc(ret.a[i][j], 1ll * m1.a[i][k] * m2.a[k][j] % mod);
      }
    }
    return ret;
  }
} S, M;

Matrix qpow(Matrix bs, int idx) {
  Matrix ret = bs; --idx;
  for (; idx; idx &gt;&gt;= 1, bs = bs * bs)
    if (idx &amp; 1)
      ret = ret * bs;
  return ret;
}

int getcnt(int n, int m, int k) {
  if (k == 0) return 0;
  if (m == 1) return k &lt;= n;
  S.set(1, k), M.set(k, k);
  S.a[1][1] = 1;
  for (int i = 1; i &lt; k; ++i) M.a[i][i + 1] = 1;
  for (int i = 1; i &lt;= k; ++i) M.a[i][1] = m - 1;
  // S = S * qpow(M, n);
  for (; n; n &gt;&gt;= 1, M = M * M)
    if (n &amp; 1)
      S = S * M;
  return 1ll * S.a[1][1] * m % mod * ::qpow(m - 1) % mod;
}

void solve() {
  std::cout &lt;&lt; sub(::qpow(m, n), getcnt(n, m, 2 * k - 2)) &lt;&lt; '\n';
}
} // namespace Sub1

namespace Sub2 {
const int kMaxMod = 1e7 + 25;

int fac[kMaxMod], ifac[kMaxMod];

void prework() {
  fac[0] = 1;
  for (int i = 1; i &lt; mod; ++i) fac[i] = 1ll * i * fac[i - 1] % mod;
  ifac[mod - 1] = qpow(fac[mod - 1]);
  for (int i = mod - 1; i; --i) ifac[i - 1] = 1ll * i * ifac[i] % mod;
}

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % mod * ifac[m - n] % mod;
}

int L(int m, int n) {
  if (!n) return 1;
  int val = C(m % mod, n % mod);
  if (!val) return 0;
  return 1ll * val * L(m / mod, n / mod) % mod;
}

int getg(int n, int m, int k) {
  int ret = 0, pw1 = 1, pw2 = qpow(m, n), bs = qpow(qpow(m, k + 1));
  for (int i = 0; i &lt;= n / (k + 1); ++i) {
    int j = i + n - (k + 1) * i;
    // inc(ret, 1ll * L(j, i) * qpow(sub(0, m - 1), i) % mod * qpow(m, j - i) % mod);
    inc(ret, 1ll * L(j, i) * pw1 % mod * pw2 % mod);
    pw1 = 1ll * pw1 * sub(0, m - 1) % mod, pw2 = 1ll * pw2 * bs % mod;
  }
  return ret;
}

int getcnt(int n, int m, int k) {
  if (k == 0) return 0;
  if (m == 1) return k &lt;= n;
  return 1ll * sub(getg(n, m, k), getg(n - 1, m, k)) * m % mod * qpow(m - 1) % mod;
}

void solve() {
  prework();
  std::cout &lt;&lt; sub(qpow(m, n), getcnt(n, m, 2 * k - 2)) &lt;&lt; '\n';
}
} // namespace Sub2

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; mod;
  if (k &lt;= 100) Sub1::solve();
  else Sub2::solve();
}

int32_t main() {
  freopen("game.in", "r", stdin);
  freopen("game.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;

# 20250211

## T3（暴力部分）

### Description

[题面](https://eggxiao.lanzouu.com/iGp282ngtsla)

## Solution

首先显然需要转化为 01 序列问题。

对于任意的 $x$，另 $b_i=[a_i&gt;x]$，答案即为让所有这样的 $x$ 对应的 $b$ 数组排序次数的最大值。

考虑固定 $x$ 怎么做。容易发现如果没有排好序，一次操作会让最前面的 $1$ 放到最后一个 $0$ 之后，然后将最后一个 $0$ 放到最前面的 $1$ 之前，这等价于将最前面的 $1$ 和最后面的 $0$ 交换。

我们的目标是让前 $x$ 位全变为 $0$，后 $n-x$ 位变为 $1$，如果没有排序完成，则最前面的 $1$ 一定在前 $x$ 范围内且最后面的 $0$ 也一定在后 $n-x$ 范围内。所以排序次数为 $\sum_{i=1}^{x}{b_i}$。

于是一个排列 $a$ 合法，等价于对于所有 $x$，满足 $\sum_{i=1}^{x}{[a_i&gt;x]}\leq k$。

考虑将排列看成二分图的一个完美匹配，左部点为 $a_i$，右部点为 $i$，则这等价于对于任意左部点长度为 $x$ 的前缀，与右部点长度为 $n-x$ 的后缀连边数不超过 $k$。

这样就可以 dp 了。

设 $f_{i,j}$ 表示考虑了左部和右部的前 $i$ 个点，两边分别有 $j$ 个还没连边，转移就分讨一下新加的点怎么连边即可，转移如下：

$$
f_{i,j}=
\begin{cases}
f_{i-1,j-1}+(2j+1)f_{i-1,j}+(j+1)^2f_{i-1,j+1} &amp;j\leq k\\
0 &amp;\text{otherwise}
\end{cases}
$$

时间复杂度：$O(n^2)$，正解好像要用到科技就没改。

## Code

&lt;details&gt;
&lt;summary&gt;代码&lt;/summary&gt;

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 1e4 + 5, kMod = 998244353;

int n, k;
int f[2][kMaxN];

int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k;
  k = std::min(k, n / 2);
  int o = 0;
  f[o][0] = 1;
  for (int i = 0; i &lt; n; ++i) {
    o ^= 1;
    std::fill_n(f[o], k + 1, 0);
    for (int j = 0; j &lt;= std::min(i, k); ++j) {
      inc(f[o][j], 1ll * (2 * j + 1) * f[o ^ 1][j] % kMod);
      if (j) inc(f[o][j - 1], 1ll * j * j % kMod * f[o ^ 1][j] % kMod);
      if (j &lt; k) inc(f[o][j + 1], f[o ^ 1][j]);
    }
  }
  std::cout &lt;&lt; f[o][0] &lt;&lt; '\n';
}

int32_t main() {
  freopen("sort.in", "r", stdin);
  freopen("sort.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18701634.html</id>
    <title type="text">Public Round #14 A 安顿 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-06T12:24:00Z</published>
    <updated>2025-02-06T12:24:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18701634.html" />
    <content type="text">## Description

对于一个数组 $A$ 和数字 $X$，让我们定义 $f(A,X)$ 如下：

如果不能将 $A$ 拆分为几个子段使得每个子数组中所有元素的异或不等于 $X$，则 $f(A,X)=0$。

否则，$f(A,X)$ 等于这种拆分中最大可能的子段数。

给定整数 $N,K$ 和 $X$，其中 $0\leq X&lt;2^K$。 考虑长度为 $N$ 的数组 $A$，如果每个元素都是从 $0$ 到 $2^K-1$ 均匀生成的整数。 求 $f(A,X)$ 的期望值对 $998244353$ 取模的值。

$1 \le N \le 10^6, 1 \le K \le 60, 0 \leq X &lt; 2^K$。

## Solution

考虑将 $A$ 的前缀异或和数组 $S$ 拿出来，题目转化为选出最多的断点，满足 $i_0=0&lt;i_1&lt;i_2&lt;\ldots&lt;i_k=n$，且 $S_{i_j}\oplus S_{i_{j-1}}\neq X$。

首先如果 $X=0$，那么显然 $f(A,X)$ 等于 $S$ 中极长连续段的个数减一。

如果 $X\neq 0$，考虑用类似 $X=0$ 的做法，将 $v$ 和 $v\oplus X$ 看成一种数去缩连续段，那么不同连续段之间显然不互相影响。而对于连续段内，如果当前是开始或者末尾连续段，个数即为开始或者末尾对应的数的个数，否则个数为这个连续段内两种数的出现次数最大值。容易发现这么做是最优的。

然后考虑怎么计数。

设 $f_i$ 表示长度为 $i$ 的连续段（不在开始或者末尾）的贡献。可以得到：

$$f_i=\sum_{j=0}^{i}{\binom{i}{j}\max\{j,i-j\}}$$

这个东西可以分类讨论 $\max\{j,i-j\}$ 的类型然后递推求。

对于前缀和后缀串的贡献容易得到。

时间复杂度：$O(n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 1e6 + 5, kMod = 998244353;

int n, k, x, cnt;
int fac[kMaxN], ifac[kMaxN], f[kMaxN], g[kMaxN];

int qpow(int bs, int64_t idx = kMod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % kMod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % kMod;
  return ret;
}

inline int fix(int x) { return (x % kMod + kMod) % kMod; }
inline int add(int x, int y) { return (x + y &gt;= kMod ? x + y - kMod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + kMod); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= kMod ? x -= kMod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += kMod : x; }
inline int getop(int x) { return (~x &amp; 1) ? 1 : (kMod - 1); }

int C(int m, int n) {
  if (m &lt; n || m &lt; 0 || n &lt; 0) return 0;
  return 1ll * fac[m] * ifac[n] % kMod * ifac[m - n] % kMod;
}

void prework(int n = 1e6) {
  fac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * i * fac[i - 1] % kMod;
  ifac[n] = qpow(fac[n]);
  for (int i = n; i; --i) ifac[i - 1] = 1ll * i * ifac[i] % kMod;
}

int getcnt(int n) {
  if (n == 0) return 0;
  else if (n == 1) return 1;
  else return add(1ll * (n - 1) * qpow(2, n - 2) % kMod, qpow(2, n - 1));
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;
  prework();
  int ans = 0, cnt = fix(1ll &lt;&lt; k), cntg = fix(1ll &lt;&lt; (k - 1));
  if (x == 0) return void(std::cout &lt;&lt; sub(n, 1ll * n * qpow(cnt) % kMod) &lt;&lt; '\n');
  for (int i = 2; i &lt;= n; ++i) {
    g[i] = add(2ll * g[i - 1] % kMod, 1ll * getop(i) * C(i - 2, i / 2 - 1) % kMod);
  }
  for (int i = 1; i &lt;= n; ++i) {
    f[i] = sub(2ll * i % kMod * g[i] % kMod, (i % 2 == 0) * (i / 2) * C(i, i / 2) % kMod);
    f[i] = sub(1ll * i * qpow(2, i) % kMod, f[i]);
    if (i &lt;= n - 2) inc(ans, 1ll * (n - i - 1) * f[i] % kMod * cntg % kMod * (cnt - 2) % kMod * (cnt - 2) % kMod * qpow(cnt, n - i - 2) % kMod);
  }
  // std::cerr &lt;&lt; f[4] &lt;&lt; '\n';
  for (int i = 1; i &lt;= n - 1; ++i)
    inc(ans, 1ll * f[i] * (cntg - 1) % kMod * (cnt - 2) % kMod * qpow(cnt, n - i - 1) % kMod);
  // std::cerr &lt;&lt; ans &lt;&lt; '\n';
  for (int i = 1; i &lt;= n - 1; ++i) { // 后缀
    inc(ans, 1ll * getcnt(i) * cnt % kMod * (cnt - 2) % kMod * qpow(cnt, n - i - 1) % kMod);
  }
  // std::cerr &lt;&lt; ans &lt;&lt; '\n';
  inc(ans, 1ll * getcnt(n) % kMod * (cnt - 2) % kMod);
  // std::cerr &lt;&lt; ans &lt;&lt; '\n';
  // std::cerr &lt;&lt; 124780545ll * 16 % kMod &lt;&lt; '\n';
  for (int i = 1; i &lt;= n - 1; ++i) {
    inc(ans, 1ll * i * qpow(2, i - 1) % kMod * (cnt - 2) % kMod * qpow(cnt, n - i - 1) % kMod);
  }
  // std::cerr &lt;&lt; ans &lt;&lt; '\n';
  for (int i = 1; i &lt;= n; ++i) inc(ans, 1ll * i * C(n - 1, i - 1) % kMod);
  // std::cerr &lt;&lt; ans &lt;&lt; '\n';
  std::cout &lt;&lt; 1ll * ans * qpow(qpow(cnt), n) % kMod &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18702973.html</id>
    <title type="text">CF1458F Range Diameter Sum 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-07T09:31:00Z</published>
    <updated>2025-02-07T09:31:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18702973.html" />
    <content type="text">## Description

给定一棵包含 $n$ 个节点(编号 $1$ 到 $n$)， $n-1$ 条长度为 $1$ 的无向边的树。

设 $d(u,v)$ 为编号 $u$ 到编号 $v$ 两点之间唯一路径的长度。

设 $f(l,r)$ 为 $\max\{d(u,v)\}(l\leq u,v\leq r)$

求:

$$\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)$$

第一行输入 $1$ 个整数 $n\ (1\leq n\leq 10^5)$。

接下来 $n-1$ 行，每行两个整数 $x,y$ 表示编号为 $x$ 和编号为 $y$ 的点之间有一条长度为 $1$ 的边$(1\leq x,y\leq n)$，保证给定的图是一棵树。

输出对于这棵树，上述表达式的值。

$1\leq n\leq 10^5$。

## Solution

首先需要说一下树上圆理论。

对于任意一个点集 $S$，则所有直径的中点一定重合，否则一定存在另一个更长的直径，设 $C(S)=(v,r)$ 表示 $v$ 是直径的中点，$r$ 是直径长度的一半（$v$ 可以在边上）。

---

引理 1：如果 $S\subseteq (v,r)$ 且 $a,b\in S$，则 $dist(mid(a,b),v)+\frac{dist(a,b)}{2}\leq r$。

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;
画图后易得。
&lt;/details&gt;

---

引理 2：如果 $S\subseteq (v,r)$，则 $C(s)\subseteq (v,r)$。

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

设 $C(S)=(v',r')$，则 $v'$ 一定是 $S$ 中某个直径的中点，由引理 1 可得：$dist(v,v')+r'\leq r$。

那么对于任意 $x\in C(S)$，则 $dist(v,x)\leq dist(v,v')+dist(v',x)\leq r-r'+r'\leq r$。结论得证。

&lt;/details&gt;

---

然后考虑怎么合并两个树上圆。

如果 $C_1\supseteq C_2$，则合并为 $C_1$，条件为 $dist(v_1,v_2)\leq r_1-r_2$。

如果 $C_1\subseteq C_2$，则合并为 $C_2$，条件为 $dist(v_1,v_2)\leq r_2-r_1$。

否则可以用类似几何圆的合并，将其合并为 $(v,r)$，满足 $r=\frac{r_1+r_2+dist(v_1,v_2)}{2}$，$v$ 为 $v_1$ 向 $v_2$ 的方向移动 $r-r_1$ 步的最终位置。证明略。

回到这题，先分治，假设当前分治区间为 $[l,r]$，$mid$ 为中点。

设 $C_{1,i}$ 为将 $[i,mid]$ 合并后的圆，$C_{2,i}$ 为将 $[mid+1,i]$ 合并后的圆。

那么固定 $C_{1,i}$，则有三段：$[mid+1,t_{1,i}]$ 结果为 $r_i$，$(t_{1,i},t_{2,i}-1)$ 结果为 $r_i+r_j+dist(r(C_{1,i},r(C_{2,j})))$，后面的结果是 $r_j$。

第一和第三部分是好算的，第二部分树剖维护即可。

时间复杂度：$O(n\log^3n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;
using pii = std::pair&lt;int, int&gt;;

const int kMaxN = 2e5 + 5;

int n; i64 ans = 0;
int p[kMaxN], dep[kMaxN], sz[kMaxN], wson[kMaxN], st[kMaxN][20];
int dfn[kMaxN], idx[kMaxN], top[kMaxN];
std::vector&lt;int&gt; G[kMaxN];

/*
  sum1[i] (bit1) : i 或者 i 的轻子树的标记点到 i 的距离和
  cnt1[i] (bit2) : i 或者 i 的轻子树的标记点个数
  sum2[i] (bit3) : i 或者 i 的轻子树的标记点个数 * dep[i]
  cnt2[i] (bit4) : i 的子树内的标记点个数
  sum3[i] (bit5) : i 的子树内标记点的 dep 和
*/

struct BIT {
  i64 c[kMaxN];
  void upd(int x, int v) {
    for (; x &lt;= 2 * n; x += x &amp; -x) c[x] += v;
  }
  void upd(int l, int r, int v) {
    if (l &lt;= r) upd(l, v), upd(r + 1, -v);
  }
  i64 qry(int x) {
    i64 ret = 0;
    for (; x; x -= x &amp; -x) ret += c[x];
    return ret;
  }
  i64 qry(int l, int r) { return l &lt;= r ? qry(r) - qry(l - 1) : 0; }
} bit1, bit2, bit3, bit4, bit5;

int get(int x, int y) { return dfn[x] &lt; dfn[y] ? x : y; }

void dfs1(int u, int fa) {
  sz[u] = 1, dep[u] = dep[fa] + 1, p[u] = fa;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    if (sz[v] &gt; sz[wson[u]]) wson[u] = v;
  }
}

void dfs2(int u, int fa, int t) {
  static int cnt = 0;
  st[dfn[u] = ++cnt][0] = fa, idx[cnt] = u, top[u] = t;
  if (wson[u]) dfs2(wson[u], u, t);
  for (auto v : G[u]) {
    if (v == fa || v == wson[u]) continue;
    dfs2(v, u, v);
  }
}

int LCA(int x, int y) {
  if (x == y) return x;
  if (dfn[x] &gt; dfn[y]) std::swap(x, y);
  int k = std::__lg(dfn[y] - dfn[x]);
  return get(st[dfn[x] + 1][k], st[dfn[y] - (1 &lt;&lt; k) + 1][k]);
}

int getdis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }

int getfa(int x, int k) {
  assert(dep[x] - 1 &gt;= k);
  for (; x; k -= dep[x] - dep[p[top[x]]], x = p[top[x]]) {
    if (k &lt;= dep[x] - dep[top[x]])
      return idx[dfn[x] - k];
  }
  assert(0);
}

int move(int x, int y, int k) {
  int lca = LCA(x, y), len = dep[x] + dep[y] - 2 * dep[lca];
  assert(k &lt;= len);
  if (k &lt;= dep[x] - dep[lca]) return getfa(x, k);
  else return getfa(y, len - k);
}

pii merge(pii a, pii b) {
  if (a.second &lt; b.second) std::swap(a, b);
  auto [u1, r1] = a;
  auto [u2, r2] = b;
  int dis = getdis(u1, u2);
  if (dis &lt;= r1 - r2) return a;
  assert((r1 + r2 + dis) % 2 == 0);
  int r = (r1 + r2 + dis) / 2, u = move(u1, u2, r - r1);
  return {u, r};
}

void prework() {
  dfs1(1, 0), dfs2(1, 0, 1);
  for (int i = 1; i &lt;= std::__lg(2 * n - 1); ++i)
    for (int j = 1; j &lt;= 2 * n - 1 - (1 &lt;&lt; i) + 1; ++j)
      st[j][i] = get(st[j][i - 1], st[j + (1 &lt;&lt; (i - 1))][i - 1]);
}

void update(int x, int v) {
  bit4.upd(dfn[x], v), bit5.upd(dfn[x], v * dep[x]);
  for (int i = x; i; i = p[top[i]]) {
    bit1.upd(dfn[i], v * (dep[x] - dep[i])), bit2.upd(dfn[i], v);
    bit3.upd(dfn[i], v * dep[i]);
  }
}

i64 query(int x) {
  i64 ret = 0;
  int lst = 0;
  for (int i = x; i; i = p[top[i]]) {
    int cnt = bit2.qry(dfn[top[i]], dfn[i] - 1);
    ret += 1ll * cnt * dep[x] - bit3.qry(dfn[top[i]], dfn[i] - 1) + bit1.qry(dfn[top[i]], dfn[i] - 1);
    int cnt1 = bit4.qry(dfn[i], dfn[i] + sz[i] - 1);
    ret += 1ll * cnt1 * (dep[x] - dep[i]) + bit5.qry(dfn[i], dfn[i] + sz[i] - 1) - 1ll * cnt1 * dep[i];
    if (lst) {
      int cnt2 = bit4.qry(dfn[lst], dfn[lst] + sz[lst] - 1);
      ret -= 1ll * cnt2 * (dep[x] - dep[i]) + bit5.qry(dfn[lst], dfn[lst] + sz[lst] - 1) - 1ll * cnt2 * dep[i];
    }
    lst = top[i];
  }
  return ret;
}

void solve(int l, int r) {
  static pii c[kMaxN];
  static int t1[kMaxN], t2[kMaxN];
  static i64 sum[kMaxN];
  if (l == r) return;
  int mid = (l + r) &gt;&gt; 1;
  solve(l, mid), solve(mid + 1, r);
  c[mid] = {mid, 0}, c[mid + 1] = {mid + 1, 0};
  for (int i = mid - 1; i &gt;= l; --i) c[i] = merge(c[i + 1], {i, 0});
  for (int i = mid + 2; i &lt;= r; ++i) c[i] = merge(c[i - 1], {i, 0});
  for (int i = mid + 1; i &lt;= r; ++i) sum[i] = sum[i - 1] + c[i].second;
  int nl = mid + 1, nr = mid;
  for (int i = l; i &lt;= mid; ++i) {
    int L = mid, R = r + 1;
    t1[i] = mid, t2[i] = r + 1;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (merge(c[i], c[mid]) == c[i]) L = t1[i] = mid;
      else R = mid;
    }
    L = t1[i], R = r + 1;
    while (L + 1 &lt; R) {
      int mid = (L + R) &gt;&gt; 1;
      if (merge(c[i], c[mid]) == c[mid]) R = t2[i] = mid;
      else L = mid;
    }
    ans += 2ll * c[i].second * (t1[i] - mid) + 2ll * (sum[r] - sum[t2[i] - 1]);
    ans += 1ll * c[i].second * (t2[i] - t1[i] - 1) + sum[t2[i] - 1] - sum[t1[i]];
    for (; nr &lt; t2[i] - 1; update(c[++nr].first, 1)) {}
    for (; nl &gt; t1[i] + 1; update(c[--nl].first, 1)) {}
    for (; nr &gt; t2[i] - 1; update(c[nr--].first, -1)) {}
    for (; nl &lt; t1[i] + 1; update(c[nl++].first, -1)) {}
    ans += query(c[i].first);
  }
  for (int i = nl; i &lt;= nr; ++i) update(c[i].first, -1);
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt; n; ++i) {
    int u, v;
    std::cin &gt;&gt; u &gt;&gt; v;
    G[u].emplace_back(i + n), G[i + n].emplace_back(u);
    G[v].emplace_back(i + n), G[i + n].emplace_back(v);
  }
  prework(), solve(1, n);
  std::cout &lt;&lt; ans / 2 &lt;&lt; '\n';
}

int32_t main() {
  freopen("image.in", "r", stdin);
  freopen("image.out", "w", stdout);
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18705927.html</id>
    <title type="text">P10441 [JOISC 2024] 乒乓球 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-09T03:50:00Z</published>
    <updated>2025-02-09T03:50:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18705927.html" />
    <content type="text">## Description

构造一个点数为 $n$ 的竞赛图，满足其中三元环的个数为 $m$。

$n\leq 5000$。

## Solution

首先竞赛图的三元环个数是可以根据每个点的入度/出度求的。具体地，设 $deg_i$ 表示 $i$ 的出度，则三元环个数为 $\binom{n}{3}-\sum{\binom{deg_i}{2}}$。

考虑怎么判断有无解。

注意到如果 $deg_i+1&lt;deg_j$，那么让 $deg_i\leftarrow deg_i+1,deg_j\leftarrow deg_j-1$ 一定能让三元环数最多，所以度数越均匀，三元环数就越多。所以三元环最多的情况下 $deg_i$ 一定等于 $\lfloor\frac{n}{2}\rfloor$ 或者 $\lceil\frac{n}{2}\rceil$，于是就能求出最多的三元环数了。

设 $f_n$ 表示 $n$ 个点的图三元环数量的最大值，结论是如果 $m&gt;f_n$ 则无解，否则有解。

构造就考虑先把初始度数设为数量最大时的情况，然后每次选择 $deg_i=deg_j$，让 $deg_i\leftarrow deg_i-1,deg_j\leftarrow deg_j+1$，会让三元环数减一。如果选不出来，就说明 $deg=\{0,1,2,\ldots,n-1\}$，此时三元环数为 $0$，不需要再调整了。

由于每次操作可以看成选两个度数相等的点，将它们之间的边取反，并且初始状态一定能构造，所以最终也可以构造出来。

现在得到了每个点的度数，构造竞赛图就考虑每次选择度数最小的点 $i$，向其余任意 $deg_i$ 个点连从 $i$ 出发的边，剩下的 $n-1-deg_i$ 个点就连到达 $i$ 的边，然后把 $i$ 删掉即可。

但是 $m$ 可能到 $O(n^3)$ 级别，暴力调整度数会超时。注意到 $f(n)-f(n-1)$ 为 $O(n^2)$ 级别，所以只需要选择最小的 $k$ 满足 $f(k)\geq m$，然后构造大小为 $k$ 三元环数为 $m$ 的图，然后对剩余的点连出一个有向无环图即可。

时间复杂度：$O(n^2\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

#define int int64_t

const int kMaxN = 5e3 + 5;

int n, m;
bool g[kMaxN][kMaxN];

int C(int n) { return 1ll * n * (n - 1) / 2; }

int calc(int n) {
  if (n % 2 == 1) return 1ll * n * (n - 1) * (n - 2) / 6 - 1ll * n * C((n - 1) / 2);
  else {
    int k = (n - 1) / 2, cnt2 = C(n) - k * n, cnt1 = n - cnt2;
    return 1ll * n * (n - 1) * (n - 2) / 6 - (1ll * cnt1 * C(k) + 1ll * cnt2 * C(k + 1));
  }
}

void construct(int n, int m) {
  static int cnt[kMaxN] = {0}, deg[kMaxN];
  std::fill_n(cnt, n - 1, 0);
  if (n % 2 == 1) {
    cnt[(n - 1) / 2] = n;
  } else {
    int k = (n - 1) / 2, cnt2 = C(n) - k * n, cnt1 = n - cnt2;
    cnt[k] = cnt1, cnt[k + 1] = cnt2;
  }
  std::priority_queue&lt;int&gt; q;
  for (int i = 1; i &lt; n - 1; ++i)
    if (cnt[i] &gt;= 2)
      q.emplace(i);
  for (int i = 1; i &lt;= m; ++i) {
    int x = q.top(); q.pop();
    cnt[x] -= 2, ++cnt[x - 1], ++cnt[x + 1];
    if (cnt[x] &gt;= 2) q.emplace(x);
    if (cnt[x - 1] == 2 &amp;&amp; x - 1 &gt;= 1) q.emplace(x - 1);
    if (cnt[x + 1] == 2 &amp;&amp; x + 1 &lt; n - 1) q.emplace(x + 1);
  }
  int c = 0;
  static int tmp[kMaxN];
  for (int i = 0; i &lt; n; ++i) {
    for (int j = 1; j &lt;= cnt[i]; ++j)
      deg[++c] = i, tmp[c] = i;
  }
  // std::cerr &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; " : ";
  // for (int i = 1; i &lt;= n; ++i) std::cerr &lt;&lt; deg[i] &lt;&lt; " \n"[i == n];
  for (int i = 1; i &lt;= n; ++i) {
    std::vector&lt;int&gt; vec;
    assert(i + deg[i] &lt;= n);
    // std::cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; deg[i] &lt;&lt; '\n';
    for (int j = i + 1; j &lt;= n; ++j) vec.emplace_back(j);
    std::sort(vec.begin(), vec.end(), [&amp;] (int x, int y) { return deg[x] &lt; deg[y]; });
    for (int j = 0; j &lt; vec.size(); ++j) {
      int x = vec[j];
      if (j &lt; deg[i]) g[i][x] = 1;
      else g[x][i] = 1, --deg[x];
    }
  }
  // for (int i = 1; i &lt;= n; ++i) {
  //   assert(std::count(g[i] + 1, g[i] + 1 + n, 1) == tmp[i]);
  // }
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m;
  if (calc(n) &lt; m) return void(std::cout &lt;&lt; "No\n");
  for (int i = 1; i &lt;= n; ++i)
    std::fill_n(g[i] + 1, n, 0);
  for (int k = 0; k &lt;= n; ++k) {
    if (calc(k) &gt;= m) {
      construct(k, calc(k) - m);
      for (int i = 1; i &lt;= n; ++i)
        for (int j = std::max(i + 1, k + 1); j &lt;= n; ++j)
          g[i][j] = 1;
      break;
    }
  }
  std::cout &lt;&lt; "Yes\n";
  // int sum = 1ll * n * (n - 1) * (n - 2) / 6;
  // for (int i = 1; i &lt;= n; ++i) sum -= C(std::count(g[i] + 1, g[i] + 1 + n, 1));
  // std::cerr &lt;&lt; sum &lt;&lt; '\n';
  // for (int i = 1; i &lt;= n; ++i, std::cerr &lt;&lt; '\n')
  //   for (int j = 1; j &lt;= n; ++j)
  //     std::cerr &lt;&lt; g[i][j];
  for (int i = 2; i &lt;= n; ++i) {
    for (int j = 1; j &lt; i; ++j)
      std::cout &lt;&lt; g[i][j];
    std::cout &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18708156.html</id>
    <title type="text">P9331 [JOISC 2023] 护照 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-10T08:34:00Z</published>
    <updated>2025-02-10T08:34:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18708156.html" />
    <content type="text">## Description

护照是旅行家进入他国时使用的证件。

在一个星球上有 $N$ 个国家，从 $1$ 到 $N$ 编号。每个国家都签发一种护照。当旅行家获得由国家$i \ (1 \le i \le N)$ 签发的护照后，他能够进入国家 $L_i, L_{i + 1}, \dots, R_i$。**这里保证旅行家能够进入其签证的签发国。形式上地说, $L_i \le i \le R_i$ 必然成立。**

你有一个爱旅行的朋友。即使他奢望能环游世界，但他最初一种护照也没有。因此，他想通过一下重复以下两项行为来环游这 $N$ 个国家。

- 获得他当前所在国家签发的护照。
- 用他现有的护照进入某个国家。

知道他的计划后，你想知道这个计划的是否可行，和如果可行的话，他最少需要的护照数量。因为你并不清楚他现在身处何国，所以你预测了 $Q$ 个他可能正居住在那的国家 $X_1, X_2, \dots, X_Q$。

现在给定各国护照的信息 $L_i, R_i$ 和他可能居住的 $Q$ 个国家，您需要写一个程序，对于每一个可能居住的国家，判断他是否可能环游这 $N$ 个国家，如果可能的话，计算出他需要的最少护照种数。

$2 \le N \le 2 \times 10 ^ 5$，$1 \le L_i \le i \le R_i \le N$。

## Solution

首先能到的国家一定是一段区间，如果设当前区间为 $[L,R]$，则每次相当于是选择一个 $i\in [L,R]$，让 $L\leftarrow\min\{L,l_i\},R\leftarrow\max\{R,r_i\}$。

然后有个观察是在当前的 $[L,R]$ 里最多选择两个区间进行拓展，并且拓展后就再也不会选择 $[L,R]$ 内的区间了，否则提前选一定更优。

设 $f_i$ 表示区间为 $[l_i,r_i]$ 的最小答案。

如果当前只选一个区间，则 $f_i\leftarrow f_j+1\ (j\in[l_i,r_i])$。

如果选择两个区间 $[l_x,r_x],[l_y,r_y]$，则一定满足 $l_x\leq l_i,r_y\geq r_i$，此时由于 $[l_i,r_i]$ 不会再选了，那么 $x$ 和 $y$ 一定是一个拓展左端点到 $1$，另一个是拓展右端点到 $n$，否则一个在拓展的过程中一定会拓展到另一个。

这样的话如果求出 $dis1_i$ 表示将 $[l_i,r_i]$ 左端点拓展到 $1$ 的答案，$dis2_i$ 表示将右端点拓展到 $n$ 的答案，就可以让 $f_i\leftarrow dis1_x+dis2_y+1$ 即可。

考虑怎么求出 $dis1_i$ 和 $dis2_i$。下面只考虑求 $dis1_i$。

由于此时只需要单方向拓展，所以只要让 $dis1_i\leftarrow dis1_j+1\ (j\in [l_i,r_i])$ 即可。

两部分都可以用线段树优化建图和 Dijkstra 求。

时间复杂度：$O(n\log^2 n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, q;
int l[kMaxN], r[kMaxN], f[kMaxN], dis1[kMaxN], dis2[kMaxN], idx[kMaxN];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G[kMaxN * 4];

struct SGT {
  int N;
  std::pair&lt;int, int&gt; mx[kMaxN * 4];
  void pushup(int x) { mx[x] = std::max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]); }
  void build(int n, int *arr, int op = 1) {
    for (N = 1; N &lt;= n + 1; N &lt;&lt;= 1) {}
    for (int i = 1; i &lt;= n; ++i) mx[i + N] = {op * arr[i], i};
    for (int i = N - 1; i; --i) pushup(i);
  }
  std::pair&lt;int, int&gt; query(int l, int r) {
    std::pair&lt;int, int&gt; ret = {-1e9, 0};
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if (~l &amp; 1) ret = std::max(ret, mx[l ^ 1]);
      if (r &amp; 1) ret = std::max(ret, mx[r ^ 1]);
    }
    return ret;
  }
} sgtl, sgtr;

void build(int x, int l, int r) {
  if (l == r) return void(idx[l] = x);
  int mid = (l + r) &gt;&gt; 1;
  build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r);
  G[x &lt;&lt; 1].emplace_back(x, 0), G[x &lt;&lt; 1 | 1].emplace_back(x, 0);
}

void update(int x, int l, int r, int ql, int qr, int p) {
  if (l &gt; qr || r &lt; ql) return;
  else if (l &gt;= ql &amp;&amp; r &lt;= qr) return void(G[x].emplace_back(idx[p], 1));
  int mid = (l + r) &gt;&gt; 1;
  update(x &lt;&lt; 1, l, mid, ql, qr, p), update(x &lt;&lt; 1 | 1, mid + 1, r, ql, qr, p);
}

void dijkstra1(int s, int *res) {
  static int dis[kMaxN * 4];
  static bool vis[kMaxN * 4];
  std::fill_n(dis + 1, 4 * n, 1e9);
  std::fill_n(vis + 1, 4 * n, 0);
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i)
    if (l[i] &lt;= s &amp;&amp; s &lt;= r[i])
      dis[idx[i]] = 0, q.emplace(0, idx[i]);
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w] : G[u]) {
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w, q.emplace(-dis[v], v);
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i) res[i] = dis[idx[i]];
}

void dijkstra2() {
  static int dis[kMaxN * 4];
  static bool vis[kMaxN * 4];
  std::fill_n(dis + 1, 4 * n, 1e9);
  std::fill_n(vis + 1, 4 * n, 0);
  std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    dis[idx[i]] = f[i];
    q.emplace(-dis[idx[i]], idx[i]);
  }
  for (; !q.empty();) {
    int u = q.top().second; q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto [v, w] : G[u]) {
      if (dis[v] &gt; dis[u] + w) {
        dis[v] = dis[u] + w, q.emplace(-dis[v], v);
      }
    }
  }
  for (int i = 1; i &lt;= n; ++i) f[i] = dis[idx[i]];
}

void prework() {
  build(1, 1, n);
  for (int i = 1; i &lt;= n; ++i) update(1, 1, n, l[i], r[i], i);
  dijkstra1(1, dis1), dijkstra1(n, dis2);
}

void getf() {
  sgtl.build(n, dis1, -1), sgtr.build(n, dis2, -1);
  for (int i = 1; i &lt;= n; ++i) {
    if (l[i] &gt; 1) f[i] += dis1[sgtl.query(l[i], r[i]).second] + 1;
    if (r[i] &lt; n) f[i] += dis2[sgtr.query(l[i], r[i]).second] + 1;
    // std::cerr &lt;&lt; f[i] &lt;&lt; " \n"[i == n];
  }
  dijkstra2();
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i)
    std::cin &gt;&gt; l[i] &gt;&gt; r[i];
  prework(), getf();
  std::cin &gt;&gt; q;
  for (int i = 1; i &lt;= q; ++i) {
    int x;
    std::cin &gt;&gt; x;
    std::cout &lt;&lt; (f[x] &gt; n ? -1 : f[x] + 1) &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18710433.html</id>
    <title type="text">P9330 [JOISC 2023] JOI 国的节日 2 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-11T12:34:00Z</published>
    <updated>2025-02-11T12:34:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18710433.html" />
    <content type="text">## Description

对于以下问题：


&gt;给定长度为 $n$ 的序列 $a$、$b$，满足以下条件：
&gt;
&gt;- 在序列 $a$ 与序列 $b$ 中，$1$ 到 $2n$ 的整数各出现恰好一次；
&gt;- 对于 $1\leq i\leq n$，$a_i&lt;b_i$；
&gt;- 对于 $1\leq i&lt;n$，$a_i&lt;a_{i+1}$。
&gt;
&gt;求：最多能在 $[a_i,b_i]$ 中选出多少个两两不交的区间。

考虑以下算法：

&gt;从 $1$ 到 $n$ 枚举 $i$，若 $[a_i,b_i]$ 与所有已经选择的区间都不交，则选择该区间。最后输出选择的区间数。

给定 $n$，求：有多少个满足条件的序列对 $(a,b)$，使得以上算法无法求出正确的结果。答案对 $p$ 取模。

$1\leq n\leq 2\times 10^4$，$P$ 是质数。

## Solution

首先正确的策略一定是按照右端点从小到大贪心。考虑用总方案数减去最终结果正确的方案数。

不妨将第二种策略选的线段看成红色，第一种看成蓝色，两种同时选的看成紫色，都没选的看成黑色，那么将线段按照右端点排序后一定是红蓝交替或者紫色排列在一起。如图：

![](https://pic.imgdb.cn/item/64a18b841ddac507cc6fa3fa.png)

然后考虑红线段的性质：

1. 红线段不交。
2. 前一个红线段的右端点到下一个红线段的左端点之间不存在完整的线段。

蓝线段：

1. 蓝线段不交。
2. 前一个蓝线段的右端点到下一个蓝线段的左端点之间不存在某个线段的左端点。

那么就可以 dp 了。

然后考虑从前往后每次插入一对红蓝或者紫线段，设 $f_{i,j,0/1}$ 表示已经插入了 $i$ 个线段，有 $j$ 个左端点尚未匹配，且最后是红蓝/紫线段的方案数。

转移时枚举插入的黑色线段数量即可。时间复杂度：$O(n^3)$，过不了。

---

注意到上面那个做法枚举黑色线段数量这部分是无法省略的，所以考虑优化状态数量。

由于这题对左端点的限制强于右端点，所以考虑倒着插入线段，同时为左端点找其匹配的右端点。这样会发现只要确定了左端点的位置之后，右端点就随便选了。

具体地，设 $f_{i,0/1}$ 表示目前倒着插入了 $i$ 个线段，最后插入的是红蓝/紫线段，且目前已经为大于最前面的红/紫线段的右端点 的左端点找到匹配的右端点的方案数。

然后考虑转移。这里只讨论 $0\to 0$ 的转移。有两种情况，需要分类讨论：

![](https://pic.imgdb.cn/item/64a194d31ddac507cc7fc49b.png)

上图是第一种情况。先枚举加入的黑色线段的左端点个数 $j$，容易发现这 $j$ 个左端点只能放在上图中的前三个区间里，由于此时并没有给上一步最后添加到两个线段分配左端点，所以可以先固定 $j$ 个加入的左端点，然后用上一步最后线段的左端点将其分成三部分，方案数为 $\frac{(j+1)(j+2)}{2}$。

然后是为这 $j$ 个左端点找到匹配的右端点。注意到右端点可以插在最后一个区间内的任何位置，而这个区间有 $2i-2$ 个段，方案数即为 $(2i-2)^{\overline{j}}$。于是这种情况的贡献为 $f_{i,0}\times\frac{(j+1)(j+2)}{2}\times(2i-2)^{\overline{j}}$。

![](https://pic.imgdb.cn/item/64a1950f1ddac507cc802274.png)

这是第二种情况，和第一种情况贡献是一样的。所以转移式为 $f_{i+j+2,0}\leftarrow f_{i,0}\times(j+1)(j+2)\times(2i-2)^{\overline{j}}$。

其余三种转移是类似的。

求答案时还需要枚举最后加了多少个黑色线段，贡献也是类似的。

时间复杂度：$O(n^2)$，卡常后可过。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 2e4 + 5;

int n, mod;
int fac[kMaxN * 2], ifac[kMaxN * 2], f[kMaxN][2];

struct Barrett {
  int64_t m, p;
  void init(int64_t mod) {
    m = ((__int128_t)1 &lt;&lt; 64) / mod;
    p = mod;
  }
  Barrett(int64_t mod = 2) { init(mod); }
  inline int64_t operator()(int64_t x) {
    x -= (((__int128_t)x * m) &gt;&gt; 64) * p;
    return x &gt;= p ? x - p : x;
  }
} Reduce;

constexpr int qpow(int bs, int64_t idx = mod - 2) {
  int ret = 1;
  for (; idx; idx &gt;&gt;= 1, bs = (int64_t)bs * bs % mod)
    if (idx &amp; 1)
      ret = (int64_t)ret * bs % mod;
  return ret;
}

inline int add(int x, int y) { return (x + y &gt;= mod ? x + y - mod : x + y); }
inline int sub(int x, int y) { return (x &gt;= y ? x - y : x - y + mod); }
inline int mul(int x, int y) { return Reduce(1ll * x * y); }
inline void inc(int &amp;x, int y) { (x += y) &gt;= mod ? x -= mod : x; }
inline void dec(int &amp;x, int y) { (x -= y) &lt; 0 ? x += mod : x; }
inline void multi(int &amp;x, int y) { x = Reduce(1ll * x * y); }

inline int getfac(int l, int r) {
  return l &lt;= 0 ? 0 : 1ll * fac[r] * ifac[l - 1] % mod;
}

inline int up(int x, int k) {
  return getfac(x, x + k - 1);
}

void prework(int n = 4e4) {
  fac[0] = 1;
  for (int i = 1; i &lt;= n; ++i) fac[i] = 1ll * i * fac[i - 1] % mod;
  ifac[n] = qpow(fac[n]);
  for (int i = n; i; --i) ifac[i - 1] = 1ll * i * ifac[i] % mod;
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; mod;
  Reduce.init(mod);
  prework(2 * n);
  f[1][1] = f[2][0] = 1;
  for (int i = 1; i &lt; n; ++i) {
    for (int o1 = 0; o1 &lt;= 1; ++o1) {
      if (!f[i][o1]) continue;
      for (int o2 = 0; o2 &lt;= 1; ++o2) {
        int tmp = 1ll * f[i][o1] * ifac[2 * i - 2 + o1 - 1] % mod;
        for (int j = 0; j &lt;= n - i - 2 + o2; ++j) {
          int coef = tmp;
          multi(coef, fac[2 * i - 2 + o1 + j - 1]);
          if (!o1) multi(coef, j + 1);
          if (!o2) multi(coef, j + !o1 + !o2);
          inc(f[i + j + 2 - o2][o2], coef);
        }
      }
    }
  }
  int ans = 1;
  for (int i = 1; i &lt;= 2 * n; i += 2) ans = 1ll * i * ans % mod;
  for (int i = 1; i &lt;= n; ++i) {
    int j = n - i;
    dec(ans, 1ll * (j + 1) * up(2 * i - 2, j) % mod * f[i][0] % mod);
    dec(ans, 1ll * up(2 * i - 1, j) * f[i][1] % mod);
  }
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18712104.html</id>
    <title type="text">CF1446D2 Frequency Problem (Hard Version) 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-12T12:32:00Z</published>
    <updated>2025-02-12T12:32:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18712104.html" />
    <content type="text">## Description

给出 $n$ 个元素组成的序列 $a_1,a_2,\ldots,a_n$。

求最长的子段使得其中有至少两个出现次数最多的元素。

输出最长子段长度。

$1\leq n\leq 2\times 10^5$。

## Solution

首先有个关键性质是如果设全局的众数为 $x$，则在最终的最长子段中一定有个众数是 $x$。

证明就考虑如果 $x$ 不是当前子段的众数，则可以拓展左右端点，拓展一次不足以让 $x$ 变成唯一的众数，当拓展到 $x$ 刚好与之前的众数出现次数相等时这个子段就满足条件了，而由于 $x$ 是全局的众数，所以一定可以拓展到这个局面。

然后就可以自然地想到枚举另一个众数 $y$，求出满足 $x$ 和 $y$ 出现次数相等的最长子段（不需要保证 $x$ 和 $y$ 出现次数最多），这么做显然是对的，因为根据上面那个做法，如果不是众数就可以再继续拓展直到 $x$ 是众数。

但是上面的做法会做颜色种类次，可能会很多。

考虑根号分治。

对于出现次数大于 $\sqrt n$ 的 $y$ 跑上面的做法。剩下的就一定满足众数出现次数不超过 $\sqrt n$，则可以枚举众数出现次数 $k$，对于每个 $l$，找到满足众数出现次数不超过 $k$ 的最大 $r$，然后判断出现次数恰为 $r$ 的数是否有至少两个。这个容易用双指针维护。

时间复杂度：$O(n\sqrt n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

const int kMaxN = 2e5 + 5;

int n, lim, x, ans;
int a[kMaxN], cnt[kMaxN] = {0};

void solve_big(int y) {
  static int sum[kMaxN], pos[kMaxN * 2];
  std::fill_n(pos, 2 * n + 1, 1e9);
  pos[n] = 0;
  for (int i = 1; i &lt;= n; ++i) {
    sum[i] = sum[i - 1];
    if (a[i] == x) ++sum[i];
    else if (a[i] == y) --sum[i];
    if (pos[sum[i] + n] == 1e9) pos[sum[i] + n] = i;
    else ans = std::max(ans, i - pos[sum[i] + n]);
  }
}

void solve_big() {
  for (int i = 1; i &lt;= n; ++i) {
    if (cnt[i] &gt; lim &amp;&amp; i != x) {
      solve_big(i);
    }
  }
}

void solve_small() {
  for (int c = 1; c &lt;= lim; ++c) {
    static int cnt[kMaxN] = {0}, ccnt[kMaxN] = {0};
    std::fill_n(cnt, n + 1, 0);
    std::fill_n(ccnt, n + 1, 0);
    ccnt[0] = n;
    
    for (int l = 1, r = 0; l &lt;= n; --ccnt[cnt[a[l++]]--]) {
      for (; r &lt; n &amp;&amp; !ccnt[c + 1]; ++ccnt[++cnt[a[++r]]]) {}
      if (ccnt[c + 1]) --ccnt[cnt[a[r--]]--];
      assert(!ccnt[c + 1]);
      if (ccnt[c] &gt;= 2) ans = std::max(ans, r - l + 1);
    }
  }
}

void dickdreamer() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i];
    ++cnt[a[i]];
    if (cnt[a[i]] &gt; cnt[x]) x = a[i];
  }
  lim = sqrtl(n);
  solve_big(), solve_small();
  std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18712126.html</id>
    <title type="text">P3826 [NOI2017] 蔬菜 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-12T12:52:00Z</published>
    <updated>2025-02-12T12:52:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18712126.html" />
    <content type="text">## Description

有 $n$ 种蔬菜，对于所有的满足条件 $d\times x_i \leq c_i$ 的正整数 $d$ ，有 $x_i$ 个单位的蔬菜将在 第 $d$ 天结束时变质。

特别地，若 $(d - 1)\times x_i \leq c_i &lt; d\times x_i$ ，则有 $c_i - (d - 1)\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。

注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。

同时，每天销售的蔬菜，总量也是有限的，最多不能超过 $m$ 个单位。

现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益。

$n,p_j\leq 10^5,m\leq 10$。

## Solution

首先考虑怎么建出费用流模型。

注意到每天会有蔬菜消失，很难处理，所以考虑时空倒流，这样就变为每天会有一些蔬菜添加进去。

建立源点 $S$，汇点 $T$，定义 $(t,i)$ 表示第 $t$ 天第 $i$ 种蔬菜对应的点，$[t]$ 表示第 $t$ 天采购对应的点，则可以连出如下边：

- $(S,(t,i),a_i,\max\{c_i-(t-1)\times x_i,0\})$
- $((t,i),(t-1,i),+\infty,0)$
- $((t,i),[t],+\infty,0)$
- $([t],T,m,0)$

但是这里没有考虑每种蔬菜第一次买的 $s_i$ 的贡献，这也是好处理的，只需要将 $i$ 蔬菜第一次出现的时刻里选一个边的边权变为 $a_i+s_i$ 即可，容易发现一个蔬菜如果被选就一定优先选这个特殊边。

考虑如何模拟这个费用流。

![](https://cdn.luogu.com.cn/upload/image_hosting/a9qvsm06.png)

这里用每次加点的方式跑。观察上图会发现只有 II 和 III 种增广路是有效的，而这两种都不会退流，所以 $[1,t]$ 时刻最优解用到的蔬菜一定是 $[1,t-1]$ 的超集，而 $[1,t]$ 的所有蔬菜放到 $[1,t-1]$ 不考虑每天销售限制的话都能用，所以如果求出 $[1,t]$ 的蔬菜，将这些用到的按照权值从大到小排序即可得到 $[1,t-1]$ 的蔬菜。

现在只需要求出 $[1,10^5]$ 所用到的蔬菜即可，同样考虑时空倒流，用一个堆维护目前没被用完的蔬菜的权值和出现次数。注意到我们不能每次都更新每个蔬菜的剩余数量，但是由于只需要找到出现次数至少一次的蔬菜，所以当某个蔬菜删空了再更新数量即可。

时间复杂度：$O(nm\log n)$。

## Code

```cpp
#include &lt;bits/stdc++.h&gt;

// #define int int64_t

using i64 = int64_t;

const int kMaxN = 1e5 + 5, kMaxT = kMaxN * 10;

int n, m, k, t;
int a[kMaxN], s[kMaxN], c[kMaxN], x[kMaxN], lst[kMaxN], now[kMaxN];
i64 veg[kMaxT], ans[kMaxT];
std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; vec[kMaxN];

int gettime(int c, int x) {
  if (!x) return 1e5;
  else return (c - 1) / x + 1;
}

void solve() {
  std::priority_queue&lt;std::tuple&lt;int, int, int&gt;&gt; q;
  for (int c = 1e5; c; --c) {
    for (auto [x, w, cnt] : vec[c])
      q.emplace(w, x, cnt), now[x] += cnt;
    std::vector&lt;int&gt; vv;
    for (int cc = 1; cc &lt;= m &amp;&amp; !q.empty(); ++cc) {
      auto [w, i, cnt] = q.top(); q.pop();
      veg[++t] = w, --now[i], --cnt;
      if (cnt) q.emplace(w, i, cnt);
      if (!now[i] &amp;&amp; x[i]) {
        if (lst[i] &gt; c) q.emplace(a[i], i, now[i] += x[i] * (lst[i] - c)), lst[i] = c;
        else vv.emplace_back(i);
      }
    }
    for (auto i : vv) q.emplace(a[i], i, now[i] += x[i]), lst[i] = c - 1;
  }
  std::sort(veg + 1, veg + 1 + t, std::greater&lt;&gt;());
  for (int i = 1; i &lt;= t; ++i) ans[i] = ans[i - 1] + veg[i];
}

void dickdreamer() {
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  for (int i = 1; i &lt;= n; ++i) {
    std::cin &gt;&gt; a[i] &gt;&gt; s[i] &gt;&gt; c[i] &gt;&gt; x[i];
    vec[gettime(c[i], x[i])].emplace_back(0, a[i] + s[i], 1);
    --c[i];
    if (c[i]) {
      int t = gettime(c[i], x[i]);
      lst[i] = t;
      vec[t].emplace_back(i, a[i], c[i] - x[i] * (t - 1));
    }
  }
  solve();
  for (int i = 1; i &lt;= k; ++i) {
    int p;
    std::cin &gt;&gt; p;
    std::cout &lt;&lt; ans[std::min(p * m, t)] &lt;&lt; '\n';
  }
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin &gt;&gt; T;
  while (T--) dickdreamer();
  // std::cerr &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";
  return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/Scarab/p/18712714.html</id>
    <title type="text">P7417 [USACO21FEB] Minimizing Edges P 题解-下蛋爷</title>
    <summary type="html"></summary>
    <published>2025-02-13T02:57:00Z</published>
    <updated>2025-02-13T02:57:00Z</updated>
    <author>
      <name>下蛋爷</name>
      <uri>https://www.cnblogs.com/Scarab</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/Scarab/p/18712714.html" />
    <content type="text">## Description

Bessie 有一个连通无向图 $G$。$G$ 有 $N$ 个编号为 $1\ldots N$ 的结点，以及 $M$ 条边（$2\le N\le 10^5, N-1\le M\le \frac{N^2+N}{2}$）。$G$ 有可能包含自环（一个结点连到自身的边），但不包含重边（连接同一对结点的多条边）。

令 $f_G(a,b)$ 为一个布尔函数，对于每一个 $1\le a\le N$ 和 $0\le b$，如果存在一条从结点 $1$ 到结点 $a$ 的路径恰好经过了 $b$ 条边，则函数值为真，否则为假。如果一条边被经过了多次，则这条边会被计算相应的次数。

Elsie 想要复制 Bessie。具体地说，她想要构造一个无向图 $G'$，使得对于所有的 $a$ 和 $b$，均有 $f_{G'}(a,b)=f_G(a,b)$。

Elsie 想要进行最少数量的工作，所以她想要构造最小可能的图。所以，你的工作是计算 $G'$ 的边数的最小可能值。

$\sum N\leq 10^5,\sum M\leq 2\times 10^5$。

## Solution

首先对于每个人一定存在 $(x_i,y_i)$，满足 $f_{i,j}=1$ 的条件为 $j$ 为奇数且 $j\geq x_i$ 或者 $j$ 为偶数且 $j\geq y_i$。

那么现在可以先对于原图 $G$ 跑 bfs 求出到每个点的奇偶最短路，得到 $(x_i,y_i)$。注意到这里的贡献是 $x_i+1\to y_j$ 和 $y_i+1\to x_j$，不太美观，考虑将其变为 $(a_i,b_i)$ 表示到 $i$ 的最短路和与最短路奇偶性不同的最短路。

则一定满足 $a_i&lt;b_i$ 且 $a_i$ 和 $b_i$ 奇偶性不同。

此时对于 $i$，要贡献出 $(a_i,b_i)$，就一定要满足 $i$ 的邻域存在一个 $a_j=a_i-1$，且存在 $a_k=b_i-1$ 或者 $b_k=b_i-1$。同时还需要满足所有与 $i$ 相邻的 $j$ 都有 $|a_i-a_j|\leq 1$。所以 $(a_i,b_i)$ 只会连如下边：

1. $(a_i-1,b_i-1)$
2. $(a_i-1,b_i+1),(a_i+1,b_i-1)$

可以证明这两种连边满足条件，且不存在其余更优的连法。

现在如果把 $(a_i,b_i)$ 放到二维平面上，第一种相当于往左上方连边，第二种是同时往右上、左下连边。特别的，当 $a_i+1=b_i$ 时第二种是往自己和左下连边。

注意到上面的连法可以按照 $a_i+b_i$ 分层，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ha8ys65.png?x-oss-process=image/resize,m_lfit,h_200,w_400)

考虑对于同层内的点从左往右进行贪心，设 $i$ 有 $t$ 个点，$cnt$ 表示 $i-1$ 往 $i$ 要连 $cnt$ 条边。

1. 如果 $i$ 上方没有点，就只能连层内边，所以 $ans\leftarrow ans+\max\{t,cnt\},cnt\leftarrow t$。

2. 如果 $i$ 上方有点，还要分两种情况讨论：
- 如果 $t\geq cnt$，则 $t$ 中要分 $cnt$ 个点连左边，剩余的全连上面。
- 如果 $t&lt;cnt$，则 $t$ 个点全要连左边。

枚举到最后，如果在 $(x,x+1)$ 剩余 $cnt$ 个点要连右边，则一定是它们内部两两连边，即 $ans\leftarrow\left\lceil\frac{cnt}{2}\right\rceil$。

具体见代码。

时间复杂度：$O(N\log N)$。

## Code

```cpp

```</content>
  </entry>
</feed>